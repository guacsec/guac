// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: pkg/handler/collector/deps.dev/internal/api.proto

package deps_dev

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// InsightsClient is the client API for Insights service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InsightsClient interface {
	// Packages returns a list of all known packages, in a batched stream.
	Packages(ctx context.Context, in *PackagesRequest, opts ...grpc.CallOption) (Insights_PackagesClient, error)
	// Versions returns the versions of a package.
	Versions(ctx context.Context, in *VersionsRequest, opts ...grpc.CallOption) (Insights_VersionsClient, error)
	// Version returns information about specific package versions. If the
	// request matches more than one version, multiple responses are returned.
	Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (Insights_VersionClient, error)
	// Dependencies returns the full dependency graph of a package version, as a
	// stream of messages containing nodes and edges. The first node in the
	// stream is the root of the graph. Edges do not appear before their
	// referenced nodes. If the request matches more than one version, an error
	// is returned.
	Dependencies(ctx context.Context, in *DependenciesRequest, opts ...grpc.CallOption) (Insights_DependenciesClient, error)
	// DependentInfo returns information about the dependents of a package
	// version. If the request matches more than one version, an error is
	// returned.
	DependentInfo(ctx context.Context, in *DependentInfoRequest, opts ...grpc.CallOption) (*DependentInfoResponse, error)
	// Advisory returns information about a security advisory.
	Advisory(ctx context.Context, in *AdvisoryRequest, opts ...grpc.CallOption) (*AdvisoryResponse, error)
	// Project returns information about the specified project.
	Project(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*ProjectResponse, error)
	// ProjectPackageVersions returns a list of versions that reference the
	// specified project.
	// The links are not confirmed.
	ProjectPackageVersions(ctx context.Context, in *ProjectPackageVersionsRequest, opts ...grpc.CallOption) (Insights_ProjectPackageVersionsClient, error)
}

type insightsClient struct {
	cc grpc.ClientConnInterface
}

func NewInsightsClient(cc grpc.ClientConnInterface) InsightsClient {
	return &insightsClient{cc}
}

func (c *insightsClient) Packages(ctx context.Context, in *PackagesRequest, opts ...grpc.CallOption) (Insights_PackagesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Insights_ServiceDesc.Streams[0], "/deps_dev.v2alpha.Insights/Packages", opts...)
	if err != nil {
		return nil, err
	}
	x := &insightsPackagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Insights_PackagesClient interface {
	Recv() (*PackagesResponse, error)
	grpc.ClientStream
}

type insightsPackagesClient struct {
	grpc.ClientStream
}

func (x *insightsPackagesClient) Recv() (*PackagesResponse, error) {
	m := new(PackagesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *insightsClient) Versions(ctx context.Context, in *VersionsRequest, opts ...grpc.CallOption) (Insights_VersionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Insights_ServiceDesc.Streams[1], "/deps_dev.v2alpha.Insights/Versions", opts...)
	if err != nil {
		return nil, err
	}
	x := &insightsVersionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Insights_VersionsClient interface {
	Recv() (*VersionsResponse, error)
	grpc.ClientStream
}

type insightsVersionsClient struct {
	grpc.ClientStream
}

func (x *insightsVersionsClient) Recv() (*VersionsResponse, error) {
	m := new(VersionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *insightsClient) Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (Insights_VersionClient, error) {
	stream, err := c.cc.NewStream(ctx, &Insights_ServiceDesc.Streams[2], "/deps_dev.v2alpha.Insights/Version", opts...)
	if err != nil {
		return nil, err
	}
	x := &insightsVersionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Insights_VersionClient interface {
	Recv() (*VersionResponse, error)
	grpc.ClientStream
}

type insightsVersionClient struct {
	grpc.ClientStream
}

func (x *insightsVersionClient) Recv() (*VersionResponse, error) {
	m := new(VersionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *insightsClient) Dependencies(ctx context.Context, in *DependenciesRequest, opts ...grpc.CallOption) (Insights_DependenciesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Insights_ServiceDesc.Streams[3], "/deps_dev.v2alpha.Insights/Dependencies", opts...)
	if err != nil {
		return nil, err
	}
	x := &insightsDependenciesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Insights_DependenciesClient interface {
	Recv() (*DependenciesResponse, error)
	grpc.ClientStream
}

type insightsDependenciesClient struct {
	grpc.ClientStream
}

func (x *insightsDependenciesClient) Recv() (*DependenciesResponse, error) {
	m := new(DependenciesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *insightsClient) DependentInfo(ctx context.Context, in *DependentInfoRequest, opts ...grpc.CallOption) (*DependentInfoResponse, error) {
	out := new(DependentInfoResponse)
	err := c.cc.Invoke(ctx, "/deps_dev.v2alpha.Insights/DependentInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *insightsClient) Advisory(ctx context.Context, in *AdvisoryRequest, opts ...grpc.CallOption) (*AdvisoryResponse, error) {
	out := new(AdvisoryResponse)
	err := c.cc.Invoke(ctx, "/deps_dev.v2alpha.Insights/Advisory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *insightsClient) Project(ctx context.Context, in *ProjectRequest, opts ...grpc.CallOption) (*ProjectResponse, error) {
	out := new(ProjectResponse)
	err := c.cc.Invoke(ctx, "/deps_dev.v2alpha.Insights/Project", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *insightsClient) ProjectPackageVersions(ctx context.Context, in *ProjectPackageVersionsRequest, opts ...grpc.CallOption) (Insights_ProjectPackageVersionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Insights_ServiceDesc.Streams[4], "/deps_dev.v2alpha.Insights/ProjectPackageVersions", opts...)
	if err != nil {
		return nil, err
	}
	x := &insightsProjectPackageVersionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Insights_ProjectPackageVersionsClient interface {
	Recv() (*ProjectPackageVersionsResponse, error)
	grpc.ClientStream
}

type insightsProjectPackageVersionsClient struct {
	grpc.ClientStream
}

func (x *insightsProjectPackageVersionsClient) Recv() (*ProjectPackageVersionsResponse, error) {
	m := new(ProjectPackageVersionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// InsightsServer is the server API for Insights service.
// All implementations must embed UnimplementedInsightsServer
// for forward compatibility
type InsightsServer interface {
	// Packages returns a list of all known packages, in a batched stream.
	Packages(*PackagesRequest, Insights_PackagesServer) error
	// Versions returns the versions of a package.
	Versions(*VersionsRequest, Insights_VersionsServer) error
	// Version returns information about specific package versions. If the
	// request matches more than one version, multiple responses are returned.
	Version(*VersionRequest, Insights_VersionServer) error
	// Dependencies returns the full dependency graph of a package version, as a
	// stream of messages containing nodes and edges. The first node in the
	// stream is the root of the graph. Edges do not appear before their
	// referenced nodes. If the request matches more than one version, an error
	// is returned.
	Dependencies(*DependenciesRequest, Insights_DependenciesServer) error
	// DependentInfo returns information about the dependents of a package
	// version. If the request matches more than one version, an error is
	// returned.
	DependentInfo(context.Context, *DependentInfoRequest) (*DependentInfoResponse, error)
	// Advisory returns information about a security advisory.
	Advisory(context.Context, *AdvisoryRequest) (*AdvisoryResponse, error)
	// Project returns information about the specified project.
	Project(context.Context, *ProjectRequest) (*ProjectResponse, error)
	// ProjectPackageVersions returns a list of versions that reference the
	// specified project.
	// The links are not confirmed.
	ProjectPackageVersions(*ProjectPackageVersionsRequest, Insights_ProjectPackageVersionsServer) error
	mustEmbedUnimplementedInsightsServer()
}

// UnimplementedInsightsServer must be embedded to have forward compatible implementations.
type UnimplementedInsightsServer struct {
}

func (UnimplementedInsightsServer) Packages(*PackagesRequest, Insights_PackagesServer) error {
	return status.Errorf(codes.Unimplemented, "method Packages not implemented")
}
func (UnimplementedInsightsServer) Versions(*VersionsRequest, Insights_VersionsServer) error {
	return status.Errorf(codes.Unimplemented, "method Versions not implemented")
}
func (UnimplementedInsightsServer) Version(*VersionRequest, Insights_VersionServer) error {
	return status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedInsightsServer) Dependencies(*DependenciesRequest, Insights_DependenciesServer) error {
	return status.Errorf(codes.Unimplemented, "method Dependencies not implemented")
}
func (UnimplementedInsightsServer) DependentInfo(context.Context, *DependentInfoRequest) (*DependentInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DependentInfo not implemented")
}
func (UnimplementedInsightsServer) Advisory(context.Context, *AdvisoryRequest) (*AdvisoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Advisory not implemented")
}
func (UnimplementedInsightsServer) Project(context.Context, *ProjectRequest) (*ProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Project not implemented")
}
func (UnimplementedInsightsServer) ProjectPackageVersions(*ProjectPackageVersionsRequest, Insights_ProjectPackageVersionsServer) error {
	return status.Errorf(codes.Unimplemented, "method ProjectPackageVersions not implemented")
}
func (UnimplementedInsightsServer) mustEmbedUnimplementedInsightsServer() {}

// UnsafeInsightsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InsightsServer will
// result in compilation errors.
type UnsafeInsightsServer interface {
	mustEmbedUnimplementedInsightsServer()
}

func RegisterInsightsServer(s grpc.ServiceRegistrar, srv InsightsServer) {
	s.RegisterService(&Insights_ServiceDesc, srv)
}

func _Insights_Packages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PackagesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InsightsServer).Packages(m, &insightsPackagesServer{stream})
}

type Insights_PackagesServer interface {
	Send(*PackagesResponse) error
	grpc.ServerStream
}

type insightsPackagesServer struct {
	grpc.ServerStream
}

func (x *insightsPackagesServer) Send(m *PackagesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Insights_Versions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VersionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InsightsServer).Versions(m, &insightsVersionsServer{stream})
}

type Insights_VersionsServer interface {
	Send(*VersionsResponse) error
	grpc.ServerStream
}

type insightsVersionsServer struct {
	grpc.ServerStream
}

func (x *insightsVersionsServer) Send(m *VersionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Insights_Version_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VersionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InsightsServer).Version(m, &insightsVersionServer{stream})
}

type Insights_VersionServer interface {
	Send(*VersionResponse) error
	grpc.ServerStream
}

type insightsVersionServer struct {
	grpc.ServerStream
}

func (x *insightsVersionServer) Send(m *VersionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Insights_Dependencies_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DependenciesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InsightsServer).Dependencies(m, &insightsDependenciesServer{stream})
}

type Insights_DependenciesServer interface {
	Send(*DependenciesResponse) error
	grpc.ServerStream
}

type insightsDependenciesServer struct {
	grpc.ServerStream
}

func (x *insightsDependenciesServer) Send(m *DependenciesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Insights_DependentInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DependentInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InsightsServer).DependentInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/deps_dev.v2alpha.Insights/DependentInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InsightsServer).DependentInfo(ctx, req.(*DependentInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Insights_Advisory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdvisoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InsightsServer).Advisory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/deps_dev.v2alpha.Insights/Advisory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InsightsServer).Advisory(ctx, req.(*AdvisoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Insights_Project_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InsightsServer).Project(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/deps_dev.v2alpha.Insights/Project",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InsightsServer).Project(ctx, req.(*ProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Insights_ProjectPackageVersions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectPackageVersionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InsightsServer).ProjectPackageVersions(m, &insightsProjectPackageVersionsServer{stream})
}

type Insights_ProjectPackageVersionsServer interface {
	Send(*ProjectPackageVersionsResponse) error
	grpc.ServerStream
}

type insightsProjectPackageVersionsServer struct {
	grpc.ServerStream
}

func (x *insightsProjectPackageVersionsServer) Send(m *ProjectPackageVersionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

// Insights_ServiceDesc is the grpc.ServiceDesc for Insights service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Insights_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "deps_dev.v2alpha.Insights",
	HandlerType: (*InsightsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DependentInfo",
			Handler:    _Insights_DependentInfo_Handler,
		},
		{
			MethodName: "Advisory",
			Handler:    _Insights_Advisory_Handler,
		},
		{
			MethodName: "Project",
			Handler:    _Insights_Project_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Packages",
			Handler:       _Insights_Packages_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Versions",
			Handler:       _Insights_Versions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Version",
			Handler:       _Insights_Version_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Dependencies",
			Handler:       _Insights_Dependencies_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ProjectPackageVersions",
			Handler:       _Insights_ProjectPackageVersions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/handler/collector/deps.dev/internal/api.proto",
}
