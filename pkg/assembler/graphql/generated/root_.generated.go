// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Annotation struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Artifact struct {
		Algorithm func(childComplexity int) int
		Digest    func(childComplexity int) int
		ID        func(childComplexity int) int
	}

	Builder struct {
		ID  func(childComplexity int) int
		URI func(childComplexity int) int
	}

	CVE struct {
		CveID func(childComplexity int) int
		ID    func(childComplexity int) int
		Year  func(childComplexity int) int
	}

	CertifyBad struct {
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Subject       func(childComplexity int) int
	}

	CertifyGood struct {
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Subject       func(childComplexity int) int
	}

	CertifyScorecard struct {
		ID        func(childComplexity int) int
		Scorecard func(childComplexity int) int
		Source    func(childComplexity int) int
	}

	CertifyVEXStatement struct {
		Collector        func(childComplexity int) int
		ID               func(childComplexity int) int
		KnownSince       func(childComplexity int) int
		Origin           func(childComplexity int) int
		Statement        func(childComplexity int) int
		Status           func(childComplexity int) int
		StatusNotes      func(childComplexity int) int
		Subject          func(childComplexity int) int
		VexJustification func(childComplexity int) int
		Vulnerability    func(childComplexity int) int
	}

	CertifyVuln struct {
		ID            func(childComplexity int) int
		Metadata      func(childComplexity int) int
		Package       func(childComplexity int) int
		Vulnerability func(childComplexity int) int
	}

	GHSA struct {
		GhsaID func(childComplexity int) int
		ID     func(childComplexity int) int
	}

	HasSBOM struct {
		Algorithm        func(childComplexity int) int
		Annotations      func(childComplexity int) int
		Collector        func(childComplexity int) int
		Digest           func(childComplexity int) int
		DownloadLocation func(childComplexity int) int
		ID               func(childComplexity int) int
		Origin           func(childComplexity int) int
		Subject          func(childComplexity int) int
		URI              func(childComplexity int) int
	}

	HasSLSA struct {
		ID      func(childComplexity int) int
		Slsa    func(childComplexity int) int
		Subject func(childComplexity int) int
	}

	HasSourceAt struct {
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		KnownSince    func(childComplexity int) int
		Origin        func(childComplexity int) int
		Package       func(childComplexity int) int
		Source        func(childComplexity int) int
	}

	HashEqual struct {
		Artifacts     func(childComplexity int) int
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
	}

	IsDependency struct {
		Collector        func(childComplexity int) int
		DependencyType   func(childComplexity int) int
		DependentPackage func(childComplexity int) int
		ID               func(childComplexity int) int
		Justification    func(childComplexity int) int
		Origin           func(childComplexity int) int
		Package          func(childComplexity int) int
		VersionRange     func(childComplexity int) int
	}

	IsOccurrence struct {
		Artifact      func(childComplexity int) int
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Subject       func(childComplexity int) int
	}

	IsVulnerability struct {
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Osv           func(childComplexity int) int
		Vulnerability func(childComplexity int) int
	}

	Mutation struct {
		CertifyScorecard      func(childComplexity int, source model.SourceInputSpec, scorecard model.ScorecardInputSpec) int
		IngestArtifact        func(childComplexity int, artifact *model.ArtifactInputSpec) int
		IngestBuilder         func(childComplexity int, builder *model.BuilderInputSpec) int
		IngestCertifyBad      func(childComplexity int, subject model.PackageSourceOrArtifactInput, pkgMatchType *model.MatchFlags, certifyBad model.CertifyBadInputSpec) int
		IngestCertifyGood     func(childComplexity int, subject model.PackageSourceOrArtifactInput, pkgMatchType *model.MatchFlags, certifyGood model.CertifyGoodInputSpec) int
		IngestCve             func(childComplexity int, cve *model.CVEInputSpec) int
		IngestDependency      func(childComplexity int, pkg model.PkgInputSpec, depPkg model.PkgInputSpec, dependency model.IsDependencyInputSpec) int
		IngestGhsa            func(childComplexity int, ghsa *model.GHSAInputSpec) int
		IngestHasSbom         func(childComplexity int, subject model.PackageOrArtifactInput, hasSbom model.HasSBOMInputSpec) int
		IngestHasSourceAt     func(childComplexity int, pkg model.PkgInputSpec, pkgMatchType model.MatchFlags, source model.SourceInputSpec, hasSourceAt model.HasSourceAtInputSpec) int
		IngestHashEqual       func(childComplexity int, artifact model.ArtifactInputSpec, otherArtifact model.ArtifactInputSpec, hashEqual model.HashEqualInputSpec) int
		IngestIsVulnerability func(childComplexity int, osv model.OSVInputSpec, vulnerability model.CveOrGhsaInput, isVulnerability model.IsVulnerabilityInputSpec) int
		IngestMaterials       func(childComplexity int, materials []*model.ArtifactInputSpec) int
		IngestOccurrence      func(childComplexity int, subject model.PackageOrSourceInput, artifact model.ArtifactInputSpec, occurrence model.IsOccurrenceInputSpec) int
		IngestOsv             func(childComplexity int, osv *model.OSVInputSpec) int
		IngestPackage         func(childComplexity int, pkg model.PkgInputSpec) int
		IngestPkgEqual        func(childComplexity int, pkg model.PkgInputSpec, otherPackage model.PkgInputSpec, pkgEqual model.PkgEqualInputSpec) int
		IngestSlsa            func(childComplexity int, subject model.ArtifactInputSpec, builtFrom []*model.ArtifactInputSpec, builtBy model.BuilderInputSpec, slsa model.SLSAInputSpec) int
		IngestSource          func(childComplexity int, source model.SourceInputSpec) int
		IngestVEXStatement    func(childComplexity int, subject model.PackageOrArtifactInput, vulnerability model.VulnerabilityInput, vexStatement model.VexStatementInputSpec) int
		IngestVulnerability   func(childComplexity int, pkg model.PkgInputSpec, vulnerability model.VulnerabilityInput, certifyVuln model.VulnerabilityMetaDataInput) int
	}

	NoVuln struct {
		ID func(childComplexity int) int
	}

	OSV struct {
		ID    func(childComplexity int) int
		OsvID func(childComplexity int) int
	}

	Package struct {
		ID         func(childComplexity int) int
		Namespaces func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	PackageName struct {
		ID       func(childComplexity int) int
		Name     func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	PackageNamespace struct {
		ID        func(childComplexity int) int
		Names     func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	PackageQualifier struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	PackageVersion struct {
		ID         func(childComplexity int) int
		Qualifiers func(childComplexity int) int
		Subpath    func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	PkgEqual struct {
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Packages      func(childComplexity int) int
	}

	Query struct {
		Artifacts           func(childComplexity int, artifactSpec *model.ArtifactSpec) int
		Builders            func(childComplexity int, builderSpec *model.BuilderSpec) int
		CertifyBad          func(childComplexity int, certifyBadSpec *model.CertifyBadSpec) int
		CertifyGood         func(childComplexity int, certifyGoodSpec *model.CertifyGoodSpec) int
		CertifyVEXStatement func(childComplexity int, certifyVEXStatementSpec *model.CertifyVEXStatementSpec) int
		CertifyVuln         func(childComplexity int, certifyVulnSpec *model.CertifyVulnSpec) int
		Cve                 func(childComplexity int, cveSpec *model.CVESpec) int
		Ghsa                func(childComplexity int, ghsaSpec *model.GHSASpec) int
		HasSbom             func(childComplexity int, hasSBOMSpec *model.HasSBOMSpec) int
		HasSlsa             func(childComplexity int, hasSLSASpec *model.HasSLSASpec) int
		HasSourceAt         func(childComplexity int, hasSourceAtSpec *model.HasSourceAtSpec) int
		HashEqual           func(childComplexity int, hashEqualSpec *model.HashEqualSpec) int
		IsDependency        func(childComplexity int, isDependencySpec *model.IsDependencySpec) int
		IsOccurrence        func(childComplexity int, isOccurrenceSpec *model.IsOccurrenceSpec) int
		IsVulnerability     func(childComplexity int, isVulnerabilitySpec *model.IsVulnerabilitySpec) int
		Neighbors           func(childComplexity int, node string, usingOnly []model.Edge) int
		Node                func(childComplexity int, node string) int
		Nodes               func(childComplexity int, nodes []string) int
		Osv                 func(childComplexity int, osvSpec *model.OSVSpec) int
		Packages            func(childComplexity int, pkgSpec *model.PkgSpec) int
		Path                func(childComplexity int, subject string, target string, maxPathLength int, usingOnly []model.Edge) int
		PkgEqual            func(childComplexity int, pkgEqualSpec *model.PkgEqualSpec) int
		Scorecards          func(childComplexity int, scorecardSpec *model.CertifyScorecardSpec) int
		Sources             func(childComplexity int, sourceSpec *model.SourceSpec) int
	}

	SLSA struct {
		BuildType     func(childComplexity int) int
		BuiltBy       func(childComplexity int) int
		BuiltFrom     func(childComplexity int) int
		Collector     func(childComplexity int) int
		FinishedOn    func(childComplexity int) int
		Origin        func(childComplexity int) int
		SlsaPredicate func(childComplexity int) int
		SlsaVersion   func(childComplexity int) int
		StartedOn     func(childComplexity int) int
	}

	SLSAPredicate struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Scorecard struct {
		AggregateScore   func(childComplexity int) int
		Checks           func(childComplexity int) int
		Collector        func(childComplexity int) int
		Origin           func(childComplexity int) int
		ScorecardCommit  func(childComplexity int) int
		ScorecardVersion func(childComplexity int) int
		TimeScanned      func(childComplexity int) int
	}

	ScorecardCheck struct {
		Check func(childComplexity int) int
		Score func(childComplexity int) int
	}

	Source struct {
		ID         func(childComplexity int) int
		Namespaces func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	SourceName struct {
		Commit func(childComplexity int) int
		ID     func(childComplexity int) int
		Name   func(childComplexity int) int
		Tag    func(childComplexity int) int
	}

	SourceNamespace struct {
		ID        func(childComplexity int) int
		Names     func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	VulnerabilityMetaData struct {
		Collector      func(childComplexity int) int
		DbURI          func(childComplexity int) int
		DbVersion      func(childComplexity int) int
		Origin         func(childComplexity int) int
		ScannerURI     func(childComplexity int) int
		ScannerVersion func(childComplexity int) int
		TimeScanned    func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Annotation.key":
		if e.complexity.Annotation.Key == nil {
			break
		}

		return e.complexity.Annotation.Key(childComplexity), true

	case "Annotation.value":
		if e.complexity.Annotation.Value == nil {
			break
		}

		return e.complexity.Annotation.Value(childComplexity), true

	case "Artifact.algorithm":
		if e.complexity.Artifact.Algorithm == nil {
			break
		}

		return e.complexity.Artifact.Algorithm(childComplexity), true

	case "Artifact.digest":
		if e.complexity.Artifact.Digest == nil {
			break
		}

		return e.complexity.Artifact.Digest(childComplexity), true

	case "Artifact.id":
		if e.complexity.Artifact.ID == nil {
			break
		}

		return e.complexity.Artifact.ID(childComplexity), true

	case "Builder.id":
		if e.complexity.Builder.ID == nil {
			break
		}

		return e.complexity.Builder.ID(childComplexity), true

	case "Builder.uri":
		if e.complexity.Builder.URI == nil {
			break
		}

		return e.complexity.Builder.URI(childComplexity), true

	case "CVE.cveId":
		if e.complexity.CVE.CveID == nil {
			break
		}

		return e.complexity.CVE.CveID(childComplexity), true

	case "CVE.id":
		if e.complexity.CVE.ID == nil {
			break
		}

		return e.complexity.CVE.ID(childComplexity), true

	case "CVE.year":
		if e.complexity.CVE.Year == nil {
			break
		}

		return e.complexity.CVE.Year(childComplexity), true

	case "CertifyBad.collector":
		if e.complexity.CertifyBad.Collector == nil {
			break
		}

		return e.complexity.CertifyBad.Collector(childComplexity), true

	case "CertifyBad.id":
		if e.complexity.CertifyBad.ID == nil {
			break
		}

		return e.complexity.CertifyBad.ID(childComplexity), true

	case "CertifyBad.justification":
		if e.complexity.CertifyBad.Justification == nil {
			break
		}

		return e.complexity.CertifyBad.Justification(childComplexity), true

	case "CertifyBad.origin":
		if e.complexity.CertifyBad.Origin == nil {
			break
		}

		return e.complexity.CertifyBad.Origin(childComplexity), true

	case "CertifyBad.subject":
		if e.complexity.CertifyBad.Subject == nil {
			break
		}

		return e.complexity.CertifyBad.Subject(childComplexity), true

	case "CertifyGood.collector":
		if e.complexity.CertifyGood.Collector == nil {
			break
		}

		return e.complexity.CertifyGood.Collector(childComplexity), true

	case "CertifyGood.id":
		if e.complexity.CertifyGood.ID == nil {
			break
		}

		return e.complexity.CertifyGood.ID(childComplexity), true

	case "CertifyGood.justification":
		if e.complexity.CertifyGood.Justification == nil {
			break
		}

		return e.complexity.CertifyGood.Justification(childComplexity), true

	case "CertifyGood.origin":
		if e.complexity.CertifyGood.Origin == nil {
			break
		}

		return e.complexity.CertifyGood.Origin(childComplexity), true

	case "CertifyGood.subject":
		if e.complexity.CertifyGood.Subject == nil {
			break
		}

		return e.complexity.CertifyGood.Subject(childComplexity), true

	case "CertifyScorecard.id":
		if e.complexity.CertifyScorecard.ID == nil {
			break
		}

		return e.complexity.CertifyScorecard.ID(childComplexity), true

	case "CertifyScorecard.scorecard":
		if e.complexity.CertifyScorecard.Scorecard == nil {
			break
		}

		return e.complexity.CertifyScorecard.Scorecard(childComplexity), true

	case "CertifyScorecard.source":
		if e.complexity.CertifyScorecard.Source == nil {
			break
		}

		return e.complexity.CertifyScorecard.Source(childComplexity), true

	case "CertifyVEXStatement.collector":
		if e.complexity.CertifyVEXStatement.Collector == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Collector(childComplexity), true

	case "CertifyVEXStatement.id":
		if e.complexity.CertifyVEXStatement.ID == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.ID(childComplexity), true

	case "CertifyVEXStatement.knownSince":
		if e.complexity.CertifyVEXStatement.KnownSince == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.KnownSince(childComplexity), true

	case "CertifyVEXStatement.origin":
		if e.complexity.CertifyVEXStatement.Origin == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Origin(childComplexity), true

	case "CertifyVEXStatement.statement":
		if e.complexity.CertifyVEXStatement.Statement == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Statement(childComplexity), true

	case "CertifyVEXStatement.status":
		if e.complexity.CertifyVEXStatement.Status == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Status(childComplexity), true

	case "CertifyVEXStatement.statusNotes":
		if e.complexity.CertifyVEXStatement.StatusNotes == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.StatusNotes(childComplexity), true

	case "CertifyVEXStatement.subject":
		if e.complexity.CertifyVEXStatement.Subject == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Subject(childComplexity), true

	case "CertifyVEXStatement.vexJustification":
		if e.complexity.CertifyVEXStatement.VexJustification == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.VexJustification(childComplexity), true

	case "CertifyVEXStatement.vulnerability":
		if e.complexity.CertifyVEXStatement.Vulnerability == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Vulnerability(childComplexity), true

	case "CertifyVuln.id":
		if e.complexity.CertifyVuln.ID == nil {
			break
		}

		return e.complexity.CertifyVuln.ID(childComplexity), true

	case "CertifyVuln.metadata":
		if e.complexity.CertifyVuln.Metadata == nil {
			break
		}

		return e.complexity.CertifyVuln.Metadata(childComplexity), true

	case "CertifyVuln.package":
		if e.complexity.CertifyVuln.Package == nil {
			break
		}

		return e.complexity.CertifyVuln.Package(childComplexity), true

	case "CertifyVuln.vulnerability":
		if e.complexity.CertifyVuln.Vulnerability == nil {
			break
		}

		return e.complexity.CertifyVuln.Vulnerability(childComplexity), true

	case "GHSA.ghsaId":
		if e.complexity.GHSA.GhsaID == nil {
			break
		}

		return e.complexity.GHSA.GhsaID(childComplexity), true

	case "GHSA.id":
		if e.complexity.GHSA.ID == nil {
			break
		}

		return e.complexity.GHSA.ID(childComplexity), true

	case "HasSBOM.algorithm":
		if e.complexity.HasSBOM.Algorithm == nil {
			break
		}

		return e.complexity.HasSBOM.Algorithm(childComplexity), true

	case "HasSBOM.annotations":
		if e.complexity.HasSBOM.Annotations == nil {
			break
		}

		return e.complexity.HasSBOM.Annotations(childComplexity), true

	case "HasSBOM.collector":
		if e.complexity.HasSBOM.Collector == nil {
			break
		}

		return e.complexity.HasSBOM.Collector(childComplexity), true

	case "HasSBOM.digest":
		if e.complexity.HasSBOM.Digest == nil {
			break
		}

		return e.complexity.HasSBOM.Digest(childComplexity), true

	case "HasSBOM.downloadLocation":
		if e.complexity.HasSBOM.DownloadLocation == nil {
			break
		}

		return e.complexity.HasSBOM.DownloadLocation(childComplexity), true

	case "HasSBOM.id":
		if e.complexity.HasSBOM.ID == nil {
			break
		}

		return e.complexity.HasSBOM.ID(childComplexity), true

	case "HasSBOM.origin":
		if e.complexity.HasSBOM.Origin == nil {
			break
		}

		return e.complexity.HasSBOM.Origin(childComplexity), true

	case "HasSBOM.subject":
		if e.complexity.HasSBOM.Subject == nil {
			break
		}

		return e.complexity.HasSBOM.Subject(childComplexity), true

	case "HasSBOM.uri":
		if e.complexity.HasSBOM.URI == nil {
			break
		}

		return e.complexity.HasSBOM.URI(childComplexity), true

	case "HasSLSA.id":
		if e.complexity.HasSLSA.ID == nil {
			break
		}

		return e.complexity.HasSLSA.ID(childComplexity), true

	case "HasSLSA.slsa":
		if e.complexity.HasSLSA.Slsa == nil {
			break
		}

		return e.complexity.HasSLSA.Slsa(childComplexity), true

	case "HasSLSA.subject":
		if e.complexity.HasSLSA.Subject == nil {
			break
		}

		return e.complexity.HasSLSA.Subject(childComplexity), true

	case "HasSourceAt.collector":
		if e.complexity.HasSourceAt.Collector == nil {
			break
		}

		return e.complexity.HasSourceAt.Collector(childComplexity), true

	case "HasSourceAt.id":
		if e.complexity.HasSourceAt.ID == nil {
			break
		}

		return e.complexity.HasSourceAt.ID(childComplexity), true

	case "HasSourceAt.justification":
		if e.complexity.HasSourceAt.Justification == nil {
			break
		}

		return e.complexity.HasSourceAt.Justification(childComplexity), true

	case "HasSourceAt.knownSince":
		if e.complexity.HasSourceAt.KnownSince == nil {
			break
		}

		return e.complexity.HasSourceAt.KnownSince(childComplexity), true

	case "HasSourceAt.origin":
		if e.complexity.HasSourceAt.Origin == nil {
			break
		}

		return e.complexity.HasSourceAt.Origin(childComplexity), true

	case "HasSourceAt.package":
		if e.complexity.HasSourceAt.Package == nil {
			break
		}

		return e.complexity.HasSourceAt.Package(childComplexity), true

	case "HasSourceAt.source":
		if e.complexity.HasSourceAt.Source == nil {
			break
		}

		return e.complexity.HasSourceAt.Source(childComplexity), true

	case "HashEqual.artifacts":
		if e.complexity.HashEqual.Artifacts == nil {
			break
		}

		return e.complexity.HashEqual.Artifacts(childComplexity), true

	case "HashEqual.collector":
		if e.complexity.HashEqual.Collector == nil {
			break
		}

		return e.complexity.HashEqual.Collector(childComplexity), true

	case "HashEqual.id":
		if e.complexity.HashEqual.ID == nil {
			break
		}

		return e.complexity.HashEqual.ID(childComplexity), true

	case "HashEqual.justification":
		if e.complexity.HashEqual.Justification == nil {
			break
		}

		return e.complexity.HashEqual.Justification(childComplexity), true

	case "HashEqual.origin":
		if e.complexity.HashEqual.Origin == nil {
			break
		}

		return e.complexity.HashEqual.Origin(childComplexity), true

	case "IsDependency.collector":
		if e.complexity.IsDependency.Collector == nil {
			break
		}

		return e.complexity.IsDependency.Collector(childComplexity), true

	case "IsDependency.dependencyType":
		if e.complexity.IsDependency.DependencyType == nil {
			break
		}

		return e.complexity.IsDependency.DependencyType(childComplexity), true

	case "IsDependency.dependentPackage":
		if e.complexity.IsDependency.DependentPackage == nil {
			break
		}

		return e.complexity.IsDependency.DependentPackage(childComplexity), true

	case "IsDependency.id":
		if e.complexity.IsDependency.ID == nil {
			break
		}

		return e.complexity.IsDependency.ID(childComplexity), true

	case "IsDependency.justification":
		if e.complexity.IsDependency.Justification == nil {
			break
		}

		return e.complexity.IsDependency.Justification(childComplexity), true

	case "IsDependency.origin":
		if e.complexity.IsDependency.Origin == nil {
			break
		}

		return e.complexity.IsDependency.Origin(childComplexity), true

	case "IsDependency.package":
		if e.complexity.IsDependency.Package == nil {
			break
		}

		return e.complexity.IsDependency.Package(childComplexity), true

	case "IsDependency.versionRange":
		if e.complexity.IsDependency.VersionRange == nil {
			break
		}

		return e.complexity.IsDependency.VersionRange(childComplexity), true

	case "IsOccurrence.artifact":
		if e.complexity.IsOccurrence.Artifact == nil {
			break
		}

		return e.complexity.IsOccurrence.Artifact(childComplexity), true

	case "IsOccurrence.collector":
		if e.complexity.IsOccurrence.Collector == nil {
			break
		}

		return e.complexity.IsOccurrence.Collector(childComplexity), true

	case "IsOccurrence.id":
		if e.complexity.IsOccurrence.ID == nil {
			break
		}

		return e.complexity.IsOccurrence.ID(childComplexity), true

	case "IsOccurrence.justification":
		if e.complexity.IsOccurrence.Justification == nil {
			break
		}

		return e.complexity.IsOccurrence.Justification(childComplexity), true

	case "IsOccurrence.origin":
		if e.complexity.IsOccurrence.Origin == nil {
			break
		}

		return e.complexity.IsOccurrence.Origin(childComplexity), true

	case "IsOccurrence.subject":
		if e.complexity.IsOccurrence.Subject == nil {
			break
		}

		return e.complexity.IsOccurrence.Subject(childComplexity), true

	case "IsVulnerability.collector":
		if e.complexity.IsVulnerability.Collector == nil {
			break
		}

		return e.complexity.IsVulnerability.Collector(childComplexity), true

	case "IsVulnerability.id":
		if e.complexity.IsVulnerability.ID == nil {
			break
		}

		return e.complexity.IsVulnerability.ID(childComplexity), true

	case "IsVulnerability.justification":
		if e.complexity.IsVulnerability.Justification == nil {
			break
		}

		return e.complexity.IsVulnerability.Justification(childComplexity), true

	case "IsVulnerability.origin":
		if e.complexity.IsVulnerability.Origin == nil {
			break
		}

		return e.complexity.IsVulnerability.Origin(childComplexity), true

	case "IsVulnerability.osv":
		if e.complexity.IsVulnerability.Osv == nil {
			break
		}

		return e.complexity.IsVulnerability.Osv(childComplexity), true

	case "IsVulnerability.vulnerability":
		if e.complexity.IsVulnerability.Vulnerability == nil {
			break
		}

		return e.complexity.IsVulnerability.Vulnerability(childComplexity), true

	case "Mutation.certifyScorecard":
		if e.complexity.Mutation.CertifyScorecard == nil {
			break
		}

		args, err := ec.field_Mutation_certifyScorecard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CertifyScorecard(childComplexity, args["source"].(model.SourceInputSpec), args["scorecard"].(model.ScorecardInputSpec)), true

	case "Mutation.ingestArtifact":
		if e.complexity.Mutation.IngestArtifact == nil {
			break
		}

		args, err := ec.field_Mutation_ingestArtifact_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestArtifact(childComplexity, args["artifact"].(*model.ArtifactInputSpec)), true

	case "Mutation.ingestBuilder":
		if e.complexity.Mutation.IngestBuilder == nil {
			break
		}

		args, err := ec.field_Mutation_ingestBuilder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestBuilder(childComplexity, args["builder"].(*model.BuilderInputSpec)), true

	case "Mutation.ingestCertifyBad":
		if e.complexity.Mutation.IngestCertifyBad == nil {
			break
		}

		args, err := ec.field_Mutation_ingestCertifyBad_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestCertifyBad(childComplexity, args["subject"].(model.PackageSourceOrArtifactInput), args["pkgMatchType"].(*model.MatchFlags), args["certifyBad"].(model.CertifyBadInputSpec)), true

	case "Mutation.ingestCertifyGood":
		if e.complexity.Mutation.IngestCertifyGood == nil {
			break
		}

		args, err := ec.field_Mutation_ingestCertifyGood_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestCertifyGood(childComplexity, args["subject"].(model.PackageSourceOrArtifactInput), args["pkgMatchType"].(*model.MatchFlags), args["certifyGood"].(model.CertifyGoodInputSpec)), true

	case "Mutation.ingestCVE":
		if e.complexity.Mutation.IngestCve == nil {
			break
		}

		args, err := ec.field_Mutation_ingestCVE_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestCve(childComplexity, args["cve"].(*model.CVEInputSpec)), true

	case "Mutation.ingestDependency":
		if e.complexity.Mutation.IngestDependency == nil {
			break
		}

		args, err := ec.field_Mutation_ingestDependency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestDependency(childComplexity, args["pkg"].(model.PkgInputSpec), args["depPkg"].(model.PkgInputSpec), args["dependency"].(model.IsDependencyInputSpec)), true

	case "Mutation.ingestGHSA":
		if e.complexity.Mutation.IngestGhsa == nil {
			break
		}

		args, err := ec.field_Mutation_ingestGHSA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestGhsa(childComplexity, args["ghsa"].(*model.GHSAInputSpec)), true

	case "Mutation.ingestHasSBOM":
		if e.complexity.Mutation.IngestHasSbom == nil {
			break
		}

		args, err := ec.field_Mutation_ingestHasSBOM_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestHasSbom(childComplexity, args["subject"].(model.PackageOrArtifactInput), args["hasSBOM"].(model.HasSBOMInputSpec)), true

	case "Mutation.ingestHasSourceAt":
		if e.complexity.Mutation.IngestHasSourceAt == nil {
			break
		}

		args, err := ec.field_Mutation_ingestHasSourceAt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestHasSourceAt(childComplexity, args["pkg"].(model.PkgInputSpec), args["pkgMatchType"].(model.MatchFlags), args["source"].(model.SourceInputSpec), args["hasSourceAt"].(model.HasSourceAtInputSpec)), true

	case "Mutation.ingestHashEqual":
		if e.complexity.Mutation.IngestHashEqual == nil {
			break
		}

		args, err := ec.field_Mutation_ingestHashEqual_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestHashEqual(childComplexity, args["artifact"].(model.ArtifactInputSpec), args["otherArtifact"].(model.ArtifactInputSpec), args["hashEqual"].(model.HashEqualInputSpec)), true

	case "Mutation.ingestIsVulnerability":
		if e.complexity.Mutation.IngestIsVulnerability == nil {
			break
		}

		args, err := ec.field_Mutation_ingestIsVulnerability_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestIsVulnerability(childComplexity, args["osv"].(model.OSVInputSpec), args["vulnerability"].(model.CveOrGhsaInput), args["isVulnerability"].(model.IsVulnerabilityInputSpec)), true

	case "Mutation.ingestMaterials":
		if e.complexity.Mutation.IngestMaterials == nil {
			break
		}

		args, err := ec.field_Mutation_ingestMaterials_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestMaterials(childComplexity, args["materials"].([]*model.ArtifactInputSpec)), true

	case "Mutation.ingestOccurrence":
		if e.complexity.Mutation.IngestOccurrence == nil {
			break
		}

		args, err := ec.field_Mutation_ingestOccurrence_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestOccurrence(childComplexity, args["subject"].(model.PackageOrSourceInput), args["artifact"].(model.ArtifactInputSpec), args["occurrence"].(model.IsOccurrenceInputSpec)), true

	case "Mutation.ingestOSV":
		if e.complexity.Mutation.IngestOsv == nil {
			break
		}

		args, err := ec.field_Mutation_ingestOSV_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestOsv(childComplexity, args["osv"].(*model.OSVInputSpec)), true

	case "Mutation.ingestPackage":
		if e.complexity.Mutation.IngestPackage == nil {
			break
		}

		args, err := ec.field_Mutation_ingestPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestPackage(childComplexity, args["pkg"].(model.PkgInputSpec)), true

	case "Mutation.ingestPkgEqual":
		if e.complexity.Mutation.IngestPkgEqual == nil {
			break
		}

		args, err := ec.field_Mutation_ingestPkgEqual_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestPkgEqual(childComplexity, args["pkg"].(model.PkgInputSpec), args["otherPackage"].(model.PkgInputSpec), args["pkgEqual"].(model.PkgEqualInputSpec)), true

	case "Mutation.ingestSLSA":
		if e.complexity.Mutation.IngestSlsa == nil {
			break
		}

		args, err := ec.field_Mutation_ingestSLSA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestSlsa(childComplexity, args["subject"].(model.ArtifactInputSpec), args["builtFrom"].([]*model.ArtifactInputSpec), args["builtBy"].(model.BuilderInputSpec), args["slsa"].(model.SLSAInputSpec)), true

	case "Mutation.ingestSource":
		if e.complexity.Mutation.IngestSource == nil {
			break
		}

		args, err := ec.field_Mutation_ingestSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestSource(childComplexity, args["source"].(model.SourceInputSpec)), true

	case "Mutation.ingestVEXStatement":
		if e.complexity.Mutation.IngestVEXStatement == nil {
			break
		}

		args, err := ec.field_Mutation_ingestVEXStatement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestVEXStatement(childComplexity, args["subject"].(model.PackageOrArtifactInput), args["vulnerability"].(model.VulnerabilityInput), args["vexStatement"].(model.VexStatementInputSpec)), true

	case "Mutation.ingestVulnerability":
		if e.complexity.Mutation.IngestVulnerability == nil {
			break
		}

		args, err := ec.field_Mutation_ingestVulnerability_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestVulnerability(childComplexity, args["pkg"].(model.PkgInputSpec), args["vulnerability"].(model.VulnerabilityInput), args["certifyVuln"].(model.VulnerabilityMetaDataInput)), true

	case "NoVuln.id":
		if e.complexity.NoVuln.ID == nil {
			break
		}

		return e.complexity.NoVuln.ID(childComplexity), true

	case "OSV.id":
		if e.complexity.OSV.ID == nil {
			break
		}

		return e.complexity.OSV.ID(childComplexity), true

	case "OSV.osvId":
		if e.complexity.OSV.OsvID == nil {
			break
		}

		return e.complexity.OSV.OsvID(childComplexity), true

	case "Package.id":
		if e.complexity.Package.ID == nil {
			break
		}

		return e.complexity.Package.ID(childComplexity), true

	case "Package.namespaces":
		if e.complexity.Package.Namespaces == nil {
			break
		}

		return e.complexity.Package.Namespaces(childComplexity), true

	case "Package.type":
		if e.complexity.Package.Type == nil {
			break
		}

		return e.complexity.Package.Type(childComplexity), true

	case "PackageName.id":
		if e.complexity.PackageName.ID == nil {
			break
		}

		return e.complexity.PackageName.ID(childComplexity), true

	case "PackageName.name":
		if e.complexity.PackageName.Name == nil {
			break
		}

		return e.complexity.PackageName.Name(childComplexity), true

	case "PackageName.versions":
		if e.complexity.PackageName.Versions == nil {
			break
		}

		return e.complexity.PackageName.Versions(childComplexity), true

	case "PackageNamespace.id":
		if e.complexity.PackageNamespace.ID == nil {
			break
		}

		return e.complexity.PackageNamespace.ID(childComplexity), true

	case "PackageNamespace.names":
		if e.complexity.PackageNamespace.Names == nil {
			break
		}

		return e.complexity.PackageNamespace.Names(childComplexity), true

	case "PackageNamespace.namespace":
		if e.complexity.PackageNamespace.Namespace == nil {
			break
		}

		return e.complexity.PackageNamespace.Namespace(childComplexity), true

	case "PackageQualifier.key":
		if e.complexity.PackageQualifier.Key == nil {
			break
		}

		return e.complexity.PackageQualifier.Key(childComplexity), true

	case "PackageQualifier.value":
		if e.complexity.PackageQualifier.Value == nil {
			break
		}

		return e.complexity.PackageQualifier.Value(childComplexity), true

	case "PackageVersion.id":
		if e.complexity.PackageVersion.ID == nil {
			break
		}

		return e.complexity.PackageVersion.ID(childComplexity), true

	case "PackageVersion.qualifiers":
		if e.complexity.PackageVersion.Qualifiers == nil {
			break
		}

		return e.complexity.PackageVersion.Qualifiers(childComplexity), true

	case "PackageVersion.subpath":
		if e.complexity.PackageVersion.Subpath == nil {
			break
		}

		return e.complexity.PackageVersion.Subpath(childComplexity), true

	case "PackageVersion.version":
		if e.complexity.PackageVersion.Version == nil {
			break
		}

		return e.complexity.PackageVersion.Version(childComplexity), true

	case "PkgEqual.collector":
		if e.complexity.PkgEqual.Collector == nil {
			break
		}

		return e.complexity.PkgEqual.Collector(childComplexity), true

	case "PkgEqual.id":
		if e.complexity.PkgEqual.ID == nil {
			break
		}

		return e.complexity.PkgEqual.ID(childComplexity), true

	case "PkgEqual.justification":
		if e.complexity.PkgEqual.Justification == nil {
			break
		}

		return e.complexity.PkgEqual.Justification(childComplexity), true

	case "PkgEqual.origin":
		if e.complexity.PkgEqual.Origin == nil {
			break
		}

		return e.complexity.PkgEqual.Origin(childComplexity), true

	case "PkgEqual.packages":
		if e.complexity.PkgEqual.Packages == nil {
			break
		}

		return e.complexity.PkgEqual.Packages(childComplexity), true

	case "Query.artifacts":
		if e.complexity.Query.Artifacts == nil {
			break
		}

		args, err := ec.field_Query_artifacts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Artifacts(childComplexity, args["artifactSpec"].(*model.ArtifactSpec)), true

	case "Query.builders":
		if e.complexity.Query.Builders == nil {
			break
		}

		args, err := ec.field_Query_builders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Builders(childComplexity, args["builderSpec"].(*model.BuilderSpec)), true

	case "Query.CertifyBad":
		if e.complexity.Query.CertifyBad == nil {
			break
		}

		args, err := ec.field_Query_CertifyBad_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyBad(childComplexity, args["certifyBadSpec"].(*model.CertifyBadSpec)), true

	case "Query.CertifyGood":
		if e.complexity.Query.CertifyGood == nil {
			break
		}

		args, err := ec.field_Query_CertifyGood_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyGood(childComplexity, args["certifyGoodSpec"].(*model.CertifyGoodSpec)), true

	case "Query.CertifyVEXStatement":
		if e.complexity.Query.CertifyVEXStatement == nil {
			break
		}

		args, err := ec.field_Query_CertifyVEXStatement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyVEXStatement(childComplexity, args["certifyVEXStatementSpec"].(*model.CertifyVEXStatementSpec)), true

	case "Query.CertifyVuln":
		if e.complexity.Query.CertifyVuln == nil {
			break
		}

		args, err := ec.field_Query_CertifyVuln_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyVuln(childComplexity, args["certifyVulnSpec"].(*model.CertifyVulnSpec)), true

	case "Query.cve":
		if e.complexity.Query.Cve == nil {
			break
		}

		args, err := ec.field_Query_cve_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Cve(childComplexity, args["cveSpec"].(*model.CVESpec)), true

	case "Query.ghsa":
		if e.complexity.Query.Ghsa == nil {
			break
		}

		args, err := ec.field_Query_ghsa_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Ghsa(childComplexity, args["ghsaSpec"].(*model.GHSASpec)), true

	case "Query.HasSBOM":
		if e.complexity.Query.HasSbom == nil {
			break
		}

		args, err := ec.field_Query_HasSBOM_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasSbom(childComplexity, args["hasSBOMSpec"].(*model.HasSBOMSpec)), true

	case "Query.HasSLSA":
		if e.complexity.Query.HasSlsa == nil {
			break
		}

		args, err := ec.field_Query_HasSLSA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasSlsa(childComplexity, args["hasSLSASpec"].(*model.HasSLSASpec)), true

	case "Query.HasSourceAt":
		if e.complexity.Query.HasSourceAt == nil {
			break
		}

		args, err := ec.field_Query_HasSourceAt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasSourceAt(childComplexity, args["hasSourceAtSpec"].(*model.HasSourceAtSpec)), true

	case "Query.HashEqual":
		if e.complexity.Query.HashEqual == nil {
			break
		}

		args, err := ec.field_Query_HashEqual_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HashEqual(childComplexity, args["hashEqualSpec"].(*model.HashEqualSpec)), true

	case "Query.IsDependency":
		if e.complexity.Query.IsDependency == nil {
			break
		}

		args, err := ec.field_Query_IsDependency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsDependency(childComplexity, args["isDependencySpec"].(*model.IsDependencySpec)), true

	case "Query.IsOccurrence":
		if e.complexity.Query.IsOccurrence == nil {
			break
		}

		args, err := ec.field_Query_IsOccurrence_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsOccurrence(childComplexity, args["isOccurrenceSpec"].(*model.IsOccurrenceSpec)), true

	case "Query.IsVulnerability":
		if e.complexity.Query.IsVulnerability == nil {
			break
		}

		args, err := ec.field_Query_IsVulnerability_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsVulnerability(childComplexity, args["isVulnerabilitySpec"].(*model.IsVulnerabilitySpec)), true

	case "Query.neighbors":
		if e.complexity.Query.Neighbors == nil {
			break
		}

		args, err := ec.field_Query_neighbors_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Neighbors(childComplexity, args["node"].(string), args["usingOnly"].([]model.Edge)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["node"].(string)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["nodes"].([]string)), true

	case "Query.osv":
		if e.complexity.Query.Osv == nil {
			break
		}

		args, err := ec.field_Query_osv_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Osv(childComplexity, args["osvSpec"].(*model.OSVSpec)), true

	case "Query.packages":
		if e.complexity.Query.Packages == nil {
			break
		}

		args, err := ec.field_Query_packages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Packages(childComplexity, args["pkgSpec"].(*model.PkgSpec)), true

	case "Query.path":
		if e.complexity.Query.Path == nil {
			break
		}

		args, err := ec.field_Query_path_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Path(childComplexity, args["subject"].(string), args["target"].(string), args["maxPathLength"].(int), args["usingOnly"].([]model.Edge)), true

	case "Query.PkgEqual":
		if e.complexity.Query.PkgEqual == nil {
			break
		}

		args, err := ec.field_Query_PkgEqual_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PkgEqual(childComplexity, args["pkgEqualSpec"].(*model.PkgEqualSpec)), true

	case "Query.scorecards":
		if e.complexity.Query.Scorecards == nil {
			break
		}

		args, err := ec.field_Query_scorecards_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Scorecards(childComplexity, args["scorecardSpec"].(*model.CertifyScorecardSpec)), true

	case "Query.sources":
		if e.complexity.Query.Sources == nil {
			break
		}

		args, err := ec.field_Query_sources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sources(childComplexity, args["sourceSpec"].(*model.SourceSpec)), true

	case "SLSA.buildType":
		if e.complexity.SLSA.BuildType == nil {
			break
		}

		return e.complexity.SLSA.BuildType(childComplexity), true

	case "SLSA.builtBy":
		if e.complexity.SLSA.BuiltBy == nil {
			break
		}

		return e.complexity.SLSA.BuiltBy(childComplexity), true

	case "SLSA.builtFrom":
		if e.complexity.SLSA.BuiltFrom == nil {
			break
		}

		return e.complexity.SLSA.BuiltFrom(childComplexity), true

	case "SLSA.collector":
		if e.complexity.SLSA.Collector == nil {
			break
		}

		return e.complexity.SLSA.Collector(childComplexity), true

	case "SLSA.finishedOn":
		if e.complexity.SLSA.FinishedOn == nil {
			break
		}

		return e.complexity.SLSA.FinishedOn(childComplexity), true

	case "SLSA.origin":
		if e.complexity.SLSA.Origin == nil {
			break
		}

		return e.complexity.SLSA.Origin(childComplexity), true

	case "SLSA.slsaPredicate":
		if e.complexity.SLSA.SlsaPredicate == nil {
			break
		}

		return e.complexity.SLSA.SlsaPredicate(childComplexity), true

	case "SLSA.slsaVersion":
		if e.complexity.SLSA.SlsaVersion == nil {
			break
		}

		return e.complexity.SLSA.SlsaVersion(childComplexity), true

	case "SLSA.startedOn":
		if e.complexity.SLSA.StartedOn == nil {
			break
		}

		return e.complexity.SLSA.StartedOn(childComplexity), true

	case "SLSAPredicate.key":
		if e.complexity.SLSAPredicate.Key == nil {
			break
		}

		return e.complexity.SLSAPredicate.Key(childComplexity), true

	case "SLSAPredicate.value":
		if e.complexity.SLSAPredicate.Value == nil {
			break
		}

		return e.complexity.SLSAPredicate.Value(childComplexity), true

	case "Scorecard.aggregateScore":
		if e.complexity.Scorecard.AggregateScore == nil {
			break
		}

		return e.complexity.Scorecard.AggregateScore(childComplexity), true

	case "Scorecard.checks":
		if e.complexity.Scorecard.Checks == nil {
			break
		}

		return e.complexity.Scorecard.Checks(childComplexity), true

	case "Scorecard.collector":
		if e.complexity.Scorecard.Collector == nil {
			break
		}

		return e.complexity.Scorecard.Collector(childComplexity), true

	case "Scorecard.origin":
		if e.complexity.Scorecard.Origin == nil {
			break
		}

		return e.complexity.Scorecard.Origin(childComplexity), true

	case "Scorecard.scorecardCommit":
		if e.complexity.Scorecard.ScorecardCommit == nil {
			break
		}

		return e.complexity.Scorecard.ScorecardCommit(childComplexity), true

	case "Scorecard.scorecardVersion":
		if e.complexity.Scorecard.ScorecardVersion == nil {
			break
		}

		return e.complexity.Scorecard.ScorecardVersion(childComplexity), true

	case "Scorecard.timeScanned":
		if e.complexity.Scorecard.TimeScanned == nil {
			break
		}

		return e.complexity.Scorecard.TimeScanned(childComplexity), true

	case "ScorecardCheck.check":
		if e.complexity.ScorecardCheck.Check == nil {
			break
		}

		return e.complexity.ScorecardCheck.Check(childComplexity), true

	case "ScorecardCheck.score":
		if e.complexity.ScorecardCheck.Score == nil {
			break
		}

		return e.complexity.ScorecardCheck.Score(childComplexity), true

	case "Source.id":
		if e.complexity.Source.ID == nil {
			break
		}

		return e.complexity.Source.ID(childComplexity), true

	case "Source.namespaces":
		if e.complexity.Source.Namespaces == nil {
			break
		}

		return e.complexity.Source.Namespaces(childComplexity), true

	case "Source.type":
		if e.complexity.Source.Type == nil {
			break
		}

		return e.complexity.Source.Type(childComplexity), true

	case "SourceName.commit":
		if e.complexity.SourceName.Commit == nil {
			break
		}

		return e.complexity.SourceName.Commit(childComplexity), true

	case "SourceName.id":
		if e.complexity.SourceName.ID == nil {
			break
		}

		return e.complexity.SourceName.ID(childComplexity), true

	case "SourceName.name":
		if e.complexity.SourceName.Name == nil {
			break
		}

		return e.complexity.SourceName.Name(childComplexity), true

	case "SourceName.tag":
		if e.complexity.SourceName.Tag == nil {
			break
		}

		return e.complexity.SourceName.Tag(childComplexity), true

	case "SourceNamespace.id":
		if e.complexity.SourceNamespace.ID == nil {
			break
		}

		return e.complexity.SourceNamespace.ID(childComplexity), true

	case "SourceNamespace.names":
		if e.complexity.SourceNamespace.Names == nil {
			break
		}

		return e.complexity.SourceNamespace.Names(childComplexity), true

	case "SourceNamespace.namespace":
		if e.complexity.SourceNamespace.Namespace == nil {
			break
		}

		return e.complexity.SourceNamespace.Namespace(childComplexity), true

	case "VulnerabilityMetaData.collector":
		if e.complexity.VulnerabilityMetaData.Collector == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.Collector(childComplexity), true

	case "VulnerabilityMetaData.dbUri":
		if e.complexity.VulnerabilityMetaData.DbURI == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.DbURI(childComplexity), true

	case "VulnerabilityMetaData.dbVersion":
		if e.complexity.VulnerabilityMetaData.DbVersion == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.DbVersion(childComplexity), true

	case "VulnerabilityMetaData.origin":
		if e.complexity.VulnerabilityMetaData.Origin == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.Origin(childComplexity), true

	case "VulnerabilityMetaData.scannerUri":
		if e.complexity.VulnerabilityMetaData.ScannerURI == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.ScannerURI(childComplexity), true

	case "VulnerabilityMetaData.scannerVersion":
		if e.complexity.VulnerabilityMetaData.ScannerVersion == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.ScannerVersion(childComplexity), true

	case "VulnerabilityMetaData.timeScanned":
		if e.complexity.VulnerabilityMetaData.TimeScanned == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.TimeScanned(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAnnotationInputSpec,
		ec.unmarshalInputAnnotationSpec,
		ec.unmarshalInputArtifactInputSpec,
		ec.unmarshalInputArtifactSpec,
		ec.unmarshalInputBuilderInputSpec,
		ec.unmarshalInputBuilderSpec,
		ec.unmarshalInputCVEInputSpec,
		ec.unmarshalInputCVESpec,
		ec.unmarshalInputCertifyBadInputSpec,
		ec.unmarshalInputCertifyBadSpec,
		ec.unmarshalInputCertifyGoodInputSpec,
		ec.unmarshalInputCertifyGoodSpec,
		ec.unmarshalInputCertifyScorecardSpec,
		ec.unmarshalInputCertifyVEXStatementSpec,
		ec.unmarshalInputCertifyVulnSpec,
		ec.unmarshalInputCveOrGhsaInput,
		ec.unmarshalInputCveOrGhsaSpec,
		ec.unmarshalInputGHSAInputSpec,
		ec.unmarshalInputGHSASpec,
		ec.unmarshalInputHasSBOMInputSpec,
		ec.unmarshalInputHasSBOMSpec,
		ec.unmarshalInputHasSLSASpec,
		ec.unmarshalInputHasSourceAtInputSpec,
		ec.unmarshalInputHasSourceAtSpec,
		ec.unmarshalInputHashEqualInputSpec,
		ec.unmarshalInputHashEqualSpec,
		ec.unmarshalInputIsDependencyInputSpec,
		ec.unmarshalInputIsDependencySpec,
		ec.unmarshalInputIsOccurrenceInputSpec,
		ec.unmarshalInputIsOccurrenceSpec,
		ec.unmarshalInputIsVulnerabilityInputSpec,
		ec.unmarshalInputIsVulnerabilitySpec,
		ec.unmarshalInputMatchFlags,
		ec.unmarshalInputOSVInputSpec,
		ec.unmarshalInputOSVSpec,
		ec.unmarshalInputPackageOrArtifactInput,
		ec.unmarshalInputPackageOrArtifactSpec,
		ec.unmarshalInputPackageOrSourceInput,
		ec.unmarshalInputPackageOrSourceSpec,
		ec.unmarshalInputPackageQualifierInputSpec,
		ec.unmarshalInputPackageQualifierSpec,
		ec.unmarshalInputPackageSourceOrArtifactInput,
		ec.unmarshalInputPackageSourceOrArtifactSpec,
		ec.unmarshalInputPkgEqualInputSpec,
		ec.unmarshalInputPkgEqualSpec,
		ec.unmarshalInputPkgInputSpec,
		ec.unmarshalInputPkgNameSpec,
		ec.unmarshalInputPkgSpec,
		ec.unmarshalInputSLSAInputSpec,
		ec.unmarshalInputSLSAPredicateInputSpec,
		ec.unmarshalInputSLSAPredicateSpec,
		ec.unmarshalInputScorecardCheckInputSpec,
		ec.unmarshalInputScorecardCheckSpec,
		ec.unmarshalInputScorecardInputSpec,
		ec.unmarshalInputSourceInputSpec,
		ec.unmarshalInputSourceSpec,
		ec.unmarshalInputVexStatementInputSpec,
		ec.unmarshalInputVulnerabilityInput,
		ec.unmarshalInputVulnerabilityMetaDataInput,
		ec.unmarshalInputVulnerabilitySpec,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/artifact.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the artifact

"""
Artifact represents an artifact identified by a checksum hash.

The checksum is split into the digest value and the algorithm used to generate
it. Both fields are mandatory and canonicalized to be lowercase.

If having a checksum Go object, algorithm can be
strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
"""
type Artifact {
  id: ID!
  algorithm: String!
  digest: String!
}

"""
ArtifactSpec allows filtering the list of artifacts to return in a query.

The checksum fields are canonicalized to be lowercase.
"""
input ArtifactSpec {
  id: ID
  algorithm: String
  digest: String
}

"""
ArtifactInputSpec specifies an artifact for mutations.

The checksum fields are canonicalized to be lowercase.
"""
input ArtifactInputSpec {
  algorithm: String!
  digest: String!
}

extend type Query {
  "Returns all artifacts matching a filter."
  artifacts(artifactSpec: ArtifactSpec): [Artifact!]!
}

extend type Mutation {
  "Ingests a new artifact and returns it."
  ingestArtifact(artifact: ArtifactInputSpec): Artifact!
}
`, BuiltIn: false},
	{Name: "../schema/builder.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the builder

"""
Builder represents the builder (e.g., FRSCA or GitHub Actions).

Currently builders are identified by the uri field.
"""
type Builder {
  id: ID!
  uri: String!
}

"BuilderSpec allows filtering the list of builders to return in a query."
input BuilderSpec {
  id: ID
  uri: String
}

"BuilderInputSpec specifies a builder for mutations."
input BuilderInputSpec {
  uri: String!
}

extend type Query {
  "Returns all builders matching a filter."
  builders(builderSpec: BuilderSpec): [Builder!]!
}

extend type Mutation {
  "Ingests a new builder and returns it."
  ingestBuilder(builder: BuilderInputSpec): Builder!
}
`, BuiltIn: false},
	{Name: "../schema/certifyBad.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CertifyBad

"PackageSourceOrArtifact is a union of Package, Source, and Artifact."
union PackageSourceOrArtifact = Package | Source | Artifact

"""
PackageSourceOrArtifactSpec allows using PackageSourceOrArtifact union as
input type to be used in read queries.

Exactly one of the value must be set to non-nil.
"""
input PackageSourceOrArtifactSpec {
  package: PkgSpec
  source: SourceSpec
  artifact: ArtifactSpec
}

"""
PackageSourceOrArtifactInput allows using PackageSourceOrArtifact union as
input type to be used in mutations.

Exactly one of the value must be set to non-nil.
"""
input PackageSourceOrArtifactInput {
  package: PkgInputSpec
  source: SourceInputSpec
  artifact: ArtifactInputSpec
}

"""
CertifyBad is an attestation that a package, source, or artifact is considered
bad.

All evidence trees record a justification for the property they represent as
well as the document that contains the attestation (origin) and the collector
that collected the document (collector).

The certification applies to a subject which is a package, source, or artifact.
If the attestation targets a package, it must target a PackageName or a
PackageVersion. If the attestation targets a source, it must target a
SourceName.
"""
type CertifyBad {
  id: ID!
  subject: PackageSourceOrArtifact!
  justification: String!
  origin: String!
  collector: String!
}

"""
CertifyBadSpec allows filtering the list of CertifyBad evidence to return in a
query.

If a package is specified in the subject filter, then it must be specified up
to PackageName or PackageVersion. That is, user must specify package name, or
name and one of version, qualifiers, or subpath.

If a source is specified in the subject filter, then it must specify a name,
and optionally a tag and a commit.
"""
input CertifyBadSpec {
  id: ID
  subject: PackageSourceOrArtifactSpec
  justification: String
  origin: String
  collector: String
}

"""
CertifyBadInputSpec represents the mutation input to ingest a CertifyBad
evidence.
"""
input CertifyBadInputSpec {
  justification: String!
  origin: String!
  collector: String!
}

"""
PkgMatchType is an enum to determine if the attestation should be done at the
specific version or package name.
"""
enum PkgMatchType {
  ALL_VERSIONS
  SPECIFIC_VERSION
}

"MatchFlags is used to input the PkgMatchType enum."
input MatchFlags {
  pkg: PkgMatchType!
}

extend type Query {
  "Returns all CertifyBad attestations matching a filter."
  CertifyBad(certifyBadSpec: CertifyBadSpec): [CertifyBad!]!
}

extend type Mutation {
  "Adds a certification that a package, source or artifact is considered bad."
  ingestCertifyBad(subject: PackageSourceOrArtifactInput!, pkgMatchType: MatchFlags, certifyBad: CertifyBadInputSpec!): CertifyBad!
}
`, BuiltIn: false},
	{Name: "../schema/certifyGood.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CertifyGood

"""
CertifyGood is an attestation that a package, source, or artifact is considered
good.

All evidence trees record a justification for the property they represent as
well as the document that contains the attestation (origin) and the collector
that collected the document (collector).

The certification applies to a subject which is a package, source, or artifact.
If the attestation targets a package, it must target a PackageName or a
PackageVersion. If the attestation targets a source, it must target a
SourceName.
"""
type CertifyGood {
  id: ID!
  subject: PackageSourceOrArtifact!
  justification: String!
  origin: String!
  collector: String!
}

"""
CertifyBadSpec allows filtering the list of CertifyBad evidence to return in a
query.

If a package is specified in the subject filter, then it must be specified up
to PackageName or PackageVersion. That is, user must specify package name, or
name and one of version, qualifiers, or subpath.

If a source is specified in the subject filter, then it must specify a name,
and optionally a tag and a commit.
"""
input CertifyGoodSpec {
  id: ID
  subject: PackageSourceOrArtifactSpec
  justification: String
  origin: String
  collector: String
}

"""
CertifyGoodInputSpec represents the mutation input to ingest a CertifyGood evidence.
"""
input CertifyGoodInputSpec {
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all CertifyGood attestations matching a filter."
  CertifyGood(certifyGoodSpec: CertifyGoodSpec): [CertifyGood!]!
}

extend type Mutation {
  "Adds a certification that a package, source or artifact is considered good."
  ingestCertifyGood(subject: PackageSourceOrArtifactInput!, pkgMatchType: MatchFlags, certifyGood: CertifyGoodInputSpec!): CertifyGood!
}
`, BuiltIn: false},
	{Name: "../schema/certifyScorecard.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema to certify Scorecard for a source repository

"""
Define the Time scalar, to be used across GUAC. It follows RFC3339Nano format.

This is implicit via https://gqlgen.com/reference/scalars/#time

For GUAC, we assume that all times are stored in UTC format.
"""
scalar Time

"""
CertifyScorecard is an attestation to attach a Scorecard analysis to a
particular source repository.
"""
type CertifyScorecard {
  id: ID!
  "The source repository that is being scanned (attestation subject)"
  source: Source!
  "The Scorecard attached to the repository (attestation object)"
  scorecard: Scorecard!
}

"""
Scorecard contains all of the fields present in a Scorecard attestation.

We also include fields to specify under what conditions the check was performed
(time of scan, version of scanners, etc.) as well as how this information got
included into GUAC (origin document and the collector for that document).
"""
type Scorecard {
  "Individual Scorecard check scores (Branch-Protection, Code-Review, ...)"
  checks: [ScorecardCheck!]!
  "Overall Scorecard score for the source"
  aggregateScore: Float!
  "Exact timestamp when the source was last scanned (in RFC 3339 format)"
  timeScanned: Time!
  "Version of the Scorecard scanner used to analyze the source"
  scorecardVersion: String!
  "Commit of the Scorecards repository at the time of scanning the source"
  scorecardCommit: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
ScorecardCheck are the individual checks from scorecard and their values as a
key-value pair.

For example:  Branch-Protection, Code-Review...etc

Based off scorecard's:
type jsonCheckResultV2 struct {
  Details []string                 ` + "`" + `json:"details"` + "`" + `
  Score   int                      ` + "`" + `json:"score"` + "`" + `
  Reason  string                   ` + "`" + `json:"reason"` + "`" + `
  Name    string                   ` + "`" + `json:"name"` + "`" + `
  Doc     jsonCheckDocumentationV2 ` + "`" + `json:"documentation"` + "`" + `
}
This node cannot be directly referred by other parts of GUAC.
"""
type ScorecardCheck {
  check: String!
  score: Int!
}

"CertifyScorecardSpec allows filtering the list of Scorecards to return."
input CertifyScorecardSpec {
  id: ID
  source: SourceSpec
  timeScanned: Time
  aggregateScore: Float
  checks: [ScorecardCheckSpec!] = []
  scorecardVersion: String
  scorecardCommit: String
  origin: String
  collector: String
}

"ScorecardCheckSpec is the same as ScorecardCheck, but usable as query input."
input ScorecardCheckSpec {
  check: String!
  score: Int!
}

"ScorecardInputSpec represents the mutation input to ingest a Scorecard."
input ScorecardInputSpec {
  checks: [ScorecardCheckInputSpec!]!
  aggregateScore: Float!
  timeScanned: Time!
  scorecardVersion: String!
  scorecardCommit: String!
  origin: String!
  collector: String!
}

"ScorecardCheckInputSpec represents the mutation input for a Scorecard check."
input ScorecardCheckInputSpec {
  check: String!
  score: Int!
}

extend type Query {
  "Returns all Scorecard certifications matching the filter."
  scorecards(scorecardSpec: CertifyScorecardSpec): [CertifyScorecard!]!
}

extend type Mutation {
  "Adds a certification that a source repository has a Scorecard."
  certifyScorecard(source: SourceInputSpec!, scorecard: ScorecardInputSpec!): CertifyScorecard!
}
`, BuiltIn: false},
	{Name: "../schema/certifyVEXStatement.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for certifying VEX statements

"PackageOrArtifact is a union of Package and Artifact."
union PackageOrArtifact = Package | Artifact

"""
PackageOrArtifactSpec allows using PackageOrArtifact union as
input type to be used in read queries.

Exactly one of the value must be set to non-nil.
"""
input PackageOrArtifactSpec {
  package: PkgSpec
  artifact: ArtifactSpec
}

"""
PackageOrArtifactInput allows using PackageOrArtifact union as
input type to be used in mutations.

Exactly one of the value must be set to non-nil.
"""
input PackageOrArtifactInput {
  package: PkgInputSpec
  artifact: ArtifactInputSpec
}

"Records the status of a VEX statement subject."
enum VexStatus {
  NOT_AFFECTED
  AFFECTED
  FIXED
  UNDER_INVESTIGATION
}

"Records the justification included in the VEX statement."
enum VexJustification {
  COMPONENT_NOT_PRESENT
  VULNERABLE_CODE_NOT_PRESENT
  VULNERABLE_CODE_NOT_IN_EXECUTE_PATH
  VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY
  INLINE_MITIGATIONS_ALREADY_EXIST
  NOT_PROVIDED
}

"""
CertifyVEXStatement is an attestation to attach VEX statements to a package or
artifact to clarify the impact of a specific vulnerability (CVE, GHSA or OSV).
"""
type CertifyVEXStatement {
  id: ID!
  "Subject of attestation"
  subject: PackageOrArtifact!
  "Attested vulnerability"
  vulnerability: Vulnerability!
  "Status of the vulnerabilities with respect to the subject"
  status: VexStatus!
  "Justification from VEX statement"
  vexJustification: VexJustification!
  "VEX statement: impact_statement or action_statement depending on status"
  statement: String!
  "statusNotes may convey information about how status was determined"
  statusNotes: String!
  "Timestamp (exact time in RFC 3339 format) for the VEX statement"
  knownSince: Time!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
CertifyVEXStatementSpec allows filtering the list of VEX statements to
return in a query.

Only one subject type (package or artifact) and one vulnerability type (CVE,
GHSA or OSV) may be specified.

Note that setting noVuln in VulnerabilitySpec is invalid for VEX statements!
"""
input CertifyVEXStatementSpec {
  id: ID
  subject: PackageOrArtifactSpec
  vulnerability: VulnerabilitySpec
  status: VexStatus
  vexJustification: VexJustification
  statement: String
  statusNotes: String
  knownSince: Time
  origin: String
  collector: String
}

"VexStatementInputSpec represents the input to ingest VEX statements."
input VexStatementInputSpec {
  status: VexStatus!
  vexJustification: VexJustification!
  statement: String!
  statusNotes: String!
  knownSince: Time!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all VEX certifications matching the input filter."
  CertifyVEXStatement(certifyVEXStatementSpec: CertifyVEXStatementSpec): [CertifyVEXStatement!]!
}

extend type Mutation {
  "Adds a VEX certification for a package."
  ingestVEXStatement(subject: PackageOrArtifactInput!, vulnerability: VulnerabilityInput!, vexStatement: VexStatementInputSpec!): CertifyVEXStatement!
}
`, BuiltIn: false},
	{Name: "../schema/certifyVuln.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the vulnerability certifications

"""
NoVuln is a special vulnerability node to attest that no vulnerability has been
found during a vulnerability scan.

Backends guarantee that this is a singleton node.
"""
type NoVuln {
  id: ID!
}

"Vulnerability is a union of OSV, CVE, GHSA or the NoVuln node."
union Vulnerability = OSV | CVE | GHSA | NoVuln

"""
VulnerabilitySpec allows using Vulnerability union as input type to be used in
read queries.

Either noVuln must be set to true or exactly one of osv, cve or ghsa
must be set to non-nil. Setting noVuln to true means retrieving nodes where
there is no vulnerability attached (thus, the special NoVuln node). Setting one
of the other fields means retrieving certifications for the corresponding
vulnerability types.
"""
input VulnerabilitySpec {
  osv: OSVSpec
  cve: CVESpec
  ghsa: GHSASpec
  noVuln: Boolean
}

"""
VulnerabilityInput allows using Vulnerability union as
input type to be used in mutations.

Either noVuln must be set to true or one of osv, cve, or ghsa must be
set to non-nil. If noVuln is set then this is an ingestion of a known lack of
vulnerabilities, so the special NoVuln node will be used by the backend.
Otherwise, the specific vulnerability type will be linked to this attestation.
"""
input VulnerabilityInput {
  osv: OSVInputSpec
  cve: CVEInputSpec
  ghsa: GHSAInputSpec
  noVuln: Boolean
}

"""
CertifyVuln is an attestation to attach vulnerability information to a package.

This information is obtained via a scanner. If there is no vulnerability
detected (no OSV, CVE, or GHSA), we attach the special NoVuln node.
"""
type CertifyVuln {
  id: ID!
  "The package that is attested"
  package: Package!
  "The vulnerability object. Can be an OSV, CVE, or GHSA or the special NoVuln node."
  vulnerability: Vulnerability!
  "Metadata attached to the certification"
  metadata: VulnerabilityMetaData!
}

"""
VulnerabilityMetaData is the metadata attached to vulnerability certification.

It contains metadata about the scanner process that created the certification.
"""
type VulnerabilityMetaData {
  "Time of scan (in RFC 3339 format)"
  timeScanned: Time!
  "URI of the vulnerability database used by the scanner"
  dbUri: String!
  "Version of the vulnerability database used by the scanner"
  dbVersion: String!
  "URI of the scanner"
  scannerUri: String!
  "Version of the scanner"
  scannerVersion: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
CertifyVulnSpec allows filtering the list of vulnerability certifications to
return in a query.

Specifying just the package allows to query for all vulnerabilities associated
with the package.

Only one vulnerability type (OSV, CVE, GHSA, or special NoVuln) may be
specified.
"""
input CertifyVulnSpec {
  id: ID
  package: PkgSpec
  vulnerability: VulnerabilitySpec
  timeScanned: Time
  dbUri: String
  dbVersion: String
  scannerUri: String
  scannerVersion: String
  origin: String
  collector: String
}

"""
VulnerabilityMetaDataInput represents the input for certifying vulnerability
scans in mutations.
"""
input VulnerabilityMetaDataInput {
  timeScanned: Time!
  dbUri: String!
  dbVersion: String!
  scannerUri: String!
  scannerVersion: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all vulnerability certifications matching the input filter."
  CertifyVuln(certifyVulnSpec: CertifyVulnSpec): [CertifyVuln!]!
}

extend type Mutation {
  "Adds a certification that a package has been scanned for vulnerabilities."
  ingestVulnerability(pkg: PkgInputSpec!, vulnerability: VulnerabilityInput!, certifyVuln: VulnerabilityMetaDataInput!): CertifyVuln!
}
`, BuiltIn: false},
	{Name: "../schema/cve.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for a vulnerability in CVE schema

"""
CVE represents a vulnerability in the Common Vulnerabilities and Exposures
schema.

The vulnerability identifier contains a year field, so we are extracting that
to allow matching for vulnerabilities found in a given year.

The vulnerability identifier field is mandatory and canonicalized to be
lowercase.

This node can be referred to by other parts of GUAC.
"""
type CVE {
  id: ID!
  year: Int!
  cveId: String!
}

"CVESpec allows filtering the list of advisories to return in a query."
input CVESpec {
  id: ID
  year: Int
  cveId: String
}

"CVEInputSpec specifies a CVE vulnerability for mutations."
input CVEInputSpec {
  year: Int!
  cveId: String!
}

extend type Query {
  "Returns all CVEs matching a filter."
  cve(cveSpec: CVESpec): [CVE!]!
}

extend type Mutation {
  "Ingests new CVE and returns it."
  ingestCVE(cve: CVEInputSpec): CVE!
}
`, BuiltIn: false},
	{Name: "../schema/ghsa.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

"""
GHSA represents GitHub security advisories.

The advisory id field is mandatory and canonicalized to be lowercase.

This node can be referred to by other parts of GUAC.
"""
type GHSA {
  id: ID!
  ghsaId: String!
}

"GHSASpec allows filtering the list of advisories to return in a query."
input GHSASpec {
  id: ID
  ghsaId: String
}

"GHSAInputSpec specifies a GitHub Security Advisory for mutations."
input GHSAInputSpec {
  ghsaId: String!
}

extend type Query {
  "Returns all GitHub Security Advisories matching a filter."
  ghsa(ghsaSpec: GHSASpec): [GHSA!]!
}

extend type Mutation {
  "Ingests a new GitHub Security Advisory and returns it."
  ingestGHSA(ghsa: GHSAInputSpec): GHSA!
}
`, BuiltIn: false},
	{Name: "../schema/hasSBOM.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for recording presence of SBOMs

type HasSBOM {
  id: ID!
  "SBOM subject"
  subject: PackageOrArtifact!
  "Identifier for the SBOM document"
  uri: String!
  "Algorithm by which SBOMs digest was computed"
  algorithm: String!
  "Digest of SBOM"
  digest: String!
  "Location from which the SBOM can be downloaded"
  downloadLocation: String!
  "SBOM annotations (e.g., SBOM Scorecard information)"
  annotations: [Annotation!]!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
Annotation is a key-value pair to provide additional information or metadata
about an SBOM.
"""
type Annotation {
  key: String!
  value: String!
}

"""
HasSBOMSpec allows filtering the list of HasSBOM to return.

Only the package or artifact can be added, not both.
"""
input HasSBOMSpec {
  id: ID
  subject: PackageOrArtifactSpec
  uri: String
  algorithm: String
  digest: String
  downloadLocation: String
  annotations: [AnnotationSpec!] = []
  origin: String
  collector: String
}

"AnnotationSpec allows creating query filters for Annotation objects."
input AnnotationSpec {
  key: String!
  value: String!
}

"HasSBOMInputSpec is the same as HasSBOM but for mutation input."
input HasSBOMInputSpec {
  uri: String!
  algorithm: String!
  digest: String!
  downloadLocation: String!
  annotations: [AnnotationInputSpec!]!
  origin: String!
  collector: String!
}

"AnnotationInputSpec allows ingesting Annotation objects."
input AnnotationInputSpec {
  key: String!
  value: String!
}

extend type Query {
  "Returns all SBOM certifications."
  HasSBOM(hasSBOMSpec: HasSBOMSpec): [HasSBOM!]!
}

extend type Mutation {
  "Certifies that a package or artifact has an SBOM."
  ingestHasSBOM(subject: PackageOrArtifactInput!, hasSBOM: HasSBOMInputSpec!): HasSBOM!
}
`, BuiltIn: false},
	{Name: "../schema/hasSLSA.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for specifiying SLSA provenance

"HasSLSA records that a subject node has a SLSA attestation."
type HasSLSA {
  id: ID!
  "The subject of SLSA attestation"
  subject: Artifact!
  "The SLSA attestation"
  slsa: SLSA!
}

"""
SLSA contains all of the fields present in a SLSA attestation.

The materials and builders are objects of the HasSLSA predicate, everything
else are properties extracted from the attestation.

We also include fields to specify under what conditions the check was performed
(time of scan, version of scanners, etc.) as well as how this information got
included into GUAC (origin document and the collector for that document).
"""
type SLSA {
  "Materials of the build resulting in subject"
  builtFrom: [Artifact!]!
  "Builder performing the build"
  builtBy: Builder!
  "Type of the builder"
  buildType: String!
  "Individual predicates found in the attestation"
  slsaPredicate: [SLSAPredicate!]!
  "Version of the SLSA predicate"
  slsaVersion: String!
  "Timestamp (RFC3339Nano format) of build start time"
  startedOn: Time!
  "Timestamp (RFC3339Nano format) of build end time"
  finishedOn: Time!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
SLSAPredicate are the values from the SLSA predicate in key-value pair form.

For example, given the following predicate

` + "`" + `` + "`" + `` + "`" + `
"predicate": {
  "buildDefinition": {
    "externalParameters": {
      "repository": "https://github.com/octocat/hello-world",
      ...
    },
    ...
  },
  ...
}
` + "`" + `` + "`" + `` + "`" + `

we have

` + "`" + `` + "`" + `` + "`" + `
key   = "buildDefinition.externalParameters.repository"
value = "https://github.com/octocat/hello-world"
` + "`" + `` + "`" + `` + "`" + `

This node cannot be directly referred by other parts of GUAC.
"""
type SLSAPredicate {
  key: String!
  value: String!
}

"HasSLSASpec allows filtering the list of HasSLSA to return."
input HasSLSASpec {
  id: ID
  subject: ArtifactSpec
  builtFrom: [ArtifactSpec!]
  builtBy: BuilderSpec
  buildType: String
  predicate: [SLSAPredicateSpec!] = []
  slsaVersion: String
  startedOn: Time
  finishedOn: Time
  origin: String
  collector: String
}

"SLSAPredicateSpec is the same as SLSAPredicate, but usable as query input."
input SLSAPredicateSpec {
  key: String!
  value: String!
}

"SLSAInputSpec is the same as SLSA but for mutation input."
input SLSAInputSpec {
  buildType: String!
  slsaPredicate: [SLSAPredicateInputSpec!]!
  slsaVersion: String!
  startedOn: Time!
  finishedOn: Time!
  origin: String!
  collector: String!
}

"SLSAPredicateInputSpec allows ingesting SLSAPredicateSpec."
input SLSAPredicateInputSpec {
  key: String!
  value: String!
}

extend type Query {
  "Returns all SLSA attestations matching the filter."
  HasSLSA(hasSLSASpec: HasSLSASpec): [HasSLSA!]!
}

extend type Mutation {
  "Ingests a SLSA attestation."
  ingestSLSA(subject: ArtifactInputSpec!, builtFrom: [ArtifactInputSpec!]!, builtBy: BuilderInputSpec!, slsa: SLSAInputSpec!): HasSLSA!

  "Helper mutation to ingest multiple artifacts as materials for SLSA."
  ingestMaterials(materials: [ArtifactInputSpec!]!): [Artifact!]!
}
`, BuiltIn: false},
	{Name: "../schema/hasSourceAt.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the linking packages and sources

"HasSourceAt records that a package's repository is a given source."
type HasSourceAt {
  id: ID!
  "The subject of the attestation: can be a PackageName or a PackageVersion"
  package: Package!
  "Source repository from which the package is built"
  source: Source!
  "Timestamp since this link between package and source was certified"
  knownSince: Time!
  "Justification for the attested relationship"
  justification: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"HasSourceAtSpec allows filtering the list of HasSourceAt to return."
input HasSourceAtSpec {
  id: ID
  package: PkgSpec
  source: SourceSpec
  knownSince: Time
  justification: String
  origin: String
  collector: String
}

"HasSourceAtInputSpec is the same as HasSourceAt but for mutation input."
input HasSourceAtInputSpec {
  knownSince: Time!
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all source mappings that match the filter."
  HasSourceAt(hasSourceAtSpec: HasSourceAtSpec): [HasSourceAt!]!
}

extend type Mutation {
  "Adds a certification that a package (PackageName or PackageVersion) is built from the source."
  ingestHasSourceAt(pkg: PkgInputSpec!, pkgMatchType: MatchFlags!, source: SourceInputSpec!, hasSourceAt: HasSourceAtInputSpec!): HasSourceAt!
}
`, BuiltIn: false},
	{Name: "../schema/hashEqual.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the artifact equality

"HashEqual is an attestation that a set of artifacts are identical."
type HashEqual {
  id: ID!
  "Collection of artifacts that are similar"
  artifacts: [Artifact!]!
  "Justification for the claim that the artifacts are similar"
  justification: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
HashEqualSpec allows filtering the list of artifact equality statements to
return in a query.

Specifying just one artifact allows to query for all similar artifacts (if any
exists).
"""
input HashEqualSpec {
  id: ID
  artifacts: [ArtifactSpec]
  justification: String
  origin: String
  collector: String
}


"HashEqualInputSpec represents the input to certify that packages are similar."
input HashEqualInputSpec {
  justification: String!
  origin: String!
  collector: String!
}


extend type Query {
  "Returns all artifact equality statements matching a filter."
  HashEqual(hashEqualSpec: HashEqualSpec): [HashEqual!]!
}

extend type Mutation {
  "Adds a certification that two artifacts are similar."
  ingestHashEqual(artifact: ArtifactInputSpec!, otherArtifact: ArtifactInputSpec!, hashEqual: HashEqualInputSpec!): HashEqual!
}
`, BuiltIn: false},
	{Name: "../schema/isDependency.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for specifying dependencies

"DependencyType determines the type of the dependency."
enum DependencyType {
  "direct dependency"
  DIRECT
  "indirect dependency"
  INDIRECT
  "type not known/not specified"
  UNKNOWN
}

"IsDependency is an attestation to record that a package depends on another."
type IsDependency {
  id: ID!
  "Package that has the dependency"
  package: Package!
  "Package for the dependency; MUST BE PackageName, not PackageVersion"
  dependentPackage: Package!
  "Version range for the dependency link"
  versionRange: String!
  "Type of dependency"
  dependencyType: DependencyType!
  "Justification for the attested relationship"
  justification: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
IsDependencySpec allows filtering the list of dependencies to return.

To obtain the list of dependency packages, caller must fill in the package
field.

Dependent packages must be defined at PackageName, not PackageVersion.
"""
input IsDependencySpec {
  id: ID
  package: PkgSpec
  dependentPackage: PkgNameSpec
  versionRange: String
  dependencyType: DependencyType
  justification: String
  origin: String
  collector: String
}

"""
PkgNameSpec is used to query for dependent packages.

This is different from PkgSpec as the IsDependency attestation should only be
allowed to be made to the packageName node and not the packageVersion node.
Versions will be handled by the version_range in the IsDependency attestation
node.
"""
input PkgNameSpec {
  id: ID
  type: String
  namespace: String
  name: String
}

"IsDependencyInputSpec is the input to record a new dependency."
input IsDependencyInputSpec {
  versionRange: String!
  dependencyType: DependencyType!
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all package dependencies that match the filter."
  IsDependency(isDependencySpec: IsDependencySpec): [IsDependency!]!
}

extend type Mutation {
  "Adds a dependency between two packages"
  ingestDependency(pkg: PkgInputSpec!, depPkg: PkgInputSpec!, dependency: IsDependencyInputSpec!): IsDependency!
}
`, BuiltIn: false},
	{Name: "../schema/isOccurrence.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for occurence certifications

"PackageOrSource is a union of Package and Source."
union PackageOrSource = Package | Source

"""
PackageOrSourceSpec allows using PackageOrSource union as input for queries.

Exactly one field must be specified.
"""
input PackageOrSourceSpec {
  package: PkgSpec
  source: SourceSpec
}

"""
PackageOrSourceInput allows using PackageOrSource union as input for mutations.

Exactly one field must be specified.
"""
input PackageOrSourceInput {
  package: PkgInputSpec
  source: SourceInputSpec
}

"""
IsOccurrence is an attestation to link an artifact to a package or source.

Attestation must occur at the PackageVersion or at the SourceName.
"""
type IsOccurrence {
  id: ID!
  "Package or source from which the artifact originates"
  subject: PackageOrSource!
  "The artifact in the relationship"
  artifact: Artifact!
  "Justification for the attested relationship"
  justification: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
IsOccurrenceSpec allows filtering the list of artifact occurences to return in
a query.
"""
input IsOccurrenceSpec {
  id: ID
  subject: PackageOrSourceSpec
  artifact: ArtifactSpec
  justification: String
  origin: String
  collector: String
}

"IsOccurrenceInputSpec represents the input to record an artifact's origin."
input IsOccurrenceInputSpec {
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all artifacts-source/package mappings that match a filter."
  IsOccurrence(isOccurrenceSpec: IsOccurrenceSpec): [IsOccurrence!]!
}

extend type Mutation {
  "Ingest that an artifact is produced from a package or source."
  ingestOccurrence(subject: PackageOrSourceInput!, artifact: ArtifactInputSpec!, occurrence: IsOccurrenceInputSpec!): IsOccurrence!
}
`, BuiltIn: false},
	{Name: "../schema/isVulnerability.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema to link CVE/GHSA to the OSV data

"CveOrGhsa is a union of CVE and GHSA."
union CveOrGhsa = CVE | GHSA

"""
CveOrGhsaSpec allows using CveOrGhsa union as input type for queries.

Exactly one field must be specified.
"""
input CveOrGhsaSpec {
  cve: CVESpec
  ghsa: GHSASpec
}

"""
CveOrGhsaInput allows using CveOrGhsa union as input type for mutations.

Exactly one field must be specified.
"""
input CveOrGhsaInput {
  cve: CVEInputSpec
  ghsa: GHSAInputSpec
}

"IsVulnerability is an attestation to link CVE/GHSA with data in OSV."
type IsVulnerability {
  id: ID!
  "The OSV that encapsulates the vulnerability"
  osv: OSV!
  "The upstream vulnerability information"
  vulnerability: CveOrGhsa!
  "Justification for the attested relationship"
  justification: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
IsVulnerabilitySpec allows filtering the list of vulnerability links to return
in a query.
"""
input IsVulnerabilitySpec {
  id: ID
  osv: OSVSpec
  vulnerability: CveOrGhsaSpec
  justification: String
  origin: String
  collector: String
}

"IsVulnerabilityInputSpec represents the input to link CVE/GHSA with OSV data."
input IsVulnerabilityInputSpec {
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all OSV-CVE/GHSA vulnerability mappings that match a filter."
  IsVulnerability(isVulnerabilitySpec: IsVulnerabilitySpec): [IsVulnerability!]!
}

extend type Mutation {
  "Ingest a mapping between an OSV entry and a CVE/GHSA vulnerability."
  ingestIsVulnerability(osv: OSVInputSpec!, vulnerability: CveOrGhsaInput!, isVulnerability: IsVulnerabilityInputSpec!): IsVulnerability!
}
`, BuiltIn: false},
	{Name: "../schema/osv.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for a vulnerability in OSV schema

"""
OSV represents an Open Source Vulnerability.

The osvId field is mandatory and canonicalized to be lowercase.

This maps to a vulnerability ID specific to the environment (e.g., GHSA ID or
CVE ID).

This node can be referred to by other parts of GUAC.
"""
type OSV {
  id: ID!
  osvId: String!
}

"OSVSpec allows filtering the list of advisories to return in a query."
input OSVSpec {
  id: ID
  osvId: String
}

"OSVInputSpec specifies a OSV vulnerability for mutations."
input OSVInputSpec {
  osvId: String!
}

extend type Query {
  "Returns all OSV vulnerabilities matching a filter."
  osv(osvSpec: OSVSpec): [OSV!]!
}

extend type Mutation {
  "Ingests a new OSV vulnerability and returns it."
  ingestOSV(osv: OSVInputSpec): OSV!
}
`, BuiltIn: false},
	{Name: "../schema/package.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the package trie/tree

"""
Package represents the root of the package trie/tree.

We map package information to a trie, closely matching the pURL specification
(https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
but deviating from it where GUAC heuristics allow for better representation of
package information. Each path in the trie fully represents a package; we split
the trie based on the pURL components.

This node matches a pkg:<type> partial pURL. The type field matches the
pURL types but we might also use "guac" for the cases where the pURL
representation is not complete or when we have custom rules.

Since this node is at the root of the package trie, it is named Package, not
PackageType.
"""
type Package {
  id: ID!
  type: String!
  namespaces: [PackageNamespace!]!
}

"""
PackageNamespace is a namespace for packages.

In the pURL representation, each PackageNamespace matches the
pkg:<type>/<namespace>/ partial pURL.

Namespaces are optional and type specific. Because they are optional, we use
empty string to denote missing namespaces.
"""
type PackageNamespace {
  id: ID!
  namespace: String!
  names: [PackageName!]!
}

"""
PackageName is a name for packages.

In the pURL representation, each PackageName matches the
pkg:<type>/<namespace>/<name> pURL.

Names are always mandatory.

This is the first node in the trie that can be referred to by other parts of
GUAC.
"""
type PackageName {
  id: ID!
  name: String!
  versions: [PackageVersion!]!
}

"""
PackageVersion is a package version.

In the pURL representation, each PackageName matches the
pkg:<type>/<namespace>/<name>@<version> pURL.

Versions are optional and each Package type defines own rules for handling
them. For this level of GUAC, these are just opaque strings.

NOTE: The handling of versions might change before this schema becomes stable.

This node can be referred to by other parts of GUAC.

Subpath and qualifiers are optional. Lack of qualifiers is represented by an
empty list and lack of subpath by empty string (to be consistent with
optionality of namespace and version). Two nodes that have different qualifiers
and/or subpath but the same version mean two different packages in the trie
(they are different). Two nodes that have same version but qualifiers of one
are a subset of the qualifier of the other also mean two different packages in
the trie.
"""
type PackageVersion {
  id: ID!
  version: String!
  qualifiers: [PackageQualifier!]!
  subpath: String!
}

"""
PackageQualifier is a qualifier for a package, a key-value pair.

In the pURL representation, it is a part of the <qualifiers> part of the
pkg:<type>/<namespace>/<name>@<version>?<qualifiers> pURL.

Qualifiers are optional, each Package type defines own rules for handling them,
and multiple qualifiers could be attached to the same package.

This node cannot be directly referred by other parts of GUAC.
"""
type PackageQualifier {
  key: String!
  value: String!
}

"""
PkgSpec allows filtering the list of sources to return in a query.

Each field matches a qualifier from pURL. Use null to match on all values at
that level. For example, to get all packages in GUAC backend, use a PkgSpec
where every field is null.

Empty string at a field means matching with the empty string. If passing in
qualifiers, all of the values in the list must match. Since we want to return
nodes with any number of qualifiers if no qualifiers are passed in the input,
we must also return the same set of nodes it the qualifiers list is empty. To
match on nodes that don't contain any qualifier, set matchOnlyEmptyQualifiers
to true. If this field is true, then the qualifiers argument is ignored.
"""
input PkgSpec {
  id: ID
  type: String
  namespace: String
  name: String
  version: String
  qualifiers: [PackageQualifierSpec!] = []
  matchOnlyEmptyQualifiers: Boolean = false
  subpath: String
}

"""
PackageQualifierSpec allows filtering package qualifiers in a query.

Keys are mandatory, but values could also be null if we want to match all
values for a specific key.

NOTE: Before the schema becomes stable, we might change the nulability
requirements of these fields.
"""
input PackageQualifierSpec {
  key: String!
  value: String
}

"""
PkgInputSpec specifies a package for mutations.

This is different than PkgSpec because we want to encode mandatory fields:
type and name. All optional fields are given empty default values.
"""
input PkgInputSpec {
  type: String!
  namespace: String = ""
  name: String!
  version: String = ""
  qualifiers: [PackageQualifierInputSpec!] = []
  subpath: String = ""
}

"PackageQualifierInputSpec allows specifying package qualifiers in mutations."
input PackageQualifierInputSpec {
  key: String!
  value: String!
}

extend type Query {
  "Returns all packages matching a filter."
  packages(pkgSpec: PkgSpec): [Package!]!
}

extend type Mutation {
  "Ingests a new package and returns the corresponding package trie path."
  ingestPackage(pkg: PkgInputSpec!): Package!
}
`, BuiltIn: false},
	{Name: "../schema/path.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for advanced queries over all GUAC nodes

"""
Node is a union type of all the possible nodes.

It encapsulates the software tree nodes along with the evidence nodes. In a
path query, all connecting evidence nodes along with their intermediate subject
nodes need to be returned in order to create a complete graph.
"""
union Node
  = Package
  | Source
  | Artifact
  | Builder
  | OSV
  | CVE
  | GHSA
  | NoVuln
  | IsOccurrence
  | IsDependency
  | IsVulnerability
  | CertifyVEXStatement
  | HashEqual
  | CertifyBad
  | CertifyGood
  | PkgEqual
  | CertifyScorecard
  | CertifyVuln
  | HasSourceAt
  | HasSBOM
  | HasSLSA

"""
Edge allows filtering path/neighbors output to only contain a subset of all
possible GUAC links.

Each member of the enum is formed by merging two Node names with _. Each name
is converted from CamelCase to CAPITALS_WITH_UNDERSCORES. Only valid edges
(pairs from Node to Node) are included.

The only exception to the above rule is for links out of HasSLSA. The names are
HAS_SLSA_SUBJECT, HAS_SLSA_BUILT_BY, and HAS_SLSA_MATERIALS. This is because
ARTIFACT_HAS_SLSA is only from subject Artifact to HasSLSA.
"""
enum Edge {
  ARTIFACT_CERTIFY_BAD
  ARTIFACT_CERTIFY_GOOD
  ARTIFACT_CERTIFY_VEX_STATEMENT
  ARTIFACT_HASH_EQUAL
  ARTIFACT_HAS_SBOM
  ARTIFACT_HAS_SLSA
  ARTIFACT_IS_OCCURRENCE
  BUILDER_HAS_SLSA
  CVE_CERTIFY_VEX_STATEMENT
  CVE_CERTIFY_VULN
  CVE_IS_VULNERABILITY
  GHSA_CERTIFY_VEX_STATEMENT
  GHSA_CERTIFY_VULN
  GHSA_IS_VULNERABILITY
  NO_VULN_CERTIFY_VULN
  OSV_CERTIFY_VEX_STATEMENT
  OSV_CERTIFY_VULN
  OSV_IS_VULNERABILITY
  PACKAGE_CERTIFY_BAD
  PACKAGE_CERTIFY_GOOD
  PACKAGE_CERTIFY_VEX_STATEMENT
  PACKAGE_CERTIFY_VULN
  PACKAGE_HAS_SBOM
  PACKAGE_HAS_SOURCE_AT
  PACKAGE_IS_DEPENDENCY
  PACKAGE_IS_OCCURRENCE
  PACKAGE_PKG_EQUAL
  SOURCE_CERTIFY_BAD
  SOURCE_CERTIFY_GOOD
  SOURCE_CERTIFY_SCORECARD
  SOURCE_HAS_SOURCE_AT
  SOURCE_IS_OCCURRENCE

  CERTIFY_BAD_ARTIFACT
  CERTIFY_BAD_PACKAGE
  CERTIFY_BAD_SOURCE
  CERTIFY_GOOD_ARTIFACT
  CERTIFY_GOOD_PACKAGE
  CERTIFY_GOOD_SOURCE
  CERTIFY_SCORECARD_SOURCE
  CERTIFY_VEX_STATEMENT_ARTIFACT
  CERTIFY_VEX_STATEMENT_CVE
  CERTIFY_VEX_STATEMENT_GHSA
  CERTIFY_VEX_STATEMENT_OSV
  CERTIFY_VEX_STATEMENT_PACKAGE
  CERTIFY_VULN_CVE
  CERTIFY_VULN_GHSA
  CERTIFY_VULN_NO_VULN
  CERTIFY_VULN_OSV
  CERTIFY_VULN_PACKAGE
  HASH_EQUAL_ARTIFACT
  HAS_SBOM_ARTIFACT
  HAS_SBOM_PACKAGE
  HAS_SLSA_BUILT_BY
  HAS_SLSA_MATERIALS
  HAS_SLSA_SUBJECT
  HAS_SOURCE_AT_PACKAGE
  HAS_SOURCE_AT_SOURCE
  IS_DEPENDENCY_PACKAGE
  IS_OCCURRENCE_ARTIFACT
  IS_OCCURRENCE_PACKAGE
  IS_OCCURRENCE_SOURCE
  IS_VULNERABILITY_CVE
  IS_VULNERABILITY_GHSA
  IS_VULNERABILITY_OSV
  PKG_EQUAL_PACKAGE
}

extend type Query {
  """
  path query returns a path between subject and target, of a maximum length.

  Since we want to uniquely identify endpoints, nodes must be specified by
  valid IDs only (instead of using filters/input spec structs).

  Specifying any Edge value in ` + "`" + `usingOnly` + "`" + ` will make the path only contain the
  corresponding GUAC evidence trees (GUAC verbs).
  """
  path(subject: ID!, target: ID!, maxPathLength: Int!, usingOnly: [Edge!]!): [Node!]!

  """
  neighbors returns all the direct neighbors of a node.

  Similarly, the input is only specified by its ID.

  Specifying any Edge value in ` + "`" + `usingOnly` + "`" + ` will make the neighbors list only
  contain the corresponding GUAC evidence trees (GUAC verbs).
  """
  neighbors(node: ID!, usingOnly: [Edge!]!): [Node!]!

  """
  node returns a single node, regardless of type.

  The input is only specified by its ID.
  """
  node(node: ID!): Node!

  """
  nodes returns an array of nodes, regardless of type.

  The input is an array of IDs to retrieve.
  """
  nodes(nodes: [ID!]!): [Node!]!
}
`, BuiltIn: false},
	{Name: "../schema/pkgEqual.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for package equality

"PkgEqual is an attestation that a set of packages are similar."
type PkgEqual {
  id: ID!
  "Collection of packages that are similar"
  packages: [Package!]!
  "Justification for the claim that the packages are similar"
  justification: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
PkgEqualSpec allows filtering the list of package equality statements to return
in a query.

Specifying just one package allows to query for all similar packages (if any
exists).
"""
input PkgEqualSpec {
  id: ID
  packages: [PkgSpec]
  justification: String
  origin: String
  collector: String
}

"PkgEqualInputSpec represents the input to certify that packages are similar."
input PkgEqualInputSpec {
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all package equality statements matching a filter."
  PkgEqual(pkgEqualSpec: PkgEqualSpec): [PkgEqual!]!
}

extend type Mutation {
  "Adds a certification that two packages are similar."
  ingestPkgEqual(pkg: PkgInputSpec!, otherPackage: PkgInputSpec!, pkgEqual: PkgEqualInputSpec!): PkgEqual!
}
`, BuiltIn: false},
	{Name: "../schema/source.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the source trie/tree

"""
Source represents the root of the source trie/tree.

We map source information to a trie, as a derivative of the pURL specification:
each path in the trie represents a type, namespace, name and an optional
qualifier that stands for tag/commit information.

This node represents the type part of the trie path. It is used to represent
the version control system that is being used.

Since this node is at the root of the source trie, it is named Source, not
SourceType.
"""
type Source {
  id: ID!
  type: String!
  namespaces: [SourceNamespace!]!
}

"""
SourceNamespace is a namespace for sources.

This is the location of the repository (such as github/gitlab/bitbucket).

The namespace field is mandatory.
"""
type SourceNamespace {
  id: ID!
  namespace: String!
  names: [SourceName!]!
}

"""
SourceName represents the url of the repository.

The name field is mandatory. The tag and commit fields are optional, but it is
an error to specify both.

This is the only source trie node that can be referenced by other parts of GUAC.
"""
type SourceName {
  id: ID!
  name: String!
  tag: String
  commit: String
}

"""
SourceSpec allows filtering the list of sources to return in a query.

Empty string at a field means matching with the empty string. Missing field
means retrieving all possible matches.

It is an error to specify both tag and commit fields, except it both are set as
empty string (in which case the returned sources are only those for which there
is no tag/commit information).
"""
input SourceSpec {
  id: ID
  type: String
  namespace: String
  name: String
  tag: String
  commit: String
}

"""
SourceInputSpec specifies a source for mutations.

This is different than SourceSpec because we want to encode that all fields
except tag and commit are mandatory fields. All optional fields are given empty
default values.

It is an error to set both tag and commit fields to values different than the
default.
"""
input SourceInputSpec {
  type: String!
  namespace: String!
  name: String!
  tag: String = ""
  commit: String = ""
}

extend type Query {
  "Returns all sources matching a filter."
  sources(sourceSpec: SourceSpec): [Source!]!
}

extend type Mutation {
  "Ingests a new source and returns the corresponding source trie path."
  ingestSource(source: SourceInputSpec!): Source!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
