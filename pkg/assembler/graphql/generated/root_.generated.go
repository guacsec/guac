// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Artifact struct {
		BuiltBy       func(childComplexity int) int
		CollectorInfo func(childComplexity int) int
		DependsOn     func(childComplexity int) int
		Digest        func(childComplexity int) int
		Name          func(childComplexity int) int
		SourceInfo    func(childComplexity int) int
		Tags          func(childComplexity int) int
	}

	Attestation struct {
		AttestedObjects func(childComplexity int) int
		CollectorInfo   func(childComplexity int) int
		Digest          func(childComplexity int) int
		FilePath        func(childComplexity int) int
		Payload         func(childComplexity int) int
		SourceInfo      func(childComplexity int) int
		Type            func(childComplexity int) int
		Vulnerabilities func(childComplexity int) int
	}

	Builder struct {
		CollectorInfo func(childComplexity int) int
		ID            func(childComplexity int) int
		SourceInfo    func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	Identity struct {
		Attestations  func(childComplexity int) int
		CollectorInfo func(childComplexity int) int
		Digest        func(childComplexity int) int
		ID            func(childComplexity int) int
		Key           func(childComplexity int) int
		KeyScheme     func(childComplexity int) int
		KeyType       func(childComplexity int) int
		SourceInfo    func(childComplexity int) int
	}

	Metadata struct {
		AttachedTo    func(childComplexity int) int
		CollectorInfo func(childComplexity int) int
		ID            func(childComplexity int) int
		Payload       func(childComplexity int) int
		SourceInfo    func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	OldPackage struct {
		CPEs          func(childComplexity int) int
		CollectorInfo func(childComplexity int) int
		Contains      func(childComplexity int) int
		DependsOn     func(childComplexity int) int
		Digest        func(childComplexity int) int
		Name          func(childComplexity int) int
		Purl          func(childComplexity int) int
		SourceInfo    func(childComplexity int) int
		Tags          func(childComplexity int) int
		Version       func(childComplexity int) int
	}

	Package struct {
		Namespaces func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	PackageName struct {
		Name     func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	PackageNamespace struct {
		Names     func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	PackageVersion struct {
		Version func(childComplexity int) int
	}

	Query struct {
		Artifacts func(childComplexity int) int
		Packages  func(childComplexity int, pkgSpec *model.PkgSpec) int
	}

	ScorecardPayload struct {
		AggregateScore   func(childComplexity int) int
		Commit           func(childComplexity int) int
		Repo             func(childComplexity int) int
		ScorecardCommit  func(childComplexity int) int
		ScorecardVersion func(childComplexity int) int
	}

	VEXInvocation struct {
		EventID    func(childComplexity int) int
		Parameters func(childComplexity int) int
		ProducerID func(childComplexity int) int
		ScannedOn  func(childComplexity int) int
		URI        func(childComplexity int) int
	}

	VEXPayload struct {
		Invocation      func(childComplexity int) int
		Scanner         func(childComplexity int) int
		Vulnerabilities func(childComplexity int) int
	}

	VEXScanner struct {
		DbURI     func(childComplexity int) int
		DbVersion func(childComplexity int) int
		URI       func(childComplexity int) int
		Version   func(childComplexity int) int
	}

	VEXVulnerability struct {
		Aliases func(childComplexity int) int
		ID      func(childComplexity int) int
	}

	Vulnerability struct {
		CollectorInfo func(childComplexity int) int
		ID            func(childComplexity int) int
		SourceInfo    func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Artifact.builtBy":
		if e.complexity.Artifact.BuiltBy == nil {
			break
		}

		return e.complexity.Artifact.BuiltBy(childComplexity), true

	case "Artifact.collectorInfo":
		if e.complexity.Artifact.CollectorInfo == nil {
			break
		}

		return e.complexity.Artifact.CollectorInfo(childComplexity), true

	case "Artifact.dependsOn":
		if e.complexity.Artifact.DependsOn == nil {
			break
		}

		return e.complexity.Artifact.DependsOn(childComplexity), true

	case "Artifact.digest":
		if e.complexity.Artifact.Digest == nil {
			break
		}

		return e.complexity.Artifact.Digest(childComplexity), true

	case "Artifact.name":
		if e.complexity.Artifact.Name == nil {
			break
		}

		return e.complexity.Artifact.Name(childComplexity), true

	case "Artifact.sourceInfo":
		if e.complexity.Artifact.SourceInfo == nil {
			break
		}

		return e.complexity.Artifact.SourceInfo(childComplexity), true

	case "Artifact.tags":
		if e.complexity.Artifact.Tags == nil {
			break
		}

		return e.complexity.Artifact.Tags(childComplexity), true

	case "Attestation.attestedObjects":
		if e.complexity.Attestation.AttestedObjects == nil {
			break
		}

		return e.complexity.Attestation.AttestedObjects(childComplexity), true

	case "Attestation.collectorInfo":
		if e.complexity.Attestation.CollectorInfo == nil {
			break
		}

		return e.complexity.Attestation.CollectorInfo(childComplexity), true

	case "Attestation.digest":
		if e.complexity.Attestation.Digest == nil {
			break
		}

		return e.complexity.Attestation.Digest(childComplexity), true

	case "Attestation.filePath":
		if e.complexity.Attestation.FilePath == nil {
			break
		}

		return e.complexity.Attestation.FilePath(childComplexity), true

	case "Attestation.payload":
		if e.complexity.Attestation.Payload == nil {
			break
		}

		return e.complexity.Attestation.Payload(childComplexity), true

	case "Attestation.sourceInfo":
		if e.complexity.Attestation.SourceInfo == nil {
			break
		}

		return e.complexity.Attestation.SourceInfo(childComplexity), true

	case "Attestation.type":
		if e.complexity.Attestation.Type == nil {
			break
		}

		return e.complexity.Attestation.Type(childComplexity), true

	case "Attestation.vulnerabilities":
		if e.complexity.Attestation.Vulnerabilities == nil {
			break
		}

		return e.complexity.Attestation.Vulnerabilities(childComplexity), true

	case "Builder.collectorInfo":
		if e.complexity.Builder.CollectorInfo == nil {
			break
		}

		return e.complexity.Builder.CollectorInfo(childComplexity), true

	case "Builder.id":
		if e.complexity.Builder.ID == nil {
			break
		}

		return e.complexity.Builder.ID(childComplexity), true

	case "Builder.sourceInfo":
		if e.complexity.Builder.SourceInfo == nil {
			break
		}

		return e.complexity.Builder.SourceInfo(childComplexity), true

	case "Builder.type":
		if e.complexity.Builder.Type == nil {
			break
		}

		return e.complexity.Builder.Type(childComplexity), true

	case "Identity.attestations":
		if e.complexity.Identity.Attestations == nil {
			break
		}

		return e.complexity.Identity.Attestations(childComplexity), true

	case "Identity.collectorInfo":
		if e.complexity.Identity.CollectorInfo == nil {
			break
		}

		return e.complexity.Identity.CollectorInfo(childComplexity), true

	case "Identity.digest":
		if e.complexity.Identity.Digest == nil {
			break
		}

		return e.complexity.Identity.Digest(childComplexity), true

	case "Identity.id":
		if e.complexity.Identity.ID == nil {
			break
		}

		return e.complexity.Identity.ID(childComplexity), true

	case "Identity.key":
		if e.complexity.Identity.Key == nil {
			break
		}

		return e.complexity.Identity.Key(childComplexity), true

	case "Identity.keyScheme":
		if e.complexity.Identity.KeyScheme == nil {
			break
		}

		return e.complexity.Identity.KeyScheme(childComplexity), true

	case "Identity.keyType":
		if e.complexity.Identity.KeyType == nil {
			break
		}

		return e.complexity.Identity.KeyType(childComplexity), true

	case "Identity.sourceInfo":
		if e.complexity.Identity.SourceInfo == nil {
			break
		}

		return e.complexity.Identity.SourceInfo(childComplexity), true

	case "Metadata.attachedTo":
		if e.complexity.Metadata.AttachedTo == nil {
			break
		}

		return e.complexity.Metadata.AttachedTo(childComplexity), true

	case "Metadata.collectorInfo":
		if e.complexity.Metadata.CollectorInfo == nil {
			break
		}

		return e.complexity.Metadata.CollectorInfo(childComplexity), true

	case "Metadata.id":
		if e.complexity.Metadata.ID == nil {
			break
		}

		return e.complexity.Metadata.ID(childComplexity), true

	case "Metadata.payload":
		if e.complexity.Metadata.Payload == nil {
			break
		}

		return e.complexity.Metadata.Payload(childComplexity), true

	case "Metadata.sourceInfo":
		if e.complexity.Metadata.SourceInfo == nil {
			break
		}

		return e.complexity.Metadata.SourceInfo(childComplexity), true

	case "Metadata.type":
		if e.complexity.Metadata.Type == nil {
			break
		}

		return e.complexity.Metadata.Type(childComplexity), true

	case "OldPackage.CPEs":
		if e.complexity.OldPackage.CPEs == nil {
			break
		}

		return e.complexity.OldPackage.CPEs(childComplexity), true

	case "OldPackage.collectorInfo":
		if e.complexity.OldPackage.CollectorInfo == nil {
			break
		}

		return e.complexity.OldPackage.CollectorInfo(childComplexity), true

	case "OldPackage.contains":
		if e.complexity.OldPackage.Contains == nil {
			break
		}

		return e.complexity.OldPackage.Contains(childComplexity), true

	case "OldPackage.dependsOn":
		if e.complexity.OldPackage.DependsOn == nil {
			break
		}

		return e.complexity.OldPackage.DependsOn(childComplexity), true

	case "OldPackage.digest":
		if e.complexity.OldPackage.Digest == nil {
			break
		}

		return e.complexity.OldPackage.Digest(childComplexity), true

	case "OldPackage.name":
		if e.complexity.OldPackage.Name == nil {
			break
		}

		return e.complexity.OldPackage.Name(childComplexity), true

	case "OldPackage.purl":
		if e.complexity.OldPackage.Purl == nil {
			break
		}

		return e.complexity.OldPackage.Purl(childComplexity), true

	case "OldPackage.sourceInfo":
		if e.complexity.OldPackage.SourceInfo == nil {
			break
		}

		return e.complexity.OldPackage.SourceInfo(childComplexity), true

	case "OldPackage.tags":
		if e.complexity.OldPackage.Tags == nil {
			break
		}

		return e.complexity.OldPackage.Tags(childComplexity), true

	case "OldPackage.version":
		if e.complexity.OldPackage.Version == nil {
			break
		}

		return e.complexity.OldPackage.Version(childComplexity), true

	case "Package.namespaces":
		if e.complexity.Package.Namespaces == nil {
			break
		}

		return e.complexity.Package.Namespaces(childComplexity), true

	case "Package.type":
		if e.complexity.Package.Type == nil {
			break
		}

		return e.complexity.Package.Type(childComplexity), true

	case "PackageName.name":
		if e.complexity.PackageName.Name == nil {
			break
		}

		return e.complexity.PackageName.Name(childComplexity), true

	case "PackageName.versions":
		if e.complexity.PackageName.Versions == nil {
			break
		}

		return e.complexity.PackageName.Versions(childComplexity), true

	case "PackageNamespace.names":
		if e.complexity.PackageNamespace.Names == nil {
			break
		}

		return e.complexity.PackageNamespace.Names(childComplexity), true

	case "PackageNamespace.namespace":
		if e.complexity.PackageNamespace.Namespace == nil {
			break
		}

		return e.complexity.PackageNamespace.Namespace(childComplexity), true

	case "PackageVersion.version":
		if e.complexity.PackageVersion.Version == nil {
			break
		}

		return e.complexity.PackageVersion.Version(childComplexity), true

	case "Query.artifacts":
		if e.complexity.Query.Artifacts == nil {
			break
		}

		return e.complexity.Query.Artifacts(childComplexity), true

	case "Query.packages":
		if e.complexity.Query.Packages == nil {
			break
		}

		args, err := ec.field_Query_packages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Packages(childComplexity, args["pkgSpec"].(*model.PkgSpec)), true

	case "ScorecardPayload.aggregate_score":
		if e.complexity.ScorecardPayload.AggregateScore == nil {
			break
		}

		return e.complexity.ScorecardPayload.AggregateScore(childComplexity), true

	case "ScorecardPayload.commit":
		if e.complexity.ScorecardPayload.Commit == nil {
			break
		}

		return e.complexity.ScorecardPayload.Commit(childComplexity), true

	case "ScorecardPayload.repo":
		if e.complexity.ScorecardPayload.Repo == nil {
			break
		}

		return e.complexity.ScorecardPayload.Repo(childComplexity), true

	case "ScorecardPayload.scorecard_commit":
		if e.complexity.ScorecardPayload.ScorecardCommit == nil {
			break
		}

		return e.complexity.ScorecardPayload.ScorecardCommit(childComplexity), true

	case "ScorecardPayload.scorecard_version":
		if e.complexity.ScorecardPayload.ScorecardVersion == nil {
			break
		}

		return e.complexity.ScorecardPayload.ScorecardVersion(childComplexity), true

	case "VEXInvocation.eventID":
		if e.complexity.VEXInvocation.EventID == nil {
			break
		}

		return e.complexity.VEXInvocation.EventID(childComplexity), true

	case "VEXInvocation.parameters":
		if e.complexity.VEXInvocation.Parameters == nil {
			break
		}

		return e.complexity.VEXInvocation.Parameters(childComplexity), true

	case "VEXInvocation.producerID":
		if e.complexity.VEXInvocation.ProducerID == nil {
			break
		}

		return e.complexity.VEXInvocation.ProducerID(childComplexity), true

	case "VEXInvocation.scannedOn":
		if e.complexity.VEXInvocation.ScannedOn == nil {
			break
		}

		return e.complexity.VEXInvocation.ScannedOn(childComplexity), true

	case "VEXInvocation.uri":
		if e.complexity.VEXInvocation.URI == nil {
			break
		}

		return e.complexity.VEXInvocation.URI(childComplexity), true

	case "VEXPayload.invocation":
		if e.complexity.VEXPayload.Invocation == nil {
			break
		}

		return e.complexity.VEXPayload.Invocation(childComplexity), true

	case "VEXPayload.scanner":
		if e.complexity.VEXPayload.Scanner == nil {
			break
		}

		return e.complexity.VEXPayload.Scanner(childComplexity), true

	case "VEXPayload.vulnerabilities":
		if e.complexity.VEXPayload.Vulnerabilities == nil {
			break
		}

		return e.complexity.VEXPayload.Vulnerabilities(childComplexity), true

	case "VEXScanner.db_uri":
		if e.complexity.VEXScanner.DbURI == nil {
			break
		}

		return e.complexity.VEXScanner.DbURI(childComplexity), true

	case "VEXScanner.db_version":
		if e.complexity.VEXScanner.DbVersion == nil {
			break
		}

		return e.complexity.VEXScanner.DbVersion(childComplexity), true

	case "VEXScanner.uri":
		if e.complexity.VEXScanner.URI == nil {
			break
		}

		return e.complexity.VEXScanner.URI(childComplexity), true

	case "VEXScanner.version":
		if e.complexity.VEXScanner.Version == nil {
			break
		}

		return e.complexity.VEXScanner.Version(childComplexity), true

	case "VEXVulnerability.aliases":
		if e.complexity.VEXVulnerability.Aliases == nil {
			break
		}

		return e.complexity.VEXVulnerability.Aliases(childComplexity), true

	case "VEXVulnerability.id":
		if e.complexity.VEXVulnerability.ID == nil {
			break
		}

		return e.complexity.VEXVulnerability.ID(childComplexity), true

	case "Vulnerability.collectorInfo":
		if e.complexity.Vulnerability.CollectorInfo == nil {
			break
		}

		return e.complexity.Vulnerability.CollectorInfo(childComplexity), true

	case "Vulnerability.id":
		if e.complexity.Vulnerability.ID == nil {
			break
		}

		return e.complexity.Vulnerability.ID(childComplexity), true

	case "Vulnerability.sourceInfo":
		if e.complexity.Vulnerability.SourceInfo == nil {
			break
		}

		return e.complexity.Vulnerability.SourceInfo(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputPkgSpec,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/package.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the package trie/tree. This tree closely matches
# the pURL specification (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst)
# but deviates from it where GUAC rules state otherwise. In principle, we want
# this to represent a trie for packages, so information that represents a
# smaller collection of packages is being pushed downwards in the trie.

"""
Package represents a package.

In the pURL representation, each Package matches a ` + "`" + `pkg:<type>` + "`" + ` partial pURL.
The ` + "`" + `type` + "`" + ` field matches the pURL types but we might also use ` + "`" + `"guac"` + "`" + ` for the
cases where the pURL representation is not complete or when we have custom
rules.

This node is a singleton: backends guarantee that there is exactly one node with
the same ` + "`" + `type` + "`" + ` value.

Also note that this is named ` + "`" + `Package` + "`" + `, not ` + "`" + `PackageType` + "`" + `. This is only to make
queries more readable.
"""
type Package {
  type: String!
  namespaces: [PackageNamespace!]!
}

"""
PackageNamespace is a namespace for packages.

In the pURL representation, each PackageNamespace matches the
` + "`" + `pgk:<type>/<namespace>/` + "`" + ` partial pURL.

Namespaces are optional and type specific. Because they are optional, we use
empty string to denote missing namespaces.
"""
type PackageNamespace {
  namespace: String!
  names: [PackageName!]!
}

"""
PackageName is a name for packages.

In the pURL representation, each PackageName matches the
` + "`" + `pgk:<type>/<namespace>/<name>` + "`" + ` partial pURL.

Names are always mandatory.

This is the first node in the trie that can be referred to by other parts of
GUAC.
"""
type PackageName {
  name: String!
  versions: [PackageVersion!]!
}

"""
PackageVersion is a package version.

In the pURL representation, each PackageName matches the
` + "`" + `pgk:<type>/<namespace>/<name>@<version>` + "`" + ` partial pURL.

Versions are optional and each Package type defines own rules for handling them.
For this level of GUAC, these are just opaque strings.

This node can be referred to by other parts of GUAC.
"""
type PackageVersion {
  version: String!
}

"""
PkgSpec allows filtering the list of packages to return.

Each field matches a qualifier from pURL. Use ` + "`" + `null` + "`" + ` to match on all values at
that level. For example, to get all packages in GUAC backend, use a PkgSpec
where every field is ` + "`" + `null` + "`" + `.

Empty string at a field means matching with the empty string.
"""
input PkgSpec {
  type: String
  namespace: String
  name: String
  version: String
}

extend type Query {
  "Returns all packages"
  packages(pkgSpec: PkgSpec): [Package!]!
}
`, BuiltIn: false},
	{Name: "../schema/schema.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and will change in the near future.

"""
NodeInfo contains fields that are common for any GUAC node. These are metadata
information that allows identifying the collector details from which a node
gets created after parsing a document.
"""
interface NodeInfo {
  """
  sourceInfo is the file location for the document from which the node was
  created.
  """
  sourceInfo: String
  """
  collectorInfo is the collector from which the file that created the node came
  from
  """
  collectorInfo: String
}

"""
Artifact nodes represent artifacts. These are files on disk (cf. OldPackage).
There could be artifacts not included in any package.
"""
type Artifact implements NodeInfo {
  """
  digest is the identifier of an artifact. It is in the format
  ` + "`" + `algorithm:value` + "`" + ` where ` + "`" + `algorithm` + "`" + ` is the hashing algorithm (e.g. "sha1")
  and ` + "`" + `value` + "`" + ` is the digest obtained by using this algorithm.

  Note: in the future we might change this to contain a collection of hashes,
  at which point we will need other ways to resolve an artifact given a digest.
  """
  digest: String!
  "name of the artifact"
  name: String
  "tags associated with the artifact"
  tags: [String!]!

  # Inherited fields from NodeInfo
  sourceInfo: String
  collectorInfo: String

  # Links to other nodes
  builtBy: [Builder!]!
  dependsOn: [ArtifactOrPackage!]!
}

"""
OldPackage nodes represent packages. These are packages from a package repository
(cf. Artifact). Upon installing a package one or multiple artifacts could be
generated.
"""
type OldPackage implements NodeInfo {
  """
  purl is the OldPackage identifier, in purl format. Uniquely identifies the package.
  """
  purl: String!
  "name of the package"
  name: String
  "version of the package"
  version: String
  "digests for the package"
  digest: [String!]!
  "CPEs represent CPEs for the package"
  CPEs: [String!]!
  "tags associated with the artifact"
  tags: [String!]!

  # Inherited fields from NodeInfo
  sourceInfo: String
  collectorInfo: String

  # Links to other nodes
  contains: [Artifact!]!
  dependsOn: [ArtifactOrPackage!]!
}

"""
Currently artifacts and packages can depend on each other. Hence, we need a union for this edge.
"""
union ArtifactOrPackage = Artifact | OldPackage

"""
Builder nodes represent builders of artifacts (from provenance documents).
"""
type Builder implements NodeInfo {
  "type is type of builder. Coupled with id, it uniquely identifies the builder."
  type: String!
  "id is the id of builder. Coupled with type, it uniquely identifies the builder."
  id: String!  # Note: not ID! at this time

  # Inherited fields from NodeInfo
  sourceInfo: String
  collectorInfo: String
}

"""
Attestation nodes represent attestations about artifacts and packages.
"""
type Attestation implements NodeInfo {
  """
  digest is the identifier of an attestation, uniquely identifying it.

  Note: in the future we might change this to contain a collection of hashes,
  at which point we will need other ways to resolve an identity given a digest.
  """
  digest: String!
  # TODO: filePath and sourceInfo are the same?
  "filePath is the path to the attestation, during ingestion"
  filePath: String
  "type is the attestation type (SLSA/VEX/...?)"
  type: String

  # payloads
  "payload is additional payload on the attestation, depending on type"
  payload: AttestationPayload

  # Inherited fields from NodeInfo
  sourceInfo: String
  collectorInfo: String

  # Links to other nodes
  attestedObjects: [ArtifactOrPackage!]!
  # TODO: merge?
  vulnerabilities: [Vulnerability!]!
}

# Right now we only support VEXPayload as attestation payloads.
union AttestationPayload = VEXPayload

"""
Metadata nodes represent metadata about an artifact. These are extracted from attestations.
"""
type Metadata implements NodeInfo {
  "type is type of metadata. Coupled with id, it uniquely identifies the metadata."
  type: String!
  "id is the id of metadata. Coupled with type, it uniquely identifies the metadata."
  id: String!  # Note: not ID! at this time

  # payloads
  "payload is additional payload on the attestation, depending on type"
  payload: MetadataPayload

  # Inherited fields from NodeInfo
  sourceInfo: String
  collectorInfo: String

  # Links to other nodes
  attachedTo: [ArtifactOrPackage!]!
}

# Right now we only support ScorecardPayload as metadata payloads.
union MetadataPayload = ScorecardPayload

"""
Identity nodes are ....
"""
type Identity implements NodeInfo {
  """
  digest is the identifier of an identity, uniquely identifying it.

  Note: in the future we might change this to contain a collection of hashes,
  at which point we will need other ways to resolve an identity given a digest.
  """
  digest: String!
  "id is the id of an identity."
  id: String!  # Note: not ID! at this time
  "key ..."
  key: String
  "keyType ..."
  keyType: String
  "keyScheme ..."
  keyScheme: String

  # Inherited fields from NodeInfo
  sourceInfo: String
  collectorInfo: String

  # Links to other nodes
  attestations: [Attestation!]!
}

# TODO: maybe move to separate schema?
"""
ScorecardPayload are payloads of Scorecards metadata.
"""
type ScorecardPayload {
  repo: String!
  commit: String!
  scorecard_version: String!
  scorecard_commit: String!
  aggregate_score: Float!
  # TODO: need to add individual scores but need to think on how to keep them up to date
}

# TODO: maybe move to separate schema?
"""
Vulnerability nodes represent vulnerability information
"""
type Vulnerability implements NodeInfo {
  "id is the id of a vulnerability (cve??)"
  id: String!  # Note: not ID! at this time

  # Inherited fields from NodeInfo
  sourceInfo: String
  collectorInfo: String
}

# TODO: maybe move to separate schema?
"""
VEXPayload are payloads commonly found in VEX attestations.
"""
type VEXPayload {
  "invocation represents data about the VEX scanner invocation"
  invocation: VEXInvocation!
  "scanner represents data about the VEX scanner process"
  scanner: VEXScanner!
  "vulnerability represents data about vulnerabilities found by VEX scanning"
  vulnerabilities: [VEXVulnerability!]!
}

# TODO: maybe move to separate schema?
"""
VEXInvocation contains details about a VEX scan invocation
"""
type VEXInvocation {
  parameters: [String!]!
  uri: String!
  eventID: String!
  producerID: String!
  scannedOn: String! # TODO: should be a date field but not supported by default
}

# TODO: maybe move to separate schema?
"""
VEXScanner contains details about a scanner used by a VEX scan invocation
"""
type VEXScanner {
  uri: String!
  version: String!
  db_uri: String!
  db_version: String!
}

# TODO: maybe move to separate schema?
# TODO: merge with Vulnerability?
"""
VEXVulnerability is a vulnerability found by a VEX scan invocation
"""
type VEXVulnerability {
  id: String!  # CVE?
  aliases: [String!]!
}

"""
The queries that we support.

Subject to frequent changes
"""
type Query {
  artifacts: [Artifact!]!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
