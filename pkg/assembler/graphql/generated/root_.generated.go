// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Artifact struct {
		Algorithm func(childComplexity int) int
		Digest    func(childComplexity int) int
	}

	Builder struct {
		URI func(childComplexity int) int
	}

	CVE struct {
		CveID func(childComplexity int) int
		Year  func(childComplexity int) int
	}

	CVEId struct {
		ID func(childComplexity int) int
	}

	CertifyBad struct {
		Collector     func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Subject       func(childComplexity int) int
	}

	CertifyPkg struct {
		Collector     func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Packages      func(childComplexity int) int
	}

	CertifyScorecard struct {
		Scorecard func(childComplexity int) int
		Source    func(childComplexity int) int
	}

	CertifyVEXStatement struct {
		Collector     func(childComplexity int) int
		Justification func(childComplexity int) int
		KnownSince    func(childComplexity int) int
		Origin        func(childComplexity int) int
		Subject       func(childComplexity int) int
		Vulnerability func(childComplexity int) int
	}

	CertifyVuln struct {
		Metadata      func(childComplexity int) int
		Package       func(childComplexity int) int
		Vulnerability func(childComplexity int) int
	}

	GHSA struct {
		GhsaID func(childComplexity int) int
	}

	GHSAId struct {
		ID func(childComplexity int) int
	}

	HasSBOM struct {
		Collector func(childComplexity int) int
		Origin    func(childComplexity int) int
		Subject   func(childComplexity int) int
		URI       func(childComplexity int) int
	}

	HasSLSA struct {
		Slsa    func(childComplexity int) int
		Subject func(childComplexity int) int
	}

	HasSourceAt struct {
		Collector     func(childComplexity int) int
		Justification func(childComplexity int) int
		KnownSince    func(childComplexity int) int
		Origin        func(childComplexity int) int
		Package       func(childComplexity int) int
		Source        func(childComplexity int) int
	}

	HashEqual struct {
		Artifacts     func(childComplexity int) int
		Collector     func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
	}

	IsDependency struct {
		Collector        func(childComplexity int) int
		DependentPackage func(childComplexity int) int
		Justification    func(childComplexity int) int
		Origin           func(childComplexity int) int
		Package          func(childComplexity int) int
		VersionRange     func(childComplexity int) int
	}

	IsOccurrence struct {
		Artifact      func(childComplexity int) int
		Collector     func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Subject       func(childComplexity int) int
	}

	IsVulnerability struct {
		Collector     func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Osv           func(childComplexity int) int
		Vulnerability func(childComplexity int) int
	}

	Mutation struct {
		CertifyScorecard    func(childComplexity int, source model.SourceInputSpec, scorecard model.ScorecardInputSpec) int
		IngestArtifact      func(childComplexity int, artifact *model.ArtifactInputSpec) int
		IngestBuilder       func(childComplexity int, builder *model.BuilderInputSpec) int
		IngestCertifyBad    func(childComplexity int, subject model.PackageSourceOrArtifactInput, pkgMatchType *model.MatchFlags, certifyBad model.CertifyBadInputSpec) int
		IngestCertifyPkg    func(childComplexity int, pkg model.PkgInputSpec, depPkg model.PkgInputSpec, certifyPkg model.CertifyPkgInputSpec) int
		IngestCve           func(childComplexity int, cve *model.CVEInputSpec) int
		IngestDependency    func(childComplexity int, pkg model.PkgInputSpec, depPkg model.PkgInputSpec, dependency model.IsDependencyInputSpec) int
		IngestGhsa          func(childComplexity int, ghsa *model.GHSAInputSpec) int
		IngestOccurrence    func(childComplexity int, subject model.PackageOrSourceInput, artifact model.ArtifactInputSpec, occurrence model.IsOccurrenceInputSpec) int
		IngestOsv           func(childComplexity int, osv *model.OSVInputSpec) int
		IngestPackage       func(childComplexity int, pkg *model.PkgInputSpec) int
		IngestSlsa          func(childComplexity int, subject model.PackageSourceOrArtifactInput, slsa model.SLSAInputSpec) int
		IngestSource        func(childComplexity int, source *model.SourceInputSpec) int
		IngestVulnerability func(childComplexity int, pkg model.PkgInputSpec, vulnerability model.OsvCveOrGhsaInput, certifyVuln model.VulnerabilityMetaDataInput) int
	}

	OSV struct {
		OsvID func(childComplexity int) int
	}

	OSVId struct {
		ID func(childComplexity int) int
	}

	Package struct {
		Namespaces func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	PackageName struct {
		Name     func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	PackageNamespace struct {
		Names     func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	PackageQualifier struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	PackageVersion struct {
		Qualifiers func(childComplexity int) int
		Subpath    func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	Query struct {
		Artifacts           func(childComplexity int, artifactSpec *model.ArtifactSpec) int
		Builders            func(childComplexity int, builderSpec *model.BuilderSpec) int
		CertifyBad          func(childComplexity int, certifyBadSpec *model.CertifyBadSpec) int
		CertifyPkg          func(childComplexity int, certifyPkgSpec *model.CertifyPkgSpec) int
		CertifyVEXStatement func(childComplexity int, certifyVEXStatementSpec *model.CertifyVEXStatementSpec) int
		CertifyVuln         func(childComplexity int, certifyVulnSpec *model.CertifyVulnSpec) int
		Cve                 func(childComplexity int, cveSpec *model.CVESpec) int
		Ghsa                func(childComplexity int, ghsaSpec *model.GHSASpec) int
		HasSbom             func(childComplexity int, hasSBOMSpec *model.HasSBOMSpec) int
		HasSlsa             func(childComplexity int, hasSLSASpec *model.HasSLSASpec) int
		HasSourceAt         func(childComplexity int, hasSourceAtSpec *model.HasSourceAtSpec) int
		HashEqual           func(childComplexity int, hashEqualSpec *model.HashEqualSpec) int
		IsDependency        func(childComplexity int, isDependencySpec *model.IsDependencySpec) int
		IsOccurrence        func(childComplexity int, isOccurrenceSpec *model.IsOccurrenceSpec) int
		IsVulnerability     func(childComplexity int, isVulnerabilitySpec *model.IsVulnerabilitySpec) int
		Osv                 func(childComplexity int, osvSpec *model.OSVSpec) int
		Packages            func(childComplexity int, pkgSpec *model.PkgSpec) int
		Scorecards          func(childComplexity int, scorecardSpec *model.CertifyScorecardSpec) int
		Sources             func(childComplexity int, sourceSpec *model.SourceSpec) int
	}

	SLSA struct {
		BuildType     func(childComplexity int) int
		BuiltBy       func(childComplexity int) int
		BuiltFrom     func(childComplexity int) int
		Collector     func(childComplexity int) int
		FinishedOn    func(childComplexity int) int
		Origin        func(childComplexity int) int
		SlsaPredicate func(childComplexity int) int
		SlsaVersion   func(childComplexity int) int
		StartedOn     func(childComplexity int) int
	}

	SLSAPredicate struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Scorecard struct {
		AggregateScore   func(childComplexity int) int
		Checks           func(childComplexity int) int
		Collector        func(childComplexity int) int
		Origin           func(childComplexity int) int
		ScorecardCommit  func(childComplexity int) int
		ScorecardVersion func(childComplexity int) int
		TimeScanned      func(childComplexity int) int
	}

	ScorecardCheck struct {
		Check func(childComplexity int) int
		Score func(childComplexity int) int
	}

	Source struct {
		Namespaces func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	SourceName struct {
		Commit func(childComplexity int) int
		Name   func(childComplexity int) int
		Tag    func(childComplexity int) int
	}

	SourceNamespace struct {
		Names     func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	VulnerabilityMetaData struct {
		Collector      func(childComplexity int) int
		DbURI          func(childComplexity int) int
		DbVersion      func(childComplexity int) int
		Origin         func(childComplexity int) int
		ScannerURI     func(childComplexity int) int
		ScannerVersion func(childComplexity int) int
		TimeScanned    func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Artifact.algorithm":
		if e.complexity.Artifact.Algorithm == nil {
			break
		}

		return e.complexity.Artifact.Algorithm(childComplexity), true

	case "Artifact.digest":
		if e.complexity.Artifact.Digest == nil {
			break
		}

		return e.complexity.Artifact.Digest(childComplexity), true

	case "Builder.uri":
		if e.complexity.Builder.URI == nil {
			break
		}

		return e.complexity.Builder.URI(childComplexity), true

	case "CVE.cveId":
		if e.complexity.CVE.CveID == nil {
			break
		}

		return e.complexity.CVE.CveID(childComplexity), true

	case "CVE.year":
		if e.complexity.CVE.Year == nil {
			break
		}

		return e.complexity.CVE.Year(childComplexity), true

	case "CVEId.id":
		if e.complexity.CVEId.ID == nil {
			break
		}

		return e.complexity.CVEId.ID(childComplexity), true

	case "CertifyBad.collector":
		if e.complexity.CertifyBad.Collector == nil {
			break
		}

		return e.complexity.CertifyBad.Collector(childComplexity), true

	case "CertifyBad.justification":
		if e.complexity.CertifyBad.Justification == nil {
			break
		}

		return e.complexity.CertifyBad.Justification(childComplexity), true

	case "CertifyBad.origin":
		if e.complexity.CertifyBad.Origin == nil {
			break
		}

		return e.complexity.CertifyBad.Origin(childComplexity), true

	case "CertifyBad.subject":
		if e.complexity.CertifyBad.Subject == nil {
			break
		}

		return e.complexity.CertifyBad.Subject(childComplexity), true

	case "CertifyPkg.collector":
		if e.complexity.CertifyPkg.Collector == nil {
			break
		}

		return e.complexity.CertifyPkg.Collector(childComplexity), true

	case "CertifyPkg.justification":
		if e.complexity.CertifyPkg.Justification == nil {
			break
		}

		return e.complexity.CertifyPkg.Justification(childComplexity), true

	case "CertifyPkg.origin":
		if e.complexity.CertifyPkg.Origin == nil {
			break
		}

		return e.complexity.CertifyPkg.Origin(childComplexity), true

	case "CertifyPkg.packages":
		if e.complexity.CertifyPkg.Packages == nil {
			break
		}

		return e.complexity.CertifyPkg.Packages(childComplexity), true

	case "CertifyScorecard.scorecard":
		if e.complexity.CertifyScorecard.Scorecard == nil {
			break
		}

		return e.complexity.CertifyScorecard.Scorecard(childComplexity), true

	case "CertifyScorecard.source":
		if e.complexity.CertifyScorecard.Source == nil {
			break
		}

		return e.complexity.CertifyScorecard.Source(childComplexity), true

	case "CertifyVEXStatement.collector":
		if e.complexity.CertifyVEXStatement.Collector == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Collector(childComplexity), true

	case "CertifyVEXStatement.justification":
		if e.complexity.CertifyVEXStatement.Justification == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Justification(childComplexity), true

	case "CertifyVEXStatement.knownSince":
		if e.complexity.CertifyVEXStatement.KnownSince == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.KnownSince(childComplexity), true

	case "CertifyVEXStatement.origin":
		if e.complexity.CertifyVEXStatement.Origin == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Origin(childComplexity), true

	case "CertifyVEXStatement.subject":
		if e.complexity.CertifyVEXStatement.Subject == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Subject(childComplexity), true

	case "CertifyVEXStatement.vulnerability":
		if e.complexity.CertifyVEXStatement.Vulnerability == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Vulnerability(childComplexity), true

	case "CertifyVuln.metadata":
		if e.complexity.CertifyVuln.Metadata == nil {
			break
		}

		return e.complexity.CertifyVuln.Metadata(childComplexity), true

	case "CertifyVuln.package":
		if e.complexity.CertifyVuln.Package == nil {
			break
		}

		return e.complexity.CertifyVuln.Package(childComplexity), true

	case "CertifyVuln.vulnerability":
		if e.complexity.CertifyVuln.Vulnerability == nil {
			break
		}

		return e.complexity.CertifyVuln.Vulnerability(childComplexity), true

	case "GHSA.ghsaId":
		if e.complexity.GHSA.GhsaID == nil {
			break
		}

		return e.complexity.GHSA.GhsaID(childComplexity), true

	case "GHSAId.id":
		if e.complexity.GHSAId.ID == nil {
			break
		}

		return e.complexity.GHSAId.ID(childComplexity), true

	case "HasSBOM.collector":
		if e.complexity.HasSBOM.Collector == nil {
			break
		}

		return e.complexity.HasSBOM.Collector(childComplexity), true

	case "HasSBOM.origin":
		if e.complexity.HasSBOM.Origin == nil {
			break
		}

		return e.complexity.HasSBOM.Origin(childComplexity), true

	case "HasSBOM.subject":
		if e.complexity.HasSBOM.Subject == nil {
			break
		}

		return e.complexity.HasSBOM.Subject(childComplexity), true

	case "HasSBOM.uri":
		if e.complexity.HasSBOM.URI == nil {
			break
		}

		return e.complexity.HasSBOM.URI(childComplexity), true

	case "HasSLSA.slsa":
		if e.complexity.HasSLSA.Slsa == nil {
			break
		}

		return e.complexity.HasSLSA.Slsa(childComplexity), true

	case "HasSLSA.subject":
		if e.complexity.HasSLSA.Subject == nil {
			break
		}

		return e.complexity.HasSLSA.Subject(childComplexity), true

	case "HasSourceAt.collector":
		if e.complexity.HasSourceAt.Collector == nil {
			break
		}

		return e.complexity.HasSourceAt.Collector(childComplexity), true

	case "HasSourceAt.justification":
		if e.complexity.HasSourceAt.Justification == nil {
			break
		}

		return e.complexity.HasSourceAt.Justification(childComplexity), true

	case "HasSourceAt.knownSince":
		if e.complexity.HasSourceAt.KnownSince == nil {
			break
		}

		return e.complexity.HasSourceAt.KnownSince(childComplexity), true

	case "HasSourceAt.origin":
		if e.complexity.HasSourceAt.Origin == nil {
			break
		}

		return e.complexity.HasSourceAt.Origin(childComplexity), true

	case "HasSourceAt.package":
		if e.complexity.HasSourceAt.Package == nil {
			break
		}

		return e.complexity.HasSourceAt.Package(childComplexity), true

	case "HasSourceAt.source":
		if e.complexity.HasSourceAt.Source == nil {
			break
		}

		return e.complexity.HasSourceAt.Source(childComplexity), true

	case "HashEqual.artifacts":
		if e.complexity.HashEqual.Artifacts == nil {
			break
		}

		return e.complexity.HashEqual.Artifacts(childComplexity), true

	case "HashEqual.collector":
		if e.complexity.HashEqual.Collector == nil {
			break
		}

		return e.complexity.HashEqual.Collector(childComplexity), true

	case "HashEqual.justification":
		if e.complexity.HashEqual.Justification == nil {
			break
		}

		return e.complexity.HashEqual.Justification(childComplexity), true

	case "HashEqual.origin":
		if e.complexity.HashEqual.Origin == nil {
			break
		}

		return e.complexity.HashEqual.Origin(childComplexity), true

	case "IsDependency.collector":
		if e.complexity.IsDependency.Collector == nil {
			break
		}

		return e.complexity.IsDependency.Collector(childComplexity), true

	case "IsDependency.dependentPackage":
		if e.complexity.IsDependency.DependentPackage == nil {
			break
		}

		return e.complexity.IsDependency.DependentPackage(childComplexity), true

	case "IsDependency.justification":
		if e.complexity.IsDependency.Justification == nil {
			break
		}

		return e.complexity.IsDependency.Justification(childComplexity), true

	case "IsDependency.origin":
		if e.complexity.IsDependency.Origin == nil {
			break
		}

		return e.complexity.IsDependency.Origin(childComplexity), true

	case "IsDependency.package":
		if e.complexity.IsDependency.Package == nil {
			break
		}

		return e.complexity.IsDependency.Package(childComplexity), true

	case "IsDependency.versionRange":
		if e.complexity.IsDependency.VersionRange == nil {
			break
		}

		return e.complexity.IsDependency.VersionRange(childComplexity), true

	case "IsOccurrence.artifact":
		if e.complexity.IsOccurrence.Artifact == nil {
			break
		}

		return e.complexity.IsOccurrence.Artifact(childComplexity), true

	case "IsOccurrence.collector":
		if e.complexity.IsOccurrence.Collector == nil {
			break
		}

		return e.complexity.IsOccurrence.Collector(childComplexity), true

	case "IsOccurrence.justification":
		if e.complexity.IsOccurrence.Justification == nil {
			break
		}

		return e.complexity.IsOccurrence.Justification(childComplexity), true

	case "IsOccurrence.origin":
		if e.complexity.IsOccurrence.Origin == nil {
			break
		}

		return e.complexity.IsOccurrence.Origin(childComplexity), true

	case "IsOccurrence.subject":
		if e.complexity.IsOccurrence.Subject == nil {
			break
		}

		return e.complexity.IsOccurrence.Subject(childComplexity), true

	case "IsVulnerability.collector":
		if e.complexity.IsVulnerability.Collector == nil {
			break
		}

		return e.complexity.IsVulnerability.Collector(childComplexity), true

	case "IsVulnerability.justification":
		if e.complexity.IsVulnerability.Justification == nil {
			break
		}

		return e.complexity.IsVulnerability.Justification(childComplexity), true

	case "IsVulnerability.origin":
		if e.complexity.IsVulnerability.Origin == nil {
			break
		}

		return e.complexity.IsVulnerability.Origin(childComplexity), true

	case "IsVulnerability.osv":
		if e.complexity.IsVulnerability.Osv == nil {
			break
		}

		return e.complexity.IsVulnerability.Osv(childComplexity), true

	case "IsVulnerability.vulnerability":
		if e.complexity.IsVulnerability.Vulnerability == nil {
			break
		}

		return e.complexity.IsVulnerability.Vulnerability(childComplexity), true

	case "Mutation.certifyScorecard":
		if e.complexity.Mutation.CertifyScorecard == nil {
			break
		}

		args, err := ec.field_Mutation_certifyScorecard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CertifyScorecard(childComplexity, args["source"].(model.SourceInputSpec), args["scorecard"].(model.ScorecardInputSpec)), true

	case "Mutation.ingestArtifact":
		if e.complexity.Mutation.IngestArtifact == nil {
			break
		}

		args, err := ec.field_Mutation_ingestArtifact_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestArtifact(childComplexity, args["artifact"].(*model.ArtifactInputSpec)), true

	case "Mutation.ingestBuilder":
		if e.complexity.Mutation.IngestBuilder == nil {
			break
		}

		args, err := ec.field_Mutation_ingestBuilder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestBuilder(childComplexity, args["builder"].(*model.BuilderInputSpec)), true

	case "Mutation.ingestCertifyBad":
		if e.complexity.Mutation.IngestCertifyBad == nil {
			break
		}

		args, err := ec.field_Mutation_ingestCertifyBad_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestCertifyBad(childComplexity, args["subject"].(model.PackageSourceOrArtifactInput), args["pkgMatchType"].(*model.MatchFlags), args["certifyBad"].(model.CertifyBadInputSpec)), true

	case "Mutation.ingestCertifyPkg":
		if e.complexity.Mutation.IngestCertifyPkg == nil {
			break
		}

		args, err := ec.field_Mutation_ingestCertifyPkg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestCertifyPkg(childComplexity, args["pkg"].(model.PkgInputSpec), args["depPkg"].(model.PkgInputSpec), args["certifyPkg"].(model.CertifyPkgInputSpec)), true

	case "Mutation.ingestCVE":
		if e.complexity.Mutation.IngestCve == nil {
			break
		}

		args, err := ec.field_Mutation_ingestCVE_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestCve(childComplexity, args["cve"].(*model.CVEInputSpec)), true

	case "Mutation.ingestDependency":
		if e.complexity.Mutation.IngestDependency == nil {
			break
		}

		args, err := ec.field_Mutation_ingestDependency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestDependency(childComplexity, args["pkg"].(model.PkgInputSpec), args["depPkg"].(model.PkgInputSpec), args["dependency"].(model.IsDependencyInputSpec)), true

	case "Mutation.ingestGHSA":
		if e.complexity.Mutation.IngestGhsa == nil {
			break
		}

		args, err := ec.field_Mutation_ingestGHSA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestGhsa(childComplexity, args["ghsa"].(*model.GHSAInputSpec)), true

	case "Mutation.ingestOccurrence":
		if e.complexity.Mutation.IngestOccurrence == nil {
			break
		}

		args, err := ec.field_Mutation_ingestOccurrence_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestOccurrence(childComplexity, args["subject"].(model.PackageOrSourceInput), args["artifact"].(model.ArtifactInputSpec), args["occurrence"].(model.IsOccurrenceInputSpec)), true

	case "Mutation.ingestOSV":
		if e.complexity.Mutation.IngestOsv == nil {
			break
		}

		args, err := ec.field_Mutation_ingestOSV_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestOsv(childComplexity, args["osv"].(*model.OSVInputSpec)), true

	case "Mutation.ingestPackage":
		if e.complexity.Mutation.IngestPackage == nil {
			break
		}

		args, err := ec.field_Mutation_ingestPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestPackage(childComplexity, args["pkg"].(*model.PkgInputSpec)), true

	case "Mutation.ingestSLSA":
		if e.complexity.Mutation.IngestSlsa == nil {
			break
		}

		args, err := ec.field_Mutation_ingestSLSA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestSlsa(childComplexity, args["subject"].(model.PackageSourceOrArtifactInput), args["slsa"].(model.SLSAInputSpec)), true

	case "Mutation.ingestSource":
		if e.complexity.Mutation.IngestSource == nil {
			break
		}

		args, err := ec.field_Mutation_ingestSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestSource(childComplexity, args["source"].(*model.SourceInputSpec)), true

	case "Mutation.ingestVulnerability":
		if e.complexity.Mutation.IngestVulnerability == nil {
			break
		}

		args, err := ec.field_Mutation_ingestVulnerability_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestVulnerability(childComplexity, args["pkg"].(model.PkgInputSpec), args["vulnerability"].(model.OsvCveOrGhsaInput), args["certifyVuln"].(model.VulnerabilityMetaDataInput)), true

	case "OSV.osvId":
		if e.complexity.OSV.OsvID == nil {
			break
		}

		return e.complexity.OSV.OsvID(childComplexity), true

	case "OSVId.id":
		if e.complexity.OSVId.ID == nil {
			break
		}

		return e.complexity.OSVId.ID(childComplexity), true

	case "Package.namespaces":
		if e.complexity.Package.Namespaces == nil {
			break
		}

		return e.complexity.Package.Namespaces(childComplexity), true

	case "Package.type":
		if e.complexity.Package.Type == nil {
			break
		}

		return e.complexity.Package.Type(childComplexity), true

	case "PackageName.name":
		if e.complexity.PackageName.Name == nil {
			break
		}

		return e.complexity.PackageName.Name(childComplexity), true

	case "PackageName.versions":
		if e.complexity.PackageName.Versions == nil {
			break
		}

		return e.complexity.PackageName.Versions(childComplexity), true

	case "PackageNamespace.names":
		if e.complexity.PackageNamespace.Names == nil {
			break
		}

		return e.complexity.PackageNamespace.Names(childComplexity), true

	case "PackageNamespace.namespace":
		if e.complexity.PackageNamespace.Namespace == nil {
			break
		}

		return e.complexity.PackageNamespace.Namespace(childComplexity), true

	case "PackageQualifier.key":
		if e.complexity.PackageQualifier.Key == nil {
			break
		}

		return e.complexity.PackageQualifier.Key(childComplexity), true

	case "PackageQualifier.value":
		if e.complexity.PackageQualifier.Value == nil {
			break
		}

		return e.complexity.PackageQualifier.Value(childComplexity), true

	case "PackageVersion.qualifiers":
		if e.complexity.PackageVersion.Qualifiers == nil {
			break
		}

		return e.complexity.PackageVersion.Qualifiers(childComplexity), true

	case "PackageVersion.subpath":
		if e.complexity.PackageVersion.Subpath == nil {
			break
		}

		return e.complexity.PackageVersion.Subpath(childComplexity), true

	case "PackageVersion.version":
		if e.complexity.PackageVersion.Version == nil {
			break
		}

		return e.complexity.PackageVersion.Version(childComplexity), true

	case "Query.artifacts":
		if e.complexity.Query.Artifacts == nil {
			break
		}

		args, err := ec.field_Query_artifacts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Artifacts(childComplexity, args["artifactSpec"].(*model.ArtifactSpec)), true

	case "Query.builders":
		if e.complexity.Query.Builders == nil {
			break
		}

		args, err := ec.field_Query_builders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Builders(childComplexity, args["builderSpec"].(*model.BuilderSpec)), true

	case "Query.CertifyBad":
		if e.complexity.Query.CertifyBad == nil {
			break
		}

		args, err := ec.field_Query_CertifyBad_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyBad(childComplexity, args["certifyBadSpec"].(*model.CertifyBadSpec)), true

	case "Query.CertifyPkg":
		if e.complexity.Query.CertifyPkg == nil {
			break
		}

		args, err := ec.field_Query_CertifyPkg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyPkg(childComplexity, args["certifyPkgSpec"].(*model.CertifyPkgSpec)), true

	case "Query.CertifyVEXStatement":
		if e.complexity.Query.CertifyVEXStatement == nil {
			break
		}

		args, err := ec.field_Query_CertifyVEXStatement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyVEXStatement(childComplexity, args["certifyVEXStatementSpec"].(*model.CertifyVEXStatementSpec)), true

	case "Query.CertifyVuln":
		if e.complexity.Query.CertifyVuln == nil {
			break
		}

		args, err := ec.field_Query_CertifyVuln_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyVuln(childComplexity, args["certifyVulnSpec"].(*model.CertifyVulnSpec)), true

	case "Query.cve":
		if e.complexity.Query.Cve == nil {
			break
		}

		args, err := ec.field_Query_cve_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Cve(childComplexity, args["cveSpec"].(*model.CVESpec)), true

	case "Query.ghsa":
		if e.complexity.Query.Ghsa == nil {
			break
		}

		args, err := ec.field_Query_ghsa_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Ghsa(childComplexity, args["ghsaSpec"].(*model.GHSASpec)), true

	case "Query.HasSBOM":
		if e.complexity.Query.HasSbom == nil {
			break
		}

		args, err := ec.field_Query_HasSBOM_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasSbom(childComplexity, args["hasSBOMSpec"].(*model.HasSBOMSpec)), true

	case "Query.HasSLSA":
		if e.complexity.Query.HasSlsa == nil {
			break
		}

		args, err := ec.field_Query_HasSLSA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasSlsa(childComplexity, args["hasSLSASpec"].(*model.HasSLSASpec)), true

	case "Query.HasSourceAt":
		if e.complexity.Query.HasSourceAt == nil {
			break
		}

		args, err := ec.field_Query_HasSourceAt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasSourceAt(childComplexity, args["hasSourceAtSpec"].(*model.HasSourceAtSpec)), true

	case "Query.HashEqual":
		if e.complexity.Query.HashEqual == nil {
			break
		}

		args, err := ec.field_Query_HashEqual_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HashEqual(childComplexity, args["hashEqualSpec"].(*model.HashEqualSpec)), true

	case "Query.IsDependency":
		if e.complexity.Query.IsDependency == nil {
			break
		}

		args, err := ec.field_Query_IsDependency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsDependency(childComplexity, args["isDependencySpec"].(*model.IsDependencySpec)), true

	case "Query.IsOccurrence":
		if e.complexity.Query.IsOccurrence == nil {
			break
		}

		args, err := ec.field_Query_IsOccurrence_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsOccurrence(childComplexity, args["isOccurrenceSpec"].(*model.IsOccurrenceSpec)), true

	case "Query.IsVulnerability":
		if e.complexity.Query.IsVulnerability == nil {
			break
		}

		args, err := ec.field_Query_IsVulnerability_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsVulnerability(childComplexity, args["isVulnerabilitySpec"].(*model.IsVulnerabilitySpec)), true

	case "Query.osv":
		if e.complexity.Query.Osv == nil {
			break
		}

		args, err := ec.field_Query_osv_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Osv(childComplexity, args["osvSpec"].(*model.OSVSpec)), true

	case "Query.packages":
		if e.complexity.Query.Packages == nil {
			break
		}

		args, err := ec.field_Query_packages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Packages(childComplexity, args["pkgSpec"].(*model.PkgSpec)), true

	case "Query.scorecards":
		if e.complexity.Query.Scorecards == nil {
			break
		}

		args, err := ec.field_Query_scorecards_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Scorecards(childComplexity, args["scorecardSpec"].(*model.CertifyScorecardSpec)), true

	case "Query.sources":
		if e.complexity.Query.Sources == nil {
			break
		}

		args, err := ec.field_Query_sources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sources(childComplexity, args["sourceSpec"].(*model.SourceSpec)), true

	case "SLSA.buildType":
		if e.complexity.SLSA.BuildType == nil {
			break
		}

		return e.complexity.SLSA.BuildType(childComplexity), true

	case "SLSA.builtBy":
		if e.complexity.SLSA.BuiltBy == nil {
			break
		}

		return e.complexity.SLSA.BuiltBy(childComplexity), true

	case "SLSA.builtFrom":
		if e.complexity.SLSA.BuiltFrom == nil {
			break
		}

		return e.complexity.SLSA.BuiltFrom(childComplexity), true

	case "SLSA.collector":
		if e.complexity.SLSA.Collector == nil {
			break
		}

		return e.complexity.SLSA.Collector(childComplexity), true

	case "SLSA.finishedOn":
		if e.complexity.SLSA.FinishedOn == nil {
			break
		}

		return e.complexity.SLSA.FinishedOn(childComplexity), true

	case "SLSA.origin":
		if e.complexity.SLSA.Origin == nil {
			break
		}

		return e.complexity.SLSA.Origin(childComplexity), true

	case "SLSA.slsaPredicate":
		if e.complexity.SLSA.SlsaPredicate == nil {
			break
		}

		return e.complexity.SLSA.SlsaPredicate(childComplexity), true

	case "SLSA.slsaVersion":
		if e.complexity.SLSA.SlsaVersion == nil {
			break
		}

		return e.complexity.SLSA.SlsaVersion(childComplexity), true

	case "SLSA.startedOn":
		if e.complexity.SLSA.StartedOn == nil {
			break
		}

		return e.complexity.SLSA.StartedOn(childComplexity), true

	case "SLSAPredicate.key":
		if e.complexity.SLSAPredicate.Key == nil {
			break
		}

		return e.complexity.SLSAPredicate.Key(childComplexity), true

	case "SLSAPredicate.value":
		if e.complexity.SLSAPredicate.Value == nil {
			break
		}

		return e.complexity.SLSAPredicate.Value(childComplexity), true

	case "Scorecard.aggregateScore":
		if e.complexity.Scorecard.AggregateScore == nil {
			break
		}

		return e.complexity.Scorecard.AggregateScore(childComplexity), true

	case "Scorecard.checks":
		if e.complexity.Scorecard.Checks == nil {
			break
		}

		return e.complexity.Scorecard.Checks(childComplexity), true

	case "Scorecard.collector":
		if e.complexity.Scorecard.Collector == nil {
			break
		}

		return e.complexity.Scorecard.Collector(childComplexity), true

	case "Scorecard.origin":
		if e.complexity.Scorecard.Origin == nil {
			break
		}

		return e.complexity.Scorecard.Origin(childComplexity), true

	case "Scorecard.scorecardCommit":
		if e.complexity.Scorecard.ScorecardCommit == nil {
			break
		}

		return e.complexity.Scorecard.ScorecardCommit(childComplexity), true

	case "Scorecard.scorecardVersion":
		if e.complexity.Scorecard.ScorecardVersion == nil {
			break
		}

		return e.complexity.Scorecard.ScorecardVersion(childComplexity), true

	case "Scorecard.timeScanned":
		if e.complexity.Scorecard.TimeScanned == nil {
			break
		}

		return e.complexity.Scorecard.TimeScanned(childComplexity), true

	case "ScorecardCheck.check":
		if e.complexity.ScorecardCheck.Check == nil {
			break
		}

		return e.complexity.ScorecardCheck.Check(childComplexity), true

	case "ScorecardCheck.score":
		if e.complexity.ScorecardCheck.Score == nil {
			break
		}

		return e.complexity.ScorecardCheck.Score(childComplexity), true

	case "Source.namespaces":
		if e.complexity.Source.Namespaces == nil {
			break
		}

		return e.complexity.Source.Namespaces(childComplexity), true

	case "Source.type":
		if e.complexity.Source.Type == nil {
			break
		}

		return e.complexity.Source.Type(childComplexity), true

	case "SourceName.commit":
		if e.complexity.SourceName.Commit == nil {
			break
		}

		return e.complexity.SourceName.Commit(childComplexity), true

	case "SourceName.name":
		if e.complexity.SourceName.Name == nil {
			break
		}

		return e.complexity.SourceName.Name(childComplexity), true

	case "SourceName.tag":
		if e.complexity.SourceName.Tag == nil {
			break
		}

		return e.complexity.SourceName.Tag(childComplexity), true

	case "SourceNamespace.names":
		if e.complexity.SourceNamespace.Names == nil {
			break
		}

		return e.complexity.SourceNamespace.Names(childComplexity), true

	case "SourceNamespace.namespace":
		if e.complexity.SourceNamespace.Namespace == nil {
			break
		}

		return e.complexity.SourceNamespace.Namespace(childComplexity), true

	case "VulnerabilityMetaData.collector":
		if e.complexity.VulnerabilityMetaData.Collector == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.Collector(childComplexity), true

	case "VulnerabilityMetaData.dbUri":
		if e.complexity.VulnerabilityMetaData.DbURI == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.DbURI(childComplexity), true

	case "VulnerabilityMetaData.dbVersion":
		if e.complexity.VulnerabilityMetaData.DbVersion == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.DbVersion(childComplexity), true

	case "VulnerabilityMetaData.origin":
		if e.complexity.VulnerabilityMetaData.Origin == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.Origin(childComplexity), true

	case "VulnerabilityMetaData.scannerUri":
		if e.complexity.VulnerabilityMetaData.ScannerURI == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.ScannerURI(childComplexity), true

	case "VulnerabilityMetaData.scannerVersion":
		if e.complexity.VulnerabilityMetaData.ScannerVersion == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.ScannerVersion(childComplexity), true

	case "VulnerabilityMetaData.timeScanned":
		if e.complexity.VulnerabilityMetaData.TimeScanned == nil {
			break
		}

		return e.complexity.VulnerabilityMetaData.TimeScanned(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputArtifactInputSpec,
		ec.unmarshalInputArtifactSpec,
		ec.unmarshalInputBuilderInputSpec,
		ec.unmarshalInputBuilderSpec,
		ec.unmarshalInputCVEInputSpec,
		ec.unmarshalInputCVESpec,
		ec.unmarshalInputCertifyBadInputSpec,
		ec.unmarshalInputCertifyBadSpec,
		ec.unmarshalInputCertifyPkgInputSpec,
		ec.unmarshalInputCertifyPkgSpec,
		ec.unmarshalInputCertifyScorecardSpec,
		ec.unmarshalInputCertifyVEXStatementSpec,
		ec.unmarshalInputCertifyVulnSpec,
		ec.unmarshalInputGHSAInputSpec,
		ec.unmarshalInputGHSASpec,
		ec.unmarshalInputHasSBOMSpec,
		ec.unmarshalInputHasSLSASpec,
		ec.unmarshalInputHasSourceAtSpec,
		ec.unmarshalInputHashEqualSpec,
		ec.unmarshalInputIsDependencyInputSpec,
		ec.unmarshalInputIsDependencySpec,
		ec.unmarshalInputIsOccurrenceInputSpec,
		ec.unmarshalInputIsOccurrenceSpec,
		ec.unmarshalInputIsVulnerabilitySpec,
		ec.unmarshalInputMatchFlags,
		ec.unmarshalInputOSVInputSpec,
		ec.unmarshalInputOSVSpec,
		ec.unmarshalInputOsvCveOrGhsaInput,
		ec.unmarshalInputOsvCveOrGhsaSpec,
		ec.unmarshalInputPackageOrSourceInput,
		ec.unmarshalInputPackageOrSourceSpec,
		ec.unmarshalInputPackageQualifierInputSpec,
		ec.unmarshalInputPackageQualifierSpec,
		ec.unmarshalInputPackageSourceOrArtifactInput,
		ec.unmarshalInputPackageSourceOrArtifactSpec,
		ec.unmarshalInputPkgInputSpec,
		ec.unmarshalInputPkgNameSpec,
		ec.unmarshalInputPkgSpec,
		ec.unmarshalInputSLSAInputSpec,
		ec.unmarshalInputSLSAPredicateInputSpec,
		ec.unmarshalInputSLSAPredicateSpec,
		ec.unmarshalInputScorecardCheckInputSpec,
		ec.unmarshalInputScorecardCheckSpec,
		ec.unmarshalInputScorecardInputSpec,
		ec.unmarshalInputSourceInputSpec,
		ec.unmarshalInputSourceSpec,
		ec.unmarshalInputVulnerabilityMetaDataInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/artifact.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the artifact. It contains the algorithm and
# digest fields

"""
Artifact represents the artifact and contains a digest field

Both field are mandatory and canonicalized to be lowercase.

If having a ` + "`" + `checksum` + "`" + ` Go object, ` + "`" + `algorithm` + "`" + ` can be
` + "`" + `strings.ToLower(string(checksum.Algorithm))` + "`" + ` and ` + "`" + `digest` + "`" + ` can be
` + "`" + `checksum.Value` + "`" + `.
"""
type Artifact {
  algorithm: String!
  digest: String!
}

"""
ArtifactSpec allows filtering the list of artifacts to return.

Both arguments will be canonicalized to lowercase.
"""
input ArtifactSpec {
  algorithm: String
  digest: String
}

"""
ArtifactInputSpec is the same as Artifact, but used as mutation input.

Both arguments will be canonicalized to lowercase.
"""
input ArtifactInputSpec {
  algorithm: String!
  digest: String!
}

extend type Query {
  "Returns all artifacts"
  artifacts(artifactSpec: ArtifactSpec): [Artifact!]!
}

extend type Mutation {
  "Ingest a new artifact. Returns the ingested artifact"
  ingestArtifact(artifact: ArtifactInputSpec): Artifact!
}
`, BuiltIn: false},
	{Name: "../schema/builder.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the builder. It only contains the uri

"""
Builder represents the builder such as (FRSCA or github actions).

Currently builders are identified by the ` + "`" + `uri` + "`" + ` field, which is mandatory.
"""
type Builder {
  uri: String!
}

"""
BuilderSpec allows filtering the list of builders to return.
"""
input BuilderSpec {
  uri: String
}

"""
BuilderInputSpec is the same as Builder, but used for mutation ingestion.
"""
input BuilderInputSpec {
  uri: String!
}

extend type Query {
  "Returns all builders"
  builders(builderSpec: BuilderSpec): [Builder!]!
}

extend type Mutation {
  "Ingest a new builder. Returns the ingested builder"
  ingestBuilder(builder: BuilderInputSpec): Builder!
}
`, BuiltIn: false},
	{Name: "../schema/certifyBad.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CertifyBad. It contains the subject (which can be either a package, source or artifact),
#  justification, origin of the attestation, and collector
"""
CertifyBad is an attestation represents when a package, source or artifact is considered bad

subject - union type that can be either a package, source or artifact object type
justification (property) - string value representing why the subject is considered bad
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation

Note: Attestation must occur at the PackageName or the PackageVersion or at the SourceName.
"""
type CertifyBad {
  subject: PackageSourceOrArtifact!
  justification: String!
  origin: String!
  collector: String!
}

"""
CertifyBadSpec allows filtering the list of CertifyBad to return.
Note: Package, Source or artifact must be specified but not at the same time
For package - a PackageName or PackageVersion must be specified (name or name, version, qualifiers and subpath)
For source - a SourceName must be specified (name, tag or commit)
"""
input CertifyBadSpec {
  subject: PackageSourceOrArtifactSpec
  justification: String
  origin: String
  collector: String
}

"""
CertifyBadInputSpec is the same as CertifyBad but for mutation input.

All fields are required.
"""
input CertifyBadInputSpec {
  justification: String!
  origin: String!
  collector: String!
}

# TODO: use this for ingestion for CertifyBad and HasSourceAt
enum PkgMatchType {
  ALL_VERSIONS
  SPECIFIC_VERSION
}

input MatchFlags {
  pkg: PkgMatchType!
} 

extend type Query {
  "Returns all CertifyBad"
  CertifyBad(certifyBadSpec: CertifyBadSpec): [CertifyBad!]!
}

extend type Mutation {
  "Adds a certification that two packages are similar"
  ingestCertifyBad(subject: PackageSourceOrArtifactInput!, pkgMatchType: MatchFlags, certifyBad: CertifyBadInputSpec!): CertifyBad!
}
`, BuiltIn: false},
	{Name: "../schema/certifyPkg.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CertifyPkg. It contains a list of packages that are similar
# along with the justification, origin and collector.
"""
CertifyPkg is an attestation that represents when a package objects are similar

packages (subject) - list of package objects
justification (property) - string value representing why the packages are similar
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type CertifyPkg {
  packages: [Package!]!
  justification: String!
  origin: String!
  collector: String!
}

"""
CertifyPkgSpec allows filtering the list of CertifyPkg to return.

Specifying just the package allows to query for all similar packages (if they exist)
"""
input CertifyPkgSpec {
  packages: [PkgSpec]
  justification: String
  origin: String
  collector: String
}

"""
CertifyPkgInputSpec is the same as CertifyPkg but for mutation input.

All fields are required.
"""
input CertifyPkgInputSpec {
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all CertifyPkg"
  CertifyPkg(certifyPkgSpec: CertifyPkgSpec): [CertifyPkg!]!
}

extend type Mutation {
  "Adds a certification that two packages are similar"
  ingestCertifyPkg(pkg: PkgInputSpec!, depPkg: PkgInputSpec!, certifyPkg: CertifyPkgInputSpec!): CertifyPkg!
}

`, BuiltIn: false},
	{Name: "../schema/certifyScorecard.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema to certify Scorecard for a source repository.

"""
Define the Time scalar, to be used across GUAC. It follows RFC3339Nano format.

This is implicit via https://gqlgen.com/reference/scalars/#time

For GUAC, we assume that all times are stored in UTC format.
"""
scalar Time

"""
CertifyScorecard is an attestation which represents the scorecard of a
particular source repository.
"""
type CertifyScorecard {
  "The source repository that is being scanned (attestation subject)"
  source: Source!
  "The Scorecard attached to the repository (attestation object)"
  scorecard: Scorecard!
}

"""
Scorecard contains all of the fields present in a Scorecard attestation.

We also include fields to specify under what conditions the check was performed
(time of scan, version of scanners, etc.) as well as how this information got
included into GUAC (origin document and the collector for that document).
"""
type Scorecard {
  "Individual Scorecard check scores (Branch-Protection, Code-Review, ...)"
  checks: [ScorecardCheck!]!
  "Overall Scorecard score for the source"
  aggregateScore: Float!
  "Exact timestamp when the source was last scanned (in RFC 3339 format)"
  timeScanned: Time!
  "Version of the Scorecard scanner used to analyze the source"
  scorecardVersion: String!
  "Commit of the Scorecards repository at the time of scanning the source"
  scorecardCommit: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
ScorecardCheck are the individual checks from scorecard and their values as a
key-value pair.

For example:  Branch-Protection, Code-Review...etc

Based off scorecard's:
type jsonCheckResultV2 struct {
  Details []string                 ` + "`" + `json:"details"` + "`" + `
  Score   int                      ` + "`" + `json:"score"` + "`" + `
  Reason  string                   ` + "`" + `json:"reason"` + "`" + `
  Name    string                   ` + "`" + `json:"name"` + "`" + `
  Doc     jsonCheckDocumentationV2 ` + "`" + `json:"documentation"` + "`" + `
}
This node cannot be directly referred by other parts of GUAC.
"""
type ScorecardCheck {
  check: String!
  score: Int!
}

"CertifyScorecardSpec allows filtering the list of CertifyScorecard to return."
input CertifyScorecardSpec {
  source: SourceSpec
  timeScanned: Time
  aggregateScore: Float
  checks: [ScorecardCheckSpec!] = []
  scorecardVersion: String
  scorecardCommit: String
  origin: String
  collector: String
}

"ScorecardCheckSpec is the same as ScorecardCheck, but usable as query input."
input ScorecardCheckSpec {
  check: String!
  score: Int!
}

"""
ScorecardInputSpec is the same as Scorecard but for mutation input.

All fields are required.
"""
input ScorecardInputSpec {
  checks: [ScorecardCheckInputSpec!]!
  aggregateScore: Float!
  timeScanned: Time!
  scorecardVersion: String!
  scorecardCommit: String!
  origin: String!
  collector: String!
}

"""
ScorecardCheckInputSpec is the same as ScorecardCheck, but for mutation input.
"""
input ScorecardCheckInputSpec {
  check: String!
  score: Int!
}

extend type Query {
  "Returns all Scorecard certifications matching the filter"
  scorecards(scorecardSpec: CertifyScorecardSpec): [CertifyScorecard!]!
}

extend type Mutation {
  "Certifies the Scorecard scanning of a source repository"
  certifyScorecard(source: SourceInputSpec!, scorecard: ScorecardInputSpec!): CertifyScorecard!
}
`, BuiltIn: false},
	{Name: "../schema/certifyVEXStatement.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CertifyVEXStatement. It contains a subject which can be a package or artifact object, vulnerability that can be of type
# cve or ghsa, justification, origin and collector
"""
CertifyVEXStatement is an attestation that represents when a package or artifact has a VEX about a specific vulnerability (CVE or GHSA)

subject - union type that represents a package or artifact
vulnerability (object) - union type that consists of cve or ghsa
justification (property) - justification for VEX
knownSince (property) - timestamp of the VEX (exact time in RFC 3339 format)
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type CertifyVEXStatement {
  subject: PkgArtObject!
  vulnerability: CveGhsaObject!
  justification: String!
  knownSince: Time!
  origin: String!
  collector: String!
}

"""
CertifyVEXStatementSpec allows filtering the list of CertifyVEXStatement to return.
Only package or artifact and CVE or GHSA can be specified at once.
"""
input CertifyVEXStatementSpec {
  package: PkgSpec
  artifact: ArtifactSpec
  cve: CVESpec
  ghsa: GHSASpec
  justification: String
  knownSince: Time
  origin: String
  collector: String
}

"""
PkgArtObject is a union of Package and Artifact. Any of these objects can be specified
"""
union PkgArtObject = Package | Artifact

extend type Query {
  "Returns all CertifyVEXStatement"
  CertifyVEXStatement(certifyVEXStatementSpec: CertifyVEXStatementSpec): [CertifyVEXStatement!]!
}
`, BuiltIn: false},
	{Name: "../schema/certifyVuln.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CertifyVuln. It contains a package, vulnerability that can be of type
# cve, ghsa or osv, time scanned, db uri, db version, scanner uri, scanner version, origin and collector
"""
CertifyVuln is an attestation that represents when a package has a vulnerability

"""
type CertifyVuln {
  "package (subject) - the package object type that represents the package"
  package: Package!
  "vulnerability (object) - union type that consists of osv, cve or ghsa"
  vulnerability: OsvCveOrGhsa!
  "metadata (property) - contains all the vulnerability metadata "
  metadata: VulnerabilityMetaData!
}

type VulnerabilityMetaData {
  "timeScanned (property) - timestamp of when the package was last scanned"
  timeScanned: Time!
  "dbUri (property) - scanner vulnerability database uri"
  dbUri: String!
  "dbVersion (property) - scanner vulnerability database version"
  dbVersion: String!
  "scannerUri (property) - vulnerability scanner's uri"
  scannerUri: String!
  "scannerVersion (property) - vulnerability scanner version"
  scannerVersion: String!
  "origin (property) - where this attestation was generated from (based on which document)"
  origin: String!
  "collector (property) - the GUAC collector that collected the document that generated this attestation"
  collector: String!
}

"""
OsvCveGhsaObject is a union of OSV, CVE and GHSA. Any of these objects can be specified for vulnerability
"""
union OsvCveOrGhsa = OSV | CVE | GHSA

"""
OsvCveOrGhsaSpec allows using OsvCveOrGhsa union as
input type to be used in read queries.
Exactly one of the value must be set to non-nil.
"""
input OsvCveOrGhsaSpec {
  osv: OSVSpec
  cve: CVESpec
  ghsa: GHSASpec
}

"""
CertifyVulnSpec allows filtering the list of CertifyVuln to return.

Specifying just the package allows to query for all vulnerabilities associated with the package.
Only OSV, CVE or GHSA can be specified at once
"""
input CertifyVulnSpec {
  package: PkgSpec
  vulnerability: OsvCveOrGhsaSpec
  timeScanned: Time
  dbUri: String
  dbVersion: String
  scannerUri: String
  scannerVersion: String
  origin: String
  collector: String
}

"""
VulnerabilityInputSpec is the same as VulnerabilityMetaData but for mutation input.

All fields are required.
"""
input VulnerabilityMetaDataInput {
  timeScanned: Time!
  dbUri: String!
  dbVersion: String!
  scannerUri: String!
  scannerVersion: String!
  origin: String!
  collector: String!
}

"""
OsvCveOrGhsaInput allows using OsvCveOrGhsa union as
input type to be used in mutations.
Exactly one of the value must be set to non-nil.
"""
input OsvCveOrGhsaInput {
  osv: OSVInputSpec
  cve: CVEInputSpec
  ghsa: GHSAInputSpec
}

extend type Query {
  "Returns all CertifyVuln"
  CertifyVuln(certifyVulnSpec: CertifyVulnSpec): [CertifyVuln!]!
}

extend type Mutation {
  "certify that a package is vulnerable to a vulnerability (OSV, CVE or GHSA)"
  ingestVulnerability(pkg: PkgInputSpec!, vulnerability: OsvCveOrGhsaInput!, certifyVuln: VulnerabilityMetaDataInput!): CertifyVuln!
}
`, BuiltIn: false},
	{Name: "../schema/cve.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CVE trie/tree. It contains the year
# along with the ID associated with vulnerability (CVE ID).

"""
CVE represents common vulnerabilities and exposures. It contains the year along
with the CVE ID.

The year is mandatory.

This node is a singleton: backends guarantee that there is exactly one node
with the same ` + "`" + `year` + "`" + ` value.
"""
type CVE {
  year: String!
  cveId: [CVEId!]!
}

"""
CVEId is the actual ID that is given to a specific vulnerability

The ` + "`" + `id` + "`" + ` field is mandatory and canonicalized to be lowercase.

This node can be referred to by other parts of GUAC.
"""
type CVEId {
  id: String!
}

"""
CVESpec allows filtering the list of cves to return.
"""
input CVESpec {
  year: String
  cveId: String
}

"""
CVEInputSpec is the same as CVESpec, but used for mutation ingestion.
"""
input CVEInputSpec {
  year: String!
  cveId: String!
}

extend type Query {
  "Returns all CVEs"
  cve(cveSpec: CVESpec): [CVE!]!
}

extend type Mutation {
  "Ingest a new CVE. Returns the ingested object"
  ingestCVE(cve: CVEInputSpec): CVE!
}
`, BuiltIn: false},
	{Name: "../schema/ghsa.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the GitHub Security Advisory (GSHA) trie/tree.
# It contains the ID associated with a vulnerability in the GitHub numbering
# schema (GHSA ID).

"""
GHSA represents GitHub security advisories.

We create a separate node to allow retrieving all GHSAs.
"""
type GHSA {
  ghsaId: [GHSAId!]!
}

"""
GHSAId is the actual ID that is given to a specific vulnerability on GitHub

The ` + "`" + `id` + "`" + ` field is mandatory and canonicalized to be lowercase.

This node can be referred to by other parts of GUAC.
"""
type GHSAId {
  id: String!
}

"""
GHSASpec allows filtering the list of GHSA to return.

The argument will be canonicalized to lowercase.
"""
input GHSASpec {
  ghsaId: String
}

"""
GHSAInputSpec is the same as GHSASpec, but used for mutation ingestion.
"""
input GHSAInputSpec {
  ghsaId: String!
}

extend type Query {
  "Returns all GHSA nodes"
  ghsa(ghsaSpec: GHSASpec): [GHSA!]!
}

extend type Mutation {
  "Ingest a new GHSA. Returns the ingested object"
  ingestGHSA(ghsa: GHSAInputSpec): GHSA!
}
`, BuiltIn: false},
	{Name: "../schema/hasSBOM.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the HasSBOM. It contains the subject (which can be either a package or source), uri, origin and collector. 
"""
HasSBOM is an attestation represents that a package object or source object has an SBOM associated with a uri

subject - union type that can be either a package or source object type
uri (property) - identifier string for the SBOM
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation

Note: Only package object or source object can be defined. Not both.
"""
type HasSBOM {
  subject: PackageOrSource!
  uri: String!
  origin: String!
  collector: String!
}

"""
HashEqualSpec allows filtering the list of HasSBOM to return.

Only the package or source can be added, not both. HasSourceAt will be used to create the package to source
relationship. 
"""
input HasSBOMSpec {
  package: PkgSpec
  source: SourceSpec
  uri: String
  origin: String
  collector: String
}

extend type Query {
  "Returns all HasSBOM"
  HasSBOM(hasSBOMSpec: HasSBOMSpec): [HasSBOM!]!
}
`, BuiltIn: false},
	{Name: "../schema/hasSLSA.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for specifiying SLSA provenance.

"PackageSourceOrArtifact is a union of Package, Source, and Artifact."
union PackageSourceOrArtifact = Package | Source | Artifact

"""
PackageSourceOrArtifactSpec allows using PackageSourceOrArtifact union as
input type to be used in read queries.

Exactly one of the value must be set to non-nil.
"""
input PackageSourceOrArtifactSpec {
  package: PkgSpec
  source: SourceSpec
  artifact: ArtifactSpec
}

"""
PackageSourceOrArtifactInput allows using PackageSourceOrArtifact union as
input type to be used in mutations.

Exactly one of the value must be set to non-nil.
"""
input PackageSourceOrArtifactInput {
  package: PkgInputSpec
  source: SourceInputSpec
  artifact: ArtifactInputSpec
}

"HasSLSA records that a subject node has a SLSA attestation."
type HasSLSA {
  "The subject of SLSA attestation: package, source, or artifact."
  subject: PackageSourceOrArtifact!
  "The SLSA attestation."
  slsa: SLSA
}

"""
SLSA contains all of the fields present in a SLSA attestation.

The materials and builders are objects of the HasSLSA predicate, everything
else are properties extracted from the attestation.

We also include fields to specify under what conditions the check was performed
(time of scan, version of scanners, etc.) as well as how this information got
included into GUAC (origin document and the collector for that document).
"""
type SLSA {
  "Sources of the build resulting in subject (materials)"
  builtFrom: [PackageSourceOrArtifact!]!
  "Builder performing the build"
  builtBy: Builder!
  "Type of the builder"
  buildType: String!
  "Individual predicates found in the attestation"
  slsaPredicate: [SLSAPredicate!]!
  "Version of the SLSA predicate"
  slsaVersion: String!
  "Timestamp (RFC3339Nano format) of build start time"
  startedOn: Time!
  "Timestamp (RFC3339Nano format) of build end time"
  finishedOn: Time!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
SLSAPredicate are the values from the SLSA predicate in key-value pair form.

For example, given the following predicate

` + "`" + `` + "`" + `` + "`" + `
"predicate": {
  "buildDefinition": {
    "externalParameters": {
      "repository": "https://github.com/octocat/hello-world",
      ...
    },
    ...
  },
  ...
}
` + "`" + `` + "`" + `` + "`" + `

we have

` + "`" + `` + "`" + `` + "`" + `
key   = "buildDefinition.externalParameters.repository"
value = "https://github.com/octocat/hello-world"
` + "`" + `` + "`" + `` + "`" + `

This node cannot be directly referred by other parts of GUAC.

TODO(mihaimaruseac): Can we define these directly?
"""
type SLSAPredicate {
  key: String!
  value: String!
}

"HasSLSASpec allows filtering the list of HasSLSA to return."
input HasSLSASpec {
  subject: PackageSourceOrArtifactSpec
  builtFrom: [PackageSourceOrArtifactSpec!]
  builtBy: BuilderSpec
  buildType: String
  predicate: [SLSAPredicateSpec!] = []
  slsaVersion: String
  startedOn: Time
  finishedOn: Time
  origin: String
  collector: String
}

"SLSAPredicateSpec is the same as SLSAPredicate, but usable as query input."
input SLSAPredicateSpec {
  key: String!
  value: String!
}

"""
SLSAInputSpec is the same as SLSA but for mutation input.

All fields are required.
"""
input SLSAInputSpec {
  builtFrom: [PackageSourceOrArtifactInput!]
  builtBy: BuilderInputSpec!
  buildType: String!
  slsaPredicate: [SLSAPredicateInputSpec!]!
  slsaVersion: String!
  startedOn: Time!
  finishedOn: Time!
  origin: String!
  collector: String!
}

"""
SLSAPredicateInputSpec is the same as SLSAPredicateSpec, but for mutation
input.
"""
input SLSAPredicateInputSpec {
  key: String!
  value: String!
}

extend type Query {
  "Returns all SLSA attestations matching the filter"
  HasSLSA(hasSLSASpec: HasSLSASpec): [HasSLSA!]!
}

extend type Mutation {
  "Ingests a SLSA attestation"
  ingestSLSA(subject: PackageSourceOrArtifactInput!, slsa: SLSAInputSpec!): HasSLSA!
}
`, BuiltIn: false},
	{Name: "../schema/hasSourceAt.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the HasSourceAt. It contains the package object, source object, since (timestamp), justification, origin and collector. 
"""
HasSourceAt is an attestation represents that a package object has a source object since a timestamp

package (subject) - the package object type that represents the package
source (object) - the source object type that represents the source
knownSince (property) - timestamp when this was last checked (exact time)
justification (property) - string value representing why the package has a source specified
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type HasSourceAt {
  package: Package!
  source: Source!
  knownSince: String!
  justification: String!
  origin: String!
  collector: String!
}

"""
HasSourceAtSpec allows filtering the list of HasSourceAt to return.
"""
input HasSourceAtSpec {
  package: PkgSpec
  source: SourceSpec
  knownSince: String
  justification: String
  origin: String
  collector: String
}


extend type Query {
  "Returns all HasSourceAt"
  HasSourceAt(hasSourceAtSpec: HasSourceAtSpec): [HasSourceAt!]!
}
`, BuiltIn: false},
	{Name: "../schema/hashEqual.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the HashEqual. It contains the justification, artifacts, origin and collector. 
"""
HashEqual is an attestation that represents when two artifact hash are similar based on a justification.

artifacts (subject) - the artifacts (represented by algorithm and digest) that are equal
justification (property) - string value representing why the artifacts are the equal
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type HashEqual {
  artifacts: [Artifact!]!
  justification: String!
  origin: String!
  collector: String!
}

"""
HashEqualSpec allows filtering the list of HashEqual to return.

Specifying just the artifacts allows to query for all equivalent artifacts (if they exist)
"""
input HashEqualSpec {
  artifacts: [ArtifactSpec]
  justification: String
  origin: String
  collector: String
}


extend type Query {
  "Returns all HashEqual"
  HashEqual(hashEqualSpec: HashEqualSpec): [HashEqual!]!
}
`, BuiltIn: false},
	{Name: "../schema/isDependency.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the IsDependency. It contains the package object, dependent package object
# version range of the dependent package that it applies to, justification, origin and collector.
"""
IsDependency is an attestation that represents when a package is dependent on another package

package (subject) - the package object type that represents the package
dependentPackage (object) - the package object type that represents the packageName (cannot be to the packageVersion)
versionRange (property) - string value for version range that applies to the dependent package
justification (property) - string value representing why the artifacts are the equal
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type IsDependency {
  package: Package!
  dependentPackage: Package!
  versionRange: String!
  justification: String!
  origin: String!
  collector: String!
}

"""
IsDependencySpec allows filtering the list of IsDependency to return.

Note: the package object must be defined to return its dependent packages.
Dependent Packages must represent the packageName (cannot be the packageVersion)
"""
input IsDependencySpec {
  package: PkgSpec
  dependentPackage: PkgNameSpec
  versionRange: String
  justification: String
  origin: String
  collector: String
}

"""
PkgNameSpec is used for IsDependency to input dependent packages. This is different from PkgSpec
as the IsDependency attestation should only be allowed to be made to the packageName node and not the
packageVersion node. Versions will be handled by the version_range in the IsDependency attestation node.
"""
input PkgNameSpec {
  type: String
  namespace: String
  name: String
}

"""
IsDependencyInputSpec is the same as IsDependency but for mutation input.

All fields are required.
"""
input IsDependencyInputSpec {
  versionRange: String!
  justification: String!
  origin: String!
  collector: String!
}


extend type Query {
  "Returns all IsDependency"
  IsDependency(isDependencySpec: IsDependencySpec): [IsDependency!]!
}

extend type Mutation {
  "Adds dependency between two packages"
  ingestDependency(pkg: PkgInputSpec!, depPkg: PkgInputSpec!, dependency: IsDependencyInputSpec!): IsDependency!
}
`, BuiltIn: false},
	{Name: "../schema/isOccurrence.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the IsOccurrence. It contains the subject (which can be either a package or source),
#  occurrenceArtifact, justification,  origin of the attestation, and collector

"""
PackageOrSource is a union of Package and Source. Any of these objects can be specified
"""
union PackageOrSource = Package | Source

"""
IsOccurrence is an attestation represents when either a package or source is represented by an artifact

Note: Package or Source must be specified but not both at the same time.
Attestation must occur at the PackageVersion or at the SourceName.
"""
type IsOccurrence {
  "subject - union type that can be either a package or source object type"
  subject: PackageOrSource!
  "artifact (object) - artifact that represent the the package or source"
  artifact: Artifact!
  "justification (property) - string value representing why the package or source is represented by the specified artifact"
  justification: String!
  "origin (property) - where this attestation was generated from (based on which document)"
  origin: String!
  "collector (property) - the GUAC collector that collected the document that generated this attestation"
  collector: String!
}

"""
IsOccurrenceSpec allows filtering the list of IsOccurrence to return.
Note: Package or Source must be specified but not both at the same time
For package - PackageVersion must be specified (version, qualifiers and subpath) 
or it defaults to empty string for version, subpath and empty list for qualifiers
For source - a SourceName must be specified (name, tag or commit)
"""
input IsOccurrenceSpec {
  subject: PackageOrSourceSpec
  artifact: ArtifactSpec
  justification: String
  origin: String
  collector: String
}

"""
PackageOrSourceSpec allows using PackageOrSource union as
input type to be used in read queries.
Exactly one of the value must be set to non-nil.
"""
input PackageOrSourceSpec {
  package: PkgSpec
  source: SourceSpec
}

"""
PackageOrSourceInput allows using PackageOrSource union as
input type to be used in mutations.
Exactly one of the value must be set to non-nil.
"""
input PackageOrSourceInput {
  package: PkgInputSpec
  source: SourceInputSpec
}


"""
IsOccurrenceInputSpec is the same as IsOccurrence but for mutation input.

All fields are required.
"""
input IsOccurrenceInputSpec {
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all IsOccurrence"
  IsOccurrence(isOccurrenceSpec: IsOccurrenceSpec): [IsOccurrence!]!
}

extend type Mutation {
  "Adds an artifact as an occurrence for either a package or a source"
  ingestOccurrence(subject: PackageOrSourceInput!, artifact: ArtifactInputSpec!, occurrence: IsOccurrenceInputSpec!): IsOccurrence!
}
`, BuiltIn: false},
	{Name: "../schema/isVulnerability.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the IsVulnerability. It contains a OSV, vulnerability that can be of type
# cve or ghsa, justification, origin and collector
"""
IsVulnerability is an attestation that represents when an OSV ID represents a CVE or GHSA

osv (subject) - the osv object type that represents OSV and its ID
vulnerability (object) - union type that consists of cve or ghsa
justification (property) - the reason why the osv ID represents the cve or ghsa
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type IsVulnerability {
  osv: OSV!
  vulnerability: CveGhsaObject!
  justification: String!
  origin: String!
  collector: String!
}

"""
IsVulnerabilitySpec allows filtering the list of IsVulnerability to return.
Only CVE or GHSA can be specified at once.
"""
input IsVulnerabilitySpec {
  osv: OSVSpec
  cve: CVESpec
  ghsa: GHSASpec
  justification: String
  origin: String
  collector: String
}

"""
CveGhsaObject is a union of CVE and GHSA.
"""
union CveGhsaObject = CVE | GHSA

extend type Query {
  "Returns all IsVulnerability"
  IsVulnerability(isVulnerabilitySpec: IsVulnerabilitySpec): [IsVulnerability!]!
}`, BuiltIn: false},
	{Name: "../schema/osv.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the OSV trie/tree. It contains the OSV ID
# associated with the vulnerability.

"""
OSV represents an Open Source Vulnerability.

We create a separate node to allow retrieving all OSVs.
"""
type OSV {
  osvId: [OSVId!]!
}

"""
OSVId is the actual ID that is given to a specific vulnerability.

The ` + "`" + `id` + "`" + ` field is mandatory and canonicalized to be lowercase.

This maps to a vulnerability ID specific to the environment (e.g., GHSA ID or
CVE ID).

This node can be referred to by other parts of GUAC.
"""
type OSVId {
  id: String!
}

"""
OSVSpec allows filtering the list of OSV to return.
"""
input OSVSpec {
  osvId: String
}

"""
OSVInputSpec is the same as OSVSpec, but used for mutation ingestion.
"""
input OSVInputSpec {
  osvId: String!
}

extend type Query {
  "Returns all OSV"
  osv(osvSpec: OSVSpec): [OSV!]!
}

extend type Mutation {
  "Ingest a new OSV. Returns the ingested object"
  ingestOSV(osv: OSVInputSpec): OSV!
}
`, BuiltIn: false},
	{Name: "../schema/package.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the package trie/tree. This tree closely matches
# the pURL specification (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst)
# but deviates from it where GUAC rules state otherwise. In principle, we want
# this to represent a trie for packages, so information that represents a
# smaller collection of packages is being pushed downwards in the trie.

"""
Package represents a package.

In the pURL representation, each Package matches a ` + "`" + `pkg:<type>` + "`" + ` partial pURL.
The ` + "`" + `type` + "`" + ` field matches the pURL types but we might also use ` + "`" + `"guac"` + "`" + ` for the
cases where the pURL representation is not complete or when we have custom
rules.

This node is a singleton: backends guarantee that there is exactly one node
with the same ` + "`" + `type` + "`" + ` value.

Also note that this is named ` + "`" + `Package` + "`" + `, not ` + "`" + `PackageType` + "`" + `. This is only to make
queries more readable.
"""
type Package {
  type: String!
  namespaces: [PackageNamespace!]!
}

"""
PackageNamespace is a namespace for packages.

In the pURL representation, each PackageNamespace matches the
` + "`" + `pkg:<type>/<namespace>/` + "`" + ` partial pURL.

Namespaces are optional and type specific. Because they are optional, we use
empty string to denote missing namespaces.
"""
type PackageNamespace {
  namespace: String!
  names: [PackageName!]!
}

"""
PackageName is a name for packages.

In the pURL representation, each PackageName matches the
` + "`" + `pkg:<type>/<namespace>/<name>` + "`" + ` pURL.

Names are always mandatory.

This is the first node in the trie that can be referred to by other parts of
GUAC.
"""
type PackageName {
  name: String!
  versions: [PackageVersion!]!
}

"""
PackageVersion is a package version.

In the pURL representation, each PackageName matches the
` + "`" + `pkg:<type>/<namespace>/<name>@<version>` + "`" + ` pURL.

Versions are optional and each Package type defines own rules for handling them.
For this level of GUAC, these are just opaque strings.

This node can be referred to by other parts of GUAC.

Subpath and qualifiers are optional. Lack of qualifiers is represented by an
empty list and lack of subpath by empty string (to be consistent with
optionality of namespace and version). Two nodes that have different qualifiers
and/or subpath but the same version mean two different packages in the trie
(they are different). Two nodes that have same version but qualifiers of one are
a subset of the qualifier of the other also mean two different packages in the
trie.
"""
type PackageVersion {
  version: String!
  qualifiers: [PackageQualifier!]!
  subpath: String!
}

"""
PackageQualifier is a qualifier for a package, a key-value pair.

In the pURL representation, it is a part of the ` + "`" + `<qualifiers>` + "`" + ` part of the
` + "`" + `pkg:<type>/<namespace>/<name>@<version>?<qualifiers>` + "`" + ` pURL.

Qualifiers are optional, each Package type defines own rules for handling them,
and multiple qualifiers could be attached to the same package.

This node cannot be directly referred by other parts of GUAC.
"""
type PackageQualifier {
  key: String!
  value: String!
}

"""
PkgSpec allows filtering the list of packages to return.

Each field matches a qualifier from pURL. Use ` + "`" + `null` + "`" + ` to match on all values at
that level. For example, to get all packages in GUAC backend, use a PkgSpec
where every field is ` + "`" + `null` + "`" + `.

Empty string at a field means matching with the empty string. If passing in
qualifiers, all of the values in the list must match. Since we want to return
nodes with any number of qualifiers if no qualifiers are passed in the input, we
must also return the same set of nodes it the qualifiers list is empty. To match
on nodes that don't contain any qualifier, set ` + "`" + `matchOnlyEmptyQualifiers` + "`" + ` to
true. If this field is true, then the qualifiers argument is ignored.
"""
input PkgSpec {
  type: String
  namespace: String
  name: String
  version: String
  qualifiers: [PackageQualifierSpec!] = []
  matchOnlyEmptyQualifiers: Boolean = false
  subpath: String
}

"""
PackageQualifierSpec is the same as PackageQualifier, but usable as query
input.

GraphQL does not allow input types to contain composite types and does not allow
composite types to contain input types. So, although in this case these two
types are semantically the same, we have to duplicate the definition.

Keys are mandatory, but values could also be ` + "`" + `null` + "`" + ` if we want to match all
values for a specific key.

TODO(mihaimaruseac): Formalize empty vs null when the schema is fully done
"""
input PackageQualifierSpec {
  key: String!
  value: String
}

"""
PkgInputSpec specifies a package for a mutation.

This is different than PkgSpec because we want to encode mandatory fields:
` + "`" + `type` + "`" + ` and ` + "`" + `name` + "`" + `. All optional fields are given empty default values.
"""
input PkgInputSpec {
  type: String!
  namespace: String = ""
  name: String!
  version: String = ""
  qualifiers: [PackageQualifierInputSpec!] = []
  subpath: String = ""
}

"""
PackageQualifierInputSpec is the same as PackageQualifier, but usable as
mutation input.

GraphQL does not allow input types to contain composite types and does not allow
composite types to contain input types. So, although in this case these two
types are semantically the same, we have to duplicate the definition.

Both fields are mandatory.
"""
input PackageQualifierInputSpec {
  key: String!
  value: String!
}

extend type Query {
  "Returns all packages"
  packages(pkgSpec: PkgSpec): [Package!]!
}

extend type Mutation {
  "Ingest a new package. Returns the ingested package trie"
  ingestPackage(pkg: PkgInputSpec): Package!
}
`, BuiltIn: false},
	{Name: "../schema/source.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the source trie/tree. This tree is a derivative
# of the pURL specification where it has a type, namespace, name and finally a
# qualifier that contain the tag or commit.

"""
Source represents a source.

This can be the version control system that is being used.

This node is a singleton: backends guarantee that there is exactly one node
with the same ` + "`" + `type` + "`" + ` value.

Also note that this is named ` + "`" + `Source` + "`" + `, not ` + "`" + `SourceType` + "`" + `. This is only to make
queries more readable.
"""
type Source {
  type: String!
  namespaces: [SourceNamespace!]!
}

"""
SourceNamespace is a namespace for sources.

This is the location of the repository (such as github/gitlab/bitbucket).

The ` + "`" + `namespace` + "`" + ` field is mandatory.
"""
type SourceNamespace {
  namespace: String!
  names: [SourceName!]!
}

"""
SourceName is a url of the repository and its tag or commit.

The ` + "`" + `name` + "`" + ` field is mandatory. The ` + "`" + `tag` + "`" + ` and ` + "`" + `commit` + "`" + ` fields are optional, but
it is an error to specify both.

This is the only source trie node that can be referenced by other parts of
GUAC.
"""
type SourceName {
  name: String!
  tag: String
  commit: String
}

"""
SourceSpec allows filtering the list of sources to return.

Empty string at a field means matching with the empty string. Missing field
means retrieving all possible matches.

It is an error to specify both ` + "`" + `tag` + "`" + ` and ` + "`" + `commit` + "`" + ` fields, except it both are
set as empty string (in which case the returned sources are only those for
which there is no tag/commit information).
"""
input SourceSpec {
  type: String
  namespace: String
  name: String
  tag: String
  commit: String
}

"""
SourceInputSpec specifies a source for a mutation.

This is different than SourceSpec because we want to encode that all fields
except tag and commit are mandatory fields. All optional fields are given
empty default values.

It is an error to set both ` + "`" + `tag` + "`" + ` and ` + "`" + `commit` + "`" + ` fields to values different than
the default.
"""
input SourceInputSpec {
  type: String!
  namespace: String!
  name: String!
  tag: String = ""
  commit: String = ""
}

extend type Query {
  "Returns all sources"
  sources(sourceSpec: SourceSpec): [Source!]!
}

extend type Mutation {
  "Ingest a new source. Returns the ingested source trie"
  ingestSource(source: SourceInputSpec): Source!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
