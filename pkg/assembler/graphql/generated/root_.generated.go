// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Artifact struct {
		Algorithm func(childComplexity int) int
		Digest    func(childComplexity int) int
	}

	Builder struct {
		URI func(childComplexity int) int
	}

	CVE struct {
		CveID func(childComplexity int) int
		Year  func(childComplexity int) int
	}

	CVEId struct {
		ID func(childComplexity int) int
	}

	CertifyBad struct {
		Collector     func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Subject       func(childComplexity int) int
	}

	CertifyPkg struct {
		Collector     func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Packages      func(childComplexity int) int
	}

	CertifyScorecard struct {
		AggregateScore   func(childComplexity int) int
		Checks           func(childComplexity int) int
		Collector        func(childComplexity int) int
		Origin           func(childComplexity int) int
		ScorecardCommit  func(childComplexity int) int
		ScorecardVersion func(childComplexity int) int
		Source           func(childComplexity int) int
		TimeScanned      func(childComplexity int) int
	}

	CertifyVEXStatement struct {
		Collector     func(childComplexity int) int
		Justification func(childComplexity int) int
		KnownSince    func(childComplexity int) int
		Origin        func(childComplexity int) int
		Subject       func(childComplexity int) int
		Vulnerability func(childComplexity int) int
	}

	CertifyVuln struct {
		Collector      func(childComplexity int) int
		DbURI          func(childComplexity int) int
		DbVersion      func(childComplexity int) int
		Origin         func(childComplexity int) int
		Package        func(childComplexity int) int
		ScannerURI     func(childComplexity int) int
		ScannerVersion func(childComplexity int) int
		TimeScanned    func(childComplexity int) int
		Vulnerability  func(childComplexity int) int
	}

	GHSA struct {
		GhsaID func(childComplexity int) int
	}

	GHSAId struct {
		ID func(childComplexity int) int
	}

	HasSBOM struct {
		Collector func(childComplexity int) int
		Origin    func(childComplexity int) int
		Subject   func(childComplexity int) int
		URI       func(childComplexity int) int
	}

	HasSLSA struct {
		BuildType     func(childComplexity int) int
		BuiltBy       func(childComplexity int) int
		BuiltFrom     func(childComplexity int) int
		Collector     func(childComplexity int) int
		FinishedOn    func(childComplexity int) int
		Origin        func(childComplexity int) int
		SlsaPredicate func(childComplexity int) int
		SlsaVersion   func(childComplexity int) int
		StartedOn     func(childComplexity int) int
		Subject       func(childComplexity int) int
	}

	HasSourceAt struct {
		Collector     func(childComplexity int) int
		Justification func(childComplexity int) int
		KnownSince    func(childComplexity int) int
		Origin        func(childComplexity int) int
		Package       func(childComplexity int) int
		Source        func(childComplexity int) int
	}

	HashEqual struct {
		Artifacts     func(childComplexity int) int
		Collector     func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
	}

	IsDependency struct {
		Collector        func(childComplexity int) int
		DependentPackage func(childComplexity int) int
		Justification    func(childComplexity int) int
		Origin           func(childComplexity int) int
		Package          func(childComplexity int) int
		VersionRange     func(childComplexity int) int
	}

	IsOccurrence struct {
		Collector           func(childComplexity int) int
		Justification       func(childComplexity int) int
		OccurrenceArtifacts func(childComplexity int) int
		Origin              func(childComplexity int) int
		Subject             func(childComplexity int) int
	}

	IsVulnerability struct {
		Collector     func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Osv           func(childComplexity int) int
		Vulnerability func(childComplexity int) int
	}

	Mutation struct {
		IngestArtifact func(childComplexity int, artifact *model.ArtifactInputSpec) int
		IngestBuilder  func(childComplexity int, builder *model.BuilderInputSpec) int
		IngestCve      func(childComplexity int, cve *model.CVEInputSpec) int
		IngestGhsa     func(childComplexity int, ghsa *model.GHSAInputSpec) int
		IngestOsv      func(childComplexity int, osv *model.OSVInputSpec) int
		IngestPackage  func(childComplexity int, pkg *model.PkgInputSpec) int
		IngestSource   func(childComplexity int, source *model.SourceInputSpec) int
	}

	OSV struct {
		OsvID func(childComplexity int) int
	}

	OSVId struct {
		ID func(childComplexity int) int
	}

	Package struct {
		Namespaces func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	PackageName struct {
		Name     func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	PackageNamespace struct {
		Names     func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	PackageQualifier struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	PackageVersion struct {
		Qualifiers func(childComplexity int) int
		Subpath    func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	Query struct {
		Artifacts           func(childComplexity int, artifactSpec *model.ArtifactSpec) int
		Builders            func(childComplexity int, builderSpec *model.BuilderSpec) int
		CertifyBad          func(childComplexity int, certifyBadSpec *model.CertifyBadSpec) int
		CertifyPkg          func(childComplexity int, certifyPkgSpec *model.CertifyPkgSpec) int
		CertifyScorecard    func(childComplexity int, certifyScorecardSpec *model.CertifyScorecardSpec) int
		CertifyVEXStatement func(childComplexity int, certifyVEXStatementSpec *model.CertifyVEXStatementSpec) int
		CertifyVuln         func(childComplexity int, certifyVulnSpec *model.CertifyVulnSpec) int
		Cve                 func(childComplexity int, cveSpec *model.CVESpec) int
		Ghsa                func(childComplexity int, ghsaSpec *model.GHSASpec) int
		HasSBOMs            func(childComplexity int, hasSBOMSpec *model.HasSBOMSpec) int
		HasSlsa             func(childComplexity int, hasSLSASpec *model.HasSLSASpec) int
		HasSourceAt         func(childComplexity int, hasSourceAtSpec *model.HasSourceAtSpec) int
		HashEquals          func(childComplexity int, hashEqualSpec *model.HashEqualSpec) int
		IsDependency        func(childComplexity int, isDependencySpec *model.IsDependencySpec) int
		IsOccurrences       func(childComplexity int, isOccurrenceSpec *model.IsOccurrenceSpec) int
		IsVulnerability     func(childComplexity int, isVulnerabilitySpec *model.IsVulnerabilitySpec) int
		Osv                 func(childComplexity int, osvSpec *model.OSVSpec) int
		Packages            func(childComplexity int, pkgSpec *model.PkgSpec) int
		Sources             func(childComplexity int, sourceSpec *model.SourceSpec) int
	}

	SLSAPredicate struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ScorecardCheck struct {
		Check func(childComplexity int) int
		Score func(childComplexity int) int
	}

	Source struct {
		Namespaces func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	SourceName struct {
		Commit func(childComplexity int) int
		Name   func(childComplexity int) int
		Tag    func(childComplexity int) int
	}

	SourceNamespace struct {
		Names     func(childComplexity int) int
		Namespace func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Artifact.algorithm":
		if e.complexity.Artifact.Algorithm == nil {
			break
		}

		return e.complexity.Artifact.Algorithm(childComplexity), true

	case "Artifact.digest":
		if e.complexity.Artifact.Digest == nil {
			break
		}

		return e.complexity.Artifact.Digest(childComplexity), true

	case "Builder.uri":
		if e.complexity.Builder.URI == nil {
			break
		}

		return e.complexity.Builder.URI(childComplexity), true

	case "CVE.cveId":
		if e.complexity.CVE.CveID == nil {
			break
		}

		return e.complexity.CVE.CveID(childComplexity), true

	case "CVE.year":
		if e.complexity.CVE.Year == nil {
			break
		}

		return e.complexity.CVE.Year(childComplexity), true

	case "CVEId.id":
		if e.complexity.CVEId.ID == nil {
			break
		}

		return e.complexity.CVEId.ID(childComplexity), true

	case "CertifyBad.collector":
		if e.complexity.CertifyBad.Collector == nil {
			break
		}

		return e.complexity.CertifyBad.Collector(childComplexity), true

	case "CertifyBad.justification":
		if e.complexity.CertifyBad.Justification == nil {
			break
		}

		return e.complexity.CertifyBad.Justification(childComplexity), true

	case "CertifyBad.origin":
		if e.complexity.CertifyBad.Origin == nil {
			break
		}

		return e.complexity.CertifyBad.Origin(childComplexity), true

	case "CertifyBad.subject":
		if e.complexity.CertifyBad.Subject == nil {
			break
		}

		return e.complexity.CertifyBad.Subject(childComplexity), true

	case "CertifyPkg.collector":
		if e.complexity.CertifyPkg.Collector == nil {
			break
		}

		return e.complexity.CertifyPkg.Collector(childComplexity), true

	case "CertifyPkg.justification":
		if e.complexity.CertifyPkg.Justification == nil {
			break
		}

		return e.complexity.CertifyPkg.Justification(childComplexity), true

	case "CertifyPkg.origin":
		if e.complexity.CertifyPkg.Origin == nil {
			break
		}

		return e.complexity.CertifyPkg.Origin(childComplexity), true

	case "CertifyPkg.packages":
		if e.complexity.CertifyPkg.Packages == nil {
			break
		}

		return e.complexity.CertifyPkg.Packages(childComplexity), true

	case "CertifyScorecard.aggregateScore":
		if e.complexity.CertifyScorecard.AggregateScore == nil {
			break
		}

		return e.complexity.CertifyScorecard.AggregateScore(childComplexity), true

	case "CertifyScorecard.checks":
		if e.complexity.CertifyScorecard.Checks == nil {
			break
		}

		return e.complexity.CertifyScorecard.Checks(childComplexity), true

	case "CertifyScorecard.collector":
		if e.complexity.CertifyScorecard.Collector == nil {
			break
		}

		return e.complexity.CertifyScorecard.Collector(childComplexity), true

	case "CertifyScorecard.origin":
		if e.complexity.CertifyScorecard.Origin == nil {
			break
		}

		return e.complexity.CertifyScorecard.Origin(childComplexity), true

	case "CertifyScorecard.scorecardCommit":
		if e.complexity.CertifyScorecard.ScorecardCommit == nil {
			break
		}

		return e.complexity.CertifyScorecard.ScorecardCommit(childComplexity), true

	case "CertifyScorecard.scorecardVersion":
		if e.complexity.CertifyScorecard.ScorecardVersion == nil {
			break
		}

		return e.complexity.CertifyScorecard.ScorecardVersion(childComplexity), true

	case "CertifyScorecard.source":
		if e.complexity.CertifyScorecard.Source == nil {
			break
		}

		return e.complexity.CertifyScorecard.Source(childComplexity), true

	case "CertifyScorecard.timeScanned":
		if e.complexity.CertifyScorecard.TimeScanned == nil {
			break
		}

		return e.complexity.CertifyScorecard.TimeScanned(childComplexity), true

	case "CertifyVEXStatement.collector":
		if e.complexity.CertifyVEXStatement.Collector == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Collector(childComplexity), true

	case "CertifyVEXStatement.justification":
		if e.complexity.CertifyVEXStatement.Justification == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Justification(childComplexity), true

	case "CertifyVEXStatement.knownSince":
		if e.complexity.CertifyVEXStatement.KnownSince == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.KnownSince(childComplexity), true

	case "CertifyVEXStatement.origin":
		if e.complexity.CertifyVEXStatement.Origin == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Origin(childComplexity), true

	case "CertifyVEXStatement.subject":
		if e.complexity.CertifyVEXStatement.Subject == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Subject(childComplexity), true

	case "CertifyVEXStatement.vulnerability":
		if e.complexity.CertifyVEXStatement.Vulnerability == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Vulnerability(childComplexity), true

	case "CertifyVuln.collector":
		if e.complexity.CertifyVuln.Collector == nil {
			break
		}

		return e.complexity.CertifyVuln.Collector(childComplexity), true

	case "CertifyVuln.dbUri":
		if e.complexity.CertifyVuln.DbURI == nil {
			break
		}

		return e.complexity.CertifyVuln.DbURI(childComplexity), true

	case "CertifyVuln.dbVersion":
		if e.complexity.CertifyVuln.DbVersion == nil {
			break
		}

		return e.complexity.CertifyVuln.DbVersion(childComplexity), true

	case "CertifyVuln.origin":
		if e.complexity.CertifyVuln.Origin == nil {
			break
		}

		return e.complexity.CertifyVuln.Origin(childComplexity), true

	case "CertifyVuln.package":
		if e.complexity.CertifyVuln.Package == nil {
			break
		}

		return e.complexity.CertifyVuln.Package(childComplexity), true

	case "CertifyVuln.scannerUri":
		if e.complexity.CertifyVuln.ScannerURI == nil {
			break
		}

		return e.complexity.CertifyVuln.ScannerURI(childComplexity), true

	case "CertifyVuln.scannerVersion":
		if e.complexity.CertifyVuln.ScannerVersion == nil {
			break
		}

		return e.complexity.CertifyVuln.ScannerVersion(childComplexity), true

	case "CertifyVuln.timeScanned":
		if e.complexity.CertifyVuln.TimeScanned == nil {
			break
		}

		return e.complexity.CertifyVuln.TimeScanned(childComplexity), true

	case "CertifyVuln.vulnerability":
		if e.complexity.CertifyVuln.Vulnerability == nil {
			break
		}

		return e.complexity.CertifyVuln.Vulnerability(childComplexity), true

	case "GHSA.ghsaId":
		if e.complexity.GHSA.GhsaID == nil {
			break
		}

		return e.complexity.GHSA.GhsaID(childComplexity), true

	case "GHSAId.id":
		if e.complexity.GHSAId.ID == nil {
			break
		}

		return e.complexity.GHSAId.ID(childComplexity), true

	case "HasSBOM.collector":
		if e.complexity.HasSBOM.Collector == nil {
			break
		}

		return e.complexity.HasSBOM.Collector(childComplexity), true

	case "HasSBOM.origin":
		if e.complexity.HasSBOM.Origin == nil {
			break
		}

		return e.complexity.HasSBOM.Origin(childComplexity), true

	case "HasSBOM.subject":
		if e.complexity.HasSBOM.Subject == nil {
			break
		}

		return e.complexity.HasSBOM.Subject(childComplexity), true

	case "HasSBOM.uri":
		if e.complexity.HasSBOM.URI == nil {
			break
		}

		return e.complexity.HasSBOM.URI(childComplexity), true

	case "HasSLSA.buildType":
		if e.complexity.HasSLSA.BuildType == nil {
			break
		}

		return e.complexity.HasSLSA.BuildType(childComplexity), true

	case "HasSLSA.builtBy":
		if e.complexity.HasSLSA.BuiltBy == nil {
			break
		}

		return e.complexity.HasSLSA.BuiltBy(childComplexity), true

	case "HasSLSA.builtFrom":
		if e.complexity.HasSLSA.BuiltFrom == nil {
			break
		}

		return e.complexity.HasSLSA.BuiltFrom(childComplexity), true

	case "HasSLSA.collector":
		if e.complexity.HasSLSA.Collector == nil {
			break
		}

		return e.complexity.HasSLSA.Collector(childComplexity), true

	case "HasSLSA.finishedOn":
		if e.complexity.HasSLSA.FinishedOn == nil {
			break
		}

		return e.complexity.HasSLSA.FinishedOn(childComplexity), true

	case "HasSLSA.origin":
		if e.complexity.HasSLSA.Origin == nil {
			break
		}

		return e.complexity.HasSLSA.Origin(childComplexity), true

	case "HasSLSA.slsaPredicate":
		if e.complexity.HasSLSA.SlsaPredicate == nil {
			break
		}

		return e.complexity.HasSLSA.SlsaPredicate(childComplexity), true

	case "HasSLSA.slsaVersion":
		if e.complexity.HasSLSA.SlsaVersion == nil {
			break
		}

		return e.complexity.HasSLSA.SlsaVersion(childComplexity), true

	case "HasSLSA.startedOn":
		if e.complexity.HasSLSA.StartedOn == nil {
			break
		}

		return e.complexity.HasSLSA.StartedOn(childComplexity), true

	case "HasSLSA.subject":
		if e.complexity.HasSLSA.Subject == nil {
			break
		}

		return e.complexity.HasSLSA.Subject(childComplexity), true

	case "HasSourceAt.collector":
		if e.complexity.HasSourceAt.Collector == nil {
			break
		}

		return e.complexity.HasSourceAt.Collector(childComplexity), true

	case "HasSourceAt.justification":
		if e.complexity.HasSourceAt.Justification == nil {
			break
		}

		return e.complexity.HasSourceAt.Justification(childComplexity), true

	case "HasSourceAt.knownSince":
		if e.complexity.HasSourceAt.KnownSince == nil {
			break
		}

		return e.complexity.HasSourceAt.KnownSince(childComplexity), true

	case "HasSourceAt.origin":
		if e.complexity.HasSourceAt.Origin == nil {
			break
		}

		return e.complexity.HasSourceAt.Origin(childComplexity), true

	case "HasSourceAt.package":
		if e.complexity.HasSourceAt.Package == nil {
			break
		}

		return e.complexity.HasSourceAt.Package(childComplexity), true

	case "HasSourceAt.source":
		if e.complexity.HasSourceAt.Source == nil {
			break
		}

		return e.complexity.HasSourceAt.Source(childComplexity), true

	case "HashEqual.artifacts":
		if e.complexity.HashEqual.Artifacts == nil {
			break
		}

		return e.complexity.HashEqual.Artifacts(childComplexity), true

	case "HashEqual.collector":
		if e.complexity.HashEqual.Collector == nil {
			break
		}

		return e.complexity.HashEqual.Collector(childComplexity), true

	case "HashEqual.justification":
		if e.complexity.HashEqual.Justification == nil {
			break
		}

		return e.complexity.HashEqual.Justification(childComplexity), true

	case "HashEqual.origin":
		if e.complexity.HashEqual.Origin == nil {
			break
		}

		return e.complexity.HashEqual.Origin(childComplexity), true

	case "IsDependency.collector":
		if e.complexity.IsDependency.Collector == nil {
			break
		}

		return e.complexity.IsDependency.Collector(childComplexity), true

	case "IsDependency.dependentPackage":
		if e.complexity.IsDependency.DependentPackage == nil {
			break
		}

		return e.complexity.IsDependency.DependentPackage(childComplexity), true

	case "IsDependency.justification":
		if e.complexity.IsDependency.Justification == nil {
			break
		}

		return e.complexity.IsDependency.Justification(childComplexity), true

	case "IsDependency.origin":
		if e.complexity.IsDependency.Origin == nil {
			break
		}

		return e.complexity.IsDependency.Origin(childComplexity), true

	case "IsDependency.package":
		if e.complexity.IsDependency.Package == nil {
			break
		}

		return e.complexity.IsDependency.Package(childComplexity), true

	case "IsDependency.versionRange":
		if e.complexity.IsDependency.VersionRange == nil {
			break
		}

		return e.complexity.IsDependency.VersionRange(childComplexity), true

	case "IsOccurrence.collector":
		if e.complexity.IsOccurrence.Collector == nil {
			break
		}

		return e.complexity.IsOccurrence.Collector(childComplexity), true

	case "IsOccurrence.justification":
		if e.complexity.IsOccurrence.Justification == nil {
			break
		}

		return e.complexity.IsOccurrence.Justification(childComplexity), true

	case "IsOccurrence.occurrenceArtifacts":
		if e.complexity.IsOccurrence.OccurrenceArtifacts == nil {
			break
		}

		return e.complexity.IsOccurrence.OccurrenceArtifacts(childComplexity), true

	case "IsOccurrence.origin":
		if e.complexity.IsOccurrence.Origin == nil {
			break
		}

		return e.complexity.IsOccurrence.Origin(childComplexity), true

	case "IsOccurrence.subject":
		if e.complexity.IsOccurrence.Subject == nil {
			break
		}

		return e.complexity.IsOccurrence.Subject(childComplexity), true

	case "IsVulnerability.collector":
		if e.complexity.IsVulnerability.Collector == nil {
			break
		}

		return e.complexity.IsVulnerability.Collector(childComplexity), true

	case "IsVulnerability.justification":
		if e.complexity.IsVulnerability.Justification == nil {
			break
		}

		return e.complexity.IsVulnerability.Justification(childComplexity), true

	case "IsVulnerability.origin":
		if e.complexity.IsVulnerability.Origin == nil {
			break
		}

		return e.complexity.IsVulnerability.Origin(childComplexity), true

	case "IsVulnerability.osv":
		if e.complexity.IsVulnerability.Osv == nil {
			break
		}

		return e.complexity.IsVulnerability.Osv(childComplexity), true

	case "IsVulnerability.vulnerability":
		if e.complexity.IsVulnerability.Vulnerability == nil {
			break
		}

		return e.complexity.IsVulnerability.Vulnerability(childComplexity), true

	case "Mutation.ingestArtifact":
		if e.complexity.Mutation.IngestArtifact == nil {
			break
		}

		args, err := ec.field_Mutation_ingestArtifact_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestArtifact(childComplexity, args["artifact"].(*model.ArtifactInputSpec)), true

	case "Mutation.ingestBuilder":
		if e.complexity.Mutation.IngestBuilder == nil {
			break
		}

		args, err := ec.field_Mutation_ingestBuilder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestBuilder(childComplexity, args["builder"].(*model.BuilderInputSpec)), true

	case "Mutation.ingestCVE":
		if e.complexity.Mutation.IngestCve == nil {
			break
		}

		args, err := ec.field_Mutation_ingestCVE_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestCve(childComplexity, args["cve"].(*model.CVEInputSpec)), true

	case "Mutation.ingestGHSA":
		if e.complexity.Mutation.IngestGhsa == nil {
			break
		}

		args, err := ec.field_Mutation_ingestGHSA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestGhsa(childComplexity, args["ghsa"].(*model.GHSAInputSpec)), true

	case "Mutation.ingestOSV":
		if e.complexity.Mutation.IngestOsv == nil {
			break
		}

		args, err := ec.field_Mutation_ingestOSV_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestOsv(childComplexity, args["osv"].(*model.OSVInputSpec)), true

	case "Mutation.ingestPackage":
		if e.complexity.Mutation.IngestPackage == nil {
			break
		}

		args, err := ec.field_Mutation_ingestPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestPackage(childComplexity, args["pkg"].(*model.PkgInputSpec)), true

	case "Mutation.ingestSource":
		if e.complexity.Mutation.IngestSource == nil {
			break
		}

		args, err := ec.field_Mutation_ingestSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestSource(childComplexity, args["source"].(*model.SourceInputSpec)), true

	case "OSV.osvId":
		if e.complexity.OSV.OsvID == nil {
			break
		}

		return e.complexity.OSV.OsvID(childComplexity), true

	case "OSVId.id":
		if e.complexity.OSVId.ID == nil {
			break
		}

		return e.complexity.OSVId.ID(childComplexity), true

	case "Package.namespaces":
		if e.complexity.Package.Namespaces == nil {
			break
		}

		return e.complexity.Package.Namespaces(childComplexity), true

	case "Package.type":
		if e.complexity.Package.Type == nil {
			break
		}

		return e.complexity.Package.Type(childComplexity), true

	case "PackageName.name":
		if e.complexity.PackageName.Name == nil {
			break
		}

		return e.complexity.PackageName.Name(childComplexity), true

	case "PackageName.versions":
		if e.complexity.PackageName.Versions == nil {
			break
		}

		return e.complexity.PackageName.Versions(childComplexity), true

	case "PackageNamespace.names":
		if e.complexity.PackageNamespace.Names == nil {
			break
		}

		return e.complexity.PackageNamespace.Names(childComplexity), true

	case "PackageNamespace.namespace":
		if e.complexity.PackageNamespace.Namespace == nil {
			break
		}

		return e.complexity.PackageNamespace.Namespace(childComplexity), true

	case "PackageQualifier.key":
		if e.complexity.PackageQualifier.Key == nil {
			break
		}

		return e.complexity.PackageQualifier.Key(childComplexity), true

	case "PackageQualifier.value":
		if e.complexity.PackageQualifier.Value == nil {
			break
		}

		return e.complexity.PackageQualifier.Value(childComplexity), true

	case "PackageVersion.qualifiers":
		if e.complexity.PackageVersion.Qualifiers == nil {
			break
		}

		return e.complexity.PackageVersion.Qualifiers(childComplexity), true

	case "PackageVersion.subpath":
		if e.complexity.PackageVersion.Subpath == nil {
			break
		}

		return e.complexity.PackageVersion.Subpath(childComplexity), true

	case "PackageVersion.version":
		if e.complexity.PackageVersion.Version == nil {
			break
		}

		return e.complexity.PackageVersion.Version(childComplexity), true

	case "Query.artifacts":
		if e.complexity.Query.Artifacts == nil {
			break
		}

		args, err := ec.field_Query_artifacts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Artifacts(childComplexity, args["artifactSpec"].(*model.ArtifactSpec)), true

	case "Query.builders":
		if e.complexity.Query.Builders == nil {
			break
		}

		args, err := ec.field_Query_builders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Builders(childComplexity, args["builderSpec"].(*model.BuilderSpec)), true

	case "Query.CertifyBad":
		if e.complexity.Query.CertifyBad == nil {
			break
		}

		args, err := ec.field_Query_CertifyBad_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyBad(childComplexity, args["certifyBadSpec"].(*model.CertifyBadSpec)), true

	case "Query.CertifyPkg":
		if e.complexity.Query.CertifyPkg == nil {
			break
		}

		args, err := ec.field_Query_CertifyPkg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyPkg(childComplexity, args["certifyPkgSpec"].(*model.CertifyPkgSpec)), true

	case "Query.CertifyScorecard":
		if e.complexity.Query.CertifyScorecard == nil {
			break
		}

		args, err := ec.field_Query_CertifyScorecard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyScorecard(childComplexity, args["certifyScorecardSpec"].(*model.CertifyScorecardSpec)), true

	case "Query.CertifyVEXStatement":
		if e.complexity.Query.CertifyVEXStatement == nil {
			break
		}

		args, err := ec.field_Query_CertifyVEXStatement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyVEXStatement(childComplexity, args["certifyVEXStatementSpec"].(*model.CertifyVEXStatementSpec)), true

	case "Query.CertifyVuln":
		if e.complexity.Query.CertifyVuln == nil {
			break
		}

		args, err := ec.field_Query_CertifyVuln_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyVuln(childComplexity, args["certifyVulnSpec"].(*model.CertifyVulnSpec)), true

	case "Query.cve":
		if e.complexity.Query.Cve == nil {
			break
		}

		args, err := ec.field_Query_cve_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Cve(childComplexity, args["cveSpec"].(*model.CVESpec)), true

	case "Query.ghsa":
		if e.complexity.Query.Ghsa == nil {
			break
		}

		args, err := ec.field_Query_ghsa_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Ghsa(childComplexity, args["ghsaSpec"].(*model.GHSASpec)), true

	case "Query.HasSBOMs":
		if e.complexity.Query.HasSBOMs == nil {
			break
		}

		args, err := ec.field_Query_HasSBOMs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasSBOMs(childComplexity, args["hasSBOMSpec"].(*model.HasSBOMSpec)), true

	case "Query.HasSLSA":
		if e.complexity.Query.HasSlsa == nil {
			break
		}

		args, err := ec.field_Query_HasSLSA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasSlsa(childComplexity, args["hasSLSASpec"].(*model.HasSLSASpec)), true

	case "Query.HasSourceAt":
		if e.complexity.Query.HasSourceAt == nil {
			break
		}

		args, err := ec.field_Query_HasSourceAt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasSourceAt(childComplexity, args["hasSourceAtSpec"].(*model.HasSourceAtSpec)), true

	case "Query.HashEquals":
		if e.complexity.Query.HashEquals == nil {
			break
		}

		args, err := ec.field_Query_HashEquals_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HashEquals(childComplexity, args["hashEqualSpec"].(*model.HashEqualSpec)), true

	case "Query.IsDependency":
		if e.complexity.Query.IsDependency == nil {
			break
		}

		args, err := ec.field_Query_IsDependency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsDependency(childComplexity, args["isDependencySpec"].(*model.IsDependencySpec)), true

	case "Query.IsOccurrences":
		if e.complexity.Query.IsOccurrences == nil {
			break
		}

		args, err := ec.field_Query_IsOccurrences_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsOccurrences(childComplexity, args["isOccurrenceSpec"].(*model.IsOccurrenceSpec)), true

	case "Query.IsVulnerability":
		if e.complexity.Query.IsVulnerability == nil {
			break
		}

		args, err := ec.field_Query_IsVulnerability_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsVulnerability(childComplexity, args["isVulnerabilitySpec"].(*model.IsVulnerabilitySpec)), true

	case "Query.osv":
		if e.complexity.Query.Osv == nil {
			break
		}

		args, err := ec.field_Query_osv_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Osv(childComplexity, args["osvSpec"].(*model.OSVSpec)), true

	case "Query.packages":
		if e.complexity.Query.Packages == nil {
			break
		}

		args, err := ec.field_Query_packages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Packages(childComplexity, args["pkgSpec"].(*model.PkgSpec)), true

	case "Query.sources":
		if e.complexity.Query.Sources == nil {
			break
		}

		args, err := ec.field_Query_sources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sources(childComplexity, args["sourceSpec"].(*model.SourceSpec)), true

	case "SLSAPredicate.key":
		if e.complexity.SLSAPredicate.Key == nil {
			break
		}

		return e.complexity.SLSAPredicate.Key(childComplexity), true

	case "SLSAPredicate.value":
		if e.complexity.SLSAPredicate.Value == nil {
			break
		}

		return e.complexity.SLSAPredicate.Value(childComplexity), true

	case "ScorecardCheck.check":
		if e.complexity.ScorecardCheck.Check == nil {
			break
		}

		return e.complexity.ScorecardCheck.Check(childComplexity), true

	case "ScorecardCheck.score":
		if e.complexity.ScorecardCheck.Score == nil {
			break
		}

		return e.complexity.ScorecardCheck.Score(childComplexity), true

	case "Source.namespaces":
		if e.complexity.Source.Namespaces == nil {
			break
		}

		return e.complexity.Source.Namespaces(childComplexity), true

	case "Source.type":
		if e.complexity.Source.Type == nil {
			break
		}

		return e.complexity.Source.Type(childComplexity), true

	case "SourceName.commit":
		if e.complexity.SourceName.Commit == nil {
			break
		}

		return e.complexity.SourceName.Commit(childComplexity), true

	case "SourceName.name":
		if e.complexity.SourceName.Name == nil {
			break
		}

		return e.complexity.SourceName.Name(childComplexity), true

	case "SourceName.tag":
		if e.complexity.SourceName.Tag == nil {
			break
		}

		return e.complexity.SourceName.Tag(childComplexity), true

	case "SourceNamespace.names":
		if e.complexity.SourceNamespace.Names == nil {
			break
		}

		return e.complexity.SourceNamespace.Names(childComplexity), true

	case "SourceNamespace.namespace":
		if e.complexity.SourceNamespace.Namespace == nil {
			break
		}

		return e.complexity.SourceNamespace.Namespace(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputArtifactInputSpec,
		ec.unmarshalInputArtifactSpec,
		ec.unmarshalInputBuilderInputSpec,
		ec.unmarshalInputBuilderSpec,
		ec.unmarshalInputCVEInputSpec,
		ec.unmarshalInputCVESpec,
		ec.unmarshalInputCertifyBadSpec,
		ec.unmarshalInputCertifyPkgSpec,
		ec.unmarshalInputCertifyScorecardSpec,
		ec.unmarshalInputCertifyVEXStatementSpec,
		ec.unmarshalInputCertifyVulnSpec,
		ec.unmarshalInputGHSAInputSpec,
		ec.unmarshalInputGHSASpec,
		ec.unmarshalInputHasSBOMSpec,
		ec.unmarshalInputHasSLSASpec,
		ec.unmarshalInputHasSourceAtSpec,
		ec.unmarshalInputHashEqualSpec,
		ec.unmarshalInputIsDependencySpec,
		ec.unmarshalInputIsOccurrenceSpec,
		ec.unmarshalInputIsVulnerabilitySpec,
		ec.unmarshalInputOSVInputSpec,
		ec.unmarshalInputOSVSpec,
		ec.unmarshalInputPackageQualifierInputSpec,
		ec.unmarshalInputPackageQualifierSpec,
		ec.unmarshalInputPkgInputSpec,
		ec.unmarshalInputPkgNameSpec,
		ec.unmarshalInputPkgSpec,
		ec.unmarshalInputSLSAPredicateSpec,
		ec.unmarshalInputScorecardCheckSpec,
		ec.unmarshalInputSourceInputSpec,
		ec.unmarshalInputSourceSpec,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/artifact.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the artifact. It contains the algorithm and
# digest fields

"""
Artifact represents the artifact and contains a digest field

Both field are mandatory and canonicalized to be lowercase.

If having a ` + "`" + `checksum` + "`" + ` Go object, ` + "`" + `algorithm` + "`" + ` can be
` + "`" + `strings.ToLower(string(checksum.Algorithm))` + "`" + ` and ` + "`" + `digest` + "`" + ` can be
` + "`" + `checksum.Value` + "`" + `.
"""
type Artifact {
  algorithm: String!
  digest: String!
}

"""
ArtifactSpec allows filtering the list of artifacts to return.

Both arguments will be canonicalized to lowercase.
"""
input ArtifactSpec {
  algorithm: String
  digest: String
}

"""
ArtifactInputSpec is the same as Artifact, but used as mutation input.

Both arguments will be canonicalized to lowercase.
"""
input ArtifactInputSpec {
  algorithm: String!
  digest: String!
}

extend type Query {
  "Returns all artifacts"
  artifacts(artifactSpec: ArtifactSpec): [Artifact!]!
}

extend type Mutation {
  "Ingest a new artifact. Returns the ingested artifact"
  ingestArtifact(artifact: ArtifactInputSpec): Artifact!
}
`, BuiltIn: false},
	{Name: "../schema/builder.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the builder. It only contains the uri

"""
Builder represents the builder such as (FRSCA or github actions).

Currently builders are identified by the ` + "`" + `uri` + "`" + ` field, which is mandatory.
"""
type Builder {
  uri: String!
}

"""
BuilderSpec allows filtering the list of builders to return.
"""
input BuilderSpec {
  uri: String
}

"""
BuilderInputSpec is the same as Builder, but used for mutation ingestion.
"""
input BuilderInputSpec {
  uri: String!
}

extend type Query {
  "Returns all builders"
  builders(builderSpec: BuilderSpec): [Builder!]!
}

extend type Mutation {
  "Ingest a new builder. Returns the ingested builder"
  ingestBuilder(builder: BuilderInputSpec): Builder!
}
`, BuiltIn: false},
	{Name: "../schema/certifyBad.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CertifyBad. It contains the subject (which can be either a package, source or artifact),
#  justification, origin of the attestation, and collector
"""
CertifyBad is an attestation represents when a package, source or artifact is considered bad

subject - union type that can be either a package, source or artifact object type
justification (property) - string value representing why the subject is considered bad
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation

Note: Attestation must occur at the PackageName or the PackageVersion or at the SourceName.
"""
type CertifyBad {
  subject: PkgSrcArtObject!
  justification: String!
  origin: String!
  collector: String!
}

"""
CertifyBadSpec allows filtering the list of CertifyBad to return.
Note: Package, Source or artifact must be specified but not at the same time
For package - a PackageName or PackageVersion must be specified (name or name, version, qualifiers and subpath)
For source - a SourceName must be specified (name, tag or commit)
"""
input CertifyBadSpec {
  package: PkgSpec
  source: SourceSpec
  artifact: ArtifactSpec
  justification: String
  origin: String
  collector: String
}

"""
PkgSrcArtObject is a union of Package, Source and Artifact. Any of these objects can be specified
"""
union PkgSrcArtObject = Package | Source | Artifact

extend type Query {
  "Returns all CertifyBad"
  CertifyBad(certifyBadSpec: CertifyBadSpec): [CertifyBad!]!
}
`, BuiltIn: false},
	{Name: "../schema/certifyPkg.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CertifyPkg. It contains a list of packages that are similar
# along with the justification, origin and collector.
"""
CertifyPkg is an attestation that represents when a package objects are similar

packages (subject) - list of package objects
justification (property) - string value representing why the packages are similar
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type CertifyPkg {
  packages: [Package!]!
  justification: String!
  origin: String!
  collector: String!
}

"""
CertifyPkgSpec allows filtering the list of CertifyPkg to return.

Specifying just the package allows to query for all similar packages (if they exist)
"""
input CertifyPkgSpec {
  packages: [PkgSpec]
  justification: String
  origin: String
  collector: String
}

extend type Query {
  "Returns all CertifyPkg"
  CertifyPkg(certifyPkgSpec: CertifyPkgSpec): [CertifyPkg!]!
}
`, BuiltIn: false},
	{Name: "../schema/certifyScorecard.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CertifyScorecard. It contains the source object, time the source was scanned,
# aggregate score, individual check scores, scorecard version and commit, origin and collector.
"""
CertifyScorecard is an attestation represents the scorecard of a particular source

source (subject) - the source object type that represents the source
timeScanned (property) - timestamp when this was last scanned (exact time)
aggregateScore (property) - overall scorecard score for the source
checks (property) - individual scorecard check scores (Branch-Protection, Code-Review...etc)
scorecardVersion (property) - version of the scorecard when the source was scanned
scorecardCommit (property) - commit of scorecard when the source was scanned
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type CertifyScorecard {
  source: Source!
  timeScanned: String!
  aggregateScore: Float!
  checks: [ScorecardCheck!]!
  scorecardVersion: String!
  scorecardCommit: String!
  origin: String!
  collector: String!
}

"""
ScorecardCheck are the individual checks from scorecard and their values, a key-value pair.
For example:  Branch-Protection, Code-Review...etc
Based off scorecard's:
type jsonCheckResultV2 struct {
	Details []string                 ` + "`" + `json:"details"` + "`" + `
	Score   int                      ` + "`" + `json:"score"` + "`" + `
	Reason  string                   ` + "`" + `json:"reason"` + "`" + `
	Name    string                   ` + "`" + `json:"name"` + "`" + `
	Doc     jsonCheckDocumentationV2 ` + "`" + `json:"documentation"` + "`" + `
}
This node cannot be directly referred by other parts of GUAC.
"""
type ScorecardCheck {
  check: String!
  score: Int!
}

"""
CertifyScorecardSpec allows filtering the list of CertifyScorecard to return.
"""
input CertifyScorecardSpec {
  source: SourceSpec
  timeScanned: String
  aggregateScore: Float
  checks: [ScorecardCheckSpec!] = []
  scorecardVersion: String
  scorecardCommit: String
  origin: String
  collector: String
}

"""
ScorecardCheckSpec is the same as ScorecardCheck, but usable as query
input.
"""
input ScorecardCheckSpec {
  check: String!
  score: Int!
}

extend type Query {
  "Returns all CertifyScorecard"
  CertifyScorecard(certifyScorecardSpec: CertifyScorecardSpec): [CertifyScorecard!]!
}
`, BuiltIn: false},
	{Name: "../schema/certifyVEXStatement.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CertifyVEXStatement. It contains a subject which can be a package or artifact object, vulnerability that can be of type
# cve or ghsa, justification, origin and collector
"""
CertifyVEXStatement is an attestation that represents when a package or artifact has a VEX about a specific vulnerability (CVE or GHSA)

subject - union type that represents a package or artifact
vulnerability (object) - union type that consists of cve or ghsa
justification (property) - justification for VEX
knownSince (property) - timestamp of the VEX (exact time)
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type CertifyVEXStatement {
  subject: PkgArtObject!
  vulnerability: CveGhsaObject!
  justification: String!
  knownSince: String!
  origin: String!
  collector: String!
}

"""
CertifyVEXStatementSpec allows filtering the list of CertifyVEXStatement to return.
Only package or artifact and CVE or GHSA can be specified at once.
"""
input CertifyVEXStatementSpec {
  package: PkgSpec
  artifact: ArtifactSpec
  cve: CVESpec
  ghsa: GHSASpec
  justification: String
  knownSince: String
  origin: String
  collector: String
}

"""
PkgArtObject is a union of Package and Artifact. Any of these objects can be specified
"""
union PkgArtObject = Package | Artifact

extend type Query {
  "Returns all CertifyVEXStatement"
  CertifyVEXStatement(certifyVEXStatementSpec: CertifyVEXStatementSpec): [CertifyVEXStatement!]!
}`, BuiltIn: false},
	{Name: "../schema/certifyVuln.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CertifyVuln. It contains a package, vulnerability that can be of type
# cve, ghsa or osv, time scanned, db uri, db version, scanner uri, scanner version, origin and collector
"""
CertifyVuln is an attestation that represents when a package has a vulnerability

package (subject) - the package object type that represents the package
vulnerability (object) - union type that consists of osv, cve or ghsa
timeScanned (property) - timestamp of when the package was last scanned
dbUri (property) - scanner vulnerability database uri
dbVersion (property) - scanner vulnerability database version
scannerUri (property) - vulnerability scanner's uri 
scannerVersion (property) - vulnerability scanner version
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type CertifyVuln {
  package: Package!
  vulnerability: OsvCveGhsaObject!
  timeScanned: String!
  dbUri: String!
  dbVersion: String!
  scannerUri: String!
  scannerVersion: String!
  origin: String!
  collector: String!
}

"""
CertifyVulnSpec allows filtering the list of CertifyVuln to return.

Specifying just the package allows to query for all vulnerabilities associated with the package.
Only OSV, CVE or GHSA can be specified at once
"""
input CertifyVulnSpec {
  package: PkgSpec
  osv: OSVSpec
  cve: CVESpec
  ghsa: GHSASpec
  timeScanned: String
  dbUri: String
  dbVersion: String
  scannerUri: String
  scannerVersion: String
  origin: String
  collector: String
}

"""
OsvCveGhsaObject is a union of OSV, CVE and GHSA. Any of these objects can be specified for vulnerability
"""
union OsvCveGhsaObject = OSV | CVE | GHSA

extend type Query {
  "Returns all CertifyVuln"
  CertifyVuln(certifyVulnSpec: CertifyVulnSpec): [CertifyVuln!]!
}
`, BuiltIn: false},
	{Name: "../schema/cve.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CVE trie/tree. It contains the year
# along with the ID associated with vulnerability (CVE ID).

"""
CVE represents common vulnerabilities and exposures. It contains the year along
with the CVE ID.

The year is mandatory.

This node is a singleton: backends guarantee that there is exactly one node
with the same ` + "`" + `year` + "`" + ` value.
"""
type CVE {
  year: String!
  cveId: [CVEId!]!
}

"""
CVEId is the actual ID that is given to a specific vulnerability

The ` + "`" + `id` + "`" + ` field is mandatory and canonicalized to be lowercase.

This node can be referred to by other parts of GUAC.
"""
type CVEId {
  id: String!
}

"""
CVESpec allows filtering the list of cves to return.
"""
input CVESpec {
  year: String
  cveId: String
}

"""
CVEInputSpec is the same as CVESpec, but used for mutation ingestion.
"""
input CVEInputSpec {
  year: String!
  cveId: String!
}

extend type Query {
  "Returns all CVEs"
  cve(cveSpec: CVESpec): [CVE!]!
}

extend type Mutation {
  "Ingest a new CVE. Returns the ingested object"
  ingestCVE(cve: CVEInputSpec): CVE!
}
`, BuiltIn: false},
	{Name: "../schema/ghsa.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the GitHub Security Advisory (GSHA) trie/tree.
# It contains the ID associated with a vulnerability in the GitHub numbering
# schema (GHSA ID).

"""
GHSA represents GitHub security advisories.

We create a separate node to allow retrieving all GHSAs.
"""
type GHSA {
  ghsaId: [GHSAId!]!
}

"""
GHSAId is the actual ID that is given to a specific vulnerability on GitHub

The ` + "`" + `id` + "`" + ` field is mandatory and canonicalized to be lowercase.

This node can be referred to by other parts of GUAC.
"""
type GHSAId {
  id: String!
}

"""
GHSASpec allows filtering the list of GHSA to return.

The argument will be canonicalized to lowercase.
"""
input GHSASpec {
  ghsaId: String
}

"""
GHSAInputSpec is the same as GHSASpec, but used for mutation ingestion.
"""
input GHSAInputSpec {
  ghsaId: String!
}

extend type Query {
  "Returns all GHSA nodes"
  ghsa(ghsaSpec: GHSASpec): [GHSA!]!
}

extend type Mutation {
  "Ingest a new GHSA. Returns the ingested object"
  ingestGHSA(ghsa: GHSAInputSpec): GHSA!
}
`, BuiltIn: false},
	{Name: "../schema/hasSBOM.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the HasSBOM. It contains the subject (which can be either a package or source), uri, origin and collector. 
"""
HasSBOM is an attestation represents that a package object or source object has an SBOM associated with a uri

subject - union type that can be either a package or source object type
uri (property) - identifier string for the SBOM
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation

Note: Only package object or source object can be defined. Not both.
"""
type HasSBOM {
  subject: PkgSrcObject!
  uri: String!
  origin: String!
  collector: String!
}

"""
HashEqualSpec allows filtering the list of HasSBOM to return.

Only the package or source can be added, not both. HasSourceAt will be used to create the package to source
relationship. 
"""
input HasSBOMSpec {
  package: PkgSpec
  source: SourceSpec
  uri: String
  origin: String
  collector: String
}

"""
PkgSrcObject is a union of Package and Source. Any of these objects can be specified
"""
union PkgSrcObject = Package | Source

extend type Query {
  "Returns all HasSBOM"
  HasSBOMs(hasSBOMSpec: HasSBOMSpec): [HasSBOM!]!
}
`, BuiltIn: false},
	{Name: "../schema/hasSLSA.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the HasSLSA. It contains the Subject which can be of type package, source or artifact,
# buliltFrom which can also be of type package, source or artifact, builtby (builder object), build type,  predicate (key value pair of
# the predicate values), slsa version, started on, finished on, origin and collector.
"""
HasSLSA is an attestation represents that the subject has a SLSA attestation associated with it.

subject - an union type that consists of package, source or artifact
builtFrom (object) - list of union types that consists of the package, source or artifact that the subject was build from
builtBy (object) - represents the builder that was used to build the subject
buildType (property) - individual scorecard check scores (Branch-Protection, Code-Review...etc)
slsaPredicate (property) - a list of key value pair that consist of the keys and values of the SLSA predicate
slsaVersion (property) - version of the SLSA predicate
startedOn (property) - timestamp when the SLSA predicate was recorded during the build time of the subject
finishedOn (property) - timestamp when the SLSA predicate was completed during the build time of the subject
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type HasSLSA {
  subject: PkgSrcArtObject!
  builtFrom: [PkgSrcArtObject!]!
  builtBy: Builder!
  buildType: String!
  slsaPredicate: [SLSAPredicate!]!
  slsaVersion: String!
  startedOn: String!
  finishedOn: String!
  origin: String!
  collector: String!
}

"""
SLSAPredicate are the values from the SLSA predicate in key-value pair form.
// Predicate:
"predicateType": "https://slsa.dev/provenance/v1",
"predicate": {
    "buildDefinition": {
        "buildType": string,
        "externalParameters": object,
        "systemParameters": object,
        "resolvedDependencies": [ ...#ArtifactReference ],
    },
    "runDetails": {
        "builder": {
            "id": string,
            "version": string,
            "builderDependencies": [ ...#ArtifactReference ],
        },
        "metadata": {
            "invocationId": string,
            "startedOn": #Timestamp,
            "finishedOn": #Timestamp,
        },
        "byproducts": [ ...#ArtifactReference ],
    }
}
where
"externalParameters": {
    "repository": "https://github.com/octocat/hello-world",
    "ref": "refs/heads/main"
},

For example: key = "buildDefinition.externalParameters.repository" value = "https://github.com/octocat/hello-world"
This node cannot be directly referred by other parts of GUAC.
"""
type SLSAPredicate {
  key: String!
  value: String!
}

"""
HasSLSASpec allows filtering the list of HasSLSA to return.
"""
input HasSLSASpec {
  package: PkgSpec
  source: SourceSpec
  artifact: ArtifactSpec
  builtFromPackages: [PkgSpec]
  builtFromSource: [SourceSpec]
  builtFromArtifact: [ArtifactSpec]
  builtBy: BuilderSpec
  buildType: String
  predicate: [SLSAPredicateSpec!] = []
  slsaVersion: String
  startedOn: String
  finishedOn: String
  origin: String
  collector: String
}

"""
SLSAPredicateSpec is the same as SLSAPredicateSpec, but usable as query
input.
"""
input SLSAPredicateSpec {
  key: String!
  value: String!
}

extend type Query {
  "Returns all HasSLSA"
  HasSLSA(hasSLSASpec: HasSLSASpec): [HasSLSA!]!
}
`, BuiltIn: false},
	{Name: "../schema/hasSourceAt.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the HasSourceAt. It contains the package object, source object, since (timestamp), justification, origin and collector. 
"""
HasSourceAt is an attestation represents that a package object has a source object since a timestamp

package (subject) - the package object type that represents the package
source (object) - the source object type that represents the source
knownSince (property) - timestamp when this was last checked (exact time)
justification (property) - string value representing why the package has a source specified
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type HasSourceAt {
  package: Package!
  source: Source!
  knownSince: String!
  justification: String!
  origin: String!
  collector: String!
}

"""
HasSourceAtSpec allows filtering the list of HasSourceAt to return.
"""
input HasSourceAtSpec {
  package: PkgSpec
  source: SourceSpec
  knownSince: String
  justification: String
  origin: String
  collector: String
}


extend type Query {
  "Returns all HasSourceAt"
  HasSourceAt(hasSourceAtSpec: HasSourceAtSpec): [HasSourceAt!]!
}
`, BuiltIn: false},
	{Name: "../schema/hashEqual.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the HashEqual. It contains the justification, artifacts, origin and collector. 
"""
HashEqual is an attestation that represents when two artifact hash are similar based on a justification.

artifacts (subject) - the artifacts (represented by algorithm and digest) that are equal
justification (property) - string value representing why the artifacts are the equal
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type HashEqual {
  artifacts: [Artifact!]!
  justification: String!
  origin: String!
  collector: String!
}

"""
HashEqualSpec allows filtering the list of HashEqual to return.

Specifying just the artifacts allows to query for all equivalent artifacts (if they exist)
"""
input HashEqualSpec {
  justification: String
  artifacts: [ArtifactSpec]
  origin: String
  collector: String
}


extend type Query {
  "Returns all HashEqual"
  HashEquals(hashEqualSpec: HashEqualSpec): [HashEqual!]!
}
`, BuiltIn: false},
	{Name: "../schema/isDependency.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the IsDependency. It contains the package object, dependent package object
# version range of the dependent package that it applies to, justification, origin and collector.
"""
IsDependency is an attestation that represents when a package is dependent on another package

package (subject) - the package object type that represents the package
dependentPackage (object) - the package object type that represents the packageName (cannot be to the packageVersion)
versionRange (property) - string value for version range that applies to the dependent package
justification (property) - string value representing why the artifacts are the equal
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type IsDependency {
  package: Package!
  dependentPackage: Package!
  versionRange: String!
  justification: String!
  origin: String!
  collector: String!
}

"""
IsDependencySpec allows filtering the list of IsDependency to return.

Note: the package object must be defined to return its dependent packages.
Dependent Packages must represent the packageName (cannot be the packageVersion)
"""
input IsDependencySpec {
  package: PkgSpec
  dependentPackage: PkgNameSpec
  versionRange: String
  justification: String
  origin: String
  collector: String
}

"""
PkgNameSpec is used for IsDependency to input dependent packages. This is different from PkgSpec
as the IsDependency attestation should only be allowed to be made to the packageName node and not the
packageVersion node. Versions will be handled by the version_range in the IsDependency attestation node.
"""
input PkgNameSpec {
  type: String
  namespace: String
  name: String
}


extend type Query {
  "Returns all IsDependency"
  IsDependency(isDependencySpec: IsDependencySpec): [IsDependency!]!
}
`, BuiltIn: false},
	{Name: "../schema/isOccurrence.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the IsOccurrence. It contains the subject (which can be either a package or source),
#  occurrenceArtifacts, justification,  origin of the attestation, and collector
"""
IsOccurrence is an attestation represents when either a package or source is represented by an artifact

subject - union type that can be either a package or source object type
occurrenceArtifacts (object) - list of artifacts that represent the the package or source
justification (property) - string value representing why the package or source is represented by the specified artifact
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation

Note: Package or Source must be specified but not both at the same time.
Attestation must occur at the PackageName or the PackageVersion or at the SourceName.

IsOccurrence does not connect a package with a source. 
HasSourceAt attestation will be used to connect a package with a source
"""
type IsOccurrence {
  subject: PkgSrcObject!
  occurrenceArtifacts: [Artifact!]!
  justification: String!
  origin: String!
  collector: String!
}

"""
IsOccurrenceSpec allows filtering the list of IsOccurrence to return.
Note: Package or Source must be specified but not both at the same time
For package - a PackageName or PackageVersion must be specified (name or name, version, qualifiers and subpath)
For source - a SourceName must be specified (name, tag or commit)
"""
input IsOccurrenceSpec {
  justification: String
  package: PkgSpec
  source: SourceSpec
  artifacts: [ArtifactSpec]
  origin: String
  collector: String
}


extend type Query {
  "Returns all IsOccurrence"
  IsOccurrences(isOccurrenceSpec: IsOccurrenceSpec): [IsOccurrence!]!
}
`, BuiltIn: false},
	{Name: "../schema/isVulnerability.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the IsVulnerability. It contains a OSV, vulnerability that can be of type
# cve or ghsa, justification, origin and collector
"""
IsVulnerability is an attestation that represents when an OSV ID represents a CVE or GHSA

osv (subject) - the osv object type that represents OSV and its ID
vulnerability (object) - union type that consists of cve or ghsa
justification (property) - the reason why the osv ID represents the cve or ghsa
origin (property) - where this attestation was generated from (based on which document)
collector (property) - the GUAC collector that collected the document that generated this attestation
"""
type IsVulnerability {
  osv: OSV!
  vulnerability: CveGhsaObject!
  justification: String!
  origin: String!
  collector: String!
}

"""
IsVulnerabilitySpec allows filtering the list of IsVulnerability to return.
Only CVE or GHSA can be specified at once.
"""
input IsVulnerabilitySpec {
  osv: OSVSpec
  cve: CVESpec
  ghsa: GHSASpec
  justification: String
  origin: String
  collector: String
}

"""
CveGhsaObject is a union of CVE and GHSA.
"""
union CveGhsaObject = CVE | GHSA

extend type Query {
  "Returns all IsVulnerability"
  IsVulnerability(isVulnerabilitySpec: IsVulnerabilitySpec): [IsVulnerability!]!
}`, BuiltIn: false},
	{Name: "../schema/osv.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the OSV trie/tree. It contains the OSV ID
# associated with the vulnerability.

"""
OSV represents an Open Source Vulnerability.

We create a separate node to allow retrieving all OSVs.
"""
type OSV {
  osvId: [OSVId!]!
}

"""
OSVId is the actual ID that is given to a specific vulnerability.

The ` + "`" + `id` + "`" + ` field is mandatory and canonicalized to be lowercase.

This maps to a vulnerability ID specific to the environment (e.g., GHSA ID or
CVE ID).

This node can be referred to by other parts of GUAC.
"""
type OSVId {
  id: String!
}

"""
OSVSpec allows filtering the list of OSV to return.
"""
input OSVSpec {
  osvId: String
}

"""
OSVInputSpec is the same as OSVSpec, but used for mutation ingestion.
"""
input OSVInputSpec {
  osvId: String!
}

extend type Query {
  "Returns all OSV"
  osv(osvSpec: OSVSpec): [OSV!]!
}

extend type Mutation {
  "Ingest a new OSV. Returns the ingested object"
  ingestOSV(osv: OSVInputSpec): OSV!
}
`, BuiltIn: false},
	{Name: "../schema/package.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the package trie/tree. This tree closely matches
# the pURL specification (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst)
# but deviates from it where GUAC rules state otherwise. In principle, we want
# this to represent a trie for packages, so information that represents a
# smaller collection of packages is being pushed downwards in the trie.

"""
Package represents a package.

In the pURL representation, each Package matches a ` + "`" + `pkg:<type>` + "`" + ` partial pURL.
The ` + "`" + `type` + "`" + ` field matches the pURL types but we might also use ` + "`" + `"guac"` + "`" + ` for the
cases where the pURL representation is not complete or when we have custom
rules.

This node is a singleton: backends guarantee that there is exactly one node
with the same ` + "`" + `type` + "`" + ` value.

Also note that this is named ` + "`" + `Package` + "`" + `, not ` + "`" + `PackageType` + "`" + `. This is only to make
queries more readable.
"""
type Package {
  type: String!
  namespaces: [PackageNamespace!]!
}

"""
PackageNamespace is a namespace for packages.

In the pURL representation, each PackageNamespace matches the
` + "`" + `pkg:<type>/<namespace>/` + "`" + ` partial pURL.

Namespaces are optional and type specific. Because they are optional, we use
empty string to denote missing namespaces.
"""
type PackageNamespace {
  namespace: String!
  names: [PackageName!]!
}

"""
PackageName is a name for packages.

In the pURL representation, each PackageName matches the
` + "`" + `pkg:<type>/<namespace>/<name>` + "`" + ` pURL.

Names are always mandatory.

This is the first node in the trie that can be referred to by other parts of
GUAC.
"""
type PackageName {
  name: String!
  versions: [PackageVersion!]!
}

"""
PackageVersion is a package version.

In the pURL representation, each PackageName matches the
` + "`" + `pkg:<type>/<namespace>/<name>@<version>` + "`" + ` pURL.

Versions are optional and each Package type defines own rules for handling them.
For this level of GUAC, these are just opaque strings.

This node can be referred to by other parts of GUAC.

Subpath and qualifiers are optional. Lack of qualifiers is represented by an
empty list and lack of subpath by empty string (to be consistent with
optionality of namespace and version). Two nodes that have different qualifiers
and/or subpath but the same version mean two different packages in the trie
(they are different). Two nodes that have same version but qualifiers of one are
a subset of the qualifier of the other also mean two different packages in the
trie.
"""
type PackageVersion {
  version: String!
  qualifiers: [PackageQualifier!]!
  subpath: String!
}

"""
PackageQualifier is a qualifier for a package, a key-value pair.

In the pURL representation, it is a part of the ` + "`" + `<qualifiers>` + "`" + ` part of the
` + "`" + `pkg:<type>/<namespace>/<name>@<version>?<qualifiers>` + "`" + ` pURL.

Qualifiers are optional, each Package type defines own rules for handling them,
and multiple qualifiers could be attached to the same package.

This node cannot be directly referred by other parts of GUAC.
"""
type PackageQualifier {
  key: String!
  value: String!
}

"""
PkgSpec allows filtering the list of packages to return.

Each field matches a qualifier from pURL. Use ` + "`" + `null` + "`" + ` to match on all values at
that level. For example, to get all packages in GUAC backend, use a PkgSpec
where every field is ` + "`" + `null` + "`" + `.

Empty string at a field means matching with the empty string. If passing in
qualifiers, all of the values in the list must match. Since we want to return
nodes with any number of qualifiers if no qualifiers are passed in the input, we
must also return the same set of nodes it the qualifiers list is empty. To match
on nodes that don't contain any qualifier, set ` + "`" + `matchOnlyEmptyQualifiers` + "`" + ` to
true. If this field is true, then the qualifiers argument is ignored.
"""
input PkgSpec {
  type: String
  namespace: String
  name: String
  version: String
  qualifiers: [PackageQualifierSpec!] = []
  matchOnlyEmptyQualifiers: Boolean = false
  subpath: String
}

"""
PackageQualifierSpec is the same as PackageQualifier, but usable as query
input.

GraphQL does not allow input types to contain composite types and does not allow
composite types to contain input types. So, although in this case these two
types are semantically the same, we have to duplicate the definition.

Keys are mandatory, but values could also be ` + "`" + `null` + "`" + ` if we want to match all
values for a specific key.

TODO(mihaimaruseac): Formalize empty vs null when the schema is fully done
"""
input PackageQualifierSpec {
  key: String!
  value: String
}

"""
PkgInputSpec specifies a package for a mutation.

This is different than PkgSpec because we want to encode mandatory fields:
` + "`" + `type` + "`" + ` and ` + "`" + `name` + "`" + `. All optional fields are given empty default values.
"""
input PkgInputSpec {
  type: String!
  namespace: String = ""
  name: String!
  version: String = ""
  qualifiers: [PackageQualifierInputSpec!] = []
  subpath: String = ""
}

"""
PackageQualifierInputSpec is the same as PackageQualifier, but usable as
mutation input.

GraphQL does not allow input types to contain composite types and does not allow
composite types to contain input types. So, although in this case these two
types are semantically the same, we have to duplicate the definition.

Both fields are mandatory.
"""
input PackageQualifierInputSpec {
  key: String!
  value: String!
}

extend type Query {
  "Returns all packages"
  packages(pkgSpec: PkgSpec): [Package!]!
}

extend type Mutation {
  "Ingest a new package. Returns the ingested package trie"
  ingestPackage(pkg: PkgInputSpec): Package!
}
`, BuiltIn: false},
	{Name: "../schema/source.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the source trie/tree. This tree is a derivative
# of the pURL specification where it has a type, namespace, name and finally a
# qualifier that contain the tag or commit.

"""
Source represents a source.

This can be the version control system that is being used.

This node is a singleton: backends guarantee that there is exactly one node
with the same ` + "`" + `type` + "`" + ` value.

Also note that this is named ` + "`" + `Source` + "`" + `, not ` + "`" + `SourceType` + "`" + `. This is only to make
queries more readable.
"""
type Source {
  type: String!
  namespaces: [SourceNamespace!]!
}

"""
SourceNamespace is a namespace for sources.

This is the location of the repository (such as github/gitlab/bitbucket).

The ` + "`" + `namespace` + "`" + ` field is mandatory.
"""
type SourceNamespace {
  namespace: String!
  names: [SourceName!]!
}

"""
SourceName is a url of the repository and its tag or commit.

The ` + "`" + `name` + "`" + ` field is mandatory. The ` + "`" + `tag` + "`" + ` and ` + "`" + `commit` + "`" + ` fields are optional, but
it is an error to specify both.

This is the only source trie node that can be referenced by other parts of
GUAC.
"""
type SourceName {
  name: String!
  tag: String
  commit: String
}

"""
SourceSpec allows filtering the list of sources to return.

Empty string at a field means matching with the empty string. Missing field
means retrieving all possible matches.

It is an error to specify both ` + "`" + `tag` + "`" + ` and ` + "`" + `commit` + "`" + ` fields, except it both are
set as empty string (in which case the returned sources are only those for
which there is no tag/commit information).
"""
input SourceSpec {
  type: String
  namespace: String
  name: String
  tag: String
  commit: String
}

"""
SourceInputSpec specifies a source for a mutation.

This is different than SourceSpec because we want to encode that all fields
except tag and commit are mandatory fields. All optional fields are given
empty default values.

It is an error to set both ` + "`" + `tag` + "`" + ` and ` + "`" + `commit` + "`" + ` fields to values different than
the default.
"""
input SourceInputSpec {
  type: String!
  namespace: String!
  name: String!
  tag: String = ""
  commit: String = ""
}

extend type Query {
  "Returns all sources"
  sources(sourceSpec: SourceSpec): [Source!]!
}

extend type Mutation {
  "Ingest a new source. Returns the ingested source trie"
  ingestSource(source: SourceInputSpec): Source!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
