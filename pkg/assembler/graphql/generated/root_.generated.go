// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Artifact struct {
		Algorithm func(childComplexity int) int
		Digest    func(childComplexity int) int
		ID        func(childComplexity int) int
	}

	Builder struct {
		ID  func(childComplexity int) int
		URI func(childComplexity int) int
	}

	CertifyBad struct {
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Subject       func(childComplexity int) int
	}

	CertifyGood struct {
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Subject       func(childComplexity int) int
	}

	CertifyScorecard struct {
		ID        func(childComplexity int) int
		Scorecard func(childComplexity int) int
		Source    func(childComplexity int) int
	}

	CertifyVEXStatement struct {
		Collector        func(childComplexity int) int
		ID               func(childComplexity int) int
		KnownSince       func(childComplexity int) int
		Origin           func(childComplexity int) int
		Statement        func(childComplexity int) int
		Status           func(childComplexity int) int
		StatusNotes      func(childComplexity int) int
		Subject          func(childComplexity int) int
		VexJustification func(childComplexity int) int
		Vulnerability    func(childComplexity int) int
	}

	CertifyVuln struct {
		ID            func(childComplexity int) int
		Metadata      func(childComplexity int) int
		Package       func(childComplexity int) int
		Vulnerability func(childComplexity int) int
	}

	HasMetadata struct {
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		Key           func(childComplexity int) int
		Origin        func(childComplexity int) int
		Subject       func(childComplexity int) int
		Timestamp     func(childComplexity int) int
		Value         func(childComplexity int) int
	}

	HasSBOM struct {
		Algorithm        func(childComplexity int) int
		Collector        func(childComplexity int) int
		Digest           func(childComplexity int) int
		DownloadLocation func(childComplexity int) int
		ID               func(childComplexity int) int
		Origin           func(childComplexity int) int
		Subject          func(childComplexity int) int
		URI              func(childComplexity int) int
	}

	HasSLSA struct {
		ID      func(childComplexity int) int
		Slsa    func(childComplexity int) int
		Subject func(childComplexity int) int
	}

	HasSourceAt struct {
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		KnownSince    func(childComplexity int) int
		Origin        func(childComplexity int) int
		Package       func(childComplexity int) int
		Source        func(childComplexity int) int
	}

	HashEqual struct {
		Artifacts     func(childComplexity int) int
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
	}

	IsDependency struct {
		Collector        func(childComplexity int) int
		DependencyType   func(childComplexity int) int
		DependentPackage func(childComplexity int) int
		ID               func(childComplexity int) int
		Justification    func(childComplexity int) int
		Origin           func(childComplexity int) int
		Package          func(childComplexity int) int
		VersionRange     func(childComplexity int) int
	}

	IsOccurrence struct {
		Artifact      func(childComplexity int) int
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Subject       func(childComplexity int) int
	}

	Mutation struct {
		IngestArtifact        func(childComplexity int, artifact *model.ArtifactInputSpec) int
		IngestArtifacts       func(childComplexity int, artifacts []*model.ArtifactInputSpec) int
		IngestBuilder         func(childComplexity int, builder *model.BuilderInputSpec) int
		IngestBuilders        func(childComplexity int, builders []*model.BuilderInputSpec) int
		IngestCertifyBad      func(childComplexity int, subject model.PackageSourceOrArtifactInput, pkgMatchType model.MatchFlags, certifyBad model.CertifyBadInputSpec) int
		IngestCertifyBads     func(childComplexity int, subjects model.PackageSourceOrArtifactInputs, pkgMatchType model.MatchFlags, certifyBads []*model.CertifyBadInputSpec) int
		IngestCertifyGood     func(childComplexity int, subject model.PackageSourceOrArtifactInput, pkgMatchType model.MatchFlags, certifyGood model.CertifyGoodInputSpec) int
		IngestCertifyGoods    func(childComplexity int, subjects model.PackageSourceOrArtifactInputs, pkgMatchType model.MatchFlags, certifyGoods []*model.CertifyGoodInputSpec) int
		IngestCertifyVuln     func(childComplexity int, pkg model.PkgInputSpec, vulnerability model.VulnerabilityInputSpec, certifyVuln model.ScanMetadataInput) int
		IngestDependencies    func(childComplexity int, pkgs []*model.PkgInputSpec, depPkgs []*model.PkgInputSpec, dependencies []*model.IsDependencyInputSpec) int
		IngestDependency      func(childComplexity int, pkg model.PkgInputSpec, depPkg model.PkgInputSpec, dependency model.IsDependencyInputSpec) int
		IngestHasMetadata     func(childComplexity int, subject model.PackageSourceOrArtifactInput, pkgMatchType model.MatchFlags, hasMetadata model.HasMetadataInputSpec) int
		IngestHasSBOMs        func(childComplexity int, subjects model.PackageOrArtifactInputs, hasSBOMs []*model.HasSBOMInputSpec) int
		IngestHasSbom         func(childComplexity int, subject model.PackageOrArtifactInput, hasSbom model.HasSBOMInputSpec) int
		IngestHasSourceAt     func(childComplexity int, pkg model.PkgInputSpec, pkgMatchType model.MatchFlags, source model.SourceInputSpec, hasSourceAt model.HasSourceAtInputSpec) int
		IngestHashEqual       func(childComplexity int, artifact model.ArtifactInputSpec, otherArtifact model.ArtifactInputSpec, hashEqual model.HashEqualInputSpec) int
		IngestHashEquals      func(childComplexity int, artifacts []*model.ArtifactInputSpec, otherArtifacts []*model.ArtifactInputSpec, hashEquals []*model.HashEqualInputSpec) int
		IngestOccurrence      func(childComplexity int, subject model.PackageOrSourceInput, artifact model.ArtifactInputSpec, occurrence model.IsOccurrenceInputSpec) int
		IngestOccurrences     func(childComplexity int, subjects model.PackageOrSourceInputs, artifacts []*model.ArtifactInputSpec, occurrences []*model.IsOccurrenceInputSpec) int
		IngestPackage         func(childComplexity int, pkg model.PkgInputSpec) int
		IngestPackages        func(childComplexity int, pkgs []*model.PkgInputSpec) int
		IngestPkgEqual        func(childComplexity int, pkg model.PkgInputSpec, otherPackage model.PkgInputSpec, pkgEqual model.PkgEqualInputSpec) int
		IngestPointOfContact  func(childComplexity int, subject model.PackageSourceOrArtifactInput, pkgMatchType model.MatchFlags, pointOfContact model.PointOfContactInputSpec) int
		IngestSLSAs           func(childComplexity int, subjects []*model.ArtifactInputSpec, builtFromList [][]*model.ArtifactInputSpec, builtByList []*model.BuilderInputSpec, slsaList []*model.SLSAInputSpec) int
		IngestScorecard       func(childComplexity int, source model.SourceInputSpec, scorecard model.ScorecardInputSpec) int
		IngestScorecards      func(childComplexity int, sources []*model.SourceInputSpec, scorecards []*model.ScorecardInputSpec) int
		IngestSlsa            func(childComplexity int, subject model.ArtifactInputSpec, builtFrom []*model.ArtifactInputSpec, builtBy model.BuilderInputSpec, slsa model.SLSAInputSpec) int
		IngestSource          func(childComplexity int, source model.SourceInputSpec) int
		IngestSources         func(childComplexity int, sources []*model.SourceInputSpec) int
		IngestVEXStatement    func(childComplexity int, subject model.PackageOrArtifactInput, vulnerability model.VulnerabilityInputSpec, vexStatement model.VexStatementInputSpec) int
		IngestVulnEqual       func(childComplexity int, vulnerability model.VulnerabilityInputSpec, otherVulnerability model.VulnerabilityInputSpec, vulnEqual model.VulnEqualInputSpec) int
		IngestVulnerabilities func(childComplexity int, vulns []*model.VulnerabilityInputSpec) int
		IngestVulnerability   func(childComplexity int, vuln model.VulnerabilityInputSpec) int
	}

	Package struct {
		ID         func(childComplexity int) int
		Namespaces func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	PackageName struct {
		ID       func(childComplexity int) int
		Name     func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	PackageNamespace struct {
		ID        func(childComplexity int) int
		Names     func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	PackageQualifier struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	PackageVersion struct {
		ID         func(childComplexity int) int
		Qualifiers func(childComplexity int) int
		Subpath    func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	PkgEqual struct {
		Collector     func(childComplexity int) int
		ID            func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Packages      func(childComplexity int) int
	}

	PointOfContact struct {
		Collector     func(childComplexity int) int
		Email         func(childComplexity int) int
		ID            func(childComplexity int) int
		Info          func(childComplexity int) int
		Justification func(childComplexity int) int
		Origin        func(childComplexity int) int
		Since         func(childComplexity int) int
		Subject       func(childComplexity int) int
	}

	Query struct {
		Artifacts           func(childComplexity int, artifactSpec model.ArtifactSpec) int
		Builders            func(childComplexity int, builderSpec model.BuilderSpec) int
		CertifyBad          func(childComplexity int, certifyBadSpec model.CertifyBadSpec) int
		CertifyGood         func(childComplexity int, certifyGoodSpec model.CertifyGoodSpec) int
		CertifyVEXStatement func(childComplexity int, certifyVEXStatementSpec model.CertifyVEXStatementSpec) int
		CertifyVuln         func(childComplexity int, certifyVulnSpec model.CertifyVulnSpec) int
		FindSoftware        func(childComplexity int, searchText string) int
		HasMetadata         func(childComplexity int, hasMetadataSpec model.HasMetadataSpec) int
		HasSbom             func(childComplexity int, hasSBOMSpec model.HasSBOMSpec) int
		HasSlsa             func(childComplexity int, hasSLSASpec model.HasSLSASpec) int
		HasSourceAt         func(childComplexity int, hasSourceAtSpec model.HasSourceAtSpec) int
		HashEqual           func(childComplexity int, hashEqualSpec model.HashEqualSpec) int
		IsDependency        func(childComplexity int, isDependencySpec model.IsDependencySpec) int
		IsOccurrence        func(childComplexity int, isOccurrenceSpec model.IsOccurrenceSpec) int
		Neighbors           func(childComplexity int, node string, usingOnly []model.Edge) int
		Node                func(childComplexity int, node string) int
		Nodes               func(childComplexity int, nodes []string) int
		Packages            func(childComplexity int, pkgSpec model.PkgSpec) int
		Path                func(childComplexity int, subject string, target string, maxPathLength int, usingOnly []model.Edge) int
		PkgEqual            func(childComplexity int, pkgEqualSpec model.PkgEqualSpec) int
		PointOfContact      func(childComplexity int, pointOfContactSpec model.PointOfContactSpec) int
		Scorecards          func(childComplexity int, scorecardSpec model.CertifyScorecardSpec) int
		Sources             func(childComplexity int, sourceSpec model.SourceSpec) int
		VulnEqual           func(childComplexity int, vulnEqualSpec model.VulnEqualSpec) int
		Vulnerabilities     func(childComplexity int, vulnSpec model.VulnerabilitySpec) int
	}

	SLSA struct {
		BuildType     func(childComplexity int) int
		BuiltBy       func(childComplexity int) int
		BuiltFrom     func(childComplexity int) int
		Collector     func(childComplexity int) int
		FinishedOn    func(childComplexity int) int
		Origin        func(childComplexity int) int
		SlsaPredicate func(childComplexity int) int
		SlsaVersion   func(childComplexity int) int
		StartedOn     func(childComplexity int) int
	}

	SLSAPredicate struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ScanMetadata struct {
		Collector      func(childComplexity int) int
		DbURI          func(childComplexity int) int
		DbVersion      func(childComplexity int) int
		Origin         func(childComplexity int) int
		ScannerURI     func(childComplexity int) int
		ScannerVersion func(childComplexity int) int
		TimeScanned    func(childComplexity int) int
	}

	Scorecard struct {
		AggregateScore   func(childComplexity int) int
		Checks           func(childComplexity int) int
		Collector        func(childComplexity int) int
		Origin           func(childComplexity int) int
		ScorecardCommit  func(childComplexity int) int
		ScorecardVersion func(childComplexity int) int
		TimeScanned      func(childComplexity int) int
	}

	ScorecardCheck struct {
		Check func(childComplexity int) int
		Score func(childComplexity int) int
	}

	Source struct {
		ID         func(childComplexity int) int
		Namespaces func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	SourceName struct {
		Commit func(childComplexity int) int
		ID     func(childComplexity int) int
		Name   func(childComplexity int) int
		Tag    func(childComplexity int) int
	}

	SourceNamespace struct {
		ID        func(childComplexity int) int
		Names     func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	VulnEqual struct {
		Collector       func(childComplexity int) int
		ID              func(childComplexity int) int
		Justification   func(childComplexity int) int
		Origin          func(childComplexity int) int
		Vulnerabilities func(childComplexity int) int
	}

	Vulnerability struct {
		ID               func(childComplexity int) int
		Type             func(childComplexity int) int
		VulnerabilityIDs func(childComplexity int) int
	}

	VulnerabilityID struct {
		ID              func(childComplexity int) int
		VulnerabilityID func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Artifact.algorithm":
		if e.complexity.Artifact.Algorithm == nil {
			break
		}

		return e.complexity.Artifact.Algorithm(childComplexity), true

	case "Artifact.digest":
		if e.complexity.Artifact.Digest == nil {
			break
		}

		return e.complexity.Artifact.Digest(childComplexity), true

	case "Artifact.id":
		if e.complexity.Artifact.ID == nil {
			break
		}

		return e.complexity.Artifact.ID(childComplexity), true

	case "Builder.id":
		if e.complexity.Builder.ID == nil {
			break
		}

		return e.complexity.Builder.ID(childComplexity), true

	case "Builder.uri":
		if e.complexity.Builder.URI == nil {
			break
		}

		return e.complexity.Builder.URI(childComplexity), true

	case "CertifyBad.collector":
		if e.complexity.CertifyBad.Collector == nil {
			break
		}

		return e.complexity.CertifyBad.Collector(childComplexity), true

	case "CertifyBad.id":
		if e.complexity.CertifyBad.ID == nil {
			break
		}

		return e.complexity.CertifyBad.ID(childComplexity), true

	case "CertifyBad.justification":
		if e.complexity.CertifyBad.Justification == nil {
			break
		}

		return e.complexity.CertifyBad.Justification(childComplexity), true

	case "CertifyBad.origin":
		if e.complexity.CertifyBad.Origin == nil {
			break
		}

		return e.complexity.CertifyBad.Origin(childComplexity), true

	case "CertifyBad.subject":
		if e.complexity.CertifyBad.Subject == nil {
			break
		}

		return e.complexity.CertifyBad.Subject(childComplexity), true

	case "CertifyGood.collector":
		if e.complexity.CertifyGood.Collector == nil {
			break
		}

		return e.complexity.CertifyGood.Collector(childComplexity), true

	case "CertifyGood.id":
		if e.complexity.CertifyGood.ID == nil {
			break
		}

		return e.complexity.CertifyGood.ID(childComplexity), true

	case "CertifyGood.justification":
		if e.complexity.CertifyGood.Justification == nil {
			break
		}

		return e.complexity.CertifyGood.Justification(childComplexity), true

	case "CertifyGood.origin":
		if e.complexity.CertifyGood.Origin == nil {
			break
		}

		return e.complexity.CertifyGood.Origin(childComplexity), true

	case "CertifyGood.subject":
		if e.complexity.CertifyGood.Subject == nil {
			break
		}

		return e.complexity.CertifyGood.Subject(childComplexity), true

	case "CertifyScorecard.id":
		if e.complexity.CertifyScorecard.ID == nil {
			break
		}

		return e.complexity.CertifyScorecard.ID(childComplexity), true

	case "CertifyScorecard.scorecard":
		if e.complexity.CertifyScorecard.Scorecard == nil {
			break
		}

		return e.complexity.CertifyScorecard.Scorecard(childComplexity), true

	case "CertifyScorecard.source":
		if e.complexity.CertifyScorecard.Source == nil {
			break
		}

		return e.complexity.CertifyScorecard.Source(childComplexity), true

	case "CertifyVEXStatement.collector":
		if e.complexity.CertifyVEXStatement.Collector == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Collector(childComplexity), true

	case "CertifyVEXStatement.id":
		if e.complexity.CertifyVEXStatement.ID == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.ID(childComplexity), true

	case "CertifyVEXStatement.knownSince":
		if e.complexity.CertifyVEXStatement.KnownSince == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.KnownSince(childComplexity), true

	case "CertifyVEXStatement.origin":
		if e.complexity.CertifyVEXStatement.Origin == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Origin(childComplexity), true

	case "CertifyVEXStatement.statement":
		if e.complexity.CertifyVEXStatement.Statement == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Statement(childComplexity), true

	case "CertifyVEXStatement.status":
		if e.complexity.CertifyVEXStatement.Status == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Status(childComplexity), true

	case "CertifyVEXStatement.statusNotes":
		if e.complexity.CertifyVEXStatement.StatusNotes == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.StatusNotes(childComplexity), true

	case "CertifyVEXStatement.subject":
		if e.complexity.CertifyVEXStatement.Subject == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Subject(childComplexity), true

	case "CertifyVEXStatement.vexJustification":
		if e.complexity.CertifyVEXStatement.VexJustification == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.VexJustification(childComplexity), true

	case "CertifyVEXStatement.vulnerability":
		if e.complexity.CertifyVEXStatement.Vulnerability == nil {
			break
		}

		return e.complexity.CertifyVEXStatement.Vulnerability(childComplexity), true

	case "CertifyVuln.id":
		if e.complexity.CertifyVuln.ID == nil {
			break
		}

		return e.complexity.CertifyVuln.ID(childComplexity), true

	case "CertifyVuln.metadata":
		if e.complexity.CertifyVuln.Metadata == nil {
			break
		}

		return e.complexity.CertifyVuln.Metadata(childComplexity), true

	case "CertifyVuln.package":
		if e.complexity.CertifyVuln.Package == nil {
			break
		}

		return e.complexity.CertifyVuln.Package(childComplexity), true

	case "CertifyVuln.vulnerability":
		if e.complexity.CertifyVuln.Vulnerability == nil {
			break
		}

		return e.complexity.CertifyVuln.Vulnerability(childComplexity), true

	case "HasMetadata.collector":
		if e.complexity.HasMetadata.Collector == nil {
			break
		}

		return e.complexity.HasMetadata.Collector(childComplexity), true

	case "HasMetadata.id":
		if e.complexity.HasMetadata.ID == nil {
			break
		}

		return e.complexity.HasMetadata.ID(childComplexity), true

	case "HasMetadata.justification":
		if e.complexity.HasMetadata.Justification == nil {
			break
		}

		return e.complexity.HasMetadata.Justification(childComplexity), true

	case "HasMetadata.key":
		if e.complexity.HasMetadata.Key == nil {
			break
		}

		return e.complexity.HasMetadata.Key(childComplexity), true

	case "HasMetadata.origin":
		if e.complexity.HasMetadata.Origin == nil {
			break
		}

		return e.complexity.HasMetadata.Origin(childComplexity), true

	case "HasMetadata.subject":
		if e.complexity.HasMetadata.Subject == nil {
			break
		}

		return e.complexity.HasMetadata.Subject(childComplexity), true

	case "HasMetadata.timestamp":
		if e.complexity.HasMetadata.Timestamp == nil {
			break
		}

		return e.complexity.HasMetadata.Timestamp(childComplexity), true

	case "HasMetadata.value":
		if e.complexity.HasMetadata.Value == nil {
			break
		}

		return e.complexity.HasMetadata.Value(childComplexity), true

	case "HasSBOM.algorithm":
		if e.complexity.HasSBOM.Algorithm == nil {
			break
		}

		return e.complexity.HasSBOM.Algorithm(childComplexity), true

	case "HasSBOM.collector":
		if e.complexity.HasSBOM.Collector == nil {
			break
		}

		return e.complexity.HasSBOM.Collector(childComplexity), true

	case "HasSBOM.digest":
		if e.complexity.HasSBOM.Digest == nil {
			break
		}

		return e.complexity.HasSBOM.Digest(childComplexity), true

	case "HasSBOM.downloadLocation":
		if e.complexity.HasSBOM.DownloadLocation == nil {
			break
		}

		return e.complexity.HasSBOM.DownloadLocation(childComplexity), true

	case "HasSBOM.id":
		if e.complexity.HasSBOM.ID == nil {
			break
		}

		return e.complexity.HasSBOM.ID(childComplexity), true

	case "HasSBOM.origin":
		if e.complexity.HasSBOM.Origin == nil {
			break
		}

		return e.complexity.HasSBOM.Origin(childComplexity), true

	case "HasSBOM.subject":
		if e.complexity.HasSBOM.Subject == nil {
			break
		}

		return e.complexity.HasSBOM.Subject(childComplexity), true

	case "HasSBOM.uri":
		if e.complexity.HasSBOM.URI == nil {
			break
		}

		return e.complexity.HasSBOM.URI(childComplexity), true

	case "HasSLSA.id":
		if e.complexity.HasSLSA.ID == nil {
			break
		}

		return e.complexity.HasSLSA.ID(childComplexity), true

	case "HasSLSA.slsa":
		if e.complexity.HasSLSA.Slsa == nil {
			break
		}

		return e.complexity.HasSLSA.Slsa(childComplexity), true

	case "HasSLSA.subject":
		if e.complexity.HasSLSA.Subject == nil {
			break
		}

		return e.complexity.HasSLSA.Subject(childComplexity), true

	case "HasSourceAt.collector":
		if e.complexity.HasSourceAt.Collector == nil {
			break
		}

		return e.complexity.HasSourceAt.Collector(childComplexity), true

	case "HasSourceAt.id":
		if e.complexity.HasSourceAt.ID == nil {
			break
		}

		return e.complexity.HasSourceAt.ID(childComplexity), true

	case "HasSourceAt.justification":
		if e.complexity.HasSourceAt.Justification == nil {
			break
		}

		return e.complexity.HasSourceAt.Justification(childComplexity), true

	case "HasSourceAt.knownSince":
		if e.complexity.HasSourceAt.KnownSince == nil {
			break
		}

		return e.complexity.HasSourceAt.KnownSince(childComplexity), true

	case "HasSourceAt.origin":
		if e.complexity.HasSourceAt.Origin == nil {
			break
		}

		return e.complexity.HasSourceAt.Origin(childComplexity), true

	case "HasSourceAt.package":
		if e.complexity.HasSourceAt.Package == nil {
			break
		}

		return e.complexity.HasSourceAt.Package(childComplexity), true

	case "HasSourceAt.source":
		if e.complexity.HasSourceAt.Source == nil {
			break
		}

		return e.complexity.HasSourceAt.Source(childComplexity), true

	case "HashEqual.artifacts":
		if e.complexity.HashEqual.Artifacts == nil {
			break
		}

		return e.complexity.HashEqual.Artifacts(childComplexity), true

	case "HashEqual.collector":
		if e.complexity.HashEqual.Collector == nil {
			break
		}

		return e.complexity.HashEqual.Collector(childComplexity), true

	case "HashEqual.id":
		if e.complexity.HashEqual.ID == nil {
			break
		}

		return e.complexity.HashEqual.ID(childComplexity), true

	case "HashEqual.justification":
		if e.complexity.HashEqual.Justification == nil {
			break
		}

		return e.complexity.HashEqual.Justification(childComplexity), true

	case "HashEqual.origin":
		if e.complexity.HashEqual.Origin == nil {
			break
		}

		return e.complexity.HashEqual.Origin(childComplexity), true

	case "IsDependency.collector":
		if e.complexity.IsDependency.Collector == nil {
			break
		}

		return e.complexity.IsDependency.Collector(childComplexity), true

	case "IsDependency.dependencyType":
		if e.complexity.IsDependency.DependencyType == nil {
			break
		}

		return e.complexity.IsDependency.DependencyType(childComplexity), true

	case "IsDependency.dependentPackage":
		if e.complexity.IsDependency.DependentPackage == nil {
			break
		}

		return e.complexity.IsDependency.DependentPackage(childComplexity), true

	case "IsDependency.id":
		if e.complexity.IsDependency.ID == nil {
			break
		}

		return e.complexity.IsDependency.ID(childComplexity), true

	case "IsDependency.justification":
		if e.complexity.IsDependency.Justification == nil {
			break
		}

		return e.complexity.IsDependency.Justification(childComplexity), true

	case "IsDependency.origin":
		if e.complexity.IsDependency.Origin == nil {
			break
		}

		return e.complexity.IsDependency.Origin(childComplexity), true

	case "IsDependency.package":
		if e.complexity.IsDependency.Package == nil {
			break
		}

		return e.complexity.IsDependency.Package(childComplexity), true

	case "IsDependency.versionRange":
		if e.complexity.IsDependency.VersionRange == nil {
			break
		}

		return e.complexity.IsDependency.VersionRange(childComplexity), true

	case "IsOccurrence.artifact":
		if e.complexity.IsOccurrence.Artifact == nil {
			break
		}

		return e.complexity.IsOccurrence.Artifact(childComplexity), true

	case "IsOccurrence.collector":
		if e.complexity.IsOccurrence.Collector == nil {
			break
		}

		return e.complexity.IsOccurrence.Collector(childComplexity), true

	case "IsOccurrence.id":
		if e.complexity.IsOccurrence.ID == nil {
			break
		}

		return e.complexity.IsOccurrence.ID(childComplexity), true

	case "IsOccurrence.justification":
		if e.complexity.IsOccurrence.Justification == nil {
			break
		}

		return e.complexity.IsOccurrence.Justification(childComplexity), true

	case "IsOccurrence.origin":
		if e.complexity.IsOccurrence.Origin == nil {
			break
		}

		return e.complexity.IsOccurrence.Origin(childComplexity), true

	case "IsOccurrence.subject":
		if e.complexity.IsOccurrence.Subject == nil {
			break
		}

		return e.complexity.IsOccurrence.Subject(childComplexity), true

	case "Mutation.ingestArtifact":
		if e.complexity.Mutation.IngestArtifact == nil {
			break
		}

		args, err := ec.field_Mutation_ingestArtifact_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestArtifact(childComplexity, args["artifact"].(*model.ArtifactInputSpec)), true

	case "Mutation.ingestArtifacts":
		if e.complexity.Mutation.IngestArtifacts == nil {
			break
		}

		args, err := ec.field_Mutation_ingestArtifacts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestArtifacts(childComplexity, args["artifacts"].([]*model.ArtifactInputSpec)), true

	case "Mutation.ingestBuilder":
		if e.complexity.Mutation.IngestBuilder == nil {
			break
		}

		args, err := ec.field_Mutation_ingestBuilder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestBuilder(childComplexity, args["builder"].(*model.BuilderInputSpec)), true

	case "Mutation.ingestBuilders":
		if e.complexity.Mutation.IngestBuilders == nil {
			break
		}

		args, err := ec.field_Mutation_ingestBuilders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestBuilders(childComplexity, args["builders"].([]*model.BuilderInputSpec)), true

	case "Mutation.ingestCertifyBad":
		if e.complexity.Mutation.IngestCertifyBad == nil {
			break
		}

		args, err := ec.field_Mutation_ingestCertifyBad_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestCertifyBad(childComplexity, args["subject"].(model.PackageSourceOrArtifactInput), args["pkgMatchType"].(model.MatchFlags), args["certifyBad"].(model.CertifyBadInputSpec)), true

	case "Mutation.ingestCertifyBads":
		if e.complexity.Mutation.IngestCertifyBads == nil {
			break
		}

		args, err := ec.field_Mutation_ingestCertifyBads_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestCertifyBads(childComplexity, args["subjects"].(model.PackageSourceOrArtifactInputs), args["pkgMatchType"].(model.MatchFlags), args["certifyBads"].([]*model.CertifyBadInputSpec)), true

	case "Mutation.ingestCertifyGood":
		if e.complexity.Mutation.IngestCertifyGood == nil {
			break
		}

		args, err := ec.field_Mutation_ingestCertifyGood_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestCertifyGood(childComplexity, args["subject"].(model.PackageSourceOrArtifactInput), args["pkgMatchType"].(model.MatchFlags), args["certifyGood"].(model.CertifyGoodInputSpec)), true

	case "Mutation.ingestCertifyGoods":
		if e.complexity.Mutation.IngestCertifyGoods == nil {
			break
		}

		args, err := ec.field_Mutation_ingestCertifyGoods_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestCertifyGoods(childComplexity, args["subjects"].(model.PackageSourceOrArtifactInputs), args["pkgMatchType"].(model.MatchFlags), args["certifyGoods"].([]*model.CertifyGoodInputSpec)), true

	case "Mutation.ingestCertifyVuln":
		if e.complexity.Mutation.IngestCertifyVuln == nil {
			break
		}

		args, err := ec.field_Mutation_ingestCertifyVuln_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestCertifyVuln(childComplexity, args["pkg"].(model.PkgInputSpec), args["vulnerability"].(model.VulnerabilityInputSpec), args["certifyVuln"].(model.ScanMetadataInput)), true

	case "Mutation.ingestDependencies":
		if e.complexity.Mutation.IngestDependencies == nil {
			break
		}

		args, err := ec.field_Mutation_ingestDependencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestDependencies(childComplexity, args["pkgs"].([]*model.PkgInputSpec), args["depPkgs"].([]*model.PkgInputSpec), args["dependencies"].([]*model.IsDependencyInputSpec)), true

	case "Mutation.ingestDependency":
		if e.complexity.Mutation.IngestDependency == nil {
			break
		}

		args, err := ec.field_Mutation_ingestDependency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestDependency(childComplexity, args["pkg"].(model.PkgInputSpec), args["depPkg"].(model.PkgInputSpec), args["dependency"].(model.IsDependencyInputSpec)), true

	case "Mutation.ingestHasMetadata":
		if e.complexity.Mutation.IngestHasMetadata == nil {
			break
		}

		args, err := ec.field_Mutation_ingestHasMetadata_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestHasMetadata(childComplexity, args["subject"].(model.PackageSourceOrArtifactInput), args["pkgMatchType"].(model.MatchFlags), args["hasMetadata"].(model.HasMetadataInputSpec)), true

	case "Mutation.ingestHasSBOMs":
		if e.complexity.Mutation.IngestHasSBOMs == nil {
			break
		}

		args, err := ec.field_Mutation_ingestHasSBOMs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestHasSBOMs(childComplexity, args["subjects"].(model.PackageOrArtifactInputs), args["hasSBOMs"].([]*model.HasSBOMInputSpec)), true

	case "Mutation.ingestHasSBOM":
		if e.complexity.Mutation.IngestHasSbom == nil {
			break
		}

		args, err := ec.field_Mutation_ingestHasSBOM_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestHasSbom(childComplexity, args["subject"].(model.PackageOrArtifactInput), args["hasSBOM"].(model.HasSBOMInputSpec)), true

	case "Mutation.ingestHasSourceAt":
		if e.complexity.Mutation.IngestHasSourceAt == nil {
			break
		}

		args, err := ec.field_Mutation_ingestHasSourceAt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestHasSourceAt(childComplexity, args["pkg"].(model.PkgInputSpec), args["pkgMatchType"].(model.MatchFlags), args["source"].(model.SourceInputSpec), args["hasSourceAt"].(model.HasSourceAtInputSpec)), true

	case "Mutation.ingestHashEqual":
		if e.complexity.Mutation.IngestHashEqual == nil {
			break
		}

		args, err := ec.field_Mutation_ingestHashEqual_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestHashEqual(childComplexity, args["artifact"].(model.ArtifactInputSpec), args["otherArtifact"].(model.ArtifactInputSpec), args["hashEqual"].(model.HashEqualInputSpec)), true

	case "Mutation.ingestHashEquals":
		if e.complexity.Mutation.IngestHashEquals == nil {
			break
		}

		args, err := ec.field_Mutation_ingestHashEquals_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestHashEquals(childComplexity, args["artifacts"].([]*model.ArtifactInputSpec), args["otherArtifacts"].([]*model.ArtifactInputSpec), args["hashEquals"].([]*model.HashEqualInputSpec)), true

	case "Mutation.ingestOccurrence":
		if e.complexity.Mutation.IngestOccurrence == nil {
			break
		}

		args, err := ec.field_Mutation_ingestOccurrence_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestOccurrence(childComplexity, args["subject"].(model.PackageOrSourceInput), args["artifact"].(model.ArtifactInputSpec), args["occurrence"].(model.IsOccurrenceInputSpec)), true

	case "Mutation.ingestOccurrences":
		if e.complexity.Mutation.IngestOccurrences == nil {
			break
		}

		args, err := ec.field_Mutation_ingestOccurrences_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestOccurrences(childComplexity, args["subjects"].(model.PackageOrSourceInputs), args["artifacts"].([]*model.ArtifactInputSpec), args["occurrences"].([]*model.IsOccurrenceInputSpec)), true

	case "Mutation.ingestPackage":
		if e.complexity.Mutation.IngestPackage == nil {
			break
		}

		args, err := ec.field_Mutation_ingestPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestPackage(childComplexity, args["pkg"].(model.PkgInputSpec)), true

	case "Mutation.ingestPackages":
		if e.complexity.Mutation.IngestPackages == nil {
			break
		}

		args, err := ec.field_Mutation_ingestPackages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestPackages(childComplexity, args["pkgs"].([]*model.PkgInputSpec)), true

	case "Mutation.ingestPkgEqual":
		if e.complexity.Mutation.IngestPkgEqual == nil {
			break
		}

		args, err := ec.field_Mutation_ingestPkgEqual_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestPkgEqual(childComplexity, args["pkg"].(model.PkgInputSpec), args["otherPackage"].(model.PkgInputSpec), args["pkgEqual"].(model.PkgEqualInputSpec)), true

	case "Mutation.ingestPointOfContact":
		if e.complexity.Mutation.IngestPointOfContact == nil {
			break
		}

		args, err := ec.field_Mutation_ingestPointOfContact_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestPointOfContact(childComplexity, args["subject"].(model.PackageSourceOrArtifactInput), args["pkgMatchType"].(model.MatchFlags), args["pointOfContact"].(model.PointOfContactInputSpec)), true

	case "Mutation.ingestSLSAs":
		if e.complexity.Mutation.IngestSLSAs == nil {
			break
		}

		args, err := ec.field_Mutation_ingestSLSAs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestSLSAs(childComplexity, args["subjects"].([]*model.ArtifactInputSpec), args["builtFromList"].([][]*model.ArtifactInputSpec), args["builtByList"].([]*model.BuilderInputSpec), args["slsaList"].([]*model.SLSAInputSpec)), true

	case "Mutation.ingestScorecard":
		if e.complexity.Mutation.IngestScorecard == nil {
			break
		}

		args, err := ec.field_Mutation_ingestScorecard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestScorecard(childComplexity, args["source"].(model.SourceInputSpec), args["scorecard"].(model.ScorecardInputSpec)), true

	case "Mutation.ingestScorecards":
		if e.complexity.Mutation.IngestScorecards == nil {
			break
		}

		args, err := ec.field_Mutation_ingestScorecards_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestScorecards(childComplexity, args["sources"].([]*model.SourceInputSpec), args["scorecards"].([]*model.ScorecardInputSpec)), true

	case "Mutation.ingestSLSA":
		if e.complexity.Mutation.IngestSlsa == nil {
			break
		}

		args, err := ec.field_Mutation_ingestSLSA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestSlsa(childComplexity, args["subject"].(model.ArtifactInputSpec), args["builtFrom"].([]*model.ArtifactInputSpec), args["builtBy"].(model.BuilderInputSpec), args["slsa"].(model.SLSAInputSpec)), true

	case "Mutation.ingestSource":
		if e.complexity.Mutation.IngestSource == nil {
			break
		}

		args, err := ec.field_Mutation_ingestSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestSource(childComplexity, args["source"].(model.SourceInputSpec)), true

	case "Mutation.ingestSources":
		if e.complexity.Mutation.IngestSources == nil {
			break
		}

		args, err := ec.field_Mutation_ingestSources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestSources(childComplexity, args["sources"].([]*model.SourceInputSpec)), true

	case "Mutation.ingestVEXStatement":
		if e.complexity.Mutation.IngestVEXStatement == nil {
			break
		}

		args, err := ec.field_Mutation_ingestVEXStatement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestVEXStatement(childComplexity, args["subject"].(model.PackageOrArtifactInput), args["vulnerability"].(model.VulnerabilityInputSpec), args["vexStatement"].(model.VexStatementInputSpec)), true

	case "Mutation.ingestVulnEqual":
		if e.complexity.Mutation.IngestVulnEqual == nil {
			break
		}

		args, err := ec.field_Mutation_ingestVulnEqual_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestVulnEqual(childComplexity, args["vulnerability"].(model.VulnerabilityInputSpec), args["otherVulnerability"].(model.VulnerabilityInputSpec), args["vulnEqual"].(model.VulnEqualInputSpec)), true

	case "Mutation.ingestVulnerabilities":
		if e.complexity.Mutation.IngestVulnerabilities == nil {
			break
		}

		args, err := ec.field_Mutation_ingestVulnerabilities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestVulnerabilities(childComplexity, args["vulns"].([]*model.VulnerabilityInputSpec)), true

	case "Mutation.ingestVulnerability":
		if e.complexity.Mutation.IngestVulnerability == nil {
			break
		}

		args, err := ec.field_Mutation_ingestVulnerability_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.IngestVulnerability(childComplexity, args["vuln"].(model.VulnerabilityInputSpec)), true

	case "Package.id":
		if e.complexity.Package.ID == nil {
			break
		}

		return e.complexity.Package.ID(childComplexity), true

	case "Package.namespaces":
		if e.complexity.Package.Namespaces == nil {
			break
		}

		return e.complexity.Package.Namespaces(childComplexity), true

	case "Package.type":
		if e.complexity.Package.Type == nil {
			break
		}

		return e.complexity.Package.Type(childComplexity), true

	case "PackageName.id":
		if e.complexity.PackageName.ID == nil {
			break
		}

		return e.complexity.PackageName.ID(childComplexity), true

	case "PackageName.name":
		if e.complexity.PackageName.Name == nil {
			break
		}

		return e.complexity.PackageName.Name(childComplexity), true

	case "PackageName.versions":
		if e.complexity.PackageName.Versions == nil {
			break
		}

		return e.complexity.PackageName.Versions(childComplexity), true

	case "PackageNamespace.id":
		if e.complexity.PackageNamespace.ID == nil {
			break
		}

		return e.complexity.PackageNamespace.ID(childComplexity), true

	case "PackageNamespace.names":
		if e.complexity.PackageNamespace.Names == nil {
			break
		}

		return e.complexity.PackageNamespace.Names(childComplexity), true

	case "PackageNamespace.namespace":
		if e.complexity.PackageNamespace.Namespace == nil {
			break
		}

		return e.complexity.PackageNamespace.Namespace(childComplexity), true

	case "PackageQualifier.key":
		if e.complexity.PackageQualifier.Key == nil {
			break
		}

		return e.complexity.PackageQualifier.Key(childComplexity), true

	case "PackageQualifier.value":
		if e.complexity.PackageQualifier.Value == nil {
			break
		}

		return e.complexity.PackageQualifier.Value(childComplexity), true

	case "PackageVersion.id":
		if e.complexity.PackageVersion.ID == nil {
			break
		}

		return e.complexity.PackageVersion.ID(childComplexity), true

	case "PackageVersion.qualifiers":
		if e.complexity.PackageVersion.Qualifiers == nil {
			break
		}

		return e.complexity.PackageVersion.Qualifiers(childComplexity), true

	case "PackageVersion.subpath":
		if e.complexity.PackageVersion.Subpath == nil {
			break
		}

		return e.complexity.PackageVersion.Subpath(childComplexity), true

	case "PackageVersion.version":
		if e.complexity.PackageVersion.Version == nil {
			break
		}

		return e.complexity.PackageVersion.Version(childComplexity), true

	case "PkgEqual.collector":
		if e.complexity.PkgEqual.Collector == nil {
			break
		}

		return e.complexity.PkgEqual.Collector(childComplexity), true

	case "PkgEqual.id":
		if e.complexity.PkgEqual.ID == nil {
			break
		}

		return e.complexity.PkgEqual.ID(childComplexity), true

	case "PkgEqual.justification":
		if e.complexity.PkgEqual.Justification == nil {
			break
		}

		return e.complexity.PkgEqual.Justification(childComplexity), true

	case "PkgEqual.origin":
		if e.complexity.PkgEqual.Origin == nil {
			break
		}

		return e.complexity.PkgEqual.Origin(childComplexity), true

	case "PkgEqual.packages":
		if e.complexity.PkgEqual.Packages == nil {
			break
		}

		return e.complexity.PkgEqual.Packages(childComplexity), true

	case "PointOfContact.collector":
		if e.complexity.PointOfContact.Collector == nil {
			break
		}

		return e.complexity.PointOfContact.Collector(childComplexity), true

	case "PointOfContact.email":
		if e.complexity.PointOfContact.Email == nil {
			break
		}

		return e.complexity.PointOfContact.Email(childComplexity), true

	case "PointOfContact.id":
		if e.complexity.PointOfContact.ID == nil {
			break
		}

		return e.complexity.PointOfContact.ID(childComplexity), true

	case "PointOfContact.info":
		if e.complexity.PointOfContact.Info == nil {
			break
		}

		return e.complexity.PointOfContact.Info(childComplexity), true

	case "PointOfContact.justification":
		if e.complexity.PointOfContact.Justification == nil {
			break
		}

		return e.complexity.PointOfContact.Justification(childComplexity), true

	case "PointOfContact.origin":
		if e.complexity.PointOfContact.Origin == nil {
			break
		}

		return e.complexity.PointOfContact.Origin(childComplexity), true

	case "PointOfContact.since":
		if e.complexity.PointOfContact.Since == nil {
			break
		}

		return e.complexity.PointOfContact.Since(childComplexity), true

	case "PointOfContact.subject":
		if e.complexity.PointOfContact.Subject == nil {
			break
		}

		return e.complexity.PointOfContact.Subject(childComplexity), true

	case "Query.artifacts":
		if e.complexity.Query.Artifacts == nil {
			break
		}

		args, err := ec.field_Query_artifacts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Artifacts(childComplexity, args["artifactSpec"].(model.ArtifactSpec)), true

	case "Query.builders":
		if e.complexity.Query.Builders == nil {
			break
		}

		args, err := ec.field_Query_builders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Builders(childComplexity, args["builderSpec"].(model.BuilderSpec)), true

	case "Query.CertifyBad":
		if e.complexity.Query.CertifyBad == nil {
			break
		}

		args, err := ec.field_Query_CertifyBad_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyBad(childComplexity, args["certifyBadSpec"].(model.CertifyBadSpec)), true

	case "Query.CertifyGood":
		if e.complexity.Query.CertifyGood == nil {
			break
		}

		args, err := ec.field_Query_CertifyGood_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyGood(childComplexity, args["certifyGoodSpec"].(model.CertifyGoodSpec)), true

	case "Query.CertifyVEXStatement":
		if e.complexity.Query.CertifyVEXStatement == nil {
			break
		}

		args, err := ec.field_Query_CertifyVEXStatement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyVEXStatement(childComplexity, args["certifyVEXStatementSpec"].(model.CertifyVEXStatementSpec)), true

	case "Query.CertifyVuln":
		if e.complexity.Query.CertifyVuln == nil {
			break
		}

		args, err := ec.field_Query_CertifyVuln_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CertifyVuln(childComplexity, args["certifyVulnSpec"].(model.CertifyVulnSpec)), true

	case "Query.findSoftware":
		if e.complexity.Query.FindSoftware == nil {
			break
		}

		args, err := ec.field_Query_findSoftware_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindSoftware(childComplexity, args["searchText"].(string)), true

	case "Query.HasMetadata":
		if e.complexity.Query.HasMetadata == nil {
			break
		}

		args, err := ec.field_Query_HasMetadata_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasMetadata(childComplexity, args["hasMetadataSpec"].(model.HasMetadataSpec)), true

	case "Query.HasSBOM":
		if e.complexity.Query.HasSbom == nil {
			break
		}

		args, err := ec.field_Query_HasSBOM_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasSbom(childComplexity, args["hasSBOMSpec"].(model.HasSBOMSpec)), true

	case "Query.HasSLSA":
		if e.complexity.Query.HasSlsa == nil {
			break
		}

		args, err := ec.field_Query_HasSLSA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasSlsa(childComplexity, args["hasSLSASpec"].(model.HasSLSASpec)), true

	case "Query.HasSourceAt":
		if e.complexity.Query.HasSourceAt == nil {
			break
		}

		args, err := ec.field_Query_HasSourceAt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasSourceAt(childComplexity, args["hasSourceAtSpec"].(model.HasSourceAtSpec)), true

	case "Query.HashEqual":
		if e.complexity.Query.HashEqual == nil {
			break
		}

		args, err := ec.field_Query_HashEqual_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HashEqual(childComplexity, args["hashEqualSpec"].(model.HashEqualSpec)), true

	case "Query.IsDependency":
		if e.complexity.Query.IsDependency == nil {
			break
		}

		args, err := ec.field_Query_IsDependency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsDependency(childComplexity, args["isDependencySpec"].(model.IsDependencySpec)), true

	case "Query.IsOccurrence":
		if e.complexity.Query.IsOccurrence == nil {
			break
		}

		args, err := ec.field_Query_IsOccurrence_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsOccurrence(childComplexity, args["isOccurrenceSpec"].(model.IsOccurrenceSpec)), true

	case "Query.neighbors":
		if e.complexity.Query.Neighbors == nil {
			break
		}

		args, err := ec.field_Query_neighbors_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Neighbors(childComplexity, args["node"].(string), args["usingOnly"].([]model.Edge)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["node"].(string)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["nodes"].([]string)), true

	case "Query.packages":
		if e.complexity.Query.Packages == nil {
			break
		}

		args, err := ec.field_Query_packages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Packages(childComplexity, args["pkgSpec"].(model.PkgSpec)), true

	case "Query.path":
		if e.complexity.Query.Path == nil {
			break
		}

		args, err := ec.field_Query_path_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Path(childComplexity, args["subject"].(string), args["target"].(string), args["maxPathLength"].(int), args["usingOnly"].([]model.Edge)), true

	case "Query.PkgEqual":
		if e.complexity.Query.PkgEqual == nil {
			break
		}

		args, err := ec.field_Query_PkgEqual_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PkgEqual(childComplexity, args["pkgEqualSpec"].(model.PkgEqualSpec)), true

	case "Query.PointOfContact":
		if e.complexity.Query.PointOfContact == nil {
			break
		}

		args, err := ec.field_Query_PointOfContact_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PointOfContact(childComplexity, args["pointOfContactSpec"].(model.PointOfContactSpec)), true

	case "Query.scorecards":
		if e.complexity.Query.Scorecards == nil {
			break
		}

		args, err := ec.field_Query_scorecards_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Scorecards(childComplexity, args["scorecardSpec"].(model.CertifyScorecardSpec)), true

	case "Query.sources":
		if e.complexity.Query.Sources == nil {
			break
		}

		args, err := ec.field_Query_sources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sources(childComplexity, args["sourceSpec"].(model.SourceSpec)), true

	case "Query.vulnEqual":
		if e.complexity.Query.VulnEqual == nil {
			break
		}

		args, err := ec.field_Query_vulnEqual_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.VulnEqual(childComplexity, args["vulnEqualSpec"].(model.VulnEqualSpec)), true

	case "Query.vulnerabilities":
		if e.complexity.Query.Vulnerabilities == nil {
			break
		}

		args, err := ec.field_Query_vulnerabilities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Vulnerabilities(childComplexity, args["vulnSpec"].(model.VulnerabilitySpec)), true

	case "SLSA.buildType":
		if e.complexity.SLSA.BuildType == nil {
			break
		}

		return e.complexity.SLSA.BuildType(childComplexity), true

	case "SLSA.builtBy":
		if e.complexity.SLSA.BuiltBy == nil {
			break
		}

		return e.complexity.SLSA.BuiltBy(childComplexity), true

	case "SLSA.builtFrom":
		if e.complexity.SLSA.BuiltFrom == nil {
			break
		}

		return e.complexity.SLSA.BuiltFrom(childComplexity), true

	case "SLSA.collector":
		if e.complexity.SLSA.Collector == nil {
			break
		}

		return e.complexity.SLSA.Collector(childComplexity), true

	case "SLSA.finishedOn":
		if e.complexity.SLSA.FinishedOn == nil {
			break
		}

		return e.complexity.SLSA.FinishedOn(childComplexity), true

	case "SLSA.origin":
		if e.complexity.SLSA.Origin == nil {
			break
		}

		return e.complexity.SLSA.Origin(childComplexity), true

	case "SLSA.slsaPredicate":
		if e.complexity.SLSA.SlsaPredicate == nil {
			break
		}

		return e.complexity.SLSA.SlsaPredicate(childComplexity), true

	case "SLSA.slsaVersion":
		if e.complexity.SLSA.SlsaVersion == nil {
			break
		}

		return e.complexity.SLSA.SlsaVersion(childComplexity), true

	case "SLSA.startedOn":
		if e.complexity.SLSA.StartedOn == nil {
			break
		}

		return e.complexity.SLSA.StartedOn(childComplexity), true

	case "SLSAPredicate.key":
		if e.complexity.SLSAPredicate.Key == nil {
			break
		}

		return e.complexity.SLSAPredicate.Key(childComplexity), true

	case "SLSAPredicate.value":
		if e.complexity.SLSAPredicate.Value == nil {
			break
		}

		return e.complexity.SLSAPredicate.Value(childComplexity), true

	case "ScanMetadata.collector":
		if e.complexity.ScanMetadata.Collector == nil {
			break
		}

		return e.complexity.ScanMetadata.Collector(childComplexity), true

	case "ScanMetadata.dbUri":
		if e.complexity.ScanMetadata.DbURI == nil {
			break
		}

		return e.complexity.ScanMetadata.DbURI(childComplexity), true

	case "ScanMetadata.dbVersion":
		if e.complexity.ScanMetadata.DbVersion == nil {
			break
		}

		return e.complexity.ScanMetadata.DbVersion(childComplexity), true

	case "ScanMetadata.origin":
		if e.complexity.ScanMetadata.Origin == nil {
			break
		}

		return e.complexity.ScanMetadata.Origin(childComplexity), true

	case "ScanMetadata.scannerUri":
		if e.complexity.ScanMetadata.ScannerURI == nil {
			break
		}

		return e.complexity.ScanMetadata.ScannerURI(childComplexity), true

	case "ScanMetadata.scannerVersion":
		if e.complexity.ScanMetadata.ScannerVersion == nil {
			break
		}

		return e.complexity.ScanMetadata.ScannerVersion(childComplexity), true

	case "ScanMetadata.timeScanned":
		if e.complexity.ScanMetadata.TimeScanned == nil {
			break
		}

		return e.complexity.ScanMetadata.TimeScanned(childComplexity), true

	case "Scorecard.aggregateScore":
		if e.complexity.Scorecard.AggregateScore == nil {
			break
		}

		return e.complexity.Scorecard.AggregateScore(childComplexity), true

	case "Scorecard.checks":
		if e.complexity.Scorecard.Checks == nil {
			break
		}

		return e.complexity.Scorecard.Checks(childComplexity), true

	case "Scorecard.collector":
		if e.complexity.Scorecard.Collector == nil {
			break
		}

		return e.complexity.Scorecard.Collector(childComplexity), true

	case "Scorecard.origin":
		if e.complexity.Scorecard.Origin == nil {
			break
		}

		return e.complexity.Scorecard.Origin(childComplexity), true

	case "Scorecard.scorecardCommit":
		if e.complexity.Scorecard.ScorecardCommit == nil {
			break
		}

		return e.complexity.Scorecard.ScorecardCommit(childComplexity), true

	case "Scorecard.scorecardVersion":
		if e.complexity.Scorecard.ScorecardVersion == nil {
			break
		}

		return e.complexity.Scorecard.ScorecardVersion(childComplexity), true

	case "Scorecard.timeScanned":
		if e.complexity.Scorecard.TimeScanned == nil {
			break
		}

		return e.complexity.Scorecard.TimeScanned(childComplexity), true

	case "ScorecardCheck.check":
		if e.complexity.ScorecardCheck.Check == nil {
			break
		}

		return e.complexity.ScorecardCheck.Check(childComplexity), true

	case "ScorecardCheck.score":
		if e.complexity.ScorecardCheck.Score == nil {
			break
		}

		return e.complexity.ScorecardCheck.Score(childComplexity), true

	case "Source.id":
		if e.complexity.Source.ID == nil {
			break
		}

		return e.complexity.Source.ID(childComplexity), true

	case "Source.namespaces":
		if e.complexity.Source.Namespaces == nil {
			break
		}

		return e.complexity.Source.Namespaces(childComplexity), true

	case "Source.type":
		if e.complexity.Source.Type == nil {
			break
		}

		return e.complexity.Source.Type(childComplexity), true

	case "SourceName.commit":
		if e.complexity.SourceName.Commit == nil {
			break
		}

		return e.complexity.SourceName.Commit(childComplexity), true

	case "SourceName.id":
		if e.complexity.SourceName.ID == nil {
			break
		}

		return e.complexity.SourceName.ID(childComplexity), true

	case "SourceName.name":
		if e.complexity.SourceName.Name == nil {
			break
		}

		return e.complexity.SourceName.Name(childComplexity), true

	case "SourceName.tag":
		if e.complexity.SourceName.Tag == nil {
			break
		}

		return e.complexity.SourceName.Tag(childComplexity), true

	case "SourceNamespace.id":
		if e.complexity.SourceNamespace.ID == nil {
			break
		}

		return e.complexity.SourceNamespace.ID(childComplexity), true

	case "SourceNamespace.names":
		if e.complexity.SourceNamespace.Names == nil {
			break
		}

		return e.complexity.SourceNamespace.Names(childComplexity), true

	case "SourceNamespace.namespace":
		if e.complexity.SourceNamespace.Namespace == nil {
			break
		}

		return e.complexity.SourceNamespace.Namespace(childComplexity), true

	case "VulnEqual.collector":
		if e.complexity.VulnEqual.Collector == nil {
			break
		}

		return e.complexity.VulnEqual.Collector(childComplexity), true

	case "VulnEqual.id":
		if e.complexity.VulnEqual.ID == nil {
			break
		}

		return e.complexity.VulnEqual.ID(childComplexity), true

	case "VulnEqual.justification":
		if e.complexity.VulnEqual.Justification == nil {
			break
		}

		return e.complexity.VulnEqual.Justification(childComplexity), true

	case "VulnEqual.origin":
		if e.complexity.VulnEqual.Origin == nil {
			break
		}

		return e.complexity.VulnEqual.Origin(childComplexity), true

	case "VulnEqual.vulnerabilities":
		if e.complexity.VulnEqual.Vulnerabilities == nil {
			break
		}

		return e.complexity.VulnEqual.Vulnerabilities(childComplexity), true

	case "Vulnerability.id":
		if e.complexity.Vulnerability.ID == nil {
			break
		}

		return e.complexity.Vulnerability.ID(childComplexity), true

	case "Vulnerability.type":
		if e.complexity.Vulnerability.Type == nil {
			break
		}

		return e.complexity.Vulnerability.Type(childComplexity), true

	case "Vulnerability.vulnerabilityIDs":
		if e.complexity.Vulnerability.VulnerabilityIDs == nil {
			break
		}

		return e.complexity.Vulnerability.VulnerabilityIDs(childComplexity), true

	case "VulnerabilityID.id":
		if e.complexity.VulnerabilityID.ID == nil {
			break
		}

		return e.complexity.VulnerabilityID.ID(childComplexity), true

	case "VulnerabilityID.vulnerabilityID":
		if e.complexity.VulnerabilityID.VulnerabilityID == nil {
			break
		}

		return e.complexity.VulnerabilityID.VulnerabilityID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputArtifactInputSpec,
		ec.unmarshalInputArtifactSpec,
		ec.unmarshalInputBuilderInputSpec,
		ec.unmarshalInputBuilderSpec,
		ec.unmarshalInputCertifyBadInputSpec,
		ec.unmarshalInputCertifyBadSpec,
		ec.unmarshalInputCertifyGoodInputSpec,
		ec.unmarshalInputCertifyGoodSpec,
		ec.unmarshalInputCertifyScorecardSpec,
		ec.unmarshalInputCertifyVEXStatementSpec,
		ec.unmarshalInputCertifyVulnSpec,
		ec.unmarshalInputHasMetadataInputSpec,
		ec.unmarshalInputHasMetadataSpec,
		ec.unmarshalInputHasSBOMInputSpec,
		ec.unmarshalInputHasSBOMSpec,
		ec.unmarshalInputHasSLSASpec,
		ec.unmarshalInputHasSourceAtInputSpec,
		ec.unmarshalInputHasSourceAtSpec,
		ec.unmarshalInputHashEqualInputSpec,
		ec.unmarshalInputHashEqualSpec,
		ec.unmarshalInputIsDependencyInputSpec,
		ec.unmarshalInputIsDependencySpec,
		ec.unmarshalInputIsOccurrenceInputSpec,
		ec.unmarshalInputIsOccurrenceSpec,
		ec.unmarshalInputMatchFlags,
		ec.unmarshalInputPackageOrArtifactInput,
		ec.unmarshalInputPackageOrArtifactInputs,
		ec.unmarshalInputPackageOrArtifactSpec,
		ec.unmarshalInputPackageOrSourceInput,
		ec.unmarshalInputPackageOrSourceInputs,
		ec.unmarshalInputPackageOrSourceSpec,
		ec.unmarshalInputPackageQualifierInputSpec,
		ec.unmarshalInputPackageQualifierSpec,
		ec.unmarshalInputPackageSourceOrArtifactInput,
		ec.unmarshalInputPackageSourceOrArtifactInputs,
		ec.unmarshalInputPackageSourceOrArtifactSpec,
		ec.unmarshalInputPkgEqualInputSpec,
		ec.unmarshalInputPkgEqualSpec,
		ec.unmarshalInputPkgInputSpec,
		ec.unmarshalInputPkgNameSpec,
		ec.unmarshalInputPkgSpec,
		ec.unmarshalInputPointOfContactInputSpec,
		ec.unmarshalInputPointOfContactSpec,
		ec.unmarshalInputSLSAInputSpec,
		ec.unmarshalInputSLSAPredicateInputSpec,
		ec.unmarshalInputSLSAPredicateSpec,
		ec.unmarshalInputScanMetadataInput,
		ec.unmarshalInputScorecardCheckInputSpec,
		ec.unmarshalInputScorecardCheckSpec,
		ec.unmarshalInputScorecardInputSpec,
		ec.unmarshalInputSourceInputSpec,
		ec.unmarshalInputSourceSpec,
		ec.unmarshalInputVexStatementInputSpec,
		ec.unmarshalInputVulnEqualInputSpec,
		ec.unmarshalInputVulnEqualSpec,
		ec.unmarshalInputVulnerabilityInputSpec,
		ec.unmarshalInputVulnerabilitySpec,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/artifact.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the artifact

"""
Artifact represents an artifact identified by a checksum hash.

The checksum is split into the digest value and the algorithm used to generate
it. Both fields are mandatory and canonicalized to be lowercase.

If having a checksum Go object, algorithm can be
strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
"""
type Artifact {
  id: ID!
  algorithm: String!
  digest: String!
}

"""
ArtifactSpec allows filtering the list of artifacts to return in a query.

The checksum fields are canonicalized to be lowercase.
"""
input ArtifactSpec {
  id: ID
  algorithm: String
  digest: String
}

"""
ArtifactInputSpec specifies an artifact for mutations.

The checksum fields are canonicalized to be lowercase.
"""
input ArtifactInputSpec {
  algorithm: String!
  digest: String!
}

extend type Query {
  "Returns all artifacts matching a filter."
  artifacts(artifactSpec: ArtifactSpec!): [Artifact!]!
}

extend type Mutation {
  "Ingests a new artifact and returns it."
  ingestArtifact(artifact: ArtifactInputSpec): Artifact!
  "Bulk ingests new artifacts and returns a list of them."
  ingestArtifacts(artifacts: [ArtifactInputSpec!]!): [Artifact!]!
}
`, BuiltIn: false},
	{Name: "../schema/builder.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the builder

"""
Builder represents the builder (e.g., FRSCA or GitHub Actions).

Currently builders are identified by the uri field.
"""
type Builder {
  id: ID!
  uri: String!
}

"BuilderSpec allows filtering the list of builders to return in a query."
input BuilderSpec {
  id: ID
  uri: String
}

"BuilderInputSpec specifies a builder for mutations."
input BuilderInputSpec {
  uri: String!
}

extend type Query {
  "Returns all builders matching a filter."
  builders(builderSpec: BuilderSpec!): [Builder!]!
}

extend type Mutation {
  "Ingests a new builder and returns it."
  ingestBuilder(builder: BuilderInputSpec): Builder!
  "Bulk ingests new builders and returns a list of them."
  ingestBuilders(builders: [BuilderInputSpec!]!): [Builder!]!
}
`, BuiltIn: false},
	{Name: "../schema/certifyBad.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CertifyBad

"PackageSourceOrArtifact is a union of Package, Source, and Artifact."
union PackageSourceOrArtifact = Package | Source | Artifact

"""
PackageSourceOrArtifactSpec allows using PackageSourceOrArtifact union as
input type to be used in read queries.

Exactly one of the value must be set to non-nil.
"""
input PackageSourceOrArtifactSpec {
  package: PkgSpec
  source: SourceSpec
  artifact: ArtifactSpec
}

"""
PackageSourceOrArtifactInput allows using PackageSourceOrArtifact union as
input type to be used in mutations.

Exactly one of the value must be set to non-nil.
"""
input PackageSourceOrArtifactInput {
  package: PkgInputSpec
  source: SourceInputSpec
  artifact: ArtifactInputSpec
}

"""
PackageSourceOrArtifactInputs allows using PackageSourceOrArtifact union as
input type to be used in bulk mutations.

Exactly one list must be specified.
"""
input PackageSourceOrArtifactInputs {
  packages: [PkgInputSpec!]
  sources: [SourceInputSpec!]
  artifacts: [ArtifactInputSpec!]
}

"""
CertifyBad is an attestation that a package, source, or artifact is considered
bad.

All evidence trees record a justification for the property they represent as
well as the document that contains the attestation (origin) and the collector
that collected the document (collector).

The certification applies to a subject which is a package, source, or artifact.
If the attestation targets a package, it must target a PackageName or a
PackageVersion. If the attestation targets a source, it must target a
SourceName.
"""
type CertifyBad {
  id: ID!
  subject: PackageSourceOrArtifact!
  justification: String!
  origin: String!
  collector: String!
}

"""
CertifyBadSpec allows filtering the list of CertifyBad evidence to return in a
query.

If a package is specified in the subject filter, then it must be specified up
to PackageName or PackageVersion. That is, user must specify package name, or
name and one of version, qualifiers, or subpath.

If a source is specified in the subject filter, then it must specify a name,
and optionally a tag and a commit.
"""
input CertifyBadSpec {
  id: ID
  subject: PackageSourceOrArtifactSpec
  justification: String
  origin: String
  collector: String
}

"""
CertifyBadInputSpec represents the mutation input to ingest a CertifyBad
evidence.
"""
input CertifyBadInputSpec {
  justification: String!
  origin: String!
  collector: String!
}

"""
PkgMatchType is an enum to determine if the attestation should be done at the
specific version or package name.
"""
enum PkgMatchType {
  ALL_VERSIONS
  SPECIFIC_VERSION
}

"MatchFlags is used to input the PkgMatchType enum."
input MatchFlags {
  pkg: PkgMatchType!
}

extend type Query {
  "Returns all CertifyBad attestations matching a filter."
  CertifyBad(certifyBadSpec: CertifyBadSpec!): [CertifyBad!]!
}

extend type Mutation {
  "Adds a certification that a package, source or artifact is considered bad."
  ingestCertifyBad(subject: PackageSourceOrArtifactInput!, pkgMatchType: MatchFlags!, certifyBad: CertifyBadInputSpec!): CertifyBad!
  "Adds bulk certifications that a package, source or artifact is considered bad."
  ingestCertifyBads(subjects: PackageSourceOrArtifactInputs!, pkgMatchType: MatchFlags!, certifyBads: [CertifyBadInputSpec!]!): [CertifyBad!]!
}
`, BuiltIn: false},
	{Name: "../schema/certifyGood.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the CertifyGood

"""
CertifyGood is an attestation that a package, source, or artifact is considered
good.

All evidence trees record a justification for the property they represent as
well as the document that contains the attestation (origin) and the collector
that collected the document (collector).

The certification applies to a subject which is a package, source, or artifact.
If the attestation targets a package, it must target a PackageName or a
PackageVersion. If the attestation targets a source, it must target a
SourceName.
"""
type CertifyGood {
  id: ID!
  subject: PackageSourceOrArtifact!
  justification: String!
  origin: String!
  collector: String!
}

"""
CertifyBadSpec allows filtering the list of CertifyBad evidence to return in a
query.

If a package is specified in the subject filter, then it must be specified up
to PackageName or PackageVersion. That is, user must specify package name, or
name and one of version, qualifiers, or subpath.

If a source is specified in the subject filter, then it must specify a name,
and optionally a tag and a commit.
"""
input CertifyGoodSpec {
  id: ID
  subject: PackageSourceOrArtifactSpec
  justification: String
  origin: String
  collector: String
}

"""
CertifyGoodInputSpec represents the mutation input to ingest a CertifyGood evidence.
"""
input CertifyGoodInputSpec {
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all CertifyGood attestations matching a filter."
  CertifyGood(certifyGoodSpec: CertifyGoodSpec!): [CertifyGood!]!
}

extend type Mutation {
  "Adds a certification that a package, source or artifact is considered good."
  ingestCertifyGood(subject: PackageSourceOrArtifactInput!, pkgMatchType: MatchFlags!, certifyGood: CertifyGoodInputSpec!): CertifyGood!
  "Adds bulk certifications that a package, source or artifact is considered good."
  ingestCertifyGoods(subjects: PackageSourceOrArtifactInputs!, pkgMatchType: MatchFlags!, certifyGoods: [CertifyGoodInputSpec!]!): [CertifyGood!]!
}
`, BuiltIn: false},
	{Name: "../schema/certifyScorecard.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema to certify Scorecard for a source repository

"""
Define the Time scalar, to be used across GUAC. It follows RFC3339Nano format.

This is implicit via https://gqlgen.com/reference/scalars/#time

For GUAC, we assume that all times are stored in UTC format.
"""
scalar Time

"""
CertifyScorecard is an attestation to attach a Scorecard analysis to a
particular source repository.
"""
type CertifyScorecard {
  id: ID!
  "The source repository that is being scanned (attestation subject)"
  source: Source!
  "The Scorecard attached to the repository (attestation object)"
  scorecard: Scorecard!
}

"""
Scorecard contains all of the fields present in a Scorecard attestation.

We also include fields to specify under what conditions the check was performed
(time of scan, version of scanners, etc.) as well as how this information got
included into GUAC (origin document and the collector for that document).
"""
type Scorecard {
  "Individual Scorecard check scores (Branch-Protection, Code-Review, ...)"
  checks: [ScorecardCheck!]!
  "Overall Scorecard score for the source"
  aggregateScore: Float!
  "Exact timestamp when the source was last scanned (in RFC 3339 format)"
  timeScanned: Time!
  "Version of the Scorecard scanner used to analyze the source"
  scorecardVersion: String!
  "Commit of the Scorecards repository at the time of scanning the source"
  scorecardCommit: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
ScorecardCheck are the individual checks from scorecard and their values as a
key-value pair.

For example:  Branch-Protection, Code-Review...etc

Based off scorecard's:
type jsonCheckResultV2 struct {
  Details []string                 ` + "`" + `json:"details"` + "`" + `
  Score   int                      ` + "`" + `json:"score"` + "`" + `
  Reason  string                   ` + "`" + `json:"reason"` + "`" + `
  Name    string                   ` + "`" + `json:"name"` + "`" + `
  Doc     jsonCheckDocumentationV2 ` + "`" + `json:"documentation"` + "`" + `
}
This node cannot be directly referred by other parts of GUAC.
"""
type ScorecardCheck {
  check: String!
  score: Int!
}

"CertifyScorecardSpec allows filtering the list of Scorecards to return."
input CertifyScorecardSpec {
  id: ID
  source: SourceSpec
  timeScanned: Time
  aggregateScore: Float
  checks: [ScorecardCheckSpec!] = []
  scorecardVersion: String
  scorecardCommit: String
  origin: String
  collector: String
}

"ScorecardCheckSpec is the same as ScorecardCheck, but usable as query input."
input ScorecardCheckSpec {
  check: String!
  score: Int!
}

"ScorecardInputSpec represents the mutation input to ingest a Scorecard."
input ScorecardInputSpec {
  checks: [ScorecardCheckInputSpec!]!
  aggregateScore: Float!
  timeScanned: Time!
  scorecardVersion: String!
  scorecardCommit: String!
  origin: String!
  collector: String!
}

"ScorecardCheckInputSpec represents the mutation input for a Scorecard check."
input ScorecardCheckInputSpec {
  check: String!
  score: Int!
}

extend type Query {
  "Returns all Scorecard certifications matching the filter."
  scorecards(scorecardSpec: CertifyScorecardSpec!): [CertifyScorecard!]!
}

extend type Mutation {
  "Adds a certification that a source repository has a Scorecard."
  ingestScorecard(source: SourceInputSpec!, scorecard: ScorecardInputSpec!): CertifyScorecard!
  "Adds bulk certifications that a source repository has a Scorecard."
  ingestScorecards(sources: [SourceInputSpec!]!, scorecards: [ScorecardInputSpec!]!): [CertifyScorecard!]!
}
`, BuiltIn: false},
	{Name: "../schema/certifyVEXStatement.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for certifying VEX statements

"PackageOrArtifact is a union of Package and Artifact."
union PackageOrArtifact = Package | Artifact

"""
PackageOrArtifactSpec allows using PackageOrArtifact union as
input type to be used in read queries.

Exactly one of the value must be set to non-nil.
"""
input PackageOrArtifactSpec {
  package: PkgSpec
  artifact: ArtifactSpec
}

"""
PackageOrArtifactInput allows using PackageOrArtifact union as
input type to be used in mutations.

Exactly one of the value must be set to non-nil.
"""
input PackageOrArtifactInput {
  package: PkgInputSpec
  artifact: ArtifactInputSpec
}

"""
PackageOrArtifactInputs allows using packages and artifacts as input for batch mutations.
Exactly one list must be specified.
"""
input PackageOrArtifactInputs {
  packages: [PkgInputSpec!]
  artifacts: [ArtifactInputSpec!]
}

"Records the status of a VEX statement subject."
enum VexStatus {
  NOT_AFFECTED
  AFFECTED
  FIXED
  UNDER_INVESTIGATION
}

"Records the justification included in the VEX statement."
enum VexJustification {
  COMPONENT_NOT_PRESENT
  VULNERABLE_CODE_NOT_PRESENT
  VULNERABLE_CODE_NOT_IN_EXECUTE_PATH
  VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY
  INLINE_MITIGATIONS_ALREADY_EXIST
  NOT_PROVIDED
}

"""
CertifyVEXStatement is an attestation to attach VEX statements to a package or
artifact to clarify the impact of a specific vulnerability.
"""
type CertifyVEXStatement {
  id: ID!
  "Subject of attestation"
  subject: PackageOrArtifact!
  "Attested vulnerability"
  vulnerability: Vulnerability!
  "Status of the vulnerabilities with respect to the subject"
  status: VexStatus!
  "Justification from VEX statement"
  vexJustification: VexJustification!
  "VEX statement: impact_statement or action_statement depending on status"
  statement: String!
  "statusNotes may convey information about how status was determined"
  statusNotes: String!
  "Timestamp (exact time in RFC 3339 format) for the VEX statement"
  knownSince: Time!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
CertifyVEXStatementSpec allows filtering the list of VEX statements to
return in a query.

Only one subject type (package or artifact) and one vulnerability may be specified.

Note that setting noVuln vulnerability type is invalid for VEX statements!
"""
input CertifyVEXStatementSpec {
  id: ID
  subject: PackageOrArtifactSpec
  vulnerability: VulnerabilitySpec
  status: VexStatus
  vexJustification: VexJustification
  statement: String
  statusNotes: String
  knownSince: Time
  origin: String
  collector: String
}

"VexStatementInputSpec represents the input to ingest VEX statements."
input VexStatementInputSpec {
  status: VexStatus!
  vexJustification: VexJustification!
  statement: String!
  statusNotes: String!
  knownSince: Time!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all VEX certifications matching the input filter."
  CertifyVEXStatement(certifyVEXStatementSpec: CertifyVEXStatementSpec!): [CertifyVEXStatement!]!
}

extend type Mutation {
  "Adds a VEX certification for a package."
  ingestVEXStatement(subject: PackageOrArtifactInput!, vulnerability: VulnerabilityInputSpec!, vexStatement: VexStatementInputSpec!): CertifyVEXStatement!
}
`, BuiltIn: false},
	{Name: "../schema/certifyVuln.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the vulnerability certifications

"""
CertifyVuln is an attestation to attach vulnerability information to a package.

This information is obtained via a scanner. If there is no vulnerability
detected, we attach the a vulnerability with "NoVuln" type and an empty string 
for the vulnerability ID.
"""
type CertifyVuln {
  id: ID!
  "The package that is attested"
  package: Package!
  "The vulnerability can be an be a specific vulnerability or NoVuln type."
  vulnerability: Vulnerability!
  "Metadata attached to the certification"
  metadata: ScanMetadata!
}

"""
ScanMetadata is the metadata attached to vulnerability certification.

It contains metadata about the scanner process that created the certification.
"""
type ScanMetadata {
  "Time of scan (in RFC 3339 format)"
  timeScanned: Time!
  "URI of the vulnerability database used by the scanner"
  dbUri: String!
  "Version of the vulnerability database used by the scanner"
  dbVersion: String!
  "URI of the scanner"
  scannerUri: String!
  "Version of the scanner"
  scannerVersion: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
CertifyVulnSpec allows filtering the list of vulnerability certifications to
return in a query.

Specifying just the package allows to query for all vulnerabilities associated
with the package.

Only one vulnerability (or NoVuln vulnerability type) may be
specified.
"""
input CertifyVulnSpec {
  id: ID
  package: PkgSpec
  vulnerability: VulnerabilitySpec
  timeScanned: Time
  dbUri: String
  dbVersion: String
  scannerUri: String
  scannerVersion: String
  origin: String
  collector: String
}

"""
ScanMetadataInput represents the input for certifying vulnerability
scans in mutations.
"""
input ScanMetadataInput {
  timeScanned: Time!
  dbUri: String!
  dbVersion: String!
  scannerUri: String!
  scannerVersion: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all vulnerability certifications matching the input filter."
  CertifyVuln(certifyVulnSpec: CertifyVulnSpec!): [CertifyVuln!]!
}

extend type Mutation {
  "Adds a certification that a package has been scanned for vulnerabilities."
  ingestCertifyVuln(pkg: PkgInputSpec!, vulnerability: VulnerabilityInputSpec!, certifyVuln: ScanMetadataInput!): CertifyVuln!
}
`, BuiltIn: false},
	{Name: "../schema/contact.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

"""
PointOfContact is an attestation of how to get in touch with the person(s) responsible
for a package, source, or artifact.

All evidence trees record a justification for the property they represent as
well as the document that contains the attestation (origin) and the collector
that collected the document (collector).

The attestation applies to a subject which is a package, source, or artifact.
If the attestation targets a package, it must target a PackageName or a
PackageVersion. If the attestation targets a source, it must target a
SourceName.

email is the email address (singular) of the point of contact.

info is additional contact information other than email address. This is free
form.

NOTE: the identifiers for point of contact should be part of software trees.
This will benefit from identifier look up and traversal as well as organization
hierarchy. However, until the use case arises, PointOfContact will be a flat
reference to the contact details.
"""
type PointOfContact {
  id: ID!
  subject: PackageSourceOrArtifact!
  email: String!
  info: String!
  since: Time!
  justification: String!
  origin: String!
  collector: String!
}

"""
PointOfContactSpec allows filtering the list of PointOfContact evidence to return in a
query.

If a package is specified in the subject filter, then it must be specified up
to PackageName or PackageVersion. That is, user must specify package name, or
name and one of version, qualifiers, or subpath.

If a source is specified in the subject filter, then it must specify a name,
and optionally a tag and a commit.

since filters attestations with a value of since later or equal to the provided filter.
"""
input PointOfContactSpec {
  id: ID
  subject: PackageSourceOrArtifactSpec
  email: String
  info: String
  since: Time
  justification: String
  origin: String
  collector: String
}

"""
PointOfContactInputSpec represents the mutation input to ingest a PointOfContact evidence.
"""
input PointOfContactInputSpec {
  email: String!
  info: String!
  since: Time!
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all PointOfContact attestations matching a filter."
  PointOfContact (pointOfContactSpec: PointOfContactSpec!): [PointOfContact!]!
}

extend type Mutation {
  "Adds a PointOfContact attestation to a package, source or artifact."
  ingestPointOfContact(subject: PackageSourceOrArtifactInput!, pkgMatchType: MatchFlags!, pointOfContact: PointOfContactInputSpec!): PointOfContact!
}
`, BuiltIn: false},
	{Name: "../schema/hasSBOM.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for recording presence of SBOMs

type HasSBOM {
  id: ID!
  "SBOM subject"
  subject: PackageOrArtifact!
  "Identifier for the SBOM document"
  uri: String!
  "Algorithm by which SBOMs digest was computed"
  algorithm: String!
  "Digest of SBOM"
  digest: String!
  "Location from which the SBOM can be downloaded"
  downloadLocation: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
HasSBOMSpec allows filtering the list of HasSBOM to return.

Only the package or artifact can be added, not both.
"""
input HasSBOMSpec {
  id: ID
  subject: PackageOrArtifactSpec
  uri: String
  algorithm: String
  digest: String
  downloadLocation: String
  origin: String
  collector: String
}

"HasSBOMInputSpec is the same as HasSBOM but for mutation input."
input HasSBOMInputSpec {
  uri: String!
  algorithm: String!
  digest: String!
  downloadLocation: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all SBOM certifications."
  HasSBOM(hasSBOMSpec: HasSBOMSpec!): [HasSBOM!]!
}

extend type Mutation {
  "Certifies that a package or artifact has an SBOM."
  ingestHasSBOM(subject: PackageOrArtifactInput!, hasSBOM: HasSBOMInputSpec!): HasSBOM!
  "Bulk ingest that package or artifact has an SBOM."
  ingestHasSBOMs(subjects: PackageOrArtifactInputs!, hasSBOMs: [HasSBOMInputSpec!]!): [HasSBOM!]!
}
`, BuiltIn: false},
	{Name: "../schema/hasSLSA.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for specifiying SLSA provenance

"HasSLSA records that a subject node has a SLSA attestation."
type HasSLSA {
  id: ID!
  "The subject of SLSA attestation"
  subject: Artifact!
  "The SLSA attestation"
  slsa: SLSA!
}

"""
SLSA contains all of the fields present in a SLSA attestation.

The materials and builders are objects of the HasSLSA predicate, everything
else are properties extracted from the attestation.

We also include fields to specify under what conditions the check was performed
(time of scan, version of scanners, etc.) as well as how this information got
included into GUAC (origin document and the collector for that document).
"""
type SLSA {
  "Materials of the build resulting in subject"
  builtFrom: [Artifact!]!
  "Builder performing the build"
  builtBy: Builder!
  "Type of the builder"
  buildType: String!
  "Individual predicates found in the attestation"
  slsaPredicate: [SLSAPredicate!]!
  "Version of the SLSA predicate"
  slsaVersion: String!
  "Timestamp (RFC3339Nano format) of build start time"
  startedOn: Time
  "Timestamp (RFC3339Nano format) of build end time"
  finishedOn: Time
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
SLSAPredicate are the values from the SLSA predicate in key-value pair form.

For example, given the following predicate

` + "`" + `` + "`" + `` + "`" + `
"predicate": {
  "buildDefinition": {
    "externalParameters": {
      "repository": "https://github.com/octocat/hello-world",
      ...
    },
    ...
  },
  ...
}
` + "`" + `` + "`" + `` + "`" + `

we have

` + "`" + `` + "`" + `` + "`" + `
key   = "buildDefinition.externalParameters.repository"
value = "https://github.com/octocat/hello-world"
` + "`" + `` + "`" + `` + "`" + `

This node cannot be directly referred by other parts of GUAC.
"""
type SLSAPredicate {
  key: String!
  value: String!
}

"HasSLSASpec allows filtering the list of HasSLSA to return."
input HasSLSASpec {
  id: ID
  subject: ArtifactSpec
  builtFrom: [ArtifactSpec!]
  builtBy: BuilderSpec
  buildType: String
  predicate: [SLSAPredicateSpec!] = []
  slsaVersion: String
  startedOn: Time
  finishedOn: Time
  origin: String
  collector: String
}

"SLSAPredicateSpec is the same as SLSAPredicate, but usable as query input."
input SLSAPredicateSpec {
  key: String!
  value: String!
}

"SLSAInputSpec is the same as SLSA but for mutation input."
input SLSAInputSpec {
  buildType: String!
  slsaPredicate: [SLSAPredicateInputSpec!]!
  slsaVersion: String!
  startedOn: Time
  finishedOn: Time
  origin: String!
  collector: String!
}

"SLSAPredicateInputSpec allows ingesting SLSAPredicateSpec."
input SLSAPredicateInputSpec {
  key: String!
  value: String!
}

extend type Query {
  "Returns all SLSA attestations matching the filter."
  HasSLSA(hasSLSASpec: HasSLSASpec!): [HasSLSA!]!
}

extend type Mutation {
  "Ingests a SLSA attestation"
  ingestSLSA(subject: ArtifactInputSpec!, builtFrom: [ArtifactInputSpec!]!, builtBy: BuilderInputSpec!, slsa: SLSAInputSpec!): HasSLSA!
  "Bulk Ingest SLSA attestations"
  ingestSLSAs(subjects: [ArtifactInputSpec!]!, builtFromList: [[ArtifactInputSpec!]!]!, builtByList: [BuilderInputSpec!]!, slsaList: [SLSAInputSpec!]!): [HasSLSA!]!
}
`, BuiltIn: false},
	{Name: "../schema/hasSourceAt.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the linking packages and sources

"HasSourceAt records that a package's repository is a given source."
type HasSourceAt {
  id: ID!
  "The subject of the attestation: can be a PackageName or a PackageVersion"
  package: Package!
  "Source repository from which the package is built"
  source: Source!
  "Timestamp since this link between package and source was certified"
  knownSince: Time!
  "Justification for the attested relationship"
  justification: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"HasSourceAtSpec allows filtering the list of HasSourceAt to return."
input HasSourceAtSpec {
  id: ID
  package: PkgSpec
  source: SourceSpec
  knownSince: Time
  justification: String
  origin: String
  collector: String
}

"HasSourceAtInputSpec is the same as HasSourceAt but for mutation input."
input HasSourceAtInputSpec {
  knownSince: Time!
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all source mappings that match the filter."
  HasSourceAt(hasSourceAtSpec: HasSourceAtSpec!): [HasSourceAt!]!
}

extend type Mutation {
  "Adds a certification that a package (PackageName or PackageVersion) is built from the source."
  ingestHasSourceAt(pkg: PkgInputSpec!, pkgMatchType: MatchFlags!, source: SourceInputSpec!, hasSourceAt: HasSourceAtInputSpec!): HasSourceAt!
}
`, BuiltIn: false},
	{Name: "../schema/hashEqual.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the artifact equality

"HashEqual is an attestation that a set of artifacts are identical."
type HashEqual {
  id: ID!
  "Collection of artifacts that are similar"
  artifacts: [Artifact!]!
  "Justification for the claim that the artifacts are similar"
  justification: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
HashEqualSpec allows filtering the list of artifact equality statements to
return in a query.

Specifying just one artifact allows to query for all similar artifacts (if any
exists).
"""
input HashEqualSpec {
  id: ID
  artifacts: [ArtifactSpec]
  justification: String
  origin: String
  collector: String
}


"HashEqualInputSpec represents the input to certify that packages are similar."
input HashEqualInputSpec {
  justification: String!
  origin: String!
  collector: String!
}


extend type Query {
  "Returns all artifact equality statements matching a filter."
  HashEqual(hashEqualSpec: HashEqualSpec!): [HashEqual!]!
}

extend type Mutation {
 "Adds a certification that two artifacts are equal."
  ingestHashEqual(artifact: ArtifactInputSpec!, otherArtifact: ArtifactInputSpec!, hashEqual: HashEqualInputSpec!): HashEqual!
  "Bulk ingest certifications that two artifacts are equal."
  ingestHashEquals(artifacts: [ArtifactInputSpec!]!, otherArtifacts: [ArtifactInputSpec!]!, hashEquals: [HashEqualInputSpec!]!): [HashEqual!]!
}
`, BuiltIn: false},
	{Name: "../schema/isDependency.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for specifying dependencies

"DependencyType determines the type of the dependency."
enum DependencyType {
  "direct dependency"
  DIRECT
  "indirect dependency"
  INDIRECT
  "type not known/not specified"
  UNKNOWN
}

"IsDependency is an attestation to record that a package depends on another."
type IsDependency {
  id: ID!
  "Package that has the dependency"
  package: Package!
  "Package for the dependency; MUST BE PackageName, not PackageVersion"
  dependentPackage: Package!
  "Version range for the dependency link"
  versionRange: String!
  "Type of dependency"
  dependencyType: DependencyType!
  "Justification for the attested relationship"
  justification: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
IsDependencySpec allows filtering the list of dependencies to return.

To obtain the list of dependency packages, caller must fill in the package
field.

Dependent packages must be defined at PackageName, not PackageVersion.
"""
input IsDependencySpec {
  id: ID
  package: PkgSpec
  dependentPackage: PkgNameSpec
  versionRange: String
  dependencyType: DependencyType
  justification: String
  origin: String
  collector: String
}

"""
PkgNameSpec is used to query for dependent packages.

This is different from PkgSpec as the IsDependency attestation should only be
allowed to be made to the packageName node and not the packageVersion node.
Versions will be handled by the version_range in the IsDependency attestation
node.
"""
input PkgNameSpec {
  id: ID
  type: String
  namespace: String
  name: String
}

"IsDependencyInputSpec is the input to record a new dependency."
input IsDependencyInputSpec {
  versionRange: String!
  dependencyType: DependencyType!
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all package dependencies that match the filter."
  IsDependency(isDependencySpec: IsDependencySpec!): [IsDependency!]!
}

extend type Mutation {
  "Adds a dependency between two packages"
  ingestDependency(pkg: PkgInputSpec!, depPkg: PkgInputSpec!, dependency: IsDependencyInputSpec!): IsDependency!
  "Bulk adds a dependency between two packages"
  ingestDependencies(pkgs: [PkgInputSpec!]!, depPkgs: [PkgInputSpec!]!, dependencies: [IsDependencyInputSpec!]!): [IsDependency!]!
}
`, BuiltIn: false},
	{Name: "../schema/isOccurrence.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for occurence certifications

"PackageOrSource is a union of Package and Source."
union PackageOrSource = Package | Source

"""
PackageOrSourceSpec allows using PackageOrSource union as input for queries.

Exactly one field must be specified.
"""
input PackageOrSourceSpec {
  package: PkgSpec
  source: SourceSpec
}

"""
PackageOrSourceInput allows using PackageOrSource union as input for mutations.

Exactly one field must be specified.
"""
input PackageOrSourceInput {
  package: PkgInputSpec
  source: SourceInputSpec
}

"""
PackageOrSourceInputs allows using packages and sources as input for batch mutations.
Exactly one list must be specified.
"""
input PackageOrSourceInputs {
  packages: [PkgInputSpec!]
  sources: [SourceInputSpec!]
}


"""
IsOccurrence is an attestation to link an artifact to a package or source.

Attestation must occur at the PackageVersion or at the SourceName.
"""
type IsOccurrence {
  id: ID!
  "Package or source from which the artifact originates"
  subject: PackageOrSource!
  "The artifact in the relationship"
  artifact: Artifact!
  "Justification for the attested relationship"
  justification: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
IsOccurrenceSpec allows filtering the list of artifact occurences to return in
a query.
"""
input IsOccurrenceSpec {
  id: ID
  subject: PackageOrSourceSpec
  artifact: ArtifactSpec
  justification: String
  origin: String
  collector: String
}

"IsOccurrenceInputSpec represents the input to record an artifact's origin."
input IsOccurrenceInputSpec {
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all artifacts-source/package mappings that match a filter."
  IsOccurrence(isOccurrenceSpec: IsOccurrenceSpec!): [IsOccurrence!]!
}

extend type Mutation {
  "Ingest that an artifact is produced from a package or source."
  ingestOccurrence(subject: PackageOrSourceInput!, artifact: ArtifactInputSpec!, occurrence: IsOccurrenceInputSpec!): IsOccurrence!
  "Bulk ingest that an artifact is produced from a package or source."
  ingestOccurrences(subjects: PackageOrSourceInputs!, artifacts: [ArtifactInputSpec!]!, occurrences: [IsOccurrenceInputSpec!]!): [IsOccurrence!]!
}
`, BuiltIn: false},
	{Name: "../schema/metadata.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the HasMetadata

"""
HasMetadata is an attestation that a package, source, or artifact has a certain
attested property (key) with value (value). For example, a source may have
metadata "SourceRepo2FAEnabled=true".

The intent of this evidence tree predicate is to allow extensibility of metadata
expressible within the GUAC ontology. Metadata that is commonly used will then
be promoted to a predicate on its own.

Justification indicates how the metadata was determined.

The metadata applies to a subject which is a package, source, or artifact.
If the attestation targets a package, it must target a PackageName or a
PackageVersion. If the attestation targets a source, it must target a
SourceName.
"""
type HasMetadata {
  id: ID!
  subject: PackageSourceOrArtifact!
  key: String!
  value: String!
  timestamp: Time!
  justification: String!
  origin: String!
  collector: String!
}

"""
HasMetadataSpec allows filtering the list of HasMetadata evidence to return in a
query.

If a package is specified in the subject filter, then it must be specified up
to PackageName or PackageVersion. That is, user must specify package name, or
name and one of version, qualifiers, or subpath.

If a source is specified in the subject filter, then it must specify a name,
and optionally a tag and a commit.

since specified indicates filtering timestamps after the specified time
"""
input HasMetadataSpec {
  id: ID
  subject: PackageSourceOrArtifactSpec
  since: Time
  key: String
  value: String
  justification: String
  origin: String
  collector: String
}

"""
HasMetadataInputSpec represents the mutation input to ingest a CertifyGood evidence.
"""
input HasMetadataInputSpec {
  key: String!
  value: String!
  timestamp: Time!
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all HasMetdata attestations matching a filter."
  HasMetadata(hasMetadataSpec: HasMetadataSpec!): [HasMetadata!]!
}

extend type Mutation {
  "Adds metadata about a package, source or artifact."
  ingestHasMetadata(subject: PackageSourceOrArtifactInput!, pkgMatchType: MatchFlags!, hasMetadata: HasMetadataInputSpec!): HasMetadata!
}
`, BuiltIn: false},
	{Name: "../schema/package.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the package trie/tree

"""
Package represents the root of the package trie/tree.

We map package information to a trie, closely matching the pURL specification
(https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
but deviating from it where GUAC heuristics allow for better representation of
package information. Each path in the trie fully represents a package; we split
the trie based on the pURL components.

This node matches a pkg:<type> partial pURL. The type field matches the
pURL types but we might also use "guac" for the cases where the pURL
representation is not complete or when we have custom rules.

Since this node is at the root of the package trie, it is named Package, not
PackageType.
"""
type Package {
  id: ID!
  type: String!
  namespaces: [PackageNamespace!]!
}

"""
PackageNamespace is a namespace for packages.

In the pURL representation, each PackageNamespace matches the
pkg:<type>/<namespace>/ partial pURL.

Namespaces are optional and type specific. Because they are optional, we use
empty string to denote missing namespaces.
"""
type PackageNamespace {
  id: ID!
  namespace: String!
  names: [PackageName!]!
}

"""
PackageName is a name for packages.

In the pURL representation, each PackageName matches the
pkg:<type>/<namespace>/<name> pURL.

Names are always mandatory.

This is the first node in the trie that can be referred to by other parts of
GUAC.
"""
type PackageName {
  id: ID!
  name: String!
  versions: [PackageVersion!]!
}

"""
PackageVersion is a package version.

In the pURL representation, each PackageName matches the
pkg:<type>/<namespace>/<name>@<version> pURL.

Versions are optional and each Package type defines own rules for handling
them. For this level of GUAC, these are just opaque strings.

NOTE: The handling of versions might change before this schema becomes stable.

This node can be referred to by other parts of GUAC.

Subpath and qualifiers are optional. Lack of qualifiers is represented by an
empty list and lack of subpath by empty string (to be consistent with
optionality of namespace and version). Two nodes that have different qualifiers
and/or subpath but the same version mean two different packages in the trie
(they are different). Two nodes that have same version but qualifiers of one
are a subset of the qualifier of the other also mean two different packages in
the trie.
"""
type PackageVersion {
  id: ID!
  version: String!
  qualifiers: [PackageQualifier!]!
  subpath: String!
}

"""
PackageQualifier is a qualifier for a package, a key-value pair.

In the pURL representation, it is a part of the <qualifiers> part of the
pkg:<type>/<namespace>/<name>@<version>?<qualifiers> pURL.

Qualifiers are optional, each Package type defines own rules for handling them,
and multiple qualifiers could be attached to the same package.

This node cannot be directly referred by other parts of GUAC.
"""
type PackageQualifier {
  key: String!
  value: String!
}

"""
PkgSpec allows filtering the list of sources to return in a query.

Each field matches a qualifier from pURL. Use null to match on all values at
that level. For example, to get all packages in GUAC backend, use a PkgSpec
where every field is null.

Empty string at a field means matching with the empty string. If passing in
qualifiers, all of the values in the list must match. Since we want to return
nodes with any number of qualifiers if no qualifiers are passed in the input,
we must also return the same set of nodes it the qualifiers list is empty. To
match on nodes that don't contain any qualifier, set matchOnlyEmptyQualifiers
to true. If this field is true, then the qualifiers argument is ignored.
"""
input PkgSpec {
  id: ID
  type: String
  namespace: String
  name: String
  version: String
  qualifiers: [PackageQualifierSpec!] = []
  matchOnlyEmptyQualifiers: Boolean = false
  subpath: String
}

"""
PackageQualifierSpec allows filtering package qualifiers in a query.

Keys are mandatory, but values could also be null if we want to match all
values for a specific key.

NOTE: Before the schema becomes stable, we might change the nulability
requirements of these fields.
"""
input PackageQualifierSpec {
  key: String!
  value: String
}

"""
PkgInputSpec specifies a package for mutations.

This is different than PkgSpec because we want to encode mandatory fields:
type and name. All optional fields are given empty default values.
"""
input PkgInputSpec {
  type: String!
  namespace: String = ""
  name: String!
  version: String = ""
  qualifiers: [PackageQualifierInputSpec!] = []
  subpath: String = ""
}

"PackageQualifierInputSpec allows specifying package qualifiers in mutations."
input PackageQualifierInputSpec {
  key: String!
  value: String!
}

extend type Query {
  "Returns all packages matching a filter."
  packages(pkgSpec: PkgSpec!): [Package!]!
}

extend type Mutation {
  "Ingests a new package and returns the corresponding package trie path."
  ingestPackage(pkg: PkgInputSpec!): Package!
  "Bulk ingests packages and returns the list of corresponding package trie path."
  ingestPackages(pkgs: [PkgInputSpec!]!): [Package!]!
}
`, BuiltIn: false},
	{Name: "../schema/path.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for advanced queries over all GUAC nodes

"""
Node is a union type of all the possible nodes.

It encapsulates the software tree nodes along with the evidence nodes. In a
path query, all connecting evidence nodes along with their intermediate subject
nodes need to be returned in order to create a complete graph.
"""
union Node
  = Package
  | Source
  | Artifact
  | Builder
  | Vulnerability
  | IsOccurrence
  | IsDependency
  | VulnEqual
  | CertifyVEXStatement
  | HashEqual
  | CertifyBad
  | CertifyGood
  | PkgEqual
  | CertifyScorecard
  | CertifyVuln
  | HasSourceAt
  | HasSBOM
  | HasSLSA
  | HasMetadata
  | PointOfContact

"""
Edge allows filtering path/neighbors output to only contain a subset of all
possible GUAC links.

Each member of the enum is formed by merging two Node names with _. Each name
is converted from CamelCase to CAPITALS_WITH_UNDERSCORES. Only valid edges
(pairs from Node to Node) are included.

The only exception to the above rule is for links out of HasSLSA. The names are
HAS_SLSA_SUBJECT, HAS_SLSA_BUILT_BY, and HAS_SLSA_MATERIALS. This is because
ARTIFACT_HAS_SLSA is only from subject Artifact to HasSLSA.
"""
enum Edge {
  ARTIFACT_CERTIFY_BAD
  ARTIFACT_CERTIFY_GOOD
  ARTIFACT_CERTIFY_VEX_STATEMENT
  ARTIFACT_HASH_EQUAL
  ARTIFACT_HAS_SBOM
  ARTIFACT_HAS_SLSA
  ARTIFACT_IS_OCCURRENCE
  ARTIFACT_HAS_METADATA
  ARTIFACT_POINT_OF_CONTACT
  BUILDER_HAS_SLSA
  VULNERABILITY_CERTIFY_VEX_STATEMENT
  VULNERABILITY_CERTIFY_VULN
  VULNERABILITY_VULN_EQUAL
  PACKAGE_CERTIFY_BAD
  PACKAGE_CERTIFY_GOOD
  PACKAGE_CERTIFY_VEX_STATEMENT
  PACKAGE_CERTIFY_VULN
  PACKAGE_HAS_SBOM
  PACKAGE_HAS_SOURCE_AT
  PACKAGE_IS_DEPENDENCY
  PACKAGE_IS_OCCURRENCE
  PACKAGE_PKG_EQUAL
  PACKAGE_HAS_METADATA
  PACKAGE_POINT_OF_CONTACT
  SOURCE_CERTIFY_BAD
  SOURCE_CERTIFY_GOOD
  SOURCE_CERTIFY_SCORECARD
  SOURCE_HAS_SOURCE_AT
  SOURCE_IS_OCCURRENCE
  SOURCE_HAS_METADATA
  SOURCE_POINT_OF_CONTACT

  CERTIFY_BAD_ARTIFACT
  CERTIFY_BAD_PACKAGE
  CERTIFY_BAD_SOURCE
  CERTIFY_GOOD_ARTIFACT
  CERTIFY_GOOD_PACKAGE
  CERTIFY_GOOD_SOURCE
  CERTIFY_SCORECARD_SOURCE
  CERTIFY_VEX_STATEMENT_ARTIFACT
  CERTIFY_VEX_STATEMENT_VULNERABILITY
  CERTIFY_VEX_STATEMENT_PACKAGE
  CERTIFY_VULN_VULNERABILITY
  CERTIFY_VULN_PACKAGE
  HASH_EQUAL_ARTIFACT
  HAS_SBOM_ARTIFACT
  HAS_SBOM_PACKAGE
  HAS_SLSA_BUILT_BY
  HAS_SLSA_MATERIALS
  HAS_SLSA_SUBJECT
  HAS_SOURCE_AT_PACKAGE
  HAS_SOURCE_AT_SOURCE
  IS_DEPENDENCY_PACKAGE
  IS_OCCURRENCE_ARTIFACT
  IS_OCCURRENCE_PACKAGE
  IS_OCCURRENCE_SOURCE
  VULN_EQUAL_VULNERABILITY
  PKG_EQUAL_PACKAGE
  HAS_METADATA_PACKAGE
  HAS_METADATA_ARTIFACT
  HAS_METADATA_SOURCE
  POINT_OF_CONTACT_PACKAGE
  POINT_OF_CONTACT_ARTIFACT
  POINT_OF_CONTACT_SOURCE
}

extend type Query {
  """
  path query returns a path between subject and target, of a maximum length.

  Since we want to uniquely identify endpoints, nodes must be specified by
  valid IDs only (instead of using filters/input spec structs).

  Specifying any Edge value in ` + "`" + `usingOnly` + "`" + ` will make the path only contain the
  corresponding GUAC evidence trees (GUAC verbs).
  """
  path(subject: ID!, target: ID!, maxPathLength: Int!, usingOnly: [Edge!]!): [Node!]!

  """
  neighbors returns all the direct neighbors of a node.

  Similarly, the input is only specified by its ID.

  Specifying any Edge value in ` + "`" + `usingOnly` + "`" + ` will make the neighbors list only
  contain the corresponding GUAC evidence trees (GUAC verbs).
  """
  neighbors(node: ID!, usingOnly: [Edge!]!): [Node!]!

  """
  node returns a single node, regardless of type.

  The input is only specified by its ID.
  """
  node(node: ID!): Node!

  """
  nodes returns an array of nodes, regardless of type.

  The input is an array of IDs to retrieve.
  """
  nodes(nodes: [ID!]!): [Node!]!
}
`, BuiltIn: false},
	{Name: "../schema/pkgEqual.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for package equality

"PkgEqual is an attestation that a set of packages are similar."
type PkgEqual {
  id: ID!
  "Collection of packages that are similar"
  packages: [Package!]!
  "Justification for the claim that the packages are similar"
  justification: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
PkgEqualSpec allows filtering the list of package equality statements to return
in a query.

Specifying just one package allows to query for all similar packages (if any
exists).
"""
input PkgEqualSpec {
  id: ID
  packages: [PkgSpec]
  justification: String
  origin: String
  collector: String
}

"PkgEqualInputSpec represents the input to certify that packages are similar."
input PkgEqualInputSpec {
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all package equality statements matching a filter."
  PkgEqual(pkgEqualSpec: PkgEqualSpec!): [PkgEqual!]!
}

extend type Mutation {
  "Adds a certification that two packages are similar."
  ingestPkgEqual(pkg: PkgInputSpec!, otherPackage: PkgInputSpec!, pkgEqual: PkgEqualInputSpec!): PkgEqual!
}
`, BuiltIn: false},
	{Name: "../schema/search.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

extend type Query {
  """
  findSoftware takes in a searchText string and looks for software
  that may be relevant for the input text. This can be seen as fuzzy search
  function for Packages, Sources and Artifacts. findSoftware returns a list
  of Packages, Sources and Artifacts that it determines to be relevant to
  the input searchText.

  Due to the nature of full text search being implemented differently on
  different db platforms, the behavior of findSoftware is not guaranteed
  to be the same. In addition, their statistical nature may result in
  results being different per call and not reproducible.

  All that is asked in the implementation of this API is that it follows
  the spirit of helping to retrieve the right nodes with best effort.

  Warning: This is an EXPERIMENTAL feature. This is subject to change.
  Warning: This is an OPTIONAL feature. Backends are not required to
  implement this API.
  """
  findSoftware(searchText: String!): [PackageSourceOrArtifact!]!
}
`, BuiltIn: false},
	{Name: "../schema/source.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the source trie/tree

"""
Source represents the root of the source trie/tree.

We map source information to a trie, as a derivative of the pURL specification:
each path in the trie represents a type, namespace, name and an optional
qualifier that stands for tag/commit information.

This node represents the type part of the trie path. It is used to represent
the version control system that is being used.

Since this node is at the root of the source trie, it is named Source, not
SourceType.
"""
type Source {
  id: ID!
  type: String!
  namespaces: [SourceNamespace!]!
}

"""
SourceNamespace is a namespace for sources.

This is the location of the repository (such as github/gitlab/bitbucket).

The namespace field is mandatory.
"""
type SourceNamespace {
  id: ID!
  namespace: String!
  names: [SourceName!]!
}

"""
SourceName represents the url of the repository.

The name field is mandatory. The tag and commit fields are optional, but it is
an error to specify both.

This is the only source trie node that can be referenced by other parts of GUAC.
"""
type SourceName {
  id: ID!
  name: String!
  tag: String
  commit: String
}

"""
SourceSpec allows filtering the list of sources to return in a query.

Empty string at a field means matching with the empty string. Missing field
means retrieving all possible matches.

It is an error to specify both tag and commit fields, except it both are set as
empty string (in which case the returned sources are only those for which there
is no tag/commit information).
"""
input SourceSpec {
  id: ID
  type: String
  namespace: String
  name: String
  tag: String
  commit: String
}

"""
SourceInputSpec specifies a source for mutations.

This is different than SourceSpec because we want to encode that all fields
except tag and commit are mandatory fields. All optional fields are given empty
default values.

It is an error to set both tag and commit fields to values different than the
default.
"""
input SourceInputSpec {
  type: String!
  namespace: String!
  name: String!
  tag: String = ""
  commit: String = ""
}

extend type Query {
  "Returns all sources matching a filter."
  sources(sourceSpec: SourceSpec!): [Source!]!
}

extend type Mutation {
  "Ingests a new source and returns the corresponding source trie path."
  ingestSource(source: SourceInputSpec!): Source!
  "Bulk ingests sources and returns the list of corresponding source trie path."
  ingestSources(sources: [SourceInputSpec!]!): [Source!]!
}
`, BuiltIn: false},
	{Name: "../schema/vulnEqual.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema to link vulnerabilities together

"""
VulnEqual is an attestation to link two vulnerabilities together as being equal"

Note that setting noVuln vulnerability type is invalid for VulnEqual!

"""
type VulnEqual {
  id: ID!
  "Collection of vulnerabilities that are similar"
  vulnerabilities: [Vulnerability!]!
  "Justification for the attested relationship"
  justification: String!
  "Document from which this attestation is generated from"
  origin: String!
  "GUAC collector for the document"
  collector: String!
}

"""
VulnEqualSpec allows filtering the list of vulnerability links to return
in a query.
"""
input VulnEqualSpec {
  id: ID
  vulnerabilities: [VulnerabilitySpec]
  justification: String
  origin: String
  collector: String
}

"VulnEqualInputSpec represents the input to link vulnerabilities to each other."
input VulnEqualInputSpec {
  justification: String!
  origin: String!
  collector: String!
}

extend type Query {
  "Returns all equal vulnerability mappings that match a filter."
  vulnEqual(vulnEqualSpec: VulnEqualSpec!): [VulnEqual!]!
}

extend type Mutation {
  "Ingest a mapping between vulnerabilities."
  ingestVulnEqual(vulnerability: VulnerabilityInputSpec!, otherVulnerability: VulnerabilityInputSpec!, vulnEqual: VulnEqualInputSpec!): VulnEqual!
}
`, BuiltIn: false},
	{Name: "../schema/vulnerability.graphql", Input: `#
# Copyright 2023 The GUAC Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This is experimental and might change in the future!

# Defines a GraphQL schema for the vulnerability trie/tree

"""
Vulnerability represents the root of the vulnerability trie/tree.

We map vulnerability information to a trie, as a derivative of the pURL specification:
each path in the trie represents a type and a vulnerability ID. This allows for generic
representation of the various vulnerabilities and does not limit to just cve, ghsa or osv. 
This would be in the general format: vuln://<general-type>/<vuln-id>

Examples:

CVE, using path separator: vuln://cve/cve-2023-20753
OSV, representing its knowledge of a GHSA: vuln://osv/ghsa-205hk
Random vendor: vuln://snyk/sn-whatever
NoVuln: vuln://novuln/


This node represents the type part of the trie path. It is used to represent
the specific type of the vulnerability: cve, ghsa, osv or some other vendor specific

Since this node is at the root of the vulnerability trie, it is named Vulnerability, not
VulnerabilityType.

NoVuln is a special vulnerability node to attest that no vulnerability has been
found during a vulnerability scan. It will have the type "novuln" and contain an empty string 
for vulnerabilityID

The resolvers will enforce that both the type and vulnerability IDs are lower case.
"""
type Vulnerability {
  id: ID!
  type: String!
  vulnerabilityIDs: [VulnerabilityID!]!
}

"""
VulnerabilityID is a specific vulnerability ID associated with the type of the vulnerability.

This will be enforced to be all lowercase.

The namespace field is mandatory.
"""
type VulnerabilityID {
  id: ID!
  vulnerabilityID: String!
}

"""
VulnerabilitySpec allows filtering the list of vulnerabilities to return in a query.

Use null to match on all values at that level. 
For example, to get all vulnerabilities in GUAC backend, use a VulnSpec
where every field is null.

"""
input VulnerabilitySpec {
  id: ID
  type: String
  vulnerabilityID: String
}

"""
VulnInputSpec specifies a vulnerability for mutations.

This is different than VulnSpec because we want to encode mandatory fields:
type and vulnerabilityID.
"""
input VulnerabilityInputSpec {
  type: String!
  vulnerabilityID: String!
}

extend type Query {
  "Returns all vulnerabilities matching a filter."
  vulnerabilities(vulnSpec: VulnerabilitySpec!): [Vulnerability!]!
}

extend type Mutation {
  "Ingests a new vulnerability and returns the corresponding vulnerability trie path."
  ingestVulnerability(vuln: VulnerabilityInputSpec!): Vulnerability!
  "Bulk ingests vulnerabilities and returns the list of corresponding vulnerability trie path."
  ingestVulnerabilities(vulns: [VulnerabilityInputSpec!]!): [Vulnerability!]!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
