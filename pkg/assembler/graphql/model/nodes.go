// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

// Artifact represents the artifact and contains a digest field
//
// algorithm is mandatory in the from strings.ToLower(string(checksum.Algorithm)) (sha256, sha1...etc)
// digest is mandatory in the form checksum.Value.
type Artifact struct {
	Algorithm string `json:"algorithm"`
	Digest    string `json:"digest"`
}

// ArtifactSpec allows filtering the list of artifacts to return.
type ArtifactSpec struct {
	Algorithm *string `json:"algorithm"`
	Digest    *string `json:"digest"`
}

// Builder represents the builder such as (FRSCA or github actions) and contains a uri field
//
// uri is mandatory and represents the specific builder.
//
// This node is a singleton: backends guarantee that there is exactly one node with
// the same `uri` value.
type Builder struct {
	URI string `json:"uri"`
}

// BuilderSpec allows filtering the list of builders to return.
type BuilderSpec struct {
	URI *string `json:"uri"`
}

// CVE represents common vulnerabilities and exposures. It contains the year along
// with the CVE ID.
//
// year is mandatory.
//
// This node is a singleton: backends guarantee that there is exactly one node with
// the same `year` value.
type Cve struct {
	Year  string   `json:"year"`
	CveID []*CVEId `json:"cveId"`
}

// CVEId is the actual ID that is given to a specific vulnerability
//
// id field is mandatory.
//
// This node can be referred to by other parts of GUAC.
type CVEId struct {
	ID string `json:"id"`
}

// CVESpec allows filtering the list of cves to return.
type CVESpec struct {
	Year  *string `json:"year"`
	CveID *string `json:"cveId"`
}

// GHSA represents github security advisory. It contains the ghsa ID (GHSA-pgvh-p3g4-86jw)
type Ghsa struct {
	GhsaID []*GHSAId `json:"ghsaId"`
}

// GHSAId is the actual ID that is given to a specific vulnerability on github
//
// id field is mandatory.
//
// This node can be referred to by other parts of GUAC.
type GHSAId struct {
	ID string `json:"id"`
}

// GHSASpec allows filtering the list of ghsa to return.
type GHSASpec struct {
	GhsaID *string `json:"ghsaId"`
}

// HasSBOM is an attestation represents that a package object or source object has an SBOM associated with a uri
//
// Package - the package object type that represents the package
// Source - the source object type that represents the source
// uri - identifier string for the SBOM
// Origin - where this attestation was generated from (based on which document)
// Collector - the GUAC collector that collected the document that generated this attestation
//
// Note: Only package object or source object can be defined. Not both.
type HasSbom struct {
	Package   *Package `json:"package"`
	Source    *Source  `json:"source"`
	URI       string   `json:"uri"`
	Origin    string   `json:"origin"`
	Collector string   `json:"collector"`
}

// HashEqualSpec allows filtering the list of HasSBOM to return.
//
// Only the package or source can be added, not both. HasSourceAt will be used to create the package to source
// relationship.
type HasSBOMSpec struct {
	Package   *PkgSpec    `json:"package"`
	Source    *SourceSpec `json:"source"`
	URI       *string     `json:"uri"`
	Origin    *string     `json:"origin"`
	Collector *string     `json:"collector"`
}

// HashEqual is an attestation that represents when two artifact hash are similar based on a justification.
//
// Justification - string value representing why the artifacts are the equal
// Origin - where this attestation was generated from (based on which document)
// Collector - the GUAC collector that collected the document that generated this attestation
// Artifacts - the artifacts (represented by algorithm and digest) that are equal
type HashEqual struct {
	Justification string      `json:"justification"`
	Artifacts     []*Artifact `json:"artifacts"`
	Origin        string      `json:"origin"`
	Collector     string      `json:"collector"`
}

// HashEqualSpec allows filtering the list of HashEqual to return.
//
// Specifying just the artifacts allows to query for all equivalent artifacts (if they exist)
type HashEqualSpec struct {
	Justification *string         `json:"justification"`
	Artifacts     []*ArtifactSpec `json:"artifacts"`
	Origin        *string         `json:"origin"`
	Collector     *string         `json:"collector"`
}

// IsDependency is an attestation that represents when a package is dependent on another package
//
// Package - the package object type that represents the package
// dependentPackage - the package object type that represents the packageName (cannot be to the packageVersion)
// VersionRange - string value for version range that applies to the dependent package
// Justification - string value representing why the artifacts are the equal
// Origin - where this attestation was generated from (based on which document)
// Collector - the GUAC collector that collected the document that generated this attestation
type IsDependency struct {
	Package          *Package `json:"package"`
	DependentPackage *Package `json:"dependentPackage"`
	VersionRange     string   `json:"versionRange"`
	Justification    string   `json:"justification"`
	Origin           string   `json:"origin"`
	Collector        string   `json:"collector"`
}

// IsDependencySpec allows filtering the list of IsDependency to return.
//
// Note: the package object must be defined to return its dependent packages.
// Dependent Packages must represent the packageName (cannot be the packageVersion)
type IsDependencySpec struct {
	Package          *PkgSpec     `json:"package"`
	DependentPackage *PkgNameSpec `json:"dependentPackage"`
	VersionRange     *string      `json:"versionRange"`
	Justification    *string      `json:"justification"`
	Origin           *string      `json:"origin"`
	Collector        *string      `json:"collector"`
}

// IsOccurrence is an attestation represents when either a package or source is represented by an artifact
// Justification - string value representing why the package or source is represented by the specified artifact
// Package - the package object type that represents the package
// Source - the source object type that represents the source
// occurrenceArtifacts - list of artifacts that represent the the package or source
// Origin - where this attestation was generated from (based on which document)
// Collector - the GUAC collector that collected the document that generated this attestation
//
// Note: Package or Source must be specified but not both at the same time.
// Attestation must occur at the PackageName or the PackageVersion or at the SourceName.
//
// IsOccurrence does not connect a package with a source.
// HasSourceAt attestation will be used to connect a package with a source
type IsOccurrence struct {
	Justification       string      `json:"justification"`
	Package             *Package    `json:"package"`
	Source              *Source     `json:"source"`
	OccurrenceArtifacts []*Artifact `json:"occurrenceArtifacts"`
	Origin              string      `json:"origin"`
	Collector           string      `json:"collector"`
}

// IsOccurrenceSpec allows filtering the list of IsOccurrence to return.
// Note: Package or Source must be specified but not both at the same time
// For package - a PackageName or PackageVersion must be specified (name or name, version, qualifiers and subpath)
// For source - a SourceName must be specified (name, tag or commit)
type IsOccurrenceSpec struct {
	Justification *string         `json:"justification"`
	Package       *PkgSpec        `json:"package"`
	Source        *SourceSpec     `json:"source"`
	Artifacts     []*ArtifactSpec `json:"artifacts"`
	Origin        *string         `json:"origin"`
	Collector     *string         `json:"collector"`
}

// OSV represents Open Source Vulnerability . It contains a OSV ID.
type Osv struct {
	OsvID []*OSVId `json:"osvId"`
}

// OSVId is the actual ID that is given to a specific vulnerability
//
// id field is mandatory. This maps to a GHSA or CVE ID
//
// This node can be referred to by other parts of GUAC.
type OSVId struct {
	ID string `json:"id"`
}

// OSVSpec allows filtering the list of osv to return.
type OSVSpec struct {
	OsvID *string `json:"osvId"`
}

// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node with
// the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type Package struct {
	Type       string              `json:"type"`
	Namespaces []*PackageNamespace `json:"namespaces"`
}

// PackageName is a name for packages.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>` pURL.
//
// Names are always mandatory.
//
// This is the first node in the trie that can be referred to by other parts of
// GUAC.
type PackageName struct {
	Name     string            `json:"name"`
	Versions []*PackageVersion `json:"versions"`
}

// PackageNamespace is a namespace for packages.
//
// In the pURL representation, each PackageNamespace matches the
// `pkg:<type>/<namespace>/` partial pURL.
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type PackageNamespace struct {
	Namespace string         `json:"namespace"`
	Names     []*PackageName `json:"names"`
}

// PackageQualifier is a qualifier for a package, a key-value pair.
//
// In the pURL representation, it is a part of the `<qualifiers>` part of the
// `pkg:<type>/<namespace>/<name>@<version>?<qualifiers>` pURL.
//
// Qualifiers are optional, each Package type defines own rules for handling them,
// and multiple qualifiers could be attached to the same package.
//
// This node cannot be directly referred by other parts of GUAC.
type PackageQualifier struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// PackageQualifierInput is the same as PackageQualifier, but usable as query
// input.
//
// GraphQL does not allow input types to contain composite types and does not allow
// composite types to contain input types. So, although in this case these two
// types are semantically the same, we have to duplicate the definition.
//
// Keys are mandatory, but values could also be `null` if we want to match all
// values for a specific key.
//
// TODO(mihaimaruseac): Formalize empty vs null when the schema is fully done
type PackageQualifierInput struct {
	Key   string  `json:"key"`
	Value *string `json:"value"`
}

// PackageVersion is a package version.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>@<version>` pURL.
//
// Versions are optional and each Package type defines own rules for handling them.
// For this level of GUAC, these are just opaque strings.
//
// This node can be referred to by other parts of GUAC.
//
// Subpath and qualifiers are optional. Lack of qualifiers is represented by an
// empty list and lack of subpath by empty string (to be consistent with
// optionality of namespace and version). Two nodes that have different qualifiers
// and/or subpath but the same version mean two different packages in the trie
// (they are different). Two nodes that have same version but qualifiers of one are
// a subset of the qualifier of the other also mean two different packages in the
// trie.
type PackageVersion struct {
	Version    string              `json:"version"`
	Qualifiers []*PackageQualifier `json:"qualifiers"`
	Subpath    string              `json:"subpath"`
}

// PkgNameSpec is used for IsDependency to input dependent packages. This is different from PkgSpec
// as the IsDependency attestation should only be allowed to be made to the packageName node and not the
// packageVersion node. Versions will be handled by the version_range in the IsDependency attestation node.
type PkgNameSpec struct {
	Type      *string `json:"type"`
	Namespace *string `json:"namespace"`
	Name      *string `json:"name"`
}

// PkgSpec allows filtering the list of packages to return.
//
// Each field matches a qualifier from pURL. Use `null` to match on all values at
// that level. For example, to get all packages in GUAC backend, use a PkgSpec
// where every field is `null`.
//
// Empty string at a field means matching with the empty string. If passing in
// qualifiers, all of the values in the list must match. Since we want to return
// nodes with any number of qualifiers if no qualifiers are passed in the input, we
// must also return the same set of nodes it the qualifiers list is empty. To match
// on nodes that don't contain any qualifier, set `matchOnlyEmptyQualifiers` to
// true. If this field is true, then the qualifiers argument is ignored.
type PkgSpec struct {
	Type                     *string                  `json:"type"`
	Namespace                *string                  `json:"namespace"`
	Name                     *string                  `json:"name"`
	Version                  *string                  `json:"version"`
	Qualifiers               []*PackageQualifierInput `json:"qualifiers"`
	MatchOnlyEmptyQualifiers *bool                    `json:"matchOnlyEmptyQualifiers"`
	Subpath                  *string                  `json:"subpath"`
}

// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node with
// the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type Source struct {
	Type       string             `json:"type"`
	Namespaces []*SourceNamespace `json:"namespaces"`
}

// SourceName is a url of the repository and its tag or commit.
//
// SourceName is mandatory. Either a tag or commit needs to be specified.
//
// This is the first node in the trie that can be referred to by other parts of
// GUAC.
type SourceName struct {
	Name   string  `json:"name"`
	Tag    *string `json:"tag"`
	Commit *string `json:"commit"`
}

// SourceNamespace is a namespace for sources.
//
// This can be represented as the location of the repo (such as github/gitlab/bitbucket)
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type SourceNamespace struct {
	Namespace string        `json:"namespace"`
	Names     []*SourceName `json:"names"`
}

// SourceQualifierInput is the same as SourceQualifier, but usable as query
// input.
type SourceQualifierInput struct {
	Tag    *string `json:"tag"`
	Commit *string `json:"commit"`
}

// SourceSpec allows filtering the list of sources to return.
//
// Empty string at a field means matching with the empty string.
type SourceSpec struct {
	Type      *string               `json:"type"`
	Namespace *string               `json:"namespace"`
	Name      *string               `json:"name"`
	Qualifier *SourceQualifierInput `json:"qualifier"`
}
