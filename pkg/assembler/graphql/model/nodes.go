// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

// CveOrGhsa is a union of CVE and GHSA.
type CveOrGhsa interface {
	IsCveOrGhsa()
}

// Node is a union type of all the possible nodes.
//
// It encapsulates the software tree nodes along with the evidence nodes. In a
// path query, all connecting evidence nodes along with their intermediate subject
// nodes need to be returned in order to create a complete graph.
type Node interface {
	IsNode()
}

// PackageOrArtifact is a union of Package and Artifact.
type PackageOrArtifact interface {
	IsPackageOrArtifact()
}

// PackageOrSource is a union of Package and Source. Any of these objects can be specified
type PackageOrSource interface {
	IsPackageOrSource()
}

// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type PackageSourceOrArtifact interface {
	IsPackageSourceOrArtifact()
}

// Vulnerability is a union of OSV, CVE, GHSA or the NoVuln node.
type Vulnerability interface {
	IsVulnerability()
}

// Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type Artifact struct {
	ID        string `json:"id"`
	Algorithm string `json:"algorithm"`
	Digest    string `json:"digest"`
}

func (Artifact) IsPackageSourceOrArtifact() {}

func (Artifact) IsPackageOrArtifact() {}

func (Artifact) IsNode() {}

// ArtifactInputSpec is the same as Artifact, but used as mutation input.
//
// Both arguments will be canonicalized to lowercase.
type ArtifactInputSpec struct {
	Algorithm string `json:"algorithm"`
	Digest    string `json:"digest"`
}

// ArtifactSpec allows filtering the list of artifacts to return.
//
// Both arguments will be canonicalized to lowercase.
type ArtifactSpec struct {
	ID        *string `json:"id,omitempty"`
	Algorithm *string `json:"algorithm,omitempty"`
	Digest    *string `json:"digest,omitempty"`
}

// Builder represents the builder such as (FRSCA or github actions).
//
// Currently builders are identified by the `uri` field, which is mandatory.
type Builder struct {
	ID  string `json:"id"`
	URI string `json:"uri"`
}

func (Builder) IsNode() {}

// BuilderInputSpec is the same as Builder, but used for mutation ingestion.
type BuilderInputSpec struct {
	URI string `json:"uri"`
}

// BuilderSpec allows filtering the list of builders to return.
type BuilderSpec struct {
	ID  *string `json:"id,omitempty"`
	URI *string `json:"uri,omitempty"`
}

// CVE represents common vulnerabilities and exposures. It contains the year along
// with the CVE ID.
//
// The `year` is mandatory.
// The `cveId` field is mandatory and canonicalized to be lowercase.
//
// This node can be referred to by other parts of GUAC.
type Cve struct {
	ID    string `json:"id"`
	Year  int    `json:"year"`
	CveID string `json:"cveId"`
}

func (Cve) IsVulnerability() {}

func (Cve) IsCveOrGhsa() {}

func (Cve) IsNode() {}

// CVEInputSpec is the same as CVESpec, but used for mutation ingestion.
type CVEInputSpec struct {
	Year  int    `json:"year"`
	CveID string `json:"cveId"`
}

// CVESpec allows filtering the list of cves to return.
type CVESpec struct {
	ID    *string `json:"id,omitempty"`
	Year  *int    `json:"year,omitempty"`
	CveID *string `json:"cveId,omitempty"`
}

// CertifyBad is an attestation represents when a package, source or artifact is considered bad
//
// subject - union type that can be either a package, source or artifact object type
// justification (property) - string value representing why the subject is considered bad
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
//
// Note: Attestation must occur at the PackageName or the PackageVersion or at the SourceName.
type CertifyBad struct {
	ID            string                  `json:"id"`
	Subject       PackageSourceOrArtifact `json:"subject"`
	Justification string                  `json:"justification"`
	Origin        string                  `json:"origin"`
	Collector     string                  `json:"collector"`
}

func (CertifyBad) IsNode() {}

// CertifyBadInputSpec is the same as CertifyBad but for mutation input.
//
// All fields are required.
type CertifyBadInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// CertifyBadSpec allows filtering the list of CertifyBad to return.
// Note: Package, Source or artifact must be specified but not at the same time
// For package - a PackageName or PackageVersion must be specified (name or name, version, qualifiers and subpath)
// For source - a SourceName must be specified (name, tag or commit)
type CertifyBadSpec struct {
	ID            *string                      `json:"id,omitempty"`
	Subject       *PackageSourceOrArtifactSpec `json:"subject,omitempty"`
	Justification *string                      `json:"justification,omitempty"`
	Origin        *string                      `json:"origin,omitempty"`
	Collector     *string                      `json:"collector,omitempty"`
}

// CertifyGood is an attestation represents when a package, source or artifact is considered good
//
// subject - union type that can be either a package, source or artifact object type
// justification (property) - string value representing why the subject is considered good
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
//
// Note: Attestation must occur at the PackageName or the PackageVersion or at the SourceName.
type CertifyGood struct {
	ID            string                  `json:"id"`
	Subject       PackageSourceOrArtifact `json:"subject"`
	Justification string                  `json:"justification"`
	Origin        string                  `json:"origin"`
	Collector     string                  `json:"collector"`
}

func (CertifyGood) IsNode() {}

// CertifyGoodInputSpec is the same as CertifyGood but for mutation input.
//
// All fields are required.
type CertifyGoodInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// CertifyGoodSpec allows filtering the list of CertifyGood to return.
// Note: Package, Source or artifact must be specified but not at the same time
// For package - a PackageName or PackageVersion must be specified (name or name, version, qualifiers and subpath)
// For source - a SourceName must be specified (name, tag or commit)
type CertifyGoodSpec struct {
	ID            *string                      `json:"id,omitempty"`
	Subject       *PackageSourceOrArtifactSpec `json:"subject,omitempty"`
	Justification *string                      `json:"justification,omitempty"`
	Origin        *string                      `json:"origin,omitempty"`
	Collector     *string                      `json:"collector,omitempty"`
}

// CertifyScorecard is an attestation which represents the scorecard of a
// particular source repository.
type CertifyScorecard struct {
	ID string `json:"id"`
	// The source repository that is being scanned (attestation subject)
	Source *Source `json:"source"`
	// The Scorecard attached to the repository (attestation object)
	Scorecard *Scorecard `json:"scorecard"`
}

func (CertifyScorecard) IsNode() {}

// CertifyScorecardSpec allows filtering the list of CertifyScorecard to return.
type CertifyScorecardSpec struct {
	ID               *string               `json:"id,omitempty"`
	Source           *SourceSpec           `json:"source,omitempty"`
	TimeScanned      *time.Time            `json:"timeScanned,omitempty"`
	AggregateScore   *float64              `json:"aggregateScore,omitempty"`
	Checks           []*ScorecardCheckSpec `json:"checks,omitempty"`
	ScorecardVersion *string               `json:"scorecardVersion,omitempty"`
	ScorecardCommit  *string               `json:"scorecardCommit,omitempty"`
	Origin           *string               `json:"origin,omitempty"`
	Collector        *string               `json:"collector,omitempty"`
}

// CertifyVEXStatement is an attestation that represents when a package or
// artifact has a VEX about a specific vulnerability (CVE, GHSA or OSV).
type CertifyVEXStatement struct {
	ID string `json:"id"`
	// Subject of attestation
	Subject PackageOrArtifact `json:"subject"`
	// Attested vulnerability
	Vulnerability Vulnerability `json:"vulnerability"`
	// Justification for VEX
	Justification string `json:"justification"`
	// Timestamp (exact time in RFC 3339 format) for the VEX statement
	KnownSince time.Time `json:"knownSince"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

func (CertifyVEXStatement) IsNode() {}

// CertifyVEXStatementSpec allows filtering the list of CertifyVEXStatement to
// return.
//
// Only one subject type (package or artifact) and one vulnerability type (CVE,
// GHSA or OSV) may be specified.
//
// Note that setting `noVuln` in VulnerabilitySpec is invalid for VEX statements!
type CertifyVEXStatementSpec struct {
	ID            *string                `json:"id,omitempty"`
	Subject       *PackageOrArtifactSpec `json:"subject,omitempty"`
	Vulnerability *VulnerabilitySpec     `json:"vulnerability,omitempty"`
	Justification *string                `json:"justification,omitempty"`
	KnownSince    *time.Time             `json:"knownSince,omitempty"`
	Origin        *string                `json:"origin,omitempty"`
	Collector     *string                `json:"collector,omitempty"`
}

// CertifyVuln is an attestation that represents when a package has a
// vulnerability (OSV, CVE, or GHSA) or the special NoVuln value to attest that at
// the time of scanning no vulnerability was found.
type CertifyVuln struct {
	ID string `json:"id"`
	// The package that is attested
	Package *Package `json:"package"`
	// The vulnerability object. Can be an OSV, CVE, or GHSA or the special NoVuln node.
	Vulnerability Vulnerability `json:"vulnerability"`
	// Metadata attached to the certification
	Metadata *VulnerabilityMetaData `json:"metadata"`
}

func (CertifyVuln) IsNode() {}

// CertifyVulnSpec allows filtering the list of CertifyVuln to return.
//
// Specifying just the package allows to query for all vulnerabilities associated
// with the package.
//
// Only one vulnerability type (OSV, CVE, GHSA, or special NoVuln) may be specified.
type CertifyVulnSpec struct {
	ID             *string            `json:"id,omitempty"`
	Package        *PkgSpec           `json:"package,omitempty"`
	Vulnerability  *VulnerabilitySpec `json:"vulnerability,omitempty"`
	TimeScanned    *time.Time         `json:"timeScanned,omitempty"`
	DbURI          *string            `json:"dbUri,omitempty"`
	DbVersion      *string            `json:"dbVersion,omitempty"`
	ScannerURI     *string            `json:"scannerUri,omitempty"`
	ScannerVersion *string            `json:"scannerVersion,omitempty"`
	Origin         *string            `json:"origin,omitempty"`
	Collector      *string            `json:"collector,omitempty"`
}

// CveOrGhsaInput allows using CveOrGhsa union as
// input type to be used in mutations.
// Exactly one of the value must be set to non-nil.
type CveOrGhsaInput struct {
	Cve  *CVEInputSpec  `json:"cve,omitempty"`
	Ghsa *GHSAInputSpec `json:"ghsa,omitempty"`
}

// CveOrGhsaSpec allows using CveOrGhsa union as
// input type to be used in read queries.
// Exactly one of the value must be set to non-nil.
type CveOrGhsaSpec struct {
	Cve  *CVESpec  `json:"cve,omitempty"`
	Ghsa *GHSASpec `json:"ghsa,omitempty"`
}

// GHSA represents GitHub security advisories.
//
// The `id` field is mandatory and canonicalized to be lowercase.
//
// This node can be referred to by other parts of GUAC.
type Ghsa struct {
	ID     string `json:"id"`
	GhsaID string `json:"ghsaId"`
}

func (Ghsa) IsVulnerability() {}

func (Ghsa) IsCveOrGhsa() {}

func (Ghsa) IsNode() {}

// GHSAInputSpec is the same as GHSASpec, but used for mutation ingestion.
type GHSAInputSpec struct {
	GhsaID string `json:"ghsaId"`
}

// GHSASpec allows filtering the list of GHSA to return.
//
// The argument will be canonicalized to lowercase.
type GHSASpec struct {
	ID     *string `json:"id,omitempty"`
	GhsaID *string `json:"ghsaId,omitempty"`
}

// HasSBOM is an attestation represents that a package object or source object has an SBOM associated with a uri
//
// subject - union type that can be either a package or source object type
// uri (property) - identifier string for the SBOM
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
//
// Note: Only package object or source object can be defined. Not both.
type HasSbom struct {
	ID        string          `json:"id"`
	Subject   PackageOrSource `json:"subject"`
	URI       string          `json:"uri"`
	Origin    string          `json:"origin"`
	Collector string          `json:"collector"`
}

func (HasSbom) IsNode() {}

// HasSBOMInputSpec is the same as HasSBOM but for mutation input.
//
// All fields are required.
type HasSBOMInputSpec struct {
	URI       string `json:"uri"`
	Origin    string `json:"origin"`
	Collector string `json:"collector"`
}

// HashEqualSpec allows filtering the list of HasSBOM to return.
//
// Only the package or source can be added, not both. HasSourceAt will be used to create the package to source
// relationship.
type HasSBOMSpec struct {
	ID        *string              `json:"id,omitempty"`
	Subject   *PackageOrSourceSpec `json:"subject,omitempty"`
	URI       *string              `json:"uri,omitempty"`
	Origin    *string              `json:"origin,omitempty"`
	Collector *string              `json:"collector,omitempty"`
}

// HasSLSA records that a subject node has a SLSA attestation.
type HasSlsa struct {
	ID string `json:"id"`
	// The subject of SLSA attestation: package, source, or artifact.
	Subject *Artifact `json:"subject"`
	// The SLSA attestation.
	Slsa *Slsa `json:"slsa"`
}

func (HasSlsa) IsNode() {}

// HasSLSASpec allows filtering the list of HasSLSA to return.
type HasSLSASpec struct {
	ID          *string              `json:"id,omitempty"`
	Subject     *ArtifactSpec        `json:"subject,omitempty"`
	BuiltFrom   []*ArtifactSpec      `json:"builtFrom,omitempty"`
	BuiltBy     *BuilderSpec         `json:"builtBy,omitempty"`
	BuildType   *string              `json:"buildType,omitempty"`
	Predicate   []*SLSAPredicateSpec `json:"predicate,omitempty"`
	SlsaVersion *string              `json:"slsaVersion,omitempty"`
	StartedOn   *time.Time           `json:"startedOn,omitempty"`
	FinishedOn  *time.Time           `json:"finishedOn,omitempty"`
	Origin      *string              `json:"origin,omitempty"`
	Collector   *string              `json:"collector,omitempty"`
}

// HasSourceAt is an attestation represents that a package object has a source object since a timestamp
//
// package (subject) - the package object type that represents the package
// source (object) - the source object type that represents the source
// knownSince (property) - timestamp when this was last checked (exact time)
// justification (property) - string value representing why the package has a source specified
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type HasSourceAt struct {
	ID            string    `json:"id"`
	Package       *Package  `json:"package"`
	Source        *Source   `json:"source"`
	KnownSince    time.Time `json:"knownSince"`
	Justification string    `json:"justification"`
	Origin        string    `json:"origin"`
	Collector     string    `json:"collector"`
}

func (HasSourceAt) IsNode() {}

// HasSourceAtInputSpec is the same as HasSourceAt but for mutation input.
//
// All fields are required.
type HasSourceAtInputSpec struct {
	KnownSince    time.Time `json:"knownSince"`
	Justification string    `json:"justification"`
	Origin        string    `json:"origin"`
	Collector     string    `json:"collector"`
}

// HasSourceAtSpec allows filtering the list of HasSourceAt to return.
type HasSourceAtSpec struct {
	ID            *string     `json:"id,omitempty"`
	Package       *PkgSpec    `json:"package,omitempty"`
	Source        *SourceSpec `json:"source,omitempty"`
	KnownSince    *time.Time  `json:"knownSince,omitempty"`
	Justification *string     `json:"justification,omitempty"`
	Origin        *string     `json:"origin,omitempty"`
	Collector     *string     `json:"collector,omitempty"`
}

// HashEqual is an attestation that represents when two artifact hash are similar based on a justification.
//
// artifacts (subject) - the artifacts (represented by algorithm and digest) that are equal
// justification (property) - string value representing why the artifacts are the equal
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type HashEqual struct {
	ID            string      `json:"id"`
	Artifacts     []*Artifact `json:"artifacts"`
	Justification string      `json:"justification"`
	Origin        string      `json:"origin"`
	Collector     string      `json:"collector"`
}

func (HashEqual) IsNode() {}

// HashEqualInputSpec is the same as HashEqual but for mutation input.
//
// All fields are required.
type HashEqualInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// HashEqualSpec allows filtering the list of HashEqual to return.
//
// Specifying just the artifacts allows to query for all equivalent artifacts (if they exist)
type HashEqualSpec struct {
	ID            *string         `json:"id,omitempty"`
	Artifacts     []*ArtifactSpec `json:"artifacts,omitempty"`
	Justification *string         `json:"justification,omitempty"`
	Origin        *string         `json:"origin,omitempty"`
	Collector     *string         `json:"collector,omitempty"`
}

// IsDependency is an attestation that represents when a package is dependent on another package
//
// package (subject) - the package object type that represents the package
// dependentPackage (object) - the package object type that represents the packageName (cannot be to the packageVersion)
// versionRange (property) - string value for version range that applies to the dependent package
// justification (property) - string value representing why the artifacts are the equal
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type IsDependency struct {
	ID               string   `json:"id"`
	Package          *Package `json:"package"`
	DependentPackage *Package `json:"dependentPackage"`
	VersionRange     string   `json:"versionRange"`
	Justification    string   `json:"justification"`
	Origin           string   `json:"origin"`
	Collector        string   `json:"collector"`
}

func (IsDependency) IsNode() {}

// IsDependencyInputSpec is the same as IsDependency but for mutation input.
//
// All fields are required.
type IsDependencyInputSpec struct {
	VersionRange  string `json:"versionRange"`
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// IsDependencySpec allows filtering the list of IsDependency to return.
//
// Note: the package object must be defined to return its dependent packages.
// Dependent Packages must represent the packageName (cannot be the packageVersion)
type IsDependencySpec struct {
	ID               *string      `json:"id,omitempty"`
	Package          *PkgSpec     `json:"package,omitempty"`
	DependentPackage *PkgNameSpec `json:"dependentPackage,omitempty"`
	VersionRange     *string      `json:"versionRange,omitempty"`
	Justification    *string      `json:"justification,omitempty"`
	Origin           *string      `json:"origin,omitempty"`
	Collector        *string      `json:"collector,omitempty"`
}

// IsOccurrence is an attestation represents when either a package or source is represented by an artifact
//
// Note: Package or Source must be specified but not both at the same time.
// Attestation must occur at the PackageVersion or at the SourceName.
type IsOccurrence struct {
	ID string `json:"id"`
	// subject - union type that can be either a package or source object type
	Subject PackageOrSource `json:"subject"`
	// artifact (object) - artifact that represent the the package or source
	Artifact *Artifact `json:"artifact"`
	// justification (property) - string value representing why the package or source is represented by the specified artifact
	Justification string `json:"justification"`
	// origin (property) - where this attestation was generated from (based on which document)
	Origin string `json:"origin"`
	// collector (property) - the GUAC collector that collected the document that generated this attestation
	Collector string `json:"collector"`
}

func (IsOccurrence) IsNode() {}

// IsOccurrenceInputSpec is the same as IsOccurrence but for mutation input.
//
// All fields are required.
type IsOccurrenceInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// IsOccurrenceSpec allows filtering the list of IsOccurrence to return.
// Note: Package or Source must be specified but not both at the same time
// For package - PackageVersion must be specified (version, qualifiers and subpath)
// or it defaults to empty string for version, subpath and empty list for qualifiers
// For source - a SourceName must be specified (name, tag or commit)
type IsOccurrenceSpec struct {
	ID            *string              `json:"id,omitempty"`
	Subject       *PackageOrSourceSpec `json:"subject,omitempty"`
	Artifact      *ArtifactSpec        `json:"artifact,omitempty"`
	Justification *string              `json:"justification,omitempty"`
	Origin        *string              `json:"origin,omitempty"`
	Collector     *string              `json:"collector,omitempty"`
}

// IsVulnerability is an attestation that represents when an OSV ID represents a CVE or GHSA
//
// osv (subject) - the osv object type that represents OSV and its ID
// vulnerability (object) - union type that consists of cve or ghsa
// justification (property) - the reason why the osv ID represents the cve or ghsa
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type IsVulnerability struct {
	ID            string    `json:"id"`
	Osv           *Osv      `json:"osv"`
	Vulnerability CveOrGhsa `json:"vulnerability"`
	Justification string    `json:"justification"`
	Origin        string    `json:"origin"`
	Collector     string    `json:"collector"`
}

func (IsVulnerability) IsNode() {}

// IsVulnerabilityInputSpec is the same as IsVulnerability but for mutation input.
//
// All fields are required.
type IsVulnerabilityInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// IsVulnerabilitySpec allows filtering the list of IsVulnerability to return.
// Only CVE or GHSA can be specified at once.
type IsVulnerabilitySpec struct {
	ID            *string        `json:"id,omitempty"`
	Osv           *OSVSpec       `json:"osv,omitempty"`
	Vulnerability *CveOrGhsaSpec `json:"vulnerability,omitempty"`
	Justification *string        `json:"justification,omitempty"`
	Origin        *string        `json:"origin,omitempty"`
	Collector     *string        `json:"collector,omitempty"`
}

// MatchFlags is used to input the PkgMatchType enum.
type MatchFlags struct {
	Pkg PkgMatchType `json:"pkg"`
}

// NoVuln is a special vulnerability node to attest that no vulnerability has been
// found during a vulnerability scan.
//
// Backends guarantee that this is a singleton node.
//
// We define an ID field due to GraphQL restrictions.
type NoVuln struct {
	ID string `json:"id"`
}

func (NoVuln) IsVulnerability() {}

func (NoVuln) IsNode() {}

// OSV represents an Open Source Vulnerability.
//
// The `osvId` field is mandatory and canonicalized to be lowercase.
//
// This maps to a vulnerability ID specific to the environment (e.g., GHSA ID or
// CVE ID).
//
// This node can be referred to by other parts of GUAC.
type Osv struct {
	ID    string `json:"id"`
	OsvID string `json:"osvId"`
}

func (Osv) IsVulnerability() {}

func (Osv) IsNode() {}

// OSVInputSpec is the same as OSVSpec, but used for mutation ingestion.
type OSVInputSpec struct {
	OsvID string `json:"osvId"`
}

// OSVSpec allows filtering the list of OSV to return.
type OSVSpec struct {
	ID    *string `json:"id,omitempty"`
	OsvID *string `json:"osvId,omitempty"`
}

// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type Package struct {
	ID         string              `json:"id"`
	Type       string              `json:"type"`
	Namespaces []*PackageNamespace `json:"namespaces"`
}

func (Package) IsPackageSourceOrArtifact() {}

func (Package) IsPackageOrArtifact() {}

func (Package) IsPackageOrSource() {}

func (Package) IsNode() {}

// PackageName is a name for packages.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>` pURL.
//
// Names are always mandatory.
//
// This is the first node in the trie that can be referred to by other parts of
// GUAC.
type PackageName struct {
	ID       string            `json:"id"`
	Name     string            `json:"name"`
	Versions []*PackageVersion `json:"versions"`
}

// PackageNamespace is a namespace for packages.
//
// In the pURL representation, each PackageNamespace matches the
// `pkg:<type>/<namespace>/` partial pURL.
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type PackageNamespace struct {
	ID        string         `json:"id"`
	Namespace string         `json:"namespace"`
	Names     []*PackageName `json:"names"`
}

// PackageOrArtifactInput allows using PackageOrArtifact union as
// input type to be used in mutations.
//
// Exactly one of the value must be set to non-nil.
type PackageOrArtifactInput struct {
	Package  *PkgInputSpec      `json:"package,omitempty"`
	Artifact *ArtifactInputSpec `json:"artifact,omitempty"`
}

// PackageOrArtifactSpec allows using PackageOrArtifact union as
// input type to be used in read queries.
//
// Exactly one of the value must be set to non-nil.
type PackageOrArtifactSpec struct {
	Package  *PkgSpec      `json:"package,omitempty"`
	Artifact *ArtifactSpec `json:"artifact,omitempty"`
}

// PackageOrSourceInput allows using PackageOrSource union as
// input type to be used in mutations.
// Exactly one of the value must be set to non-nil.
type PackageOrSourceInput struct {
	Package *PkgInputSpec    `json:"package,omitempty"`
	Source  *SourceInputSpec `json:"source,omitempty"`
}

// PackageOrSourceSpec allows using PackageOrSource union as
// input type to be used in read queries.
// Exactly one of the value must be set to non-nil.
type PackageOrSourceSpec struct {
	Package *PkgSpec    `json:"package,omitempty"`
	Source  *SourceSpec `json:"source,omitempty"`
}

// PackageQualifier is a qualifier for a package, a key-value pair.
//
// In the pURL representation, it is a part of the `<qualifiers>` part of the
// `pkg:<type>/<namespace>/<name>@<version>?<qualifiers>` pURL.
//
// Qualifiers are optional, each Package type defines own rules for handling them,
// and multiple qualifiers could be attached to the same package.
//
// This node cannot be directly referred by other parts of GUAC.
type PackageQualifier struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// PackageQualifierInputSpec is the same as PackageQualifier, but usable as
// mutation input.
//
// GraphQL does not allow input types to contain composite types and does not allow
// composite types to contain input types. So, although in this case these two
// types are semantically the same, we have to duplicate the definition.
//
// Both fields are mandatory.
type PackageQualifierInputSpec struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// PackageQualifierSpec is the same as PackageQualifier, but usable as query
// input.
//
// GraphQL does not allow input types to contain composite types and does not allow
// composite types to contain input types. So, although in this case these two
// types are semantically the same, we have to duplicate the definition.
//
// Keys are mandatory, but values could also be `null` if we want to match all
// values for a specific key.
//
// TODO(mihaimaruseac): Formalize empty vs null when the schema is fully done
type PackageQualifierSpec struct {
	Key   string  `json:"key"`
	Value *string `json:"value,omitempty"`
}

// PackageSourceOrArtifactInput allows using PackageSourceOrArtifact union as
// input type to be used in mutations.
//
// Exactly one of the value must be set to non-nil.
type PackageSourceOrArtifactInput struct {
	Package  *PkgInputSpec      `json:"package,omitempty"`
	Source   *SourceInputSpec   `json:"source,omitempty"`
	Artifact *ArtifactInputSpec `json:"artifact,omitempty"`
}

// PackageSourceOrArtifactSpec allows using PackageSourceOrArtifact union as
// input type to be used in read queries.
//
// Exactly one of the value must be set to non-nil.
type PackageSourceOrArtifactSpec struct {
	Package  *PkgSpec      `json:"package,omitempty"`
	Source   *SourceSpec   `json:"source,omitempty"`
	Artifact *ArtifactSpec `json:"artifact,omitempty"`
}

// PackageVersion is a package version.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>@<version>` pURL.
//
// Versions are optional and each Package type defines own rules for handling them.
// For this level of GUAC, these are just opaque strings.
//
// This node can be referred to by other parts of GUAC.
//
// Subpath and qualifiers are optional. Lack of qualifiers is represented by an
// empty list and lack of subpath by empty string (to be consistent with
// optionality of namespace and version). Two nodes that have different qualifiers
// and/or subpath but the same version mean two different packages in the trie
// (they are different). Two nodes that have same version but qualifiers of one are
// a subset of the qualifier of the other also mean two different packages in the
// trie.
type PackageVersion struct {
	ID         string              `json:"id"`
	Version    string              `json:"version"`
	Qualifiers []*PackageQualifier `json:"qualifiers"`
	Subpath    string              `json:"subpath"`
}

// PkgEqual is an attestation that represents when a package objects are similar
//
// packages (subject) - list of package objects
// justification (property) - string value representing why the packages are similar
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type PkgEqual struct {
	ID            string     `json:"id"`
	Packages      []*Package `json:"packages"`
	Justification string     `json:"justification"`
	Origin        string     `json:"origin"`
	Collector     string     `json:"collector"`
}

func (PkgEqual) IsNode() {}

// PkgEqualInputSpec is the same as PkgEqual but for mutation input.
//
// All fields are required.
type PkgEqualInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// PkgEqualSpec allows filtering the list of PkgEqual to return.
//
// Specifying just the package allows to query for all similar packages (if they exist)
type PkgEqualSpec struct {
	ID            *string    `json:"id,omitempty"`
	Packages      []*PkgSpec `json:"packages,omitempty"`
	Justification *string    `json:"justification,omitempty"`
	Origin        *string    `json:"origin,omitempty"`
	Collector     *string    `json:"collector,omitempty"`
}

// PkgInputSpec specifies a package for a mutation.
//
// This is different than PkgSpec because we want to encode mandatory fields:
// `type` and `name`. All optional fields are given empty default values.
type PkgInputSpec struct {
	Type       string                       `json:"type"`
	Namespace  *string                      `json:"namespace,omitempty"`
	Name       string                       `json:"name"`
	Version    *string                      `json:"version,omitempty"`
	Qualifiers []*PackageQualifierInputSpec `json:"qualifiers,omitempty"`
	Subpath    *string                      `json:"subpath,omitempty"`
}

// PkgNameSpec is used for IsDependency to input dependent packages. This is different from PkgSpec
// as the IsDependency attestation should only be allowed to be made to the packageName node and not the
// packageVersion node. Versions will be handled by the version_range in the IsDependency attestation node.
type PkgNameSpec struct {
	ID        *string `json:"id,omitempty"`
	Type      *string `json:"type,omitempty"`
	Namespace *string `json:"namespace,omitempty"`
	Name      *string `json:"name,omitempty"`
}

// PkgSpec allows filtering the list of packages to return.
//
// Each field matches a qualifier from pURL. Use `null` to match on all values at
// that level. For example, to get all packages in GUAC backend, use a PkgSpec
// where every field is `null`.
//
// Empty string at a field means matching with the empty string. If passing in
// qualifiers, all of the values in the list must match. Since we want to return
// nodes with any number of qualifiers if no qualifiers are passed in the input, we
// must also return the same set of nodes it the qualifiers list is empty. To match
// on nodes that don't contain any qualifier, set `matchOnlyEmptyQualifiers` to
// true. If this field is true, then the qualifiers argument is ignored.
type PkgSpec struct {
	ID                       *string                 `json:"id,omitempty"`
	Type                     *string                 `json:"type,omitempty"`
	Namespace                *string                 `json:"namespace,omitempty"`
	Name                     *string                 `json:"name,omitempty"`
	Version                  *string                 `json:"version,omitempty"`
	Qualifiers               []*PackageQualifierSpec `json:"qualifiers,omitempty"`
	MatchOnlyEmptyQualifiers *bool                   `json:"matchOnlyEmptyQualifiers,omitempty"`
	Subpath                  *string                 `json:"subpath,omitempty"`
}

// SLSA contains all of the fields present in a SLSA attestation.
//
// The materials and builders are objects of the HasSLSA predicate, everything
// else are properties extracted from the attestation.
//
// We also include fields to specify under what conditions the check was performed
// (time of scan, version of scanners, etc.) as well as how this information got
// included into GUAC (origin document and the collector for that document).
type Slsa struct {
	// Sources of the build resulting in subject (materials)
	BuiltFrom []*Artifact `json:"builtFrom"`
	// Builder performing the build
	BuiltBy *Builder `json:"builtBy"`
	// Type of the builder
	BuildType string `json:"buildType"`
	// Individual predicates found in the attestation
	SlsaPredicate []*SLSAPredicate `json:"slsaPredicate"`
	// Version of the SLSA predicate
	SlsaVersion string `json:"slsaVersion"`
	// Timestamp (RFC3339Nano format) of build start time
	StartedOn time.Time `json:"startedOn"`
	// Timestamp (RFC3339Nano format) of build end time
	FinishedOn time.Time `json:"finishedOn"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// SLSAInputSpec is the same as SLSA but for mutation input.
//
// All fields are required.
type SLSAInputSpec struct {
	BuildType     string                    `json:"buildType"`
	SlsaPredicate []*SLSAPredicateInputSpec `json:"slsaPredicate"`
	SlsaVersion   string                    `json:"slsaVersion"`
	StartedOn     time.Time                 `json:"startedOn"`
	FinishedOn    time.Time                 `json:"finishedOn"`
	Origin        string                    `json:"origin"`
	Collector     string                    `json:"collector"`
}

// SLSAPredicate are the values from the SLSA predicate in key-value pair form.
//
// # For example, given the following predicate
//
// ```
//
//	"predicate": {
//	  "buildDefinition": {
//	    "externalParameters": {
//	      "repository": "https://github.com/octocat/hello-world",
//	      ...
//	    },
//	    ...
//	  },
//	  ...
//	}
//
// ```
//
// we have
//
// ```
// key   = "buildDefinition.externalParameters.repository"
// value = "https://github.com/octocat/hello-world"
// ```
//
// This node cannot be directly referred by other parts of GUAC.
//
// TODO(mihaimaruseac): Can we define these directly?
type SLSAPredicate struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// SLSAPredicateInputSpec is the same as SLSAPredicateSpec, but for mutation
// input.
type SLSAPredicateInputSpec struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// SLSAPredicateSpec is the same as SLSAPredicate, but usable as query input.
type SLSAPredicateSpec struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// Scorecard contains all of the fields present in a Scorecard attestation.
//
// We also include fields to specify under what conditions the check was performed
// (time of scan, version of scanners, etc.) as well as how this information got
// included into GUAC (origin document and the collector for that document).
type Scorecard struct {
	// Individual Scorecard check scores (Branch-Protection, Code-Review, ...)
	Checks []*ScorecardCheck `json:"checks"`
	// Overall Scorecard score for the source
	AggregateScore float64 `json:"aggregateScore"`
	// Exact timestamp when the source was last scanned (in RFC 3339 format)
	TimeScanned time.Time `json:"timeScanned"`
	// Version of the Scorecard scanner used to analyze the source
	ScorecardVersion string `json:"scorecardVersion"`
	// Commit of the Scorecards repository at the time of scanning the source
	ScorecardCommit string `json:"scorecardCommit"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// ScorecardCheck are the individual checks from scorecard and their values as a
// key-value pair.
//
// For example:  Branch-Protection, Code-Review...etc
//
// Based off scorecard's:
//
//	type jsonCheckResultV2 struct {
//	  Details []string                 `json:"details"`
//	  Score   int                      `json:"score"`
//	  Reason  string                   `json:"reason"`
//	  Name    string                   `json:"name"`
//	  Doc     jsonCheckDocumentationV2 `json:"documentation"`
//	}
//
// This node cannot be directly referred by other parts of GUAC.
type ScorecardCheck struct {
	Check string `json:"check"`
	Score int    `json:"score"`
}

// ScorecardCheckInputSpec is the same as ScorecardCheck, but for mutation input.
type ScorecardCheckInputSpec struct {
	Check string `json:"check"`
	Score int    `json:"score"`
}

// ScorecardCheckSpec is the same as ScorecardCheck, but usable as query input.
type ScorecardCheckSpec struct {
	Check string `json:"check"`
	Score int    `json:"score"`
}

// ScorecardInputSpec is the same as Scorecard but for mutation input.
//
// All fields are required.
type ScorecardInputSpec struct {
	Checks           []*ScorecardCheckInputSpec `json:"checks"`
	AggregateScore   float64                    `json:"aggregateScore"`
	TimeScanned      time.Time                  `json:"timeScanned"`
	ScorecardVersion string                     `json:"scorecardVersion"`
	ScorecardCommit  string                     `json:"scorecardCommit"`
	Origin           string                     `json:"origin"`
	Collector        string                     `json:"collector"`
}

// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type Source struct {
	ID         string             `json:"id"`
	Type       string             `json:"type"`
	Namespaces []*SourceNamespace `json:"namespaces"`
}

func (Source) IsPackageSourceOrArtifact() {}

func (Source) IsPackageOrSource() {}

func (Source) IsNode() {}

// SourceInputSpec specifies a source for a mutation.
//
// This is different than SourceSpec because we want to encode that all fields
// except tag and commit are mandatory fields. All optional fields are given
// empty default values.
//
// It is an error to set both `tag` and `commit` fields to values different than
// the default.
type SourceInputSpec struct {
	Type      string  `json:"type"`
	Namespace string  `json:"namespace"`
	Name      string  `json:"name"`
	Tag       *string `json:"tag,omitempty"`
	Commit    *string `json:"commit,omitempty"`
}

// SourceName is a url of the repository and its tag or commit.
//
// The `name` field is mandatory. The `tag` and `commit` fields are optional, but
// it is an error to specify both.
//
// This is the only source trie node that can be referenced by other parts of
// GUAC.
type SourceName struct {
	ID     string  `json:"id"`
	Name   string  `json:"name"`
	Tag    *string `json:"tag,omitempty"`
	Commit *string `json:"commit,omitempty"`
}

// SourceNamespace is a namespace for sources.
//
// This is the location of the repository (such as github/gitlab/bitbucket).
//
// The `namespace` field is mandatory.
type SourceNamespace struct {
	ID        string        `json:"id"`
	Namespace string        `json:"namespace"`
	Names     []*SourceName `json:"names"`
}

// SourceSpec allows filtering the list of sources to return.
//
// Empty string at a field means matching with the empty string. Missing field
// means retrieving all possible matches.
//
// It is an error to specify both `tag` and `commit` fields, except it both are
// set as empty string (in which case the returned sources are only those for
// which there is no tag/commit information).
type SourceSpec struct {
	ID        *string `json:"id,omitempty"`
	Type      *string `json:"type,omitempty"`
	Namespace *string `json:"namespace,omitempty"`
	Name      *string `json:"name,omitempty"`
	Tag       *string `json:"tag,omitempty"`
	Commit    *string `json:"commit,omitempty"`
}

// VexStatementInputSpec is the same as CertifyVEXStatement but for mutation input.
//
// All fields are required.
type VexStatementInputSpec struct {
	Justification string    `json:"justification"`
	KnownSince    time.Time `json:"knownSince"`
	Origin        string    `json:"origin"`
	Collector     string    `json:"collector"`
}

// VulnerabilityInput allows using Vulnerability union as
// input type to be used in mutations.
//
// Either `noVuln` must be set to true or one of `osv`, `cve`, or `ghsa` must be
// set to non-nil. If `noVuln` is set then this is an ingestion of a known lack of
// vulnerabilities, so the special NoVuln node will be used by the backend.
// Otherwise, the specific vulnerability type will be linked to this attestation.
type VulnerabilityInput struct {
	Osv    *OSVInputSpec  `json:"osv,omitempty"`
	Cve    *CVEInputSpec  `json:"cve,omitempty"`
	Ghsa   *GHSAInputSpec `json:"ghsa,omitempty"`
	NoVuln *bool          `json:"noVuln,omitempty"`
}

// VulnerabilityMetaData is the metadata attached to vulnerability certification.
//
// It contains metadata about the scanner process that created the certification.
type VulnerabilityMetaData struct {
	// Time of scan (in RFC 3339 format)
	TimeScanned time.Time `json:"timeScanned"`
	// URI of the vulnerability database used by the scanner
	DbURI string `json:"dbUri"`
	// Version of the vulnerability database used by the scanner
	DbVersion string `json:"dbVersion"`
	// URI of the scanner
	ScannerURI string `json:"scannerUri"`
	// Version of the scanner
	ScannerVersion string `json:"scannerVersion"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// VulnerabilityInputSpec is the same as VulnerabilityMetaData but for mutation input.
//
// All fields are required.
type VulnerabilityMetaDataInput struct {
	TimeScanned    time.Time `json:"timeScanned"`
	DbURI          string    `json:"dbUri"`
	DbVersion      string    `json:"dbVersion"`
	ScannerURI     string    `json:"scannerUri"`
	ScannerVersion string    `json:"scannerVersion"`
	Origin         string    `json:"origin"`
	Collector      string    `json:"collector"`
}

// VulnerabilitySpec allows using Vulnerability union as input type to be used in
// read queries.
//
// Either `noVuln` must be set to true or exactly one of `osv`, `cve` or `ghsa`
// must be set to non-nil. Setting `noVuln` to true means retrieving nodes where
// there is no vulnerability attached (thus, the special NoVuln node). Setting one
// of the other fields means retrieving certifications for the corresponding
// vulnerability types.
type VulnerabilitySpec struct {
	Osv    *OSVSpec  `json:"osv,omitempty"`
	Cve    *CVESpec  `json:"cve,omitempty"`
	Ghsa   *GHSASpec `json:"ghsa,omitempty"`
	NoVuln *bool     `json:"noVuln,omitempty"`
}

// Edge allows filtering path/neighbors output to only contain a subset of all
// possible GUAC links.
//
// Each member of the enum is formed by merging two Node names with _. Each name
// is converted from CamelCase to CAPITALS_WITH_UNDERSCORES. Only valid edges
// (pairs from Node to Node) are included.
//
// The only exception to the above rule is for links out of HasSLSA. The names are
// HAS_SLSA_SUBJECT, HAS_SLSA_BUILT_BY, and HAS_SLSA_MATERIALS. This is because
// ARTIFACT_HAS_SLSA is only from subject Artifact to HasSLSA.
type Edge string

const (
	EdgeArtifactCertifyBad          Edge = "ARTIFACT_CERTIFY_BAD"
	EdgeArtifactCertifyGood         Edge = "ARTIFACT_CERTIFY_GOOD"
	EdgeArtifactCertifyVexStatement Edge = "ARTIFACT_CERTIFY_VEX_STATEMENT"
	EdgeArtifactHashEqual           Edge = "ARTIFACT_HASH_EQUAL"
	EdgeArtifactHasSlsa             Edge = "ARTIFACT_HAS_SLSA"
	EdgeArtifactIsOccurrence        Edge = "ARTIFACT_IS_OCCURRENCE"
	EdgeBuilderHasSlsa              Edge = "BUILDER_HAS_SLSA"
	EdgeCveCertifyVexStatement      Edge = "CVE_CERTIFY_VEX_STATEMENT"
	EdgeCveCertifyVuln              Edge = "CVE_CERTIFY_VULN"
	EdgeCveIsVulnerability          Edge = "CVE_IS_VULNERABILITY"
	EdgeGhsaCertifyVexStatement     Edge = "GHSA_CERTIFY_VEX_STATEMENT"
	EdgeGhsaCertifyVuln             Edge = "GHSA_CERTIFY_VULN"
	EdgeGhsaIsVulnerability         Edge = "GHSA_IS_VULNERABILITY"
	EdgeNoVulnCertifyVuln           Edge = "NO_VULN_CERTIFY_VULN"
	EdgeOsvCertifyVexStatement      Edge = "OSV_CERTIFY_VEX_STATEMENT"
	EdgeOsvCertifyVuln              Edge = "OSV_CERTIFY_VULN"
	EdgeOsvIsVulnerability          Edge = "OSV_IS_VULNERABILITY"
	EdgePackageCertifyBad           Edge = "PACKAGE_CERTIFY_BAD"
	EdgePackageCertifyGood          Edge = "PACKAGE_CERTIFY_GOOD"
	EdgePackageCertifyVexStatement  Edge = "PACKAGE_CERTIFY_VEX_STATEMENT"
	EdgePackageCertifyVuln          Edge = "PACKAGE_CERTIFY_VULN"
	EdgePackageHasSbom              Edge = "PACKAGE_HAS_SBOM"
	EdgePackageHasSourceAt          Edge = "PACKAGE_HAS_SOURCE_AT"
	EdgePackageIsDependency         Edge = "PACKAGE_IS_DEPENDENCY"
	EdgePackageIsOccurrence         Edge = "PACKAGE_IS_OCCURRENCE"
	EdgePackagePkgEqual             Edge = "PACKAGE_PKG_EQUAL"
	EdgeSourceCertifyBad            Edge = "SOURCE_CERTIFY_BAD"
	EdgeSourceCertifyGood           Edge = "SOURCE_CERTIFY_GOOD"
	EdgeSourceCertifyScorecard      Edge = "SOURCE_CERTIFY_SCORECARD"
	EdgeSourceHasSbom               Edge = "SOURCE_HAS_SBOM"
	EdgeSourceHasSourceAt           Edge = "SOURCE_HAS_SOURCE_AT"
	EdgeSourceIsOccurrence          Edge = "SOURCE_IS_OCCURRENCE"
	EdgeCertifyBadArtifact          Edge = "CERTIFY_BAD_ARTIFACT"
	EdgeCertifyBadPackage           Edge = "CERTIFY_BAD_PACKAGE"
	EdgeCertifyBadSource            Edge = "CERTIFY_BAD_SOURCE"
	EdgeCertifyGoodArtifact         Edge = "CERTIFY_GOOD_ARTIFACT"
	EdgeCertifyGoodPackage          Edge = "CERTIFY_GOOD_PACKAGE"
	EdgeCertifyGoodSource           Edge = "CERTIFY_GOOD_SOURCE"
	EdgeCertifyScorecardSource      Edge = "CERTIFY_SCORECARD_SOURCE"
	EdgeCertifyVexStatementArtifact Edge = "CERTIFY_VEX_STATEMENT_ARTIFACT"
	EdgeCertifyVexStatementCve      Edge = "CERTIFY_VEX_STATEMENT_CVE"
	EdgeCertifyVexStatementGhsa     Edge = "CERTIFY_VEX_STATEMENT_GHSA"
	EdgeCertifyVexStatementOsv      Edge = "CERTIFY_VEX_STATEMENT_OSV"
	EdgeCertifyVexStatementPackage  Edge = "CERTIFY_VEX_STATEMENT_PACKAGE"
	EdgeCertifyVulnCve              Edge = "CERTIFY_VULN_CVE"
	EdgeCertifyVulnGhsa             Edge = "CERTIFY_VULN_GHSA"
	EdgeCertifyVulnNoVuln           Edge = "CERTIFY_VULN_NO_VULN"
	EdgeCertifyVulnOsv              Edge = "CERTIFY_VULN_OSV"
	EdgeCertifyVulnPackage          Edge = "CERTIFY_VULN_PACKAGE"
	EdgeHashEqualArtifact           Edge = "HASH_EQUAL_ARTIFACT"
	EdgeHasSbomPackage              Edge = "HAS_SBOM_PACKAGE"
	EdgeHasSbomSource               Edge = "HAS_SBOM_SOURCE"
	EdgeHasSlsaBuiltBy              Edge = "HAS_SLSA_BUILT_BY"
	EdgeHasSlsaMaterials            Edge = "HAS_SLSA_MATERIALS"
	EdgeHasSlsaSubject              Edge = "HAS_SLSA_SUBJECT"
	EdgeHasSourceAtPackage          Edge = "HAS_SOURCE_AT_PACKAGE"
	EdgeHasSourceAtSource           Edge = "HAS_SOURCE_AT_SOURCE"
	EdgeIsDependencyPackage         Edge = "IS_DEPENDENCY_PACKAGE"
	EdgeIsOccurrenceArtifact        Edge = "IS_OCCURRENCE_ARTIFACT"
	EdgeIsOccurrencePackage         Edge = "IS_OCCURRENCE_PACKAGE"
	EdgeIsOccurrenceSource          Edge = "IS_OCCURRENCE_SOURCE"
	EdgeIsVulnerabilityCve          Edge = "IS_VULNERABILITY_CVE"
	EdgeIsVulnerabilityGhsa         Edge = "IS_VULNERABILITY_GHSA"
	EdgeIsVulnerabilityOsv          Edge = "IS_VULNERABILITY_OSV"
	EdgePkgEqualPackage             Edge = "PKG_EQUAL_PACKAGE"
)

var AllEdge = []Edge{
	EdgeArtifactCertifyBad,
	EdgeArtifactCertifyGood,
	EdgeArtifactCertifyVexStatement,
	EdgeArtifactHashEqual,
	EdgeArtifactHasSlsa,
	EdgeArtifactIsOccurrence,
	EdgeBuilderHasSlsa,
	EdgeCveCertifyVexStatement,
	EdgeCveCertifyVuln,
	EdgeCveIsVulnerability,
	EdgeGhsaCertifyVexStatement,
	EdgeGhsaCertifyVuln,
	EdgeGhsaIsVulnerability,
	EdgeNoVulnCertifyVuln,
	EdgeOsvCertifyVexStatement,
	EdgeOsvCertifyVuln,
	EdgeOsvIsVulnerability,
	EdgePackageCertifyBad,
	EdgePackageCertifyGood,
	EdgePackageCertifyVexStatement,
	EdgePackageCertifyVuln,
	EdgePackageHasSbom,
	EdgePackageHasSourceAt,
	EdgePackageIsDependency,
	EdgePackageIsOccurrence,
	EdgePackagePkgEqual,
	EdgeSourceCertifyBad,
	EdgeSourceCertifyGood,
	EdgeSourceCertifyScorecard,
	EdgeSourceHasSbom,
	EdgeSourceHasSourceAt,
	EdgeSourceIsOccurrence,
	EdgeCertifyBadArtifact,
	EdgeCertifyBadPackage,
	EdgeCertifyBadSource,
	EdgeCertifyGoodArtifact,
	EdgeCertifyGoodPackage,
	EdgeCertifyGoodSource,
	EdgeCertifyScorecardSource,
	EdgeCertifyVexStatementArtifact,
	EdgeCertifyVexStatementCve,
	EdgeCertifyVexStatementGhsa,
	EdgeCertifyVexStatementOsv,
	EdgeCertifyVexStatementPackage,
	EdgeCertifyVulnCve,
	EdgeCertifyVulnGhsa,
	EdgeCertifyVulnNoVuln,
	EdgeCertifyVulnOsv,
	EdgeCertifyVulnPackage,
	EdgeHashEqualArtifact,
	EdgeHasSbomPackage,
	EdgeHasSbomSource,
	EdgeHasSlsaBuiltBy,
	EdgeHasSlsaMaterials,
	EdgeHasSlsaSubject,
	EdgeHasSourceAtPackage,
	EdgeHasSourceAtSource,
	EdgeIsDependencyPackage,
	EdgeIsOccurrenceArtifact,
	EdgeIsOccurrencePackage,
	EdgeIsOccurrenceSource,
	EdgeIsVulnerabilityCve,
	EdgeIsVulnerabilityGhsa,
	EdgeIsVulnerabilityOsv,
	EdgePkgEqualPackage,
}

func (e Edge) IsValid() bool {
	switch e {
	case EdgeArtifactCertifyBad, EdgeArtifactCertifyGood, EdgeArtifactCertifyVexStatement, EdgeArtifactHashEqual, EdgeArtifactHasSlsa, EdgeArtifactIsOccurrence, EdgeBuilderHasSlsa, EdgeCveCertifyVexStatement, EdgeCveCertifyVuln, EdgeCveIsVulnerability, EdgeGhsaCertifyVexStatement, EdgeGhsaCertifyVuln, EdgeGhsaIsVulnerability, EdgeNoVulnCertifyVuln, EdgeOsvCertifyVexStatement, EdgeOsvCertifyVuln, EdgeOsvIsVulnerability, EdgePackageCertifyBad, EdgePackageCertifyGood, EdgePackageCertifyVexStatement, EdgePackageCertifyVuln, EdgePackageHasSbom, EdgePackageHasSourceAt, EdgePackageIsDependency, EdgePackageIsOccurrence, EdgePackagePkgEqual, EdgeSourceCertifyBad, EdgeSourceCertifyGood, EdgeSourceCertifyScorecard, EdgeSourceHasSbom, EdgeSourceHasSourceAt, EdgeSourceIsOccurrence, EdgeCertifyBadArtifact, EdgeCertifyBadPackage, EdgeCertifyBadSource, EdgeCertifyGoodArtifact, EdgeCertifyGoodPackage, EdgeCertifyGoodSource, EdgeCertifyScorecardSource, EdgeCertifyVexStatementArtifact, EdgeCertifyVexStatementCve, EdgeCertifyVexStatementGhsa, EdgeCertifyVexStatementOsv, EdgeCertifyVexStatementPackage, EdgeCertifyVulnCve, EdgeCertifyVulnGhsa, EdgeCertifyVulnNoVuln, EdgeCertifyVulnOsv, EdgeCertifyVulnPackage, EdgeHashEqualArtifact, EdgeHasSbomPackage, EdgeHasSbomSource, EdgeHasSlsaBuiltBy, EdgeHasSlsaMaterials, EdgeHasSlsaSubject, EdgeHasSourceAtPackage, EdgeHasSourceAtSource, EdgeIsDependencyPackage, EdgeIsOccurrenceArtifact, EdgeIsOccurrencePackage, EdgeIsOccurrenceSource, EdgeIsVulnerabilityCve, EdgeIsVulnerabilityGhsa, EdgeIsVulnerabilityOsv, EdgePkgEqualPackage:
		return true
	}
	return false
}

func (e Edge) String() string {
	return string(e)
}

func (e *Edge) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Edge(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Edge", str)
	}
	return nil
}

func (e Edge) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// PkgMatchType is an enum to determine if the attestation should be done at the
// specific version or package name
type PkgMatchType string

const (
	PkgMatchTypeAllVersions     PkgMatchType = "ALL_VERSIONS"
	PkgMatchTypeSpecificVersion PkgMatchType = "SPECIFIC_VERSION"
)

var AllPkgMatchType = []PkgMatchType{
	PkgMatchTypeAllVersions,
	PkgMatchTypeSpecificVersion,
}

func (e PkgMatchType) IsValid() bool {
	switch e {
	case PkgMatchTypeAllVersions, PkgMatchTypeSpecificVersion:
		return true
	}
	return false
}

func (e PkgMatchType) String() string {
	return string(e)
}

func (e *PkgMatchType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PkgMatchType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PkgMatchType", str)
	}
	return nil
}

func (e PkgMatchType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
