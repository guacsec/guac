// Code generated by github.com/Khan/genqlient, DO NOT EDIT.

package generated

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Khan/genqlient/graphql"
)

// ArtifactInputSpec is the same as Artifact, but used as mutation input.
//
// Both arguments will be canonicalized to lowercase.
type ArtifactInputSpec struct {
	Algorithm string `json:"algorithm"`
	Digest    string `json:"digest"`
}

// GetAlgorithm returns ArtifactInputSpec.Algorithm, and is useful for accessing the field via an interface.
func (v *ArtifactInputSpec) GetAlgorithm() string { return v.Algorithm }

// GetDigest returns ArtifactInputSpec.Digest, and is useful for accessing the field via an interface.
func (v *ArtifactInputSpec) GetDigest() string { return v.Digest }

// BuilderSpec allows filtering the list of builders to return.
type BuilderSpec struct {
	Uri *string `json:"uri"`
}

// GetUri returns BuilderSpec.Uri, and is useful for accessing the field via an interface.
func (v *BuilderSpec) GetUri() *string { return v.Uri }

// IsDependencyDependentPkgPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type IsDependencyDependentPkgPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns IsDependencyDependentPkgPackage.Type, and is useful for accessing the field via an interface.
func (v *IsDependencyDependentPkgPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns IsDependencyDependentPkgPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *IsDependencyDependentPkgPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *IsDependencyDependentPkgPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsDependencyDependentPkgPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.IsDependencyDependentPkgPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsDependencyDependentPkgPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *IsDependencyDependentPkgPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsDependencyDependentPkgPackage) __premarshalJSON() (*__premarshalIsDependencyDependentPkgPackage, error) {
	var retval __premarshalIsDependencyDependentPkgPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// IsDependencyIngestDependencyIsDependency includes the requested fields of the GraphQL type IsDependency.
// The GraphQL type's documentation follows.
//
// # IsDependency is an attestation that represents when a package is dependent on another package
//
// package (subject) - the package object type that represents the package
// dependentPackage (object) - the package object type that represents the packageName (cannot be to the packageVersion)
// versionRange (property) - string value for version range that applies to the dependent package
// justification (property) - string value representing why the artifacts are the equal
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type IsDependencyIngestDependencyIsDependency struct {
	allIsDependencyTree `json:"-"`
}

// GetJustification returns IsDependencyIngestDependencyIsDependency.Justification, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetJustification() string {
	return v.allIsDependencyTree.Justification
}

// GetPackage returns IsDependencyIngestDependencyIsDependency.Package, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetPackage() allIsDependencyTreePackage {
	return v.allIsDependencyTree.Package
}

// GetDependentPackage returns IsDependencyIngestDependencyIsDependency.DependentPackage, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetDependentPackage() allIsDependencyTreeDependentPackage {
	return v.allIsDependencyTree.DependentPackage
}

// GetVersionRange returns IsDependencyIngestDependencyIsDependency.VersionRange, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetVersionRange() string {
	return v.allIsDependencyTree.VersionRange
}

// GetOrigin returns IsDependencyIngestDependencyIsDependency.Origin, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetOrigin() string {
	return v.allIsDependencyTree.Origin
}

// GetCollector returns IsDependencyIngestDependencyIsDependency.Collector, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetCollector() string {
	return v.allIsDependencyTree.Collector
}

func (v *IsDependencyIngestDependencyIsDependency) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsDependencyIngestDependencyIsDependency
		graphql.NoUnmarshalJSON
	}
	firstPass.IsDependencyIngestDependencyIsDependency = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allIsDependencyTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsDependencyIngestDependencyIsDependency struct {
	Justification string `json:"justification"`

	Package allIsDependencyTreePackage `json:"package"`

	DependentPackage allIsDependencyTreeDependentPackage `json:"dependentPackage"`

	VersionRange string `json:"versionRange"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *IsDependencyIngestDependencyIsDependency) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsDependencyIngestDependencyIsDependency) __premarshalJSON() (*__premarshalIsDependencyIngestDependencyIsDependency, error) {
	var retval __premarshalIsDependencyIngestDependencyIsDependency

	retval.Justification = v.allIsDependencyTree.Justification
	retval.Package = v.allIsDependencyTree.Package
	retval.DependentPackage = v.allIsDependencyTree.DependentPackage
	retval.VersionRange = v.allIsDependencyTree.VersionRange
	retval.Origin = v.allIsDependencyTree.Origin
	retval.Collector = v.allIsDependencyTree.Collector
	return &retval, nil
}

// IsDependencyInputSpec is the same as IsDependency but for mutation input.
//
// All fields are required.
type IsDependencyInputSpec struct {
	VersionRange  string `json:"versionRange"`
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetVersionRange returns IsDependencyInputSpec.VersionRange, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetVersionRange() string { return v.VersionRange }

// GetJustification returns IsDependencyInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns IsDependencyInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns IsDependencyInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetCollector() string { return v.Collector }

// IsDependencyPkgPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type IsDependencyPkgPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns IsDependencyPkgPackage.Type, and is useful for accessing the field via an interface.
func (v *IsDependencyPkgPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns IsDependencyPkgPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *IsDependencyPkgPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *IsDependencyPkgPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsDependencyPkgPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.IsDependencyPkgPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsDependencyPkgPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *IsDependencyPkgPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsDependencyPkgPackage) __premarshalJSON() (*__premarshalIsDependencyPkgPackage, error) {
	var retval __premarshalIsDependencyPkgPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// IsDependencyResponse is returned by IsDependency on success.
type IsDependencyResponse struct {
	// Ingest a new package. Returns the ingested package trie
	Pkg IsDependencyPkgPackage `json:"pkg"`
	// Ingest a new package. Returns the ingested package trie
	DependentPkg IsDependencyDependentPkgPackage `json:"dependentPkg"`
	// Adds dependency between two packages
	IngestDependency IsDependencyIngestDependencyIsDependency `json:"ingestDependency"`
}

// GetPkg returns IsDependencyResponse.Pkg, and is useful for accessing the field via an interface.
func (v *IsDependencyResponse) GetPkg() IsDependencyPkgPackage { return v.Pkg }

// GetDependentPkg returns IsDependencyResponse.DependentPkg, and is useful for accessing the field via an interface.
func (v *IsDependencyResponse) GetDependentPkg() IsDependencyDependentPkgPackage {
	return v.DependentPkg
}

// GetIngestDependency returns IsDependencyResponse.IngestDependency, and is useful for accessing the field via an interface.
func (v *IsDependencyResponse) GetIngestDependency() IsDependencyIngestDependencyIsDependency {
	return v.IngestDependency
}

// IsOccurrencePkgIngestArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type IsOccurrencePkgIngestArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns IsOccurrencePkgIngestArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns IsOccurrencePkgIngestArtifact.Digest, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *IsOccurrencePkgIngestArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrencePkgIngestArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrencePkgIngestArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrencePkgIngestArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *IsOccurrencePkgIngestArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrencePkgIngestArtifact) __premarshalJSON() (*__premarshalIsOccurrencePkgIngestArtifact, error) {
	var retval __premarshalIsOccurrencePkgIngestArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// IsOccurrencePkgIngestOccurrenceIsOccurrence includes the requested fields of the GraphQL type IsOccurrence.
// The GraphQL type's documentation follows.
//
// # IsOccurrence is an attestation represents when either a package or source is represented by an artifact
//
// subject - union type that can be either a package or source object type
// occurrenceArtifact (object) - artifact that represent the the package or source
// justification (property) - string value representing why the package or source is represented by the specified artifact
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
//
// Note: Package or Source must be specified but not both at the same time.
// Attestation must occur at the PackageName or the PackageVersion or at the SourceName.
//
// HashEqual will be used to connect together two artifacts if a package or source
// is represented by more than one artifact.
//
// IsOccurrence does not connect a package with a source.
// HasSourceAt attestation will be used to connect a package with a source
type IsOccurrencePkgIngestOccurrenceIsOccurrence struct {
	allIsOccurrencesTree `json:"-"`
}

// GetSubject returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Subject, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetSubject() allIsOccurrencesTreeSubjectPkgSrcObject {
	return v.allIsOccurrencesTree.Subject
}

// GetOccurrenceArtifact returns IsOccurrencePkgIngestOccurrenceIsOccurrence.OccurrenceArtifact, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetOccurrenceArtifact() allIsOccurrencesTreeOccurrenceArtifact {
	return v.allIsOccurrencesTree.OccurrenceArtifact
}

// GetJustification returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Justification, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetJustification() string {
	return v.allIsOccurrencesTree.Justification
}

// GetOrigin returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Origin, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetOrigin() string {
	return v.allIsOccurrencesTree.Origin
}

// GetCollector returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Collector, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetCollector() string {
	return v.allIsOccurrencesTree.Collector
}

func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrencePkgIngestOccurrenceIsOccurrence
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrencePkgIngestOccurrenceIsOccurrence = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allIsOccurrencesTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrencePkgIngestOccurrenceIsOccurrence struct {
	Subject json.RawMessage `json:"subject"`

	OccurrenceArtifact allIsOccurrencesTreeOccurrenceArtifact `json:"occurrenceArtifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) __premarshalJSON() (*__premarshalIsOccurrencePkgIngestOccurrenceIsOccurrence, error) {
	var retval __premarshalIsOccurrencePkgIngestOccurrenceIsOccurrence

	{

		dst := &retval.Subject
		src := v.allIsOccurrencesTree.Subject
		var err error
		*dst, err = __marshalallIsOccurrencesTreeSubjectPkgSrcObject(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal IsOccurrencePkgIngestOccurrenceIsOccurrence.allIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.OccurrenceArtifact = v.allIsOccurrencesTree.OccurrenceArtifact
	retval.Justification = v.allIsOccurrencesTree.Justification
	retval.Origin = v.allIsOccurrencesTree.Origin
	retval.Collector = v.allIsOccurrencesTree.Collector
	return &retval, nil
}

// IsOccurrencePkgIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type IsOccurrencePkgIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns IsOccurrencePkgIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns IsOccurrencePkgIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *IsOccurrencePkgIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrencePkgIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrencePkgIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrencePkgIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *IsOccurrencePkgIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrencePkgIngestPackage) __premarshalJSON() (*__premarshalIsOccurrencePkgIngestPackage, error) {
	var retval __premarshalIsOccurrencePkgIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// IsOccurrencePkgResponse is returned by IsOccurrencePkg on success.
type IsOccurrencePkgResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage IsOccurrencePkgIngestPackage `json:"ingestPackage"`
	// Ingest a new artifact. Returns the ingested artifact
	IngestArtifact IsOccurrencePkgIngestArtifact `json:"ingestArtifact"`
	// Adds an artifact as an occurrence for either a package or a source
	IngestOccurrence IsOccurrencePkgIngestOccurrenceIsOccurrence `json:"ingestOccurrence"`
}

// GetIngestPackage returns IsOccurrencePkgResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgResponse) GetIngestPackage() IsOccurrencePkgIngestPackage {
	return v.IngestPackage
}

// GetIngestArtifact returns IsOccurrencePkgResponse.IngestArtifact, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgResponse) GetIngestArtifact() IsOccurrencePkgIngestArtifact {
	return v.IngestArtifact
}

// GetIngestOccurrence returns IsOccurrencePkgResponse.IngestOccurrence, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgResponse) GetIngestOccurrence() IsOccurrencePkgIngestOccurrenceIsOccurrence {
	return v.IngestOccurrence
}

// IsOccurrenceSpecInputSpec is the same as IsOccurrence but for mutation input.
//
// All fields are required.
type IsOccurrenceSpecInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetJustification returns IsOccurrenceSpecInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSpecInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns IsOccurrenceSpecInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSpecInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns IsOccurrenceSpecInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSpecInputSpec) GetCollector() string { return v.Collector }

// IsOccurrenceSrcIngestArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type IsOccurrenceSrcIngestArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns IsOccurrenceSrcIngestArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns IsOccurrenceSrcIngestArtifact.Digest, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *IsOccurrenceSrcIngestArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrenceSrcIngestArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrenceSrcIngestArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrenceSrcIngestArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *IsOccurrenceSrcIngestArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrenceSrcIngestArtifact) __premarshalJSON() (*__premarshalIsOccurrenceSrcIngestArtifact, error) {
	var retval __premarshalIsOccurrenceSrcIngestArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// IsOccurrenceSrcIngestOccurrenceIsOccurrence includes the requested fields of the GraphQL type IsOccurrence.
// The GraphQL type's documentation follows.
//
// # IsOccurrence is an attestation represents when either a package or source is represented by an artifact
//
// subject - union type that can be either a package or source object type
// occurrenceArtifact (object) - artifact that represent the the package or source
// justification (property) - string value representing why the package or source is represented by the specified artifact
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
//
// Note: Package or Source must be specified but not both at the same time.
// Attestation must occur at the PackageName or the PackageVersion or at the SourceName.
//
// HashEqual will be used to connect together two artifacts if a package or source
// is represented by more than one artifact.
//
// IsOccurrence does not connect a package with a source.
// HasSourceAt attestation will be used to connect a package with a source
type IsOccurrenceSrcIngestOccurrenceIsOccurrence struct {
	allIsOccurrencesTree `json:"-"`
}

// GetSubject returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Subject, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetSubject() allIsOccurrencesTreeSubjectPkgSrcObject {
	return v.allIsOccurrencesTree.Subject
}

// GetOccurrenceArtifact returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.OccurrenceArtifact, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetOccurrenceArtifact() allIsOccurrencesTreeOccurrenceArtifact {
	return v.allIsOccurrencesTree.OccurrenceArtifact
}

// GetJustification returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Justification, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetJustification() string {
	return v.allIsOccurrencesTree.Justification
}

// GetOrigin returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Origin, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetOrigin() string {
	return v.allIsOccurrencesTree.Origin
}

// GetCollector returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Collector, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetCollector() string {
	return v.allIsOccurrencesTree.Collector
}

func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrenceSrcIngestOccurrenceIsOccurrence
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrenceSrcIngestOccurrenceIsOccurrence = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allIsOccurrencesTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrenceSrcIngestOccurrenceIsOccurrence struct {
	Subject json.RawMessage `json:"subject"`

	OccurrenceArtifact allIsOccurrencesTreeOccurrenceArtifact `json:"occurrenceArtifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) __premarshalJSON() (*__premarshalIsOccurrenceSrcIngestOccurrenceIsOccurrence, error) {
	var retval __premarshalIsOccurrenceSrcIngestOccurrenceIsOccurrence

	{

		dst := &retval.Subject
		src := v.allIsOccurrencesTree.Subject
		var err error
		*dst, err = __marshalallIsOccurrencesTreeSubjectPkgSrcObject(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal IsOccurrenceSrcIngestOccurrenceIsOccurrence.allIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.OccurrenceArtifact = v.allIsOccurrencesTree.OccurrenceArtifact
	retval.Justification = v.allIsOccurrencesTree.Justification
	retval.Origin = v.allIsOccurrencesTree.Origin
	retval.Collector = v.allIsOccurrencesTree.Collector
	return &retval, nil
}

// IsOccurrenceSrcIngestSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type IsOccurrenceSrcIngestSource struct {
	allSourceTree `json:"-"`
}

// GetType returns IsOccurrenceSrcIngestSource.Type, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns IsOccurrenceSrcIngestSource.Namespaces, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *IsOccurrenceSrcIngestSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrenceSrcIngestSource
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrenceSrcIngestSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrenceSrcIngestSource struct {
	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *IsOccurrenceSrcIngestSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrenceSrcIngestSource) __premarshalJSON() (*__premarshalIsOccurrenceSrcIngestSource, error) {
	var retval __premarshalIsOccurrenceSrcIngestSource

	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// IsOccurrenceSrcResponse is returned by IsOccurrenceSrc on success.
type IsOccurrenceSrcResponse struct {
	// Ingest a new source. Returns the ingested source trie
	IngestSource IsOccurrenceSrcIngestSource `json:"ingestSource"`
	// Ingest a new artifact. Returns the ingested artifact
	IngestArtifact IsOccurrenceSrcIngestArtifact `json:"ingestArtifact"`
	// Adds an artifact as an occurrence for either a package or a source
	IngestOccurrence IsOccurrenceSrcIngestOccurrenceIsOccurrence `json:"ingestOccurrence"`
}

// GetIngestSource returns IsOccurrenceSrcResponse.IngestSource, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcResponse) GetIngestSource() IsOccurrenceSrcIngestSource {
	return v.IngestSource
}

// GetIngestArtifact returns IsOccurrenceSrcResponse.IngestArtifact, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcResponse) GetIngestArtifact() IsOccurrenceSrcIngestArtifact {
	return v.IngestArtifact
}

// GetIngestOccurrence returns IsOccurrenceSrcResponse.IngestOccurrence, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcResponse) GetIngestOccurrence() IsOccurrenceSrcIngestOccurrenceIsOccurrence {
	return v.IngestOccurrence
}

// PackageQualifierInputSpec is the same as PackageQualifier, but usable as
// mutation input.
//
// GraphQL does not allow input types to contain composite types and does not allow
// composite types to contain input types. So, although in this case these two
// types are semantically the same, we have to duplicate the definition.
//
// Both fields are mandatory.
type PackageQualifierInputSpec struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns PackageQualifierInputSpec.Key, and is useful for accessing the field via an interface.
func (v *PackageQualifierInputSpec) GetKey() string { return v.Key }

// GetValue returns PackageQualifierInputSpec.Value, and is useful for accessing the field via an interface.
func (v *PackageQualifierInputSpec) GetValue() string { return v.Value }

// PackageSourceOrArtifactInput allows using PackageSourceOrArtifact union as
// input type to be used in mutations.
//
// Exactly one of the value must be set to non-nil.
type PackageSourceOrArtifactInput struct {
	Package  *PkgInputSpec      `json:"package"`
	Source   *SourceInputSpec   `json:"source"`
	Artifact *ArtifactInputSpec `json:"artifact"`
}

// GetPackage returns PackageSourceOrArtifactInput.Package, and is useful for accessing the field via an interface.
func (v *PackageSourceOrArtifactInput) GetPackage() *PkgInputSpec { return v.Package }

// GetSource returns PackageSourceOrArtifactInput.Source, and is useful for accessing the field via an interface.
func (v *PackageSourceOrArtifactInput) GetSource() *SourceInputSpec { return v.Source }

// GetArtifact returns PackageSourceOrArtifactInput.Artifact, and is useful for accessing the field via an interface.
func (v *PackageSourceOrArtifactInput) GetArtifact() *ArtifactInputSpec { return v.Artifact }

// PkgInputSpec specifies a package for a mutation.
//
// This is different than PkgSpec because we want to encode mandatory fields:
// `type` and `name`. All optional fields are given empty default values.
type PkgInputSpec struct {
	Type       string                      `json:"type"`
	Namespace  *string                     `json:"namespace"`
	Name       string                      `json:"name"`
	Version    *string                     `json:"version"`
	Qualifiers []PackageQualifierInputSpec `json:"qualifiers"`
	Subpath    *string                     `json:"subpath"`
}

// GetType returns PkgInputSpec.Type, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetType() string { return v.Type }

// GetNamespace returns PkgInputSpec.Namespace, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetNamespace() *string { return v.Namespace }

// GetName returns PkgInputSpec.Name, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetName() string { return v.Name }

// GetVersion returns PkgInputSpec.Version, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetVersion() *string { return v.Version }

// GetQualifiers returns PkgInputSpec.Qualifiers, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetQualifiers() []PackageQualifierInputSpec { return v.Qualifiers }

// GetSubpath returns PkgInputSpec.Subpath, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetSubpath() *string { return v.Subpath }

// SLSAForArtifactIngestArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type SLSAForArtifactIngestArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns SLSAForArtifactIngestArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns SLSAForArtifactIngestArtifact.Digest, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *SLSAForArtifactIngestArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForArtifactIngestArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForArtifactIngestArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForArtifactIngestArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *SLSAForArtifactIngestArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForArtifactIngestArtifact) __premarshalJSON() (*__premarshalSLSAForArtifactIngestArtifact, error) {
	var retval __premarshalSLSAForArtifactIngestArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// SLSAForArtifactIngestSLSAHasSLSA includes the requested fields of the GraphQL type HasSLSA.
// The GraphQL type's documentation follows.
//
// HasSLSA records that a subject node has a SLSA attestation.
type SLSAForArtifactIngestSLSAHasSLSA struct {
	allSLSATree `json:"-"`
}

// GetSubject returns SLSAForArtifactIngestSLSAHasSLSA.Subject, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestSLSAHasSLSA) GetSubject() allSLSATreeSubjectPackageSourceOrArtifact {
	return v.allSLSATree.Subject
}

// GetSlsa returns SLSAForArtifactIngestSLSAHasSLSA.Slsa, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestSLSAHasSLSA) GetSlsa() *allSLSATreeSlsaSLSA { return v.allSLSATree.Slsa }

func (v *SLSAForArtifactIngestSLSAHasSLSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForArtifactIngestSLSAHasSLSA
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForArtifactIngestSLSAHasSLSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSLSATree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForArtifactIngestSLSAHasSLSA struct {
	Subject json.RawMessage `json:"subject"`

	Slsa *allSLSATreeSlsaSLSA `json:"slsa"`
}

func (v *SLSAForArtifactIngestSLSAHasSLSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForArtifactIngestSLSAHasSLSA) __premarshalJSON() (*__premarshalSLSAForArtifactIngestSLSAHasSLSA, error) {
	var retval __premarshalSLSAForArtifactIngestSLSAHasSLSA

	{

		dst := &retval.Subject
		src := v.allSLSATree.Subject
		var err error
		*dst, err = __marshalallSLSATreeSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal SLSAForArtifactIngestSLSAHasSLSA.allSLSATree.Subject: %w", err)
		}
	}
	retval.Slsa = v.allSLSATree.Slsa
	return &retval, nil
}

// SLSAForArtifactResponse is returned by SLSAForArtifact on success.
type SLSAForArtifactResponse struct {
	// Ingest a new artifact. Returns the ingested artifact
	IngestArtifact SLSAForArtifactIngestArtifact `json:"ingestArtifact"`
	// Ingests a SLSA attestation
	IngestSLSA SLSAForArtifactIngestSLSAHasSLSA `json:"ingestSLSA"`
}

// GetIngestArtifact returns SLSAForArtifactResponse.IngestArtifact, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactResponse) GetIngestArtifact() SLSAForArtifactIngestArtifact {
	return v.IngestArtifact
}

// GetIngestSLSA returns SLSAForArtifactResponse.IngestSLSA, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactResponse) GetIngestSLSA() SLSAForArtifactIngestSLSAHasSLSA {
	return v.IngestSLSA
}

// SLSAForPackageIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type SLSAForPackageIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns SLSAForPackageIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns SLSAForPackageIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *SLSAForPackageIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForPackageIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForPackageIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForPackageIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *SLSAForPackageIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForPackageIngestPackage) __premarshalJSON() (*__premarshalSLSAForPackageIngestPackage, error) {
	var retval __premarshalSLSAForPackageIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// SLSAForPackageIngestSLSAHasSLSA includes the requested fields of the GraphQL type HasSLSA.
// The GraphQL type's documentation follows.
//
// HasSLSA records that a subject node has a SLSA attestation.
type SLSAForPackageIngestSLSAHasSLSA struct {
	allSLSATree `json:"-"`
}

// GetSubject returns SLSAForPackageIngestSLSAHasSLSA.Subject, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestSLSAHasSLSA) GetSubject() allSLSATreeSubjectPackageSourceOrArtifact {
	return v.allSLSATree.Subject
}

// GetSlsa returns SLSAForPackageIngestSLSAHasSLSA.Slsa, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestSLSAHasSLSA) GetSlsa() *allSLSATreeSlsaSLSA { return v.allSLSATree.Slsa }

func (v *SLSAForPackageIngestSLSAHasSLSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForPackageIngestSLSAHasSLSA
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForPackageIngestSLSAHasSLSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSLSATree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForPackageIngestSLSAHasSLSA struct {
	Subject json.RawMessage `json:"subject"`

	Slsa *allSLSATreeSlsaSLSA `json:"slsa"`
}

func (v *SLSAForPackageIngestSLSAHasSLSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForPackageIngestSLSAHasSLSA) __premarshalJSON() (*__premarshalSLSAForPackageIngestSLSAHasSLSA, error) {
	var retval __premarshalSLSAForPackageIngestSLSAHasSLSA

	{

		dst := &retval.Subject
		src := v.allSLSATree.Subject
		var err error
		*dst, err = __marshalallSLSATreeSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal SLSAForPackageIngestSLSAHasSLSA.allSLSATree.Subject: %w", err)
		}
	}
	retval.Slsa = v.allSLSATree.Slsa
	return &retval, nil
}

// SLSAForPackageResponse is returned by SLSAForPackage on success.
type SLSAForPackageResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage SLSAForPackageIngestPackage `json:"ingestPackage"`
	// Ingests a SLSA attestation
	IngestSLSA SLSAForPackageIngestSLSAHasSLSA `json:"ingestSLSA"`
}

// GetIngestPackage returns SLSAForPackageResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *SLSAForPackageResponse) GetIngestPackage() SLSAForPackageIngestPackage {
	return v.IngestPackage
}

// GetIngestSLSA returns SLSAForPackageResponse.IngestSLSA, and is useful for accessing the field via an interface.
func (v *SLSAForPackageResponse) GetIngestSLSA() SLSAForPackageIngestSLSAHasSLSA { return v.IngestSLSA }

// SLSAForSourceIngestSLSAHasSLSA includes the requested fields of the GraphQL type HasSLSA.
// The GraphQL type's documentation follows.
//
// HasSLSA records that a subject node has a SLSA attestation.
type SLSAForSourceIngestSLSAHasSLSA struct {
	allSLSATree `json:"-"`
}

// GetSubject returns SLSAForSourceIngestSLSAHasSLSA.Subject, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestSLSAHasSLSA) GetSubject() allSLSATreeSubjectPackageSourceOrArtifact {
	return v.allSLSATree.Subject
}

// GetSlsa returns SLSAForSourceIngestSLSAHasSLSA.Slsa, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestSLSAHasSLSA) GetSlsa() *allSLSATreeSlsaSLSA { return v.allSLSATree.Slsa }

func (v *SLSAForSourceIngestSLSAHasSLSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForSourceIngestSLSAHasSLSA
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForSourceIngestSLSAHasSLSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSLSATree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForSourceIngestSLSAHasSLSA struct {
	Subject json.RawMessage `json:"subject"`

	Slsa *allSLSATreeSlsaSLSA `json:"slsa"`
}

func (v *SLSAForSourceIngestSLSAHasSLSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForSourceIngestSLSAHasSLSA) __premarshalJSON() (*__premarshalSLSAForSourceIngestSLSAHasSLSA, error) {
	var retval __premarshalSLSAForSourceIngestSLSAHasSLSA

	{

		dst := &retval.Subject
		src := v.allSLSATree.Subject
		var err error
		*dst, err = __marshalallSLSATreeSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal SLSAForSourceIngestSLSAHasSLSA.allSLSATree.Subject: %w", err)
		}
	}
	retval.Slsa = v.allSLSATree.Slsa
	return &retval, nil
}

// SLSAForSourceIngestSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type SLSAForSourceIngestSource struct {
	allSourceTree `json:"-"`
}

// GetType returns SLSAForSourceIngestSource.Type, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns SLSAForSourceIngestSource.Namespaces, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *SLSAForSourceIngestSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForSourceIngestSource
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForSourceIngestSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForSourceIngestSource struct {
	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *SLSAForSourceIngestSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForSourceIngestSource) __premarshalJSON() (*__premarshalSLSAForSourceIngestSource, error) {
	var retval __premarshalSLSAForSourceIngestSource

	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// SLSAForSourceResponse is returned by SLSAForSource on success.
type SLSAForSourceResponse struct {
	// Ingest a new source. Returns the ingested source trie
	IngestSource SLSAForSourceIngestSource `json:"ingestSource"`
	// Ingests a SLSA attestation
	IngestSLSA SLSAForSourceIngestSLSAHasSLSA `json:"ingestSLSA"`
}

// GetIngestSource returns SLSAForSourceResponse.IngestSource, and is useful for accessing the field via an interface.
func (v *SLSAForSourceResponse) GetIngestSource() SLSAForSourceIngestSource { return v.IngestSource }

// GetIngestSLSA returns SLSAForSourceResponse.IngestSLSA, and is useful for accessing the field via an interface.
func (v *SLSAForSourceResponse) GetIngestSLSA() SLSAForSourceIngestSLSAHasSLSA { return v.IngestSLSA }

// SLSAInputSpec is the same as SLSA but for mutation input.
//
// All fields are required.
type SLSAInputSpec struct {
	BuiltFrom     []PackageSourceOrArtifactInput `json:"builtFrom"`
	BuiltBy       BuilderSpec                    `json:"builtBy"`
	BuildType     string                         `json:"buildType"`
	SlsaPredicate []SLSAPredicateInputSpec       `json:"slsaPredicate"`
	SlsaVersion   string                         `json:"slsaVersion"`
	StartedOn     time.Time                      `json:"startedOn"`
	FinishedOn    time.Time                      `json:"finishedOn"`
	Origin        string                         `json:"origin"`
	Collector     string                         `json:"collector"`
}

// GetBuiltFrom returns SLSAInputSpec.BuiltFrom, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetBuiltFrom() []PackageSourceOrArtifactInput { return v.BuiltFrom }

// GetBuiltBy returns SLSAInputSpec.BuiltBy, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetBuiltBy() BuilderSpec { return v.BuiltBy }

// GetBuildType returns SLSAInputSpec.BuildType, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetBuildType() string { return v.BuildType }

// GetSlsaPredicate returns SLSAInputSpec.SlsaPredicate, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetSlsaPredicate() []SLSAPredicateInputSpec { return v.SlsaPredicate }

// GetSlsaVersion returns SLSAInputSpec.SlsaVersion, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetSlsaVersion() string { return v.SlsaVersion }

// GetStartedOn returns SLSAInputSpec.StartedOn, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetStartedOn() time.Time { return v.StartedOn }

// GetFinishedOn returns SLSAInputSpec.FinishedOn, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetFinishedOn() time.Time { return v.FinishedOn }

// GetOrigin returns SLSAInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns SLSAInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetCollector() string { return v.Collector }

// SLSAPredicateInputSpec is the same as SLSAPredicateSpec, but for mutation
// input.
type SLSAPredicateInputSpec struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns SLSAPredicateInputSpec.Key, and is useful for accessing the field via an interface.
func (v *SLSAPredicateInputSpec) GetKey() string { return v.Key }

// GetValue returns SLSAPredicateInputSpec.Value, and is useful for accessing the field via an interface.
func (v *SLSAPredicateInputSpec) GetValue() string { return v.Value }

// ScorecardCertifyScorecard includes the requested fields of the GraphQL type CertifyScorecard.
// The GraphQL type's documentation follows.
//
// CertifyScorecard is an attestation which represents the scorecard of a
// particular source repository.
type ScorecardCertifyScorecard struct {
	allCertifyScorecard `json:"-"`
}

// GetSource returns ScorecardCertifyScorecard.Source, and is useful for accessing the field via an interface.
func (v *ScorecardCertifyScorecard) GetSource() allCertifyScorecardSource {
	return v.allCertifyScorecard.Source
}

// GetScorecard returns ScorecardCertifyScorecard.Scorecard, and is useful for accessing the field via an interface.
func (v *ScorecardCertifyScorecard) GetScorecard() allCertifyScorecardScorecard {
	return v.allCertifyScorecard.Scorecard
}

func (v *ScorecardCertifyScorecard) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*ScorecardCertifyScorecard
		graphql.NoUnmarshalJSON
	}
	firstPass.ScorecardCertifyScorecard = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyScorecard)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalScorecardCertifyScorecard struct {
	Source allCertifyScorecardSource `json:"source"`

	Scorecard allCertifyScorecardScorecard `json:"scorecard"`
}

func (v *ScorecardCertifyScorecard) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *ScorecardCertifyScorecard) __premarshalJSON() (*__premarshalScorecardCertifyScorecard, error) {
	var retval __premarshalScorecardCertifyScorecard

	retval.Source = v.allCertifyScorecard.Source
	retval.Scorecard = v.allCertifyScorecard.Scorecard
	return &retval, nil
}

// ScorecardCheckInputSpec is the same as ScorecardCheck, but for mutation input.
type ScorecardCheckInputSpec struct {
	Check string `json:"check"`
	Score int    `json:"score"`
}

// GetCheck returns ScorecardCheckInputSpec.Check, and is useful for accessing the field via an interface.
func (v *ScorecardCheckInputSpec) GetCheck() string { return v.Check }

// GetScore returns ScorecardCheckInputSpec.Score, and is useful for accessing the field via an interface.
func (v *ScorecardCheckInputSpec) GetScore() int { return v.Score }

// ScorecardIngestSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type ScorecardIngestSource struct {
	allSourceTree `json:"-"`
}

// GetType returns ScorecardIngestSource.Type, and is useful for accessing the field via an interface.
func (v *ScorecardIngestSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns ScorecardIngestSource.Namespaces, and is useful for accessing the field via an interface.
func (v *ScorecardIngestSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *ScorecardIngestSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*ScorecardIngestSource
		graphql.NoUnmarshalJSON
	}
	firstPass.ScorecardIngestSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalScorecardIngestSource struct {
	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *ScorecardIngestSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *ScorecardIngestSource) __premarshalJSON() (*__premarshalScorecardIngestSource, error) {
	var retval __premarshalScorecardIngestSource

	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// ScorecardInputSpec is the same as Scorecard but for mutation input.
//
// All fields are required.
type ScorecardInputSpec struct {
	Checks           []ScorecardCheckInputSpec `json:"checks"`
	AggregateScore   float64                   `json:"aggregateScore"`
	TimeScanned      time.Time                 `json:"timeScanned"`
	ScorecardVersion string                    `json:"scorecardVersion"`
	ScorecardCommit  string                    `json:"scorecardCommit"`
	Origin           string                    `json:"origin"`
	Collector        string                    `json:"collector"`
}

// GetChecks returns ScorecardInputSpec.Checks, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetChecks() []ScorecardCheckInputSpec { return v.Checks }

// GetAggregateScore returns ScorecardInputSpec.AggregateScore, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetAggregateScore() float64 { return v.AggregateScore }

// GetTimeScanned returns ScorecardInputSpec.TimeScanned, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetTimeScanned() time.Time { return v.TimeScanned }

// GetScorecardVersion returns ScorecardInputSpec.ScorecardVersion, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetScorecardVersion() string { return v.ScorecardVersion }

// GetScorecardCommit returns ScorecardInputSpec.ScorecardCommit, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetScorecardCommit() string { return v.ScorecardCommit }

// GetOrigin returns ScorecardInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns ScorecardInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetCollector() string { return v.Collector }

// ScorecardResponse is returned by Scorecard on success.
type ScorecardResponse struct {
	// Ingest a new source. Returns the ingested source trie
	IngestSource ScorecardIngestSource `json:"ingestSource"`
	// Certifies the Scorecard scanning of a source repository
	CertifyScorecard ScorecardCertifyScorecard `json:"certifyScorecard"`
}

// GetIngestSource returns ScorecardResponse.IngestSource, and is useful for accessing the field via an interface.
func (v *ScorecardResponse) GetIngestSource() ScorecardIngestSource { return v.IngestSource }

// GetCertifyScorecard returns ScorecardResponse.CertifyScorecard, and is useful for accessing the field via an interface.
func (v *ScorecardResponse) GetCertifyScorecard() ScorecardCertifyScorecard {
	return v.CertifyScorecard
}

// SourceInputSpec specifies a source for a mutation.
//
// This is different than SourceSpec because we want to encode that all fields
// except tag and commit are mandatory fields. All optional fields are given
// empty default values.
//
// It is an error to set both `tag` and `commit` fields to values different than
// the default.
type SourceInputSpec struct {
	Type      string  `json:"type"`
	Namespace string  `json:"namespace"`
	Name      string  `json:"name"`
	Tag       *string `json:"tag"`
	Commit    *string `json:"commit"`
}

// GetType returns SourceInputSpec.Type, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetType() string { return v.Type }

// GetNamespace returns SourceInputSpec.Namespace, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetNamespace() string { return v.Namespace }

// GetName returns SourceInputSpec.Name, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetName() string { return v.Name }

// GetTag returns SourceInputSpec.Tag, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetTag() *string { return v.Tag }

// GetCommit returns SourceInputSpec.Commit, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetCommit() *string { return v.Commit }

// __IsDependencyInput is used internally by genqlient
type __IsDependencyInput struct {
	Pkg        PkgInputSpec          `json:"pkg"`
	DepPkg     PkgInputSpec          `json:"depPkg"`
	Dependency IsDependencyInputSpec `json:"dependency"`
}

// GetPkg returns __IsDependencyInput.Pkg, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetDepPkg returns __IsDependencyInput.DepPkg, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetDepPkg() PkgInputSpec { return v.DepPkg }

// GetDependency returns __IsDependencyInput.Dependency, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetDependency() IsDependencyInputSpec { return v.Dependency }

// __IsOccurrencePkgInput is used internally by genqlient
type __IsOccurrencePkgInput struct {
	Pkg        *PkgInputSpec             `json:"pkg"`
	Artifact   ArtifactInputSpec         `json:"artifact"`
	Occurrence IsOccurrenceSpecInputSpec `json:"occurrence"`
}

// GetPkg returns __IsOccurrencePkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__IsOccurrencePkgInput) GetPkg() *PkgInputSpec { return v.Pkg }

// GetArtifact returns __IsOccurrencePkgInput.Artifact, and is useful for accessing the field via an interface.
func (v *__IsOccurrencePkgInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetOccurrence returns __IsOccurrencePkgInput.Occurrence, and is useful for accessing the field via an interface.
func (v *__IsOccurrencePkgInput) GetOccurrence() IsOccurrenceSpecInputSpec { return v.Occurrence }

// __IsOccurrenceSrcInput is used internally by genqlient
type __IsOccurrenceSrcInput struct {
	Source     *SourceInputSpec          `json:"source"`
	Artifact   ArtifactInputSpec         `json:"artifact"`
	Occurrence IsOccurrenceSpecInputSpec `json:"occurrence"`
}

// GetSource returns __IsOccurrenceSrcInput.Source, and is useful for accessing the field via an interface.
func (v *__IsOccurrenceSrcInput) GetSource() *SourceInputSpec { return v.Source }

// GetArtifact returns __IsOccurrenceSrcInput.Artifact, and is useful for accessing the field via an interface.
func (v *__IsOccurrenceSrcInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetOccurrence returns __IsOccurrenceSrcInput.Occurrence, and is useful for accessing the field via an interface.
func (v *__IsOccurrenceSrcInput) GetOccurrence() IsOccurrenceSpecInputSpec { return v.Occurrence }

// __SLSAForArtifactInput is used internally by genqlient
type __SLSAForArtifactInput struct {
	Artifact ArtifactInputSpec `json:"artifact"`
	Slsa     SLSAInputSpec     `json:"slsa"`
}

// GetArtifact returns __SLSAForArtifactInput.Artifact, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetSlsa returns __SLSAForArtifactInput.Slsa, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactInput) GetSlsa() SLSAInputSpec { return v.Slsa }

// __SLSAForPackageInput is used internally by genqlient
type __SLSAForPackageInput struct {
	Pkg  PkgInputSpec  `json:"pkg"`
	Slsa SLSAInputSpec `json:"slsa"`
}

// GetPkg returns __SLSAForPackageInput.Pkg, and is useful for accessing the field via an interface.
func (v *__SLSAForPackageInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetSlsa returns __SLSAForPackageInput.Slsa, and is useful for accessing the field via an interface.
func (v *__SLSAForPackageInput) GetSlsa() SLSAInputSpec { return v.Slsa }

// __SLSAForSourceInput is used internally by genqlient
type __SLSAForSourceInput struct {
	Source SourceInputSpec `json:"source"`
	Slsa   SLSAInputSpec   `json:"slsa"`
}

// GetSource returns __SLSAForSourceInput.Source, and is useful for accessing the field via an interface.
func (v *__SLSAForSourceInput) GetSource() SourceInputSpec { return v.Source }

// GetSlsa returns __SLSAForSourceInput.Slsa, and is useful for accessing the field via an interface.
func (v *__SLSAForSourceInput) GetSlsa() SLSAInputSpec { return v.Slsa }

// __ScorecardInput is used internally by genqlient
type __ScorecardInput struct {
	Source    SourceInputSpec    `json:"source"`
	Scorecard ScorecardInputSpec `json:"scorecard"`
}

// GetSource returns __ScorecardInput.Source, and is useful for accessing the field via an interface.
func (v *__ScorecardInput) GetSource() SourceInputSpec { return v.Source }

// GetScorecard returns __ScorecardInput.Scorecard, and is useful for accessing the field via an interface.
func (v *__ScorecardInput) GetScorecard() ScorecardInputSpec { return v.Scorecard }

// allArtifactTree includes the GraphQL fields of Artifact requested by the fragment allArtifactTree.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type allArtifactTree struct {
	Algorithm string `json:"algorithm"`
	Digest    string `json:"digest"`
}

// GetAlgorithm returns allArtifactTree.Algorithm, and is useful for accessing the field via an interface.
func (v *allArtifactTree) GetAlgorithm() string { return v.Algorithm }

// GetDigest returns allArtifactTree.Digest, and is useful for accessing the field via an interface.
func (v *allArtifactTree) GetDigest() string { return v.Digest }

// allCertifyScorecard includes the GraphQL fields of CertifyScorecard requested by the fragment allCertifyScorecard.
// The GraphQL type's documentation follows.
//
// CertifyScorecard is an attestation which represents the scorecard of a
// particular source repository.
type allCertifyScorecard struct {
	// The source repository that is being scanned (attestation subject)
	Source allCertifyScorecardSource `json:"source"`
	// The Scorecard attached to the repository (attestation object)
	Scorecard allCertifyScorecardScorecard `json:"scorecard"`
}

// GetSource returns allCertifyScorecard.Source, and is useful for accessing the field via an interface.
func (v *allCertifyScorecard) GetSource() allCertifyScorecardSource { return v.Source }

// GetScorecard returns allCertifyScorecard.Scorecard, and is useful for accessing the field via an interface.
func (v *allCertifyScorecard) GetScorecard() allCertifyScorecardScorecard { return v.Scorecard }

// allCertifyScorecardScorecard includes the requested fields of the GraphQL type Scorecard.
// The GraphQL type's documentation follows.
//
// Scorecard contains all of the fields present in a Scorecard attestation.
//
// We also include fields to specify under what conditions the check was performed
// (time of scan, version of scanners, etc.) as well as how this information got
// included into GUAC (origin document and the collector for that document).
type allCertifyScorecardScorecard struct {
	// Exact timestamp when the source was last scanned (in RFC 3339 format)
	TimeScanned time.Time `json:"timeScanned"`
	// Overall Scorecard score for the source
	AggregateScore float64 `json:"aggregateScore"`
	// Individual Scorecard check scores (Branch-Protection, Code-Review, ...)
	Checks []allCertifyScorecardScorecardChecksScorecardCheck `json:"checks"`
	// Version of the Scorecard scanner used to analyze the source
	ScorecardVersion string `json:"scorecardVersion"`
	// Commit of the Scorecards repository at the time of scanning the source
	ScorecardCommit string `json:"scorecardCommit"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetTimeScanned returns allCertifyScorecardScorecard.TimeScanned, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetTimeScanned() time.Time { return v.TimeScanned }

// GetAggregateScore returns allCertifyScorecardScorecard.AggregateScore, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetAggregateScore() float64 { return v.AggregateScore }

// GetChecks returns allCertifyScorecardScorecard.Checks, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetChecks() []allCertifyScorecardScorecardChecksScorecardCheck {
	return v.Checks
}

// GetScorecardVersion returns allCertifyScorecardScorecard.ScorecardVersion, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetScorecardVersion() string { return v.ScorecardVersion }

// GetScorecardCommit returns allCertifyScorecardScorecard.ScorecardCommit, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetScorecardCommit() string { return v.ScorecardCommit }

// GetOrigin returns allCertifyScorecardScorecard.Origin, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetOrigin() string { return v.Origin }

// GetCollector returns allCertifyScorecardScorecard.Collector, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetCollector() string { return v.Collector }

// allCertifyScorecardScorecardChecksScorecardCheck includes the requested fields of the GraphQL type ScorecardCheck.
// The GraphQL type's documentation follows.
//
// ScorecardCheck are the individual checks from scorecard and their values as a
// key-value pair.
//
// For example:  Branch-Protection, Code-Review...etc
//
// Based off scorecard's:
// type jsonCheckResultV2 struct {
// Details []string                 `json:"details"`
// Score   int                      `json:"score"`
// Reason  string                   `json:"reason"`
// Name    string                   `json:"name"`
// Doc     jsonCheckDocumentationV2 `json:"documentation"`
// }
// This node cannot be directly referred by other parts of GUAC.
type allCertifyScorecardScorecardChecksScorecardCheck struct {
	Check string `json:"check"`
	Score int    `json:"score"`
}

// GetCheck returns allCertifyScorecardScorecardChecksScorecardCheck.Check, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecardChecksScorecardCheck) GetCheck() string { return v.Check }

// GetScore returns allCertifyScorecardScorecardChecksScorecardCheck.Score, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecardChecksScorecardCheck) GetScore() int { return v.Score }

// allCertifyScorecardSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allCertifyScorecardSource struct {
	allSourceTree `json:"-"`
}

// GetType returns allCertifyScorecardSource.Type, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns allCertifyScorecardSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *allCertifyScorecardSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allCertifyScorecardSource
		graphql.NoUnmarshalJSON
	}
	firstPass.allCertifyScorecardSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallCertifyScorecardSource struct {
	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *allCertifyScorecardSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allCertifyScorecardSource) __premarshalJSON() (*__premarshalallCertifyScorecardSource, error) {
	var retval __premarshalallCertifyScorecardSource

	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// allIsDependencyTree includes the GraphQL fields of IsDependency requested by the fragment allIsDependencyTree.
// The GraphQL type's documentation follows.
//
// # IsDependency is an attestation that represents when a package is dependent on another package
//
// package (subject) - the package object type that represents the package
// dependentPackage (object) - the package object type that represents the packageName (cannot be to the packageVersion)
// versionRange (property) - string value for version range that applies to the dependent package
// justification (property) - string value representing why the artifacts are the equal
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type allIsDependencyTree struct {
	Justification    string                              `json:"justification"`
	Package          allIsDependencyTreePackage          `json:"package"`
	DependentPackage allIsDependencyTreeDependentPackage `json:"dependentPackage"`
	VersionRange     string                              `json:"versionRange"`
	Origin           string                              `json:"origin"`
	Collector        string                              `json:"collector"`
}

// GetJustification returns allIsDependencyTree.Justification, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetJustification() string { return v.Justification }

// GetPackage returns allIsDependencyTree.Package, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetPackage() allIsDependencyTreePackage { return v.Package }

// GetDependentPackage returns allIsDependencyTree.DependentPackage, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetDependentPackage() allIsDependencyTreeDependentPackage {
	return v.DependentPackage
}

// GetVersionRange returns allIsDependencyTree.VersionRange, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetVersionRange() string { return v.VersionRange }

// GetOrigin returns allIsDependencyTree.Origin, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetOrigin() string { return v.Origin }

// GetCollector returns allIsDependencyTree.Collector, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetCollector() string { return v.Collector }

// allIsDependencyTreeDependentPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allIsDependencyTreeDependentPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns allIsDependencyTreeDependentPackage.Type, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreeDependentPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allIsDependencyTreeDependentPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreeDependentPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allIsDependencyTreeDependentPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsDependencyTreeDependentPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsDependencyTreeDependentPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsDependencyTreeDependentPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allIsDependencyTreeDependentPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsDependencyTreeDependentPackage) __premarshalJSON() (*__premarshalallIsDependencyTreeDependentPackage, error) {
	var retval __premarshalallIsDependencyTreeDependentPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allIsDependencyTreePackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allIsDependencyTreePackage struct {
	allPkgTree `json:"-"`
}

// GetType returns allIsDependencyTreePackage.Type, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreePackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allIsDependencyTreePackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreePackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allIsDependencyTreePackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsDependencyTreePackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsDependencyTreePackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsDependencyTreePackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allIsDependencyTreePackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsDependencyTreePackage) __premarshalJSON() (*__premarshalallIsDependencyTreePackage, error) {
	var retval __premarshalallIsDependencyTreePackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allIsOccurrencesTree includes the GraphQL fields of IsOccurrence requested by the fragment allIsOccurrencesTree.
// The GraphQL type's documentation follows.
//
// # IsOccurrence is an attestation represents when either a package or source is represented by an artifact
//
// subject - union type that can be either a package or source object type
// occurrenceArtifact (object) - artifact that represent the the package or source
// justification (property) - string value representing why the package or source is represented by the specified artifact
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
//
// Note: Package or Source must be specified but not both at the same time.
// Attestation must occur at the PackageName or the PackageVersion or at the SourceName.
//
// HashEqual will be used to connect together two artifacts if a package or source
// is represented by more than one artifact.
//
// IsOccurrence does not connect a package with a source.
// HasSourceAt attestation will be used to connect a package with a source
type allIsOccurrencesTree struct {
	Subject            allIsOccurrencesTreeSubjectPkgSrcObject `json:"-"`
	OccurrenceArtifact allIsOccurrencesTreeOccurrenceArtifact  `json:"occurrenceArtifact"`
	Justification      string                                  `json:"justification"`
	Origin             string                                  `json:"origin"`
	Collector          string                                  `json:"collector"`
}

// GetSubject returns allIsOccurrencesTree.Subject, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetSubject() allIsOccurrencesTreeSubjectPkgSrcObject { return v.Subject }

// GetOccurrenceArtifact returns allIsOccurrencesTree.OccurrenceArtifact, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetOccurrenceArtifact() allIsOccurrencesTreeOccurrenceArtifact {
	return v.OccurrenceArtifact
}

// GetJustification returns allIsOccurrencesTree.Justification, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetJustification() string { return v.Justification }

// GetOrigin returns allIsOccurrencesTree.Origin, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetOrigin() string { return v.Origin }

// GetCollector returns allIsOccurrencesTree.Collector, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetCollector() string { return v.Collector }

func (v *allIsOccurrencesTree) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsOccurrencesTree
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsOccurrencesTree = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalallIsOccurrencesTreeSubjectPkgSrcObject(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"Unable to unmarshal allIsOccurrencesTree.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalallIsOccurrencesTree struct {
	Subject json.RawMessage `json:"subject"`

	OccurrenceArtifact allIsOccurrencesTreeOccurrenceArtifact `json:"occurrenceArtifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *allIsOccurrencesTree) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsOccurrencesTree) __premarshalJSON() (*__premarshalallIsOccurrencesTree, error) {
	var retval __premarshalallIsOccurrencesTree

	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalallIsOccurrencesTreeSubjectPkgSrcObject(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal allIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.OccurrenceArtifact = v.OccurrenceArtifact
	retval.Justification = v.Justification
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// allIsOccurrencesTreeOccurrenceArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type allIsOccurrencesTreeOccurrenceArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns allIsOccurrencesTreeOccurrenceArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeOccurrenceArtifact) GetAlgorithm() string {
	return v.allArtifactTree.Algorithm
}

// GetDigest returns allIsOccurrencesTreeOccurrenceArtifact.Digest, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeOccurrenceArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *allIsOccurrencesTreeOccurrenceArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsOccurrencesTreeOccurrenceArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsOccurrencesTreeOccurrenceArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsOccurrencesTreeOccurrenceArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *allIsOccurrencesTreeOccurrenceArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsOccurrencesTreeOccurrenceArtifact) __premarshalJSON() (*__premarshalallIsOccurrencesTreeOccurrenceArtifact, error) {
	var retval __premarshalallIsOccurrencesTreeOccurrenceArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// allIsOccurrencesTreeSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allIsOccurrencesTreeSubjectPackage struct {
	Typename   *string `json:"__typename"`
	allPkgTree `json:"-"`
}

// GetTypename returns allIsOccurrencesTreeSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectPackage) GetTypename() *string { return v.Typename }

// GetType returns allIsOccurrencesTreeSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allIsOccurrencesTreeSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allIsOccurrencesTreeSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsOccurrencesTreeSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsOccurrencesTreeSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsOccurrencesTreeSubjectPackage struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allIsOccurrencesTreeSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsOccurrencesTreeSubjectPackage) __premarshalJSON() (*__premarshalallIsOccurrencesTreeSubjectPackage, error) {
	var retval __premarshalallIsOccurrencesTreeSubjectPackage

	retval.Typename = v.Typename
	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allIsOccurrencesTreeSubjectPkgSrcObject includes the requested fields of the GraphQL interface PkgSrcObject.
//
// allIsOccurrencesTreeSubjectPkgSrcObject is implemented by the following types:
// allIsOccurrencesTreeSubjectPackage
// allIsOccurrencesTreeSubjectSource
// The GraphQL type's documentation follows.
//
// PkgSrcObject is a union of Package and Source. Any of these objects can be specified
type allIsOccurrencesTreeSubjectPkgSrcObject interface {
	implementsGraphQLInterfaceallIsOccurrencesTreeSubjectPkgSrcObject()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *allIsOccurrencesTreeSubjectPackage) implementsGraphQLInterfaceallIsOccurrencesTreeSubjectPkgSrcObject() {
}
func (v *allIsOccurrencesTreeSubjectSource) implementsGraphQLInterfaceallIsOccurrencesTreeSubjectPkgSrcObject() {
}

func __unmarshalallIsOccurrencesTreeSubjectPkgSrcObject(b []byte, v *allIsOccurrencesTreeSubjectPkgSrcObject) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(allIsOccurrencesTreeSubjectPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(allIsOccurrencesTreeSubjectSource)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PkgSrcObject.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for allIsOccurrencesTreeSubjectPkgSrcObject: "%v"`, tn.TypeName)
	}
}

func __marshalallIsOccurrencesTreeSubjectPkgSrcObject(v *allIsOccurrencesTreeSubjectPkgSrcObject) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *allIsOccurrencesTreeSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallIsOccurrencesTreeSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allIsOccurrencesTreeSubjectSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallIsOccurrencesTreeSubjectSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for allIsOccurrencesTreeSubjectPkgSrcObject: "%T"`, v)
	}
}

// allIsOccurrencesTreeSubjectSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allIsOccurrencesTreeSubjectSource struct {
	Typename      *string `json:"__typename"`
	allSourceTree `json:"-"`
}

// GetTypename returns allIsOccurrencesTreeSubjectSource.Typename, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectSource) GetTypename() *string { return v.Typename }

// GetType returns allIsOccurrencesTreeSubjectSource.Type, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns allIsOccurrencesTreeSubjectSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *allIsOccurrencesTreeSubjectSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsOccurrencesTreeSubjectSource
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsOccurrencesTreeSubjectSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsOccurrencesTreeSubjectSource struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *allIsOccurrencesTreeSubjectSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsOccurrencesTreeSubjectSource) __premarshalJSON() (*__premarshalallIsOccurrencesTreeSubjectSource, error) {
	var retval __premarshalallIsOccurrencesTreeSubjectSource

	retval.Typename = v.Typename
	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// allPkgTree includes the GraphQL fields of Package requested by the fragment allPkgTree.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allPkgTree struct {
	Type       string                                 `json:"type"`
	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

// GetType returns allPkgTree.Type, and is useful for accessing the field via an interface.
func (v *allPkgTree) GetType() string { return v.Type }

// GetNamespaces returns allPkgTree.Namespaces, and is useful for accessing the field via an interface.
func (v *allPkgTree) GetNamespaces() []allPkgTreeNamespacesPackageNamespace { return v.Namespaces }

// allPkgTreeNamespacesPackageNamespace includes the requested fields of the GraphQL type PackageNamespace.
// The GraphQL type's documentation follows.
//
// PackageNamespace is a namespace for packages.
//
// In the pURL representation, each PackageNamespace matches the
// `pkg:<type>/<namespace>/` partial pURL.
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type allPkgTreeNamespacesPackageNamespace struct {
	Namespace string                                                 `json:"namespace"`
	Names     []allPkgTreeNamespacesPackageNamespaceNamesPackageName `json:"names"`
}

// GetNamespace returns allPkgTreeNamespacesPackageNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns allPkgTreeNamespacesPackageNamespace.Names, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespace) GetNames() []allPkgTreeNamespacesPackageNamespaceNamesPackageName {
	return v.Names
}

// allPkgTreeNamespacesPackageNamespaceNamesPackageName includes the requested fields of the GraphQL type PackageName.
// The GraphQL type's documentation follows.
//
// PackageName is a name for packages.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>` pURL.
//
// Names are always mandatory.
//
// This is the first node in the trie that can be referred to by other parts of
// GUAC.
type allPkgTreeNamespacesPackageNamespaceNamesPackageName struct {
	Name     string                                                                       `json:"name"`
	Versions []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion `json:"versions"`
}

// GetName returns allPkgTreeNamespacesPackageNamespaceNamesPackageName.Name, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageName) GetName() string { return v.Name }

// GetVersions returns allPkgTreeNamespacesPackageNamespaceNamesPackageName.Versions, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageName) GetVersions() []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion {
	return v.Versions
}

// allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion includes the requested fields of the GraphQL type PackageVersion.
// The GraphQL type's documentation follows.
//
// PackageVersion is a package version.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>@<version>` pURL.
//
// Versions are optional and each Package type defines own rules for handling them.
// For this level of GUAC, these are just opaque strings.
//
// This node can be referred to by other parts of GUAC.
//
// Subpath and qualifiers are optional. Lack of qualifiers is represented by an
// empty list and lack of subpath by empty string (to be consistent with
// optionality of namespace and version). Two nodes that have different qualifiers
// and/or subpath but the same version mean two different packages in the trie
// (they are different). Two nodes that have same version but qualifiers of one are
// a subset of the qualifier of the other also mean two different packages in the
// trie.
type allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion struct {
	Version    string                                                                                                 `json:"version"`
	Qualifiers []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier `json:"qualifiers"`
	Subpath    string                                                                                                 `json:"subpath"`
}

// GetVersion returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Version, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetVersion() string {
	return v.Version
}

// GetQualifiers returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Qualifiers, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetQualifiers() []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier {
	return v.Qualifiers
}

// GetSubpath returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Subpath, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetSubpath() string {
	return v.Subpath
}

// allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier includes the requested fields of the GraphQL type PackageQualifier.
// The GraphQL type's documentation follows.
//
// PackageQualifier is a qualifier for a package, a key-value pair.
//
// In the pURL representation, it is a part of the `<qualifiers>` part of the
// `pkg:<type>/<namespace>/<name>@<version>?<qualifiers>` pURL.
//
// Qualifiers are optional, each Package type defines own rules for handling them,
// and multiple qualifiers could be attached to the same package.
//
// This node cannot be directly referred by other parts of GUAC.
type allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Key, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetKey() string {
	return v.Key
}

// GetValue returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Value, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetValue() string {
	return v.Value
}

// allSLSATree includes the GraphQL fields of HasSLSA requested by the fragment allSLSATree.
// The GraphQL type's documentation follows.
//
// HasSLSA records that a subject node has a SLSA attestation.
type allSLSATree struct {
	// The subject of SLSA attestation: package, source, or artifact.
	Subject allSLSATreeSubjectPackageSourceOrArtifact `json:"-"`
	// The SLSA attestation.
	Slsa *allSLSATreeSlsaSLSA `json:"slsa"`
}

// GetSubject returns allSLSATree.Subject, and is useful for accessing the field via an interface.
func (v *allSLSATree) GetSubject() allSLSATreeSubjectPackageSourceOrArtifact { return v.Subject }

// GetSlsa returns allSLSATree.Slsa, and is useful for accessing the field via an interface.
func (v *allSLSATree) GetSlsa() *allSLSATreeSlsaSLSA { return v.Slsa }

func (v *allSLSATree) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATree
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATree = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalallSLSATreeSubjectPackageSourceOrArtifact(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"Unable to unmarshal allSLSATree.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalallSLSATree struct {
	Subject json.RawMessage `json:"subject"`

	Slsa *allSLSATreeSlsaSLSA `json:"slsa"`
}

func (v *allSLSATree) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATree) __premarshalJSON() (*__premarshalallSLSATree, error) {
	var retval __premarshalallSLSATree

	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalallSLSATreeSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal allSLSATree.Subject: %w", err)
		}
	}
	retval.Slsa = v.Slsa
	return &retval, nil
}

// allSLSATreeSlsaSLSA includes the requested fields of the GraphQL type SLSA.
// The GraphQL type's documentation follows.
//
// SLSA contains all of the fields present in a SLSA attestation.
//
// The materials and builders are objects of the HasSLSA predicate, everything
// else are properties extracted from the attestation.
//
// We also include fields to specify under what conditions the check was performed
// (time of scan, version of scanners, etc.) as well as how this information got
// included into GUAC (origin document and the collector for that document).
type allSLSATreeSlsaSLSA struct {
	// Sources of the build resulting in subject (materials)
	BuiltFrom []allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact `json:"-"`
	// Builder performing the build
	BuiltBy allSLSATreeSlsaSLSABuiltByBuilder `json:"builtBy"`
	// Type of the builder
	BuildType string `json:"buildType"`
	// Individual predicates found in the attestation
	SlsaPredicate []allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate `json:"slsaPredicate"`
	// Version of the SLSA predicate
	SlsaVersion string `json:"slsaVersion"`
	// Timestamp (RFC3339Nano format) of build start time
	StartedOn time.Time `json:"startedOn"`
	// Timestamp (RFC3339Nano format) of build end time
	FinishedOn time.Time `json:"finishedOn"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetBuiltFrom returns allSLSATreeSlsaSLSA.BuiltFrom, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetBuiltFrom() []allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact {
	return v.BuiltFrom
}

// GetBuiltBy returns allSLSATreeSlsaSLSA.BuiltBy, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetBuiltBy() allSLSATreeSlsaSLSABuiltByBuilder { return v.BuiltBy }

// GetBuildType returns allSLSATreeSlsaSLSA.BuildType, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetBuildType() string { return v.BuildType }

// GetSlsaPredicate returns allSLSATreeSlsaSLSA.SlsaPredicate, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetSlsaPredicate() []allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate {
	return v.SlsaPredicate
}

// GetSlsaVersion returns allSLSATreeSlsaSLSA.SlsaVersion, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetSlsaVersion() string { return v.SlsaVersion }

// GetStartedOn returns allSLSATreeSlsaSLSA.StartedOn, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetStartedOn() time.Time { return v.StartedOn }

// GetFinishedOn returns allSLSATreeSlsaSLSA.FinishedOn, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetFinishedOn() time.Time { return v.FinishedOn }

// GetOrigin returns allSLSATreeSlsaSLSA.Origin, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetOrigin() string { return v.Origin }

// GetCollector returns allSLSATreeSlsaSLSA.Collector, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetCollector() string { return v.Collector }

func (v *allSLSATreeSlsaSLSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSlsaSLSA
		BuiltFrom []json.RawMessage `json:"builtFrom"`
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSlsaSLSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.BuiltFrom
		src := firstPass.BuiltFrom
		*dst = make(
			[]allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				err = __unmarshalallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact(
					src, dst)
				if err != nil {
					return fmt.Errorf(
						"Unable to unmarshal allSLSATreeSlsaSLSA.BuiltFrom: %w", err)
				}
			}
		}
	}
	return nil
}

type __premarshalallSLSATreeSlsaSLSA struct {
	BuiltFrom []json.RawMessage `json:"builtFrom"`

	BuiltBy allSLSATreeSlsaSLSABuiltByBuilder `json:"builtBy"`

	BuildType string `json:"buildType"`

	SlsaPredicate []allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate `json:"slsaPredicate"`

	SlsaVersion string `json:"slsaVersion"`

	StartedOn time.Time `json:"startedOn"`

	FinishedOn time.Time `json:"finishedOn"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *allSLSATreeSlsaSLSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSlsaSLSA) __premarshalJSON() (*__premarshalallSLSATreeSlsaSLSA, error) {
	var retval __premarshalallSLSATreeSlsaSLSA

	{

		dst := &retval.BuiltFrom
		src := v.BuiltFrom
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			var err error
			*dst, err = __marshalallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact(
				&src)
			if err != nil {
				return nil, fmt.Errorf(
					"Unable to marshal allSLSATreeSlsaSLSA.BuiltFrom: %w", err)
			}
		}
	}
	retval.BuiltBy = v.BuiltBy
	retval.BuildType = v.BuildType
	retval.SlsaPredicate = v.SlsaPredicate
	retval.SlsaVersion = v.SlsaVersion
	retval.StartedOn = v.StartedOn
	retval.FinishedOn = v.FinishedOn
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// allSLSATreeSlsaSLSABuiltByBuilder includes the requested fields of the GraphQL type Builder.
// The GraphQL type's documentation follows.
//
// Builder represents the builder such as (FRSCA or github actions).
//
// Currently builders are identified by the `uri` field, which is mandatory.
type allSLSATreeSlsaSLSABuiltByBuilder struct {
	Uri string `json:"uri"`
}

// GetUri returns allSLSATreeSlsaSLSABuiltByBuilder.Uri, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltByBuilder) GetUri() string { return v.Uri }

// allSLSATreeSlsaSLSABuiltFromArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type allSLSATreeSlsaSLSABuiltFromArtifact struct {
	Typename        *string `json:"__typename"`
	allArtifactTree `json:"-"`
}

// GetTypename returns allSLSATreeSlsaSLSABuiltFromArtifact.Typename, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromArtifact) GetTypename() *string { return v.Typename }

// GetAlgorithm returns allSLSATreeSlsaSLSABuiltFromArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromArtifact) GetAlgorithm() string {
	return v.allArtifactTree.Algorithm
}

// GetDigest returns allSLSATreeSlsaSLSABuiltFromArtifact.Digest, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *allSLSATreeSlsaSLSABuiltFromArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSlsaSLSABuiltFromArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSlsaSLSABuiltFromArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallSLSATreeSlsaSLSABuiltFromArtifact struct {
	Typename *string `json:"__typename"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *allSLSATreeSlsaSLSABuiltFromArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSlsaSLSABuiltFromArtifact) __premarshalJSON() (*__premarshalallSLSATreeSlsaSLSABuiltFromArtifact, error) {
	var retval __premarshalallSLSATreeSlsaSLSABuiltFromArtifact

	retval.Typename = v.Typename
	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// allSLSATreeSlsaSLSABuiltFromPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allSLSATreeSlsaSLSABuiltFromPackage struct {
	Typename   *string `json:"__typename"`
	allPkgTree `json:"-"`
}

// GetTypename returns allSLSATreeSlsaSLSABuiltFromPackage.Typename, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromPackage) GetTypename() *string { return v.Typename }

// GetType returns allSLSATreeSlsaSLSABuiltFromPackage.Type, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allSLSATreeSlsaSLSABuiltFromPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allSLSATreeSlsaSLSABuiltFromPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSlsaSLSABuiltFromPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSlsaSLSABuiltFromPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallSLSATreeSlsaSLSABuiltFromPackage struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allSLSATreeSlsaSLSABuiltFromPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSlsaSLSABuiltFromPackage) __premarshalJSON() (*__premarshalallSLSATreeSlsaSLSABuiltFromPackage, error) {
	var retval __premarshalallSLSATreeSlsaSLSABuiltFromPackage

	retval.Typename = v.Typename
	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact includes the requested fields of the GraphQL interface PackageSourceOrArtifact.
//
// allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact is implemented by the following types:
// allSLSATreeSlsaSLSABuiltFromPackage
// allSLSATreeSlsaSLSABuiltFromSource
// allSLSATreeSlsaSLSABuiltFromArtifact
// The GraphQL type's documentation follows.
//
// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact interface {
	implementsGraphQLInterfaceallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *allSLSATreeSlsaSLSABuiltFromPackage) implementsGraphQLInterfaceallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact() {
}
func (v *allSLSATreeSlsaSLSABuiltFromSource) implementsGraphQLInterfaceallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact() {
}
func (v *allSLSATreeSlsaSLSABuiltFromArtifact) implementsGraphQLInterfaceallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact() {
}

func __unmarshalallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact(b []byte, v *allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(allSLSATreeSlsaSLSABuiltFromPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(allSLSATreeSlsaSLSABuiltFromSource)
		return json.Unmarshal(b, *v)
	case "Artifact":
		*v = new(allSLSATreeSlsaSLSABuiltFromArtifact)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageSourceOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact(v *allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *allSLSATreeSlsaSLSABuiltFromPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallSLSATreeSlsaSLSABuiltFromPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allSLSATreeSlsaSLSABuiltFromSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallSLSATreeSlsaSLSABuiltFromSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allSLSATreeSlsaSLSABuiltFromArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallSLSATreeSlsaSLSABuiltFromArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact: "%T"`, v)
	}
}

// allSLSATreeSlsaSLSABuiltFromSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allSLSATreeSlsaSLSABuiltFromSource struct {
	Typename      *string `json:"__typename"`
	allSourceTree `json:"-"`
}

// GetTypename returns allSLSATreeSlsaSLSABuiltFromSource.Typename, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromSource) GetTypename() *string { return v.Typename }

// GetType returns allSLSATreeSlsaSLSABuiltFromSource.Type, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns allSLSATreeSlsaSLSABuiltFromSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *allSLSATreeSlsaSLSABuiltFromSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSlsaSLSABuiltFromSource
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSlsaSLSABuiltFromSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallSLSATreeSlsaSLSABuiltFromSource struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *allSLSATreeSlsaSLSABuiltFromSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSlsaSLSABuiltFromSource) __premarshalJSON() (*__premarshalallSLSATreeSlsaSLSABuiltFromSource, error) {
	var retval __premarshalallSLSATreeSlsaSLSABuiltFromSource

	retval.Typename = v.Typename
	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate includes the requested fields of the GraphQL type SLSAPredicate.
// The GraphQL type's documentation follows.
//
// SLSAPredicate are the values from the SLSA predicate in key-value pair form.
//
// # For example, given the following predicate
//
// ```
// "predicate": {
// "buildDefinition": {
// "externalParameters": {
// "repository": "https://github.com/octocat/hello-world",
// ...
// },
// ...
// },
// ...
// }
// ```
//
// we have
//
// ```
// key   = "buildDefinition.externalParameters.repository"
// value = "https://github.com/octocat/hello-world"
// ```
//
// This node cannot be directly referred by other parts of GUAC.
//
// TODO(mihaimaruseac): Can we define these directly?
type allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate.Key, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate) GetKey() string { return v.Key }

// GetValue returns allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate.Value, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate) GetValue() string { return v.Value }

// allSLSATreeSubjectArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type allSLSATreeSubjectArtifact struct {
	Typename        *string `json:"__typename"`
	allArtifactTree `json:"-"`
}

// GetTypename returns allSLSATreeSubjectArtifact.Typename, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectArtifact) GetTypename() *string { return v.Typename }

// GetAlgorithm returns allSLSATreeSubjectArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns allSLSATreeSubjectArtifact.Digest, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *allSLSATreeSubjectArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSubjectArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSubjectArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallSLSATreeSubjectArtifact struct {
	Typename *string `json:"__typename"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *allSLSATreeSubjectArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSubjectArtifact) __premarshalJSON() (*__premarshalallSLSATreeSubjectArtifact, error) {
	var retval __premarshalallSLSATreeSubjectArtifact

	retval.Typename = v.Typename
	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// allSLSATreeSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allSLSATreeSubjectPackage struct {
	Typename   *string `json:"__typename"`
	allPkgTree `json:"-"`
}

// GetTypename returns allSLSATreeSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectPackage) GetTypename() *string { return v.Typename }

// GetType returns allSLSATreeSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allSLSATreeSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allSLSATreeSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallSLSATreeSubjectPackage struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allSLSATreeSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSubjectPackage) __premarshalJSON() (*__premarshalallSLSATreeSubjectPackage, error) {
	var retval __premarshalallSLSATreeSubjectPackage

	retval.Typename = v.Typename
	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allSLSATreeSubjectPackageSourceOrArtifact includes the requested fields of the GraphQL interface PackageSourceOrArtifact.
//
// allSLSATreeSubjectPackageSourceOrArtifact is implemented by the following types:
// allSLSATreeSubjectPackage
// allSLSATreeSubjectSource
// allSLSATreeSubjectArtifact
// The GraphQL type's documentation follows.
//
// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type allSLSATreeSubjectPackageSourceOrArtifact interface {
	implementsGraphQLInterfaceallSLSATreeSubjectPackageSourceOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *allSLSATreeSubjectPackage) implementsGraphQLInterfaceallSLSATreeSubjectPackageSourceOrArtifact() {
}
func (v *allSLSATreeSubjectSource) implementsGraphQLInterfaceallSLSATreeSubjectPackageSourceOrArtifact() {
}
func (v *allSLSATreeSubjectArtifact) implementsGraphQLInterfaceallSLSATreeSubjectPackageSourceOrArtifact() {
}

func __unmarshalallSLSATreeSubjectPackageSourceOrArtifact(b []byte, v *allSLSATreeSubjectPackageSourceOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(allSLSATreeSubjectPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(allSLSATreeSubjectSource)
		return json.Unmarshal(b, *v)
	case "Artifact":
		*v = new(allSLSATreeSubjectArtifact)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageSourceOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for allSLSATreeSubjectPackageSourceOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalallSLSATreeSubjectPackageSourceOrArtifact(v *allSLSATreeSubjectPackageSourceOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *allSLSATreeSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallSLSATreeSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allSLSATreeSubjectSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallSLSATreeSubjectSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allSLSATreeSubjectArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallSLSATreeSubjectArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for allSLSATreeSubjectPackageSourceOrArtifact: "%T"`, v)
	}
}

// allSLSATreeSubjectSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allSLSATreeSubjectSource struct {
	Typename      *string `json:"__typename"`
	allSourceTree `json:"-"`
}

// GetTypename returns allSLSATreeSubjectSource.Typename, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectSource) GetTypename() *string { return v.Typename }

// GetType returns allSLSATreeSubjectSource.Type, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns allSLSATreeSubjectSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *allSLSATreeSubjectSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSubjectSource
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSubjectSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallSLSATreeSubjectSource struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *allSLSATreeSubjectSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSubjectSource) __premarshalJSON() (*__premarshalallSLSATreeSubjectSource, error) {
	var retval __premarshalallSLSATreeSubjectSource

	retval.Typename = v.Typename
	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// allSourceTree includes the GraphQL fields of Source requested by the fragment allSourceTree.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allSourceTree struct {
	Type       string                                   `json:"type"`
	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

// GetType returns allSourceTree.Type, and is useful for accessing the field via an interface.
func (v *allSourceTree) GetType() string { return v.Type }

// GetNamespaces returns allSourceTree.Namespaces, and is useful for accessing the field via an interface.
func (v *allSourceTree) GetNamespaces() []allSourceTreeNamespacesSourceNamespace { return v.Namespaces }

// allSourceTreeNamespacesSourceNamespace includes the requested fields of the GraphQL type SourceNamespace.
// The GraphQL type's documentation follows.
//
// SourceNamespace is a namespace for sources.
//
// This is the location of the repository (such as github/gitlab/bitbucket).
//
// The `namespace` field is mandatory.
type allSourceTreeNamespacesSourceNamespace struct {
	Namespace string                                                  `json:"namespace"`
	Names     []allSourceTreeNamespacesSourceNamespaceNamesSourceName `json:"names"`
}

// GetNamespace returns allSourceTreeNamespacesSourceNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *allSourceTreeNamespacesSourceNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns allSourceTreeNamespacesSourceNamespace.Names, and is useful for accessing the field via an interface.
func (v *allSourceTreeNamespacesSourceNamespace) GetNames() []allSourceTreeNamespacesSourceNamespaceNamesSourceName {
	return v.Names
}

// allSourceTreeNamespacesSourceNamespaceNamesSourceName includes the requested fields of the GraphQL type SourceName.
// The GraphQL type's documentation follows.
//
// SourceName is a url of the repository and its tag or commit.
//
// The `name` field is mandatory. The `tag` and `commit` fields are optional, but
// it is an error to specify both.
//
// This is the only source trie node that can be referenced by other parts of
// GUAC.
type allSourceTreeNamespacesSourceNamespaceNamesSourceName struct {
	Name   string  `json:"name"`
	Tag    *string `json:"tag"`
	Commit *string `json:"commit"`
}

// GetName returns allSourceTreeNamespacesSourceNamespaceNamesSourceName.Name, and is useful for accessing the field via an interface.
func (v *allSourceTreeNamespacesSourceNamespaceNamesSourceName) GetName() string { return v.Name }

// GetTag returns allSourceTreeNamespacesSourceNamespaceNamesSourceName.Tag, and is useful for accessing the field via an interface.
func (v *allSourceTreeNamespacesSourceNamespaceNamesSourceName) GetTag() *string { return v.Tag }

// GetCommit returns allSourceTreeNamespacesSourceNamespaceNamesSourceName.Commit, and is useful for accessing the field via an interface.
func (v *allSourceTreeNamespacesSourceNamespaceNamesSourceName) GetCommit() *string { return v.Commit }

func IsDependency(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	depPkg PkgInputSpec,
	dependency IsDependencyInputSpec,
) (*IsDependencyResponse, error) {
	req := &graphql.Request{
		OpName: "IsDependency",
		Query: `
mutation IsDependency ($pkg: PkgInputSpec!, $depPkg: PkgInputSpec!, $dependency: IsDependencyInputSpec!) {
	pkg: ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	dependentPkg: ingestPackage(pkg: $depPkg) {
		... allPkgTree
	}
	ingestDependency(pkg: $pkg, depPkg: $depPkg, dependency: $dependency) {
		... allIsDependencyTree
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allIsDependencyTree on IsDependency {
	justification
	package {
		... allPkgTree
	}
	dependentPackage {
		... allPkgTree
	}
	versionRange
	origin
	collector
}
`,
		Variables: &__IsDependencyInput{
			Pkg:        pkg,
			DepPkg:     depPkg,
			Dependency: dependency,
		},
	}
	var err error

	var data IsDependencyResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func IsOccurrencePkg(
	ctx context.Context,
	client graphql.Client,
	pkg *PkgInputSpec,
	artifact ArtifactInputSpec,
	occurrence IsOccurrenceSpecInputSpec,
) (*IsOccurrencePkgResponse, error) {
	req := &graphql.Request{
		OpName: "IsOccurrencePkg",
		Query: `
mutation IsOccurrencePkg ($pkg: PkgInputSpec, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceSpecInputSpec!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestArtifact(artifact: $artifact) {
		... allArtifactTree
	}
	ingestOccurrence(pkg: $pkg, artifact: $artifact, occurrence: $occurrence) {
		... allIsOccurrencesTree
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
fragment allIsOccurrencesTree on IsOccurrence {
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
	}
	occurrenceArtifact {
		... allArtifactTree
	}
	justification
	origin
	collector
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
`,
		Variables: &__IsOccurrencePkgInput{
			Pkg:        pkg,
			Artifact:   artifact,
			Occurrence: occurrence,
		},
	}
	var err error

	var data IsOccurrencePkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func IsOccurrenceSrc(
	ctx context.Context,
	client graphql.Client,
	source *SourceInputSpec,
	artifact ArtifactInputSpec,
	occurrence IsOccurrenceSpecInputSpec,
) (*IsOccurrenceSrcResponse, error) {
	req := &graphql.Request{
		OpName: "IsOccurrenceSrc",
		Query: `
mutation IsOccurrenceSrc ($source: SourceInputSpec, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceSpecInputSpec!) {
	ingestSource(source: $source) {
		... allSourceTree
	}
	ingestArtifact(artifact: $artifact) {
		... allArtifactTree
	}
	ingestOccurrence(source: $source, artifact: $artifact, occurrence: $occurrence) {
		... allIsOccurrencesTree
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
fragment allIsOccurrencesTree on IsOccurrence {
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
	}
	occurrenceArtifact {
		... allArtifactTree
	}
	justification
	origin
	collector
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
`,
		Variables: &__IsOccurrenceSrcInput{
			Source:     source,
			Artifact:   artifact,
			Occurrence: occurrence,
		},
	}
	var err error

	var data IsOccurrenceSrcResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func SLSAForArtifact(
	ctx context.Context,
	client graphql.Client,
	artifact ArtifactInputSpec,
	slsa SLSAInputSpec,
) (*SLSAForArtifactResponse, error) {
	req := &graphql.Request{
		OpName: "SLSAForArtifact",
		Query: `
mutation SLSAForArtifact ($artifact: ArtifactInputSpec!, $slsa: SLSAInputSpec!) {
	ingestArtifact(artifact: $artifact) {
		... allArtifactTree
	}
	ingestSLSA(subject: {artifact:$artifact}, slsa: $slsa) {
		... allSLSATree
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
fragment allSLSATree on HasSLSA {
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
		... on Artifact {
			... allArtifactTree
		}
	}
	slsa {
		builtFrom {
			__typename
			... on Package {
				... allPkgTree
			}
			... on Source {
				... allSourceTree
			}
			... on Artifact {
				... allArtifactTree
			}
		}
		builtBy {
			uri
		}
		buildType
		slsaPredicate {
			key
			value
		}
		slsaVersion
		startedOn
		finishedOn
		origin
		collector
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
`,
		Variables: &__SLSAForArtifactInput{
			Artifact: artifact,
			Slsa:     slsa,
		},
	}
	var err error

	var data SLSAForArtifactResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func SLSAForPackage(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	slsa SLSAInputSpec,
) (*SLSAForPackageResponse, error) {
	req := &graphql.Request{
		OpName: "SLSAForPackage",
		Query: `
mutation SLSAForPackage ($pkg: PkgInputSpec!, $slsa: SLSAInputSpec!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestSLSA(subject: {package:$pkg}, slsa: $slsa) {
		... allSLSATree
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allSLSATree on HasSLSA {
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
		... on Artifact {
			... allArtifactTree
		}
	}
	slsa {
		builtFrom {
			__typename
			... on Package {
				... allPkgTree
			}
			... on Source {
				... allSourceTree
			}
			... on Artifact {
				... allArtifactTree
			}
		}
		builtBy {
			uri
		}
		buildType
		slsaPredicate {
			key
			value
		}
		slsaVersion
		startedOn
		finishedOn
		origin
		collector
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
`,
		Variables: &__SLSAForPackageInput{
			Pkg:  pkg,
			Slsa: slsa,
		},
	}
	var err error

	var data SLSAForPackageResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func SLSAForSource(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	slsa SLSAInputSpec,
) (*SLSAForSourceResponse, error) {
	req := &graphql.Request{
		OpName: "SLSAForSource",
		Query: `
mutation SLSAForSource ($source: SourceInputSpec!, $slsa: SLSAInputSpec!) {
	ingestSource(source: $source) {
		... allSourceTree
	}
	ingestSLSA(subject: {source:$source}, slsa: $slsa) {
		... allSLSATree
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allSLSATree on HasSLSA {
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
		... on Artifact {
			... allArtifactTree
		}
	}
	slsa {
		builtFrom {
			__typename
			... on Package {
				... allPkgTree
			}
			... on Source {
				... allSourceTree
			}
			... on Artifact {
				... allArtifactTree
			}
		}
		builtBy {
			uri
		}
		buildType
		slsaPredicate {
			key
			value
		}
		slsaVersion
		startedOn
		finishedOn
		origin
		collector
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
`,
		Variables: &__SLSAForSourceInput{
			Source: source,
			Slsa:   slsa,
		},
	}
	var err error

	var data SLSAForSourceResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func Scorecard(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	scorecard ScorecardInputSpec,
) (*ScorecardResponse, error) {
	req := &graphql.Request{
		OpName: "Scorecard",
		Query: `
mutation Scorecard ($source: SourceInputSpec!, $scorecard: ScorecardInputSpec!) {
	ingestSource(source: $source) {
		... allSourceTree
	}
	certifyScorecard(source: $source, scorecard: $scorecard) {
		... allCertifyScorecard
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allCertifyScorecard on CertifyScorecard {
	source {
		... allSourceTree
	}
	scorecard {
		timeScanned
		aggregateScore
		checks {
			check
			score
		}
		scorecardVersion
		scorecardCommit
		origin
		collector
	}
}
`,
		Variables: &__ScorecardInput{
			Source:    source,
			Scorecard: scorecard,
		},
	}
	var err error

	var data ScorecardResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}
