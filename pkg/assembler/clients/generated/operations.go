// Code generated by github.com/Khan/genqlient, DO NOT EDIT.

package generated

import (
	"context"
	"encoding/json"
	"time"

	"github.com/Khan/genqlient/graphql"
)

// IsDependencyDependentPkgPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type IsDependencyDependentPkgPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns IsDependencyDependentPkgPackage.Type, and is useful for accessing the field via an interface.
func (v *IsDependencyDependentPkgPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns IsDependencyDependentPkgPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *IsDependencyDependentPkgPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *IsDependencyDependentPkgPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsDependencyDependentPkgPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.IsDependencyDependentPkgPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsDependencyDependentPkgPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *IsDependencyDependentPkgPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsDependencyDependentPkgPackage) __premarshalJSON() (*__premarshalIsDependencyDependentPkgPackage, error) {
	var retval __premarshalIsDependencyDependentPkgPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// IsDependencyIngestDependencyIsDependency includes the requested fields of the GraphQL type IsDependency.
// The GraphQL type's documentation follows.
//
// # IsDependency is an attestation that represents when a package is dependent on another package
//
// package (subject) - the package object type that represents the package
// dependentPackage (object) - the package object type that represents the packageName (cannot be to the packageVersion)
// versionRange (property) - string value for version range that applies to the dependent package
// justification (property) - string value representing why the artifacts are the equal
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type IsDependencyIngestDependencyIsDependency struct {
	allIsDependencyTree `json:"-"`
}

// GetJustification returns IsDependencyIngestDependencyIsDependency.Justification, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetJustification() string {
	return v.allIsDependencyTree.Justification
}

// GetPackage returns IsDependencyIngestDependencyIsDependency.Package, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetPackage() allIsDependencyTreePackage {
	return v.allIsDependencyTree.Package
}

// GetDependentPackage returns IsDependencyIngestDependencyIsDependency.DependentPackage, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetDependentPackage() allIsDependencyTreeDependentPackage {
	return v.allIsDependencyTree.DependentPackage
}

// GetVersionRange returns IsDependencyIngestDependencyIsDependency.VersionRange, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetVersionRange() string {
	return v.allIsDependencyTree.VersionRange
}

// GetOrigin returns IsDependencyIngestDependencyIsDependency.Origin, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetOrigin() string {
	return v.allIsDependencyTree.Origin
}

// GetCollector returns IsDependencyIngestDependencyIsDependency.Collector, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetCollector() string {
	return v.allIsDependencyTree.Collector
}

func (v *IsDependencyIngestDependencyIsDependency) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsDependencyIngestDependencyIsDependency
		graphql.NoUnmarshalJSON
	}
	firstPass.IsDependencyIngestDependencyIsDependency = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allIsDependencyTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsDependencyIngestDependencyIsDependency struct {
	Justification string `json:"justification"`

	Package allIsDependencyTreePackage `json:"package"`

	DependentPackage allIsDependencyTreeDependentPackage `json:"dependentPackage"`

	VersionRange string `json:"versionRange"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *IsDependencyIngestDependencyIsDependency) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsDependencyIngestDependencyIsDependency) __premarshalJSON() (*__premarshalIsDependencyIngestDependencyIsDependency, error) {
	var retval __premarshalIsDependencyIngestDependencyIsDependency

	retval.Justification = v.allIsDependencyTree.Justification
	retval.Package = v.allIsDependencyTree.Package
	retval.DependentPackage = v.allIsDependencyTree.DependentPackage
	retval.VersionRange = v.allIsDependencyTree.VersionRange
	retval.Origin = v.allIsDependencyTree.Origin
	retval.Collector = v.allIsDependencyTree.Collector
	return &retval, nil
}

// IsDependencyInputSpec is the same as IsDependency but for mutation input.
//
// All fields are required.
type IsDependencyInputSpec struct {
	VersionRange  string `json:"versionRange"`
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetVersionRange returns IsDependencyInputSpec.VersionRange, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetVersionRange() string { return v.VersionRange }

// GetJustification returns IsDependencyInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns IsDependencyInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns IsDependencyInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetCollector() string { return v.Collector }

// IsDependencyPkgPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type IsDependencyPkgPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns IsDependencyPkgPackage.Type, and is useful for accessing the field via an interface.
func (v *IsDependencyPkgPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns IsDependencyPkgPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *IsDependencyPkgPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *IsDependencyPkgPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsDependencyPkgPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.IsDependencyPkgPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsDependencyPkgPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *IsDependencyPkgPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsDependencyPkgPackage) __premarshalJSON() (*__premarshalIsDependencyPkgPackage, error) {
	var retval __premarshalIsDependencyPkgPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// IsDependencyResponse is returned by IsDependency on success.
type IsDependencyResponse struct {
	// Ingest a new package. Returns the ingested package trie
	Pkg IsDependencyPkgPackage `json:"pkg"`
	// Ingest a new package. Returns the ingested package trie
	DependentPkg IsDependencyDependentPkgPackage `json:"dependentPkg"`
	// Adds dependency between two packages
	IngestDependency IsDependencyIngestDependencyIsDependency `json:"ingestDependency"`
}

// GetPkg returns IsDependencyResponse.Pkg, and is useful for accessing the field via an interface.
func (v *IsDependencyResponse) GetPkg() IsDependencyPkgPackage { return v.Pkg }

// GetDependentPkg returns IsDependencyResponse.DependentPkg, and is useful for accessing the field via an interface.
func (v *IsDependencyResponse) GetDependentPkg() IsDependencyDependentPkgPackage {
	return v.DependentPkg
}

// GetIngestDependency returns IsDependencyResponse.IngestDependency, and is useful for accessing the field via an interface.
func (v *IsDependencyResponse) GetIngestDependency() IsDependencyIngestDependencyIsDependency {
	return v.IngestDependency
}

// PackageQualifierInputSpec is the same as PackageQualifier, but usable as
// mutation input.
//
// GraphQL does not allow input types to contain composite types and does not allow
// composite types to contain input types. So, although in this case these two
// types are semantically the same, we have to duplicate the definition.
//
// Both fields are mandatory.
type PackageQualifierInputSpec struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns PackageQualifierInputSpec.Key, and is useful for accessing the field via an interface.
func (v *PackageQualifierInputSpec) GetKey() string { return v.Key }

// GetValue returns PackageQualifierInputSpec.Value, and is useful for accessing the field via an interface.
func (v *PackageQualifierInputSpec) GetValue() string { return v.Value }

// PkgInputSpec specifies a package for a mutation.
//
// This is different than PkgSpec because we want to encode mandatory fields:
// `type` and `name`. All optional fields are given empty default values.
type PkgInputSpec struct {
	Type       string                      `json:"type"`
	Namespace  string                      `json:"namespace"`
	Name       string                      `json:"name"`
	Version    string                      `json:"version"`
	Qualifiers []PackageQualifierInputSpec `json:"qualifiers"`
	Subpath    string                      `json:"subpath"`
}

// GetType returns PkgInputSpec.Type, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetType() string { return v.Type }

// GetNamespace returns PkgInputSpec.Namespace, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetNamespace() string { return v.Namespace }

// GetName returns PkgInputSpec.Name, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetName() string { return v.Name }

// GetVersion returns PkgInputSpec.Version, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetVersion() string { return v.Version }

// GetQualifiers returns PkgInputSpec.Qualifiers, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetQualifiers() []PackageQualifierInputSpec { return v.Qualifiers }

// GetSubpath returns PkgInputSpec.Subpath, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetSubpath() string { return v.Subpath }

// ScorecardCertifyScorecard includes the requested fields of the GraphQL type CertifyScorecard.
// The GraphQL type's documentation follows.
//
// CertifyScorecard is an attestation which represents the scorecard of a
// particular source repository.
type ScorecardCertifyScorecard struct {
	allCertifyScorecard `json:"-"`
}

// GetSource returns ScorecardCertifyScorecard.Source, and is useful for accessing the field via an interface.
func (v *ScorecardCertifyScorecard) GetSource() allCertifyScorecardSource {
	return v.allCertifyScorecard.Source
}

// GetScorecard returns ScorecardCertifyScorecard.Scorecard, and is useful for accessing the field via an interface.
func (v *ScorecardCertifyScorecard) GetScorecard() allCertifyScorecardScorecard {
	return v.allCertifyScorecard.Scorecard
}

func (v *ScorecardCertifyScorecard) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*ScorecardCertifyScorecard
		graphql.NoUnmarshalJSON
	}
	firstPass.ScorecardCertifyScorecard = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyScorecard)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalScorecardCertifyScorecard struct {
	Source allCertifyScorecardSource `json:"source"`

	Scorecard allCertifyScorecardScorecard `json:"scorecard"`
}

func (v *ScorecardCertifyScorecard) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *ScorecardCertifyScorecard) __premarshalJSON() (*__premarshalScorecardCertifyScorecard, error) {
	var retval __premarshalScorecardCertifyScorecard

	retval.Source = v.allCertifyScorecard.Source
	retval.Scorecard = v.allCertifyScorecard.Scorecard
	return &retval, nil
}

// ScorecardCheckInputSpec is the same as ScorecardCheck, but for mutation input.
type ScorecardCheckInputSpec struct {
	Check string `json:"check"`
	Score int    `json:"score"`
}

// GetCheck returns ScorecardCheckInputSpec.Check, and is useful for accessing the field via an interface.
func (v *ScorecardCheckInputSpec) GetCheck() string { return v.Check }

// GetScore returns ScorecardCheckInputSpec.Score, and is useful for accessing the field via an interface.
func (v *ScorecardCheckInputSpec) GetScore() int { return v.Score }

// ScorecardIngestSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type ScorecardIngestSource struct {
	allSrcTree `json:"-"`
}

// GetType returns ScorecardIngestSource.Type, and is useful for accessing the field via an interface.
func (v *ScorecardIngestSource) GetType() string { return v.allSrcTree.Type }

// GetNamespaces returns ScorecardIngestSource.Namespaces, and is useful for accessing the field via an interface.
func (v *ScorecardIngestSource) GetNamespaces() []allSrcTreeNamespacesSourceNamespace {
	return v.allSrcTree.Namespaces
}

func (v *ScorecardIngestSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*ScorecardIngestSource
		graphql.NoUnmarshalJSON
	}
	firstPass.ScorecardIngestSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSrcTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalScorecardIngestSource struct {
	Type string `json:"type"`

	Namespaces []allSrcTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *ScorecardIngestSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *ScorecardIngestSource) __premarshalJSON() (*__premarshalScorecardIngestSource, error) {
	var retval __premarshalScorecardIngestSource

	retval.Type = v.allSrcTree.Type
	retval.Namespaces = v.allSrcTree.Namespaces
	return &retval, nil
}

// ScorecardInputSpec is the same as Scorecard but for mutation input.
//
// All fields are required.
type ScorecardInputSpec struct {
	Checks           []ScorecardCheckInputSpec `json:"checks"`
	AggregateScore   float64                   `json:"aggregateScore"`
	TimeScanned      time.Time                 `json:"timeScanned"`
	ScorecardVersion string                    `json:"scorecardVersion"`
	ScorecardCommit  string                    `json:"scorecardCommit"`
	Origin           string                    `json:"origin"`
	Collector        string                    `json:"collector"`
}

// GetChecks returns ScorecardInputSpec.Checks, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetChecks() []ScorecardCheckInputSpec { return v.Checks }

// GetAggregateScore returns ScorecardInputSpec.AggregateScore, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetAggregateScore() float64 { return v.AggregateScore }

// GetTimeScanned returns ScorecardInputSpec.TimeScanned, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetTimeScanned() time.Time { return v.TimeScanned }

// GetScorecardVersion returns ScorecardInputSpec.ScorecardVersion, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetScorecardVersion() string { return v.ScorecardVersion }

// GetScorecardCommit returns ScorecardInputSpec.ScorecardCommit, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetScorecardCommit() string { return v.ScorecardCommit }

// GetOrigin returns ScorecardInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns ScorecardInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetCollector() string { return v.Collector }

// ScorecardResponse is returned by Scorecard on success.
type ScorecardResponse struct {
	// Ingest a new source. Returns the ingested source trie
	IngestSource ScorecardIngestSource `json:"ingestSource"`
	// Certifies the Scorecard scanning of a source repository
	CertifyScorecard ScorecardCertifyScorecard `json:"certifyScorecard"`
}

// GetIngestSource returns ScorecardResponse.IngestSource, and is useful for accessing the field via an interface.
func (v *ScorecardResponse) GetIngestSource() ScorecardIngestSource { return v.IngestSource }

// GetCertifyScorecard returns ScorecardResponse.CertifyScorecard, and is useful for accessing the field via an interface.
func (v *ScorecardResponse) GetCertifyScorecard() ScorecardCertifyScorecard {
	return v.CertifyScorecard
}

// SourceInputSpec specifies a source for a mutation.
//
// This is different than SourceSpec because we want to encode that all fields
// except tag and commit are mandatory fields. All optional fields are given
// empty default values.
//
// It is an error to set both `tag` and `commit` fields to values different than
// the default.
type SourceInputSpec struct {
	Type      string `json:"type"`
	Namespace string `json:"namespace"`
	Name      string `json:"name"`
	Tag       string `json:"tag"`
	Commit    string `json:"commit"`
}

// GetType returns SourceInputSpec.Type, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetType() string { return v.Type }

// GetNamespace returns SourceInputSpec.Namespace, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetNamespace() string { return v.Namespace }

// GetName returns SourceInputSpec.Name, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetName() string { return v.Name }

// GetTag returns SourceInputSpec.Tag, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetTag() string { return v.Tag }

// GetCommit returns SourceInputSpec.Commit, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetCommit() string { return v.Commit }

// __IsDependencyInput is used internally by genqlient
type __IsDependencyInput struct {
	Pkg        PkgInputSpec          `json:"pkg"`
	DepPkg     PkgInputSpec          `json:"depPkg"`
	Dependency IsDependencyInputSpec `json:"dependency"`
}

// GetPkg returns __IsDependencyInput.Pkg, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetDepPkg returns __IsDependencyInput.DepPkg, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetDepPkg() PkgInputSpec { return v.DepPkg }

// GetDependency returns __IsDependencyInput.Dependency, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetDependency() IsDependencyInputSpec { return v.Dependency }

// __ScorecardInput is used internally by genqlient
type __ScorecardInput struct {
	Source    SourceInputSpec    `json:"source"`
	Scorecard ScorecardInputSpec `json:"scorecard"`
}

// GetSource returns __ScorecardInput.Source, and is useful for accessing the field via an interface.
func (v *__ScorecardInput) GetSource() SourceInputSpec { return v.Source }

// GetScorecard returns __ScorecardInput.Scorecard, and is useful for accessing the field via an interface.
func (v *__ScorecardInput) GetScorecard() ScorecardInputSpec { return v.Scorecard }

// allCertifyScorecard includes the GraphQL fields of CertifyScorecard requested by the fragment allCertifyScorecard.
// The GraphQL type's documentation follows.
//
// CertifyScorecard is an attestation which represents the scorecard of a
// particular source repository.
type allCertifyScorecard struct {
	// The source repository that is being scanned (attestation subject)
	Source allCertifyScorecardSource `json:"source"`
	// The Scorecard attached to the repository (attestation object)
	Scorecard allCertifyScorecardScorecard `json:"scorecard"`
}

// GetSource returns allCertifyScorecard.Source, and is useful for accessing the field via an interface.
func (v *allCertifyScorecard) GetSource() allCertifyScorecardSource { return v.Source }

// GetScorecard returns allCertifyScorecard.Scorecard, and is useful for accessing the field via an interface.
func (v *allCertifyScorecard) GetScorecard() allCertifyScorecardScorecard { return v.Scorecard }

// allCertifyScorecardScorecard includes the requested fields of the GraphQL type Scorecard.
// The GraphQL type's documentation follows.
//
// Scorecard contains all of the fields present in a Scorecard attestation.
//
// We also include fields to specify under what conditions the check was performed
// (time of scan, version of scanners, etc.) as well as how this information got
// included into GUAC (origin document and the collector for that document).
type allCertifyScorecardScorecard struct {
	// Exact timestamp when the source was last scanned (in RFC 3339 format)
	TimeScanned time.Time `json:"timeScanned"`
	// Overall Scorecard score for the source
	AggregateScore float64 `json:"aggregateScore"`
	// Individual Scorecard check scores (Branch-Protection, Code-Review, ...)
	Checks []allCertifyScorecardScorecardChecksScorecardCheck `json:"checks"`
	// Version of the Scorecard scanner used to analyze the source
	ScorecardVersion string `json:"scorecardVersion"`
	// Commit of the Scorecards repository at the time of scanning the source
	ScorecardCommit string `json:"scorecardCommit"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetTimeScanned returns allCertifyScorecardScorecard.TimeScanned, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetTimeScanned() time.Time { return v.TimeScanned }

// GetAggregateScore returns allCertifyScorecardScorecard.AggregateScore, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetAggregateScore() float64 { return v.AggregateScore }

// GetChecks returns allCertifyScorecardScorecard.Checks, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetChecks() []allCertifyScorecardScorecardChecksScorecardCheck {
	return v.Checks
}

// GetScorecardVersion returns allCertifyScorecardScorecard.ScorecardVersion, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetScorecardVersion() string { return v.ScorecardVersion }

// GetScorecardCommit returns allCertifyScorecardScorecard.ScorecardCommit, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetScorecardCommit() string { return v.ScorecardCommit }

// GetOrigin returns allCertifyScorecardScorecard.Origin, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetOrigin() string { return v.Origin }

// GetCollector returns allCertifyScorecardScorecard.Collector, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetCollector() string { return v.Collector }

// allCertifyScorecardScorecardChecksScorecardCheck includes the requested fields of the GraphQL type ScorecardCheck.
// The GraphQL type's documentation follows.
//
// ScorecardCheck are the individual checks from scorecard and their values as a
// key-value pair.
//
// For example:  Branch-Protection, Code-Review...etc
//
// Based off scorecard's:
// type jsonCheckResultV2 struct {
// Details []string                 `json:"details"`
// Score   int                      `json:"score"`
// Reason  string                   `json:"reason"`
// Name    string                   `json:"name"`
// Doc     jsonCheckDocumentationV2 `json:"documentation"`
// }
// This node cannot be directly referred by other parts of GUAC.
type allCertifyScorecardScorecardChecksScorecardCheck struct {
	Check string `json:"check"`
	Score int    `json:"score"`
}

// GetCheck returns allCertifyScorecardScorecardChecksScorecardCheck.Check, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecardChecksScorecardCheck) GetCheck() string { return v.Check }

// GetScore returns allCertifyScorecardScorecardChecksScorecardCheck.Score, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecardChecksScorecardCheck) GetScore() int { return v.Score }

// allCertifyScorecardSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allCertifyScorecardSource struct {
	allSrcTree `json:"-"`
}

// GetType returns allCertifyScorecardSource.Type, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardSource) GetType() string { return v.allSrcTree.Type }

// GetNamespaces returns allCertifyScorecardSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardSource) GetNamespaces() []allSrcTreeNamespacesSourceNamespace {
	return v.allSrcTree.Namespaces
}

func (v *allCertifyScorecardSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allCertifyScorecardSource
		graphql.NoUnmarshalJSON
	}
	firstPass.allCertifyScorecardSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSrcTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallCertifyScorecardSource struct {
	Type string `json:"type"`

	Namespaces []allSrcTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *allCertifyScorecardSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allCertifyScorecardSource) __premarshalJSON() (*__premarshalallCertifyScorecardSource, error) {
	var retval __premarshalallCertifyScorecardSource

	retval.Type = v.allSrcTree.Type
	retval.Namespaces = v.allSrcTree.Namespaces
	return &retval, nil
}

// allIsDependencyTree includes the GraphQL fields of IsDependency requested by the fragment allIsDependencyTree.
// The GraphQL type's documentation follows.
//
// # IsDependency is an attestation that represents when a package is dependent on another package
//
// package (subject) - the package object type that represents the package
// dependentPackage (object) - the package object type that represents the packageName (cannot be to the packageVersion)
// versionRange (property) - string value for version range that applies to the dependent package
// justification (property) - string value representing why the artifacts are the equal
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type allIsDependencyTree struct {
	Justification    string                              `json:"justification"`
	Package          allIsDependencyTreePackage          `json:"package"`
	DependentPackage allIsDependencyTreeDependentPackage `json:"dependentPackage"`
	VersionRange     string                              `json:"versionRange"`
	Origin           string                              `json:"origin"`
	Collector        string                              `json:"collector"`
}

// GetJustification returns allIsDependencyTree.Justification, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetJustification() string { return v.Justification }

// GetPackage returns allIsDependencyTree.Package, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetPackage() allIsDependencyTreePackage { return v.Package }

// GetDependentPackage returns allIsDependencyTree.DependentPackage, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetDependentPackage() allIsDependencyTreeDependentPackage {
	return v.DependentPackage
}

// GetVersionRange returns allIsDependencyTree.VersionRange, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetVersionRange() string { return v.VersionRange }

// GetOrigin returns allIsDependencyTree.Origin, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetOrigin() string { return v.Origin }

// GetCollector returns allIsDependencyTree.Collector, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetCollector() string { return v.Collector }

// allIsDependencyTreeDependentPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allIsDependencyTreeDependentPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns allIsDependencyTreeDependentPackage.Type, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreeDependentPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allIsDependencyTreeDependentPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreeDependentPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allIsDependencyTreeDependentPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsDependencyTreeDependentPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsDependencyTreeDependentPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsDependencyTreeDependentPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allIsDependencyTreeDependentPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsDependencyTreeDependentPackage) __premarshalJSON() (*__premarshalallIsDependencyTreeDependentPackage, error) {
	var retval __premarshalallIsDependencyTreeDependentPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allIsDependencyTreePackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allIsDependencyTreePackage struct {
	allPkgTree `json:"-"`
}

// GetType returns allIsDependencyTreePackage.Type, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreePackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allIsDependencyTreePackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreePackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allIsDependencyTreePackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsDependencyTreePackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsDependencyTreePackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsDependencyTreePackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allIsDependencyTreePackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsDependencyTreePackage) __premarshalJSON() (*__premarshalallIsDependencyTreePackage, error) {
	var retval __premarshalallIsDependencyTreePackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allPkgTree includes the GraphQL fields of Package requested by the fragment allPkgTree.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allPkgTree struct {
	Type       string                                 `json:"type"`
	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

// GetType returns allPkgTree.Type, and is useful for accessing the field via an interface.
func (v *allPkgTree) GetType() string { return v.Type }

// GetNamespaces returns allPkgTree.Namespaces, and is useful for accessing the field via an interface.
func (v *allPkgTree) GetNamespaces() []allPkgTreeNamespacesPackageNamespace { return v.Namespaces }

// allPkgTreeNamespacesPackageNamespace includes the requested fields of the GraphQL type PackageNamespace.
// The GraphQL type's documentation follows.
//
// PackageNamespace is a namespace for packages.
//
// In the pURL representation, each PackageNamespace matches the
// `pkg:<type>/<namespace>/` partial pURL.
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type allPkgTreeNamespacesPackageNamespace struct {
	Namespace string                                                 `json:"namespace"`
	Names     []allPkgTreeNamespacesPackageNamespaceNamesPackageName `json:"names"`
}

// GetNamespace returns allPkgTreeNamespacesPackageNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns allPkgTreeNamespacesPackageNamespace.Names, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespace) GetNames() []allPkgTreeNamespacesPackageNamespaceNamesPackageName {
	return v.Names
}

// allPkgTreeNamespacesPackageNamespaceNamesPackageName includes the requested fields of the GraphQL type PackageName.
// The GraphQL type's documentation follows.
//
// PackageName is a name for packages.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>` pURL.
//
// Names are always mandatory.
//
// This is the first node in the trie that can be referred to by other parts of
// GUAC.
type allPkgTreeNamespacesPackageNamespaceNamesPackageName struct {
	Name     string                                                                       `json:"name"`
	Versions []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion `json:"versions"`
}

// GetName returns allPkgTreeNamespacesPackageNamespaceNamesPackageName.Name, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageName) GetName() string { return v.Name }

// GetVersions returns allPkgTreeNamespacesPackageNamespaceNamesPackageName.Versions, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageName) GetVersions() []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion {
	return v.Versions
}

// allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion includes the requested fields of the GraphQL type PackageVersion.
// The GraphQL type's documentation follows.
//
// PackageVersion is a package version.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>@<version>` pURL.
//
// Versions are optional and each Package type defines own rules for handling them.
// For this level of GUAC, these are just opaque strings.
//
// This node can be referred to by other parts of GUAC.
//
// Subpath and qualifiers are optional. Lack of qualifiers is represented by an
// empty list and lack of subpath by empty string (to be consistent with
// optionality of namespace and version). Two nodes that have different qualifiers
// and/or subpath but the same version mean two different packages in the trie
// (they are different). Two nodes that have same version but qualifiers of one are
// a subset of the qualifier of the other also mean two different packages in the
// trie.
type allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion struct {
	Version    string                                                                                                 `json:"version"`
	Qualifiers []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier `json:"qualifiers"`
	Subpath    string                                                                                                 `json:"subpath"`
}

// GetVersion returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Version, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetVersion() string {
	return v.Version
}

// GetQualifiers returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Qualifiers, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetQualifiers() []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier {
	return v.Qualifiers
}

// GetSubpath returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Subpath, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetSubpath() string {
	return v.Subpath
}

// allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier includes the requested fields of the GraphQL type PackageQualifier.
// The GraphQL type's documentation follows.
//
// PackageQualifier is a qualifier for a package, a key-value pair.
//
// In the pURL representation, it is a part of the `<qualifiers>` part of the
// `pkg:<type>/<namespace>/<name>@<version>?<qualifiers>` pURL.
//
// Qualifiers are optional, each Package type defines own rules for handling them,
// and multiple qualifiers could be attached to the same package.
//
// This node cannot be directly referred by other parts of GUAC.
type allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Key, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetKey() string {
	return v.Key
}

// GetValue returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Value, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetValue() string {
	return v.Value
}

// allSrcTree includes the GraphQL fields of Source requested by the fragment allSrcTree.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allSrcTree struct {
	Type       string                                `json:"type"`
	Namespaces []allSrcTreeNamespacesSourceNamespace `json:"namespaces"`
}

// GetType returns allSrcTree.Type, and is useful for accessing the field via an interface.
func (v *allSrcTree) GetType() string { return v.Type }

// GetNamespaces returns allSrcTree.Namespaces, and is useful for accessing the field via an interface.
func (v *allSrcTree) GetNamespaces() []allSrcTreeNamespacesSourceNamespace { return v.Namespaces }

// allSrcTreeNamespacesSourceNamespace includes the requested fields of the GraphQL type SourceNamespace.
// The GraphQL type's documentation follows.
//
// SourceNamespace is a namespace for sources.
//
// This is the location of the repository (such as github/gitlab/bitbucket).
//
// The `namespace` field is mandatory.
type allSrcTreeNamespacesSourceNamespace struct {
	Namespace string                                               `json:"namespace"`
	Names     []allSrcTreeNamespacesSourceNamespaceNamesSourceName `json:"names"`
}

// GetNamespace returns allSrcTreeNamespacesSourceNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *allSrcTreeNamespacesSourceNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns allSrcTreeNamespacesSourceNamespace.Names, and is useful for accessing the field via an interface.
func (v *allSrcTreeNamespacesSourceNamespace) GetNames() []allSrcTreeNamespacesSourceNamespaceNamesSourceName {
	return v.Names
}

// allSrcTreeNamespacesSourceNamespaceNamesSourceName includes the requested fields of the GraphQL type SourceName.
// The GraphQL type's documentation follows.
//
// SourceName is a url of the repository and its tag or commit.
//
// The `name` field is mandatory. The `tag` and `commit` fields are optional, but
// it is an error to specify both.
//
// This is the only source trie node that can be referenced by other parts of
// GUAC.
type allSrcTreeNamespacesSourceNamespaceNamesSourceName struct {
	Name   string `json:"name"`
	Tag    string `json:"tag"`
	Commit string `json:"commit"`
}

// GetName returns allSrcTreeNamespacesSourceNamespaceNamesSourceName.Name, and is useful for accessing the field via an interface.
func (v *allSrcTreeNamespacesSourceNamespaceNamesSourceName) GetName() string { return v.Name }

// GetTag returns allSrcTreeNamespacesSourceNamespaceNamesSourceName.Tag, and is useful for accessing the field via an interface.
func (v *allSrcTreeNamespacesSourceNamespaceNamesSourceName) GetTag() string { return v.Tag }

// GetCommit returns allSrcTreeNamespacesSourceNamespaceNamesSourceName.Commit, and is useful for accessing the field via an interface.
func (v *allSrcTreeNamespacesSourceNamespaceNamesSourceName) GetCommit() string { return v.Commit }

func IsDependency(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	depPkg PkgInputSpec,
	dependency IsDependencyInputSpec,
) (*IsDependencyResponse, error) {
	req := &graphql.Request{
		OpName: "IsDependency",
		Query: `
mutation IsDependency ($pkg: PkgInputSpec!, $depPkg: PkgInputSpec!, $dependency: IsDependencyInputSpec!) {
	pkg: ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	dependentPkg: ingestPackage(pkg: $depPkg) {
		... allPkgTree
	}
	ingestDependency(pkg: $pkg, depPkg: $depPkg, dependency: $dependency) {
		... allIsDependencyTree
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allIsDependencyTree on IsDependency {
	justification
	package {
		... allPkgTree
	}
	dependentPackage {
		... allPkgTree
	}
	versionRange
	origin
	collector
}
`,
		Variables: &__IsDependencyInput{
			Pkg:        pkg,
			DepPkg:     depPkg,
			Dependency: dependency,
		},
	}
	var err error

	var data IsDependencyResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func Scorecard(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	scorecard ScorecardInputSpec,
) (*ScorecardResponse, error) {
	req := &graphql.Request{
		OpName: "Scorecard",
		Query: `
mutation Scorecard ($source: SourceInputSpec!, $scorecard: ScorecardInputSpec!) {
	ingestSource(source: $source) {
		... allSrcTree
	}
	certifyScorecard(source: $source, scorecard: $scorecard) {
		... allCertifyScorecard
	}
}
fragment allSrcTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allCertifyScorecard on CertifyScorecard {
	source {
		... allSrcTree
	}
	scorecard {
		timeScanned
		aggregateScore
		checks {
			check
			score
		}
		scorecardVersion
		scorecardCommit
		origin
		collector
	}
}
`,
		Variables: &__ScorecardInput{
			Source:    source,
			Scorecard: scorecard,
		},
	}
	var err error

	var data ScorecardResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}
