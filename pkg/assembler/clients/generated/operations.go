// Code generated by github.com/Khan/genqlient, DO NOT EDIT.

package generated

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Khan/genqlient/graphql"
)

// AllArtifactTree includes the GraphQL fields of Artifact requested by the fragment AllArtifactTree.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type AllArtifactTree struct {
	Id        string `json:"id"`
	Algorithm string `json:"algorithm"`
	Digest    string `json:"digest"`
}

// GetId returns AllArtifactTree.Id, and is useful for accessing the field via an interface.
func (v *AllArtifactTree) GetId() string { return v.Id }

// GetAlgorithm returns AllArtifactTree.Algorithm, and is useful for accessing the field via an interface.
func (v *AllArtifactTree) GetAlgorithm() string { return v.Algorithm }

// GetDigest returns AllArtifactTree.Digest, and is useful for accessing the field via an interface.
func (v *AllArtifactTree) GetDigest() string { return v.Digest }

// AllBuilderTree includes the GraphQL fields of Builder requested by the fragment AllBuilderTree.
// The GraphQL type's documentation follows.
//
// Builder represents the builder (e.g., FRSCA or GitHub Actions).
//
// Currently builders are identified by the uri field.
type AllBuilderTree struct {
	Id  string `json:"id"`
	Uri string `json:"uri"`
}

// GetId returns AllBuilderTree.Id, and is useful for accessing the field via an interface.
func (v *AllBuilderTree) GetId() string { return v.Id }

// GetUri returns AllBuilderTree.Uri, and is useful for accessing the field via an interface.
func (v *AllBuilderTree) GetUri() string { return v.Uri }

// AllCertifyBad includes the GraphQL fields of CertifyBad requested by the fragment AllCertifyBad.
// The GraphQL type's documentation follows.
//
// CertifyBad is an attestation that a package, source, or artifact is considered
// bad.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The certification applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type AllCertifyBad struct {
	Id            string                                      `json:"id"`
	Justification string                                      `json:"justification"`
	Subject       AllCertifyBadSubjectPackageSourceOrArtifact `json:"-"`
	Origin        string                                      `json:"origin"`
	Collector     string                                      `json:"collector"`
}

// GetId returns AllCertifyBad.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyBad) GetId() string { return v.Id }

// GetJustification returns AllCertifyBad.Justification, and is useful for accessing the field via an interface.
func (v *AllCertifyBad) GetJustification() string { return v.Justification }

// GetSubject returns AllCertifyBad.Subject, and is useful for accessing the field via an interface.
func (v *AllCertifyBad) GetSubject() AllCertifyBadSubjectPackageSourceOrArtifact { return v.Subject }

// GetOrigin returns AllCertifyBad.Origin, and is useful for accessing the field via an interface.
func (v *AllCertifyBad) GetOrigin() string { return v.Origin }

// GetCollector returns AllCertifyBad.Collector, and is useful for accessing the field via an interface.
func (v *AllCertifyBad) GetCollector() string { return v.Collector }

func (v *AllCertifyBad) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyBad
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyBad = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalAllCertifyBadSubjectPackageSourceOrArtifact(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal AllCertifyBad.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalAllCertifyBad struct {
	Id string `json:"id"`

	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *AllCertifyBad) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyBad) __premarshalJSON() (*__premarshalAllCertifyBad, error) {
	var retval __premarshalAllCertifyBad

	retval.Id = v.Id
	retval.Justification = v.Justification
	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalAllCertifyBadSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal AllCertifyBad.Subject: %w", err)
		}
	}
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// AllCertifyBadSubjectArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type AllCertifyBadSubjectArtifact struct {
	Typename        *string `json:"__typename"`
	AllArtifactTree `json:"-"`
}

// GetTypename returns AllCertifyBadSubjectArtifact.Typename, and is useful for accessing the field via an interface.
func (v *AllCertifyBadSubjectArtifact) GetTypename() *string { return v.Typename }

// GetId returns AllCertifyBadSubjectArtifact.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyBadSubjectArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns AllCertifyBadSubjectArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *AllCertifyBadSubjectArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns AllCertifyBadSubjectArtifact.Digest, and is useful for accessing the field via an interface.
func (v *AllCertifyBadSubjectArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *AllCertifyBadSubjectArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyBadSubjectArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyBadSubjectArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyBadSubjectArtifact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *AllCertifyBadSubjectArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyBadSubjectArtifact) __premarshalJSON() (*__premarshalAllCertifyBadSubjectArtifact, error) {
	var retval __premarshalAllCertifyBadSubjectArtifact

	retval.Typename = v.Typename
	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// AllCertifyBadSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllCertifyBadSubjectPackage struct {
	Typename   *string `json:"__typename"`
	AllPkgTree `json:"-"`
}

// GetTypename returns AllCertifyBadSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *AllCertifyBadSubjectPackage) GetTypename() *string { return v.Typename }

// GetId returns AllCertifyBadSubjectPackage.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyBadSubjectPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns AllCertifyBadSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *AllCertifyBadSubjectPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns AllCertifyBadSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *AllCertifyBadSubjectPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *AllCertifyBadSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyBadSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyBadSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyBadSubjectPackage struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *AllCertifyBadSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyBadSubjectPackage) __premarshalJSON() (*__premarshalAllCertifyBadSubjectPackage, error) {
	var retval __premarshalAllCertifyBadSubjectPackage

	retval.Typename = v.Typename
	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// AllCertifyBadSubjectPackageSourceOrArtifact includes the requested fields of the GraphQL interface PackageSourceOrArtifact.
//
// AllCertifyBadSubjectPackageSourceOrArtifact is implemented by the following types:
// AllCertifyBadSubjectArtifact
// AllCertifyBadSubjectPackage
// AllCertifyBadSubjectSource
// The GraphQL type's documentation follows.
//
// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type AllCertifyBadSubjectPackageSourceOrArtifact interface {
	implementsGraphQLInterfaceAllCertifyBadSubjectPackageSourceOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *AllCertifyBadSubjectArtifact) implementsGraphQLInterfaceAllCertifyBadSubjectPackageSourceOrArtifact() {
}
func (v *AllCertifyBadSubjectPackage) implementsGraphQLInterfaceAllCertifyBadSubjectPackageSourceOrArtifact() {
}
func (v *AllCertifyBadSubjectSource) implementsGraphQLInterfaceAllCertifyBadSubjectPackageSourceOrArtifact() {
}

func __unmarshalAllCertifyBadSubjectPackageSourceOrArtifact(b []byte, v *AllCertifyBadSubjectPackageSourceOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Artifact":
		*v = new(AllCertifyBadSubjectArtifact)
		return json.Unmarshal(b, *v)
	case "Package":
		*v = new(AllCertifyBadSubjectPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(AllCertifyBadSubjectSource)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageSourceOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for AllCertifyBadSubjectPackageSourceOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalAllCertifyBadSubjectPackageSourceOrArtifact(v *AllCertifyBadSubjectPackageSourceOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *AllCertifyBadSubjectArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllCertifyBadSubjectArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *AllCertifyBadSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllCertifyBadSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *AllCertifyBadSubjectSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllCertifyBadSubjectSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for AllCertifyBadSubjectPackageSourceOrArtifact: "%T"`, v)
	}
}

// AllCertifyBadSubjectSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type AllCertifyBadSubjectSource struct {
	Typename      *string `json:"__typename"`
	AllSourceTree `json:"-"`
}

// GetTypename returns AllCertifyBadSubjectSource.Typename, and is useful for accessing the field via an interface.
func (v *AllCertifyBadSubjectSource) GetTypename() *string { return v.Typename }

// GetId returns AllCertifyBadSubjectSource.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyBadSubjectSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns AllCertifyBadSubjectSource.Type, and is useful for accessing the field via an interface.
func (v *AllCertifyBadSubjectSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns AllCertifyBadSubjectSource.Namespaces, and is useful for accessing the field via an interface.
func (v *AllCertifyBadSubjectSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *AllCertifyBadSubjectSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyBadSubjectSource
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyBadSubjectSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyBadSubjectSource struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *AllCertifyBadSubjectSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyBadSubjectSource) __premarshalJSON() (*__premarshalAllCertifyBadSubjectSource, error) {
	var retval __premarshalAllCertifyBadSubjectSource

	retval.Typename = v.Typename
	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// AllCertifyGood includes the GraphQL fields of CertifyGood requested by the fragment AllCertifyGood.
// The GraphQL type's documentation follows.
//
// CertifyGood is an attestation that a package, source, or artifact is considered
// good.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The certification applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type AllCertifyGood struct {
	Id            string                                       `json:"id"`
	Justification string                                       `json:"justification"`
	Subject       AllCertifyGoodSubjectPackageSourceOrArtifact `json:"-"`
	Origin        string                                       `json:"origin"`
	Collector     string                                       `json:"collector"`
}

// GetId returns AllCertifyGood.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyGood) GetId() string { return v.Id }

// GetJustification returns AllCertifyGood.Justification, and is useful for accessing the field via an interface.
func (v *AllCertifyGood) GetJustification() string { return v.Justification }

// GetSubject returns AllCertifyGood.Subject, and is useful for accessing the field via an interface.
func (v *AllCertifyGood) GetSubject() AllCertifyGoodSubjectPackageSourceOrArtifact { return v.Subject }

// GetOrigin returns AllCertifyGood.Origin, and is useful for accessing the field via an interface.
func (v *AllCertifyGood) GetOrigin() string { return v.Origin }

// GetCollector returns AllCertifyGood.Collector, and is useful for accessing the field via an interface.
func (v *AllCertifyGood) GetCollector() string { return v.Collector }

func (v *AllCertifyGood) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyGood
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyGood = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalAllCertifyGoodSubjectPackageSourceOrArtifact(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal AllCertifyGood.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalAllCertifyGood struct {
	Id string `json:"id"`

	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *AllCertifyGood) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyGood) __premarshalJSON() (*__premarshalAllCertifyGood, error) {
	var retval __premarshalAllCertifyGood

	retval.Id = v.Id
	retval.Justification = v.Justification
	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalAllCertifyGoodSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal AllCertifyGood.Subject: %w", err)
		}
	}
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// AllCertifyGoodSubjectArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type AllCertifyGoodSubjectArtifact struct {
	Typename        *string `json:"__typename"`
	AllArtifactTree `json:"-"`
}

// GetTypename returns AllCertifyGoodSubjectArtifact.Typename, and is useful for accessing the field via an interface.
func (v *AllCertifyGoodSubjectArtifact) GetTypename() *string { return v.Typename }

// GetId returns AllCertifyGoodSubjectArtifact.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyGoodSubjectArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns AllCertifyGoodSubjectArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *AllCertifyGoodSubjectArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns AllCertifyGoodSubjectArtifact.Digest, and is useful for accessing the field via an interface.
func (v *AllCertifyGoodSubjectArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *AllCertifyGoodSubjectArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyGoodSubjectArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyGoodSubjectArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyGoodSubjectArtifact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *AllCertifyGoodSubjectArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyGoodSubjectArtifact) __premarshalJSON() (*__premarshalAllCertifyGoodSubjectArtifact, error) {
	var retval __premarshalAllCertifyGoodSubjectArtifact

	retval.Typename = v.Typename
	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// AllCertifyGoodSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllCertifyGoodSubjectPackage struct {
	Typename   *string `json:"__typename"`
	AllPkgTree `json:"-"`
}

// GetTypename returns AllCertifyGoodSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *AllCertifyGoodSubjectPackage) GetTypename() *string { return v.Typename }

// GetId returns AllCertifyGoodSubjectPackage.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyGoodSubjectPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns AllCertifyGoodSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *AllCertifyGoodSubjectPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns AllCertifyGoodSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *AllCertifyGoodSubjectPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *AllCertifyGoodSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyGoodSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyGoodSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyGoodSubjectPackage struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *AllCertifyGoodSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyGoodSubjectPackage) __premarshalJSON() (*__premarshalAllCertifyGoodSubjectPackage, error) {
	var retval __premarshalAllCertifyGoodSubjectPackage

	retval.Typename = v.Typename
	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// AllCertifyGoodSubjectPackageSourceOrArtifact includes the requested fields of the GraphQL interface PackageSourceOrArtifact.
//
// AllCertifyGoodSubjectPackageSourceOrArtifact is implemented by the following types:
// AllCertifyGoodSubjectArtifact
// AllCertifyGoodSubjectPackage
// AllCertifyGoodSubjectSource
// The GraphQL type's documentation follows.
//
// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type AllCertifyGoodSubjectPackageSourceOrArtifact interface {
	implementsGraphQLInterfaceAllCertifyGoodSubjectPackageSourceOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *AllCertifyGoodSubjectArtifact) implementsGraphQLInterfaceAllCertifyGoodSubjectPackageSourceOrArtifact() {
}
func (v *AllCertifyGoodSubjectPackage) implementsGraphQLInterfaceAllCertifyGoodSubjectPackageSourceOrArtifact() {
}
func (v *AllCertifyGoodSubjectSource) implementsGraphQLInterfaceAllCertifyGoodSubjectPackageSourceOrArtifact() {
}

func __unmarshalAllCertifyGoodSubjectPackageSourceOrArtifact(b []byte, v *AllCertifyGoodSubjectPackageSourceOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Artifact":
		*v = new(AllCertifyGoodSubjectArtifact)
		return json.Unmarshal(b, *v)
	case "Package":
		*v = new(AllCertifyGoodSubjectPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(AllCertifyGoodSubjectSource)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageSourceOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for AllCertifyGoodSubjectPackageSourceOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalAllCertifyGoodSubjectPackageSourceOrArtifact(v *AllCertifyGoodSubjectPackageSourceOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *AllCertifyGoodSubjectArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllCertifyGoodSubjectArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *AllCertifyGoodSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllCertifyGoodSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *AllCertifyGoodSubjectSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllCertifyGoodSubjectSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for AllCertifyGoodSubjectPackageSourceOrArtifact: "%T"`, v)
	}
}

// AllCertifyGoodSubjectSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type AllCertifyGoodSubjectSource struct {
	Typename      *string `json:"__typename"`
	AllSourceTree `json:"-"`
}

// GetTypename returns AllCertifyGoodSubjectSource.Typename, and is useful for accessing the field via an interface.
func (v *AllCertifyGoodSubjectSource) GetTypename() *string { return v.Typename }

// GetId returns AllCertifyGoodSubjectSource.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyGoodSubjectSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns AllCertifyGoodSubjectSource.Type, and is useful for accessing the field via an interface.
func (v *AllCertifyGoodSubjectSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns AllCertifyGoodSubjectSource.Namespaces, and is useful for accessing the field via an interface.
func (v *AllCertifyGoodSubjectSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *AllCertifyGoodSubjectSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyGoodSubjectSource
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyGoodSubjectSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyGoodSubjectSource struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *AllCertifyGoodSubjectSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyGoodSubjectSource) __premarshalJSON() (*__premarshalAllCertifyGoodSubjectSource, error) {
	var retval __premarshalAllCertifyGoodSubjectSource

	retval.Typename = v.Typename
	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// AllCertifyLegalTree includes the GraphQL fields of CertifyLegal requested by the fragment AllCertifyLegalTree.
// The GraphQL type's documentation follows.
//
// CertifyLegal is an attestation to attach legal information to a package or source.
//
// The certification information is either copied from an attestation found in an
// SBOM or created by a collector/scanner.
//
// Discovered license is also known as Concluded. More information:
// https://docs.clearlydefined.io/curation-guidelines#the-difference-between-declared-and-discovered-licenses
//
// Attribution is also known as Copyright Text. It is what could be displayed to
// comply with notice
// requirements. https://www.nexb.com/oss-attribution-best-practices/
//
// License expressions follow this format:
// https://spdx.github.io/spdx-spec/v2.3/SPDX-license-expressions/
type AllCertifyLegalTree struct {
	Id string `json:"id"`
	// The package version or source that is attested
	Subject AllCertifyLegalTreeSubjectPackageOrSource `json:"-"`
	// The license expression as delcared
	DeclaredLicense string `json:"declaredLicense"`
	// A list of license objects found in the declared license expression
	DeclaredLicenses []AllCertifyLegalTreeDeclaredLicensesLicense `json:"declaredLicenses"`
	// The license expression as discovered by scan
	DiscoveredLicense string `json:"discoveredLicense"`
	// A list of license objects found in the discovered license expression
	DiscoveredLicenses []AllCertifyLegalTreeDiscoveredLicensesLicense `json:"discoveredLicenses"`
	// Attribution text of the subject
	Attribution string `json:"attribution"`
	// Extra justification for the certification
	Justification string `json:"justification"`
	// Time of scan (in RFC 3339 format)
	TimeScanned time.Time `json:"timeScanned"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetId returns AllCertifyLegalTree.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTree) GetId() string { return v.Id }

// GetSubject returns AllCertifyLegalTree.Subject, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTree) GetSubject() AllCertifyLegalTreeSubjectPackageOrSource {
	return v.Subject
}

// GetDeclaredLicense returns AllCertifyLegalTree.DeclaredLicense, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTree) GetDeclaredLicense() string { return v.DeclaredLicense }

// GetDeclaredLicenses returns AllCertifyLegalTree.DeclaredLicenses, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTree) GetDeclaredLicenses() []AllCertifyLegalTreeDeclaredLicensesLicense {
	return v.DeclaredLicenses
}

// GetDiscoveredLicense returns AllCertifyLegalTree.DiscoveredLicense, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTree) GetDiscoveredLicense() string { return v.DiscoveredLicense }

// GetDiscoveredLicenses returns AllCertifyLegalTree.DiscoveredLicenses, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTree) GetDiscoveredLicenses() []AllCertifyLegalTreeDiscoveredLicensesLicense {
	return v.DiscoveredLicenses
}

// GetAttribution returns AllCertifyLegalTree.Attribution, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTree) GetAttribution() string { return v.Attribution }

// GetJustification returns AllCertifyLegalTree.Justification, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTree) GetJustification() string { return v.Justification }

// GetTimeScanned returns AllCertifyLegalTree.TimeScanned, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTree) GetTimeScanned() time.Time { return v.TimeScanned }

// GetOrigin returns AllCertifyLegalTree.Origin, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTree) GetOrigin() string { return v.Origin }

// GetCollector returns AllCertifyLegalTree.Collector, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTree) GetCollector() string { return v.Collector }

func (v *AllCertifyLegalTree) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyLegalTree
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyLegalTree = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalAllCertifyLegalTreeSubjectPackageOrSource(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal AllCertifyLegalTree.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalAllCertifyLegalTree struct {
	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	DeclaredLicense string `json:"declaredLicense"`

	DeclaredLicenses []AllCertifyLegalTreeDeclaredLicensesLicense `json:"declaredLicenses"`

	DiscoveredLicense string `json:"discoveredLicense"`

	DiscoveredLicenses []AllCertifyLegalTreeDiscoveredLicensesLicense `json:"discoveredLicenses"`

	Attribution string `json:"attribution"`

	Justification string `json:"justification"`

	TimeScanned time.Time `json:"timeScanned"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *AllCertifyLegalTree) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyLegalTree) __premarshalJSON() (*__premarshalAllCertifyLegalTree, error) {
	var retval __premarshalAllCertifyLegalTree

	retval.Id = v.Id
	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalAllCertifyLegalTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal AllCertifyLegalTree.Subject: %w", err)
		}
	}
	retval.DeclaredLicense = v.DeclaredLicense
	retval.DeclaredLicenses = v.DeclaredLicenses
	retval.DiscoveredLicense = v.DiscoveredLicense
	retval.DiscoveredLicenses = v.DiscoveredLicenses
	retval.Attribution = v.Attribution
	retval.Justification = v.Justification
	retval.TimeScanned = v.TimeScanned
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// AllCertifyLegalTreeDeclaredLicensesLicense includes the requested fields of the GraphQL type License.
// The GraphQL type's documentation follows.
//
// License represents a particular license. If the license is found on the SPDX
// license list (https://spdx.org/licenses/) then the fields should be:
//
// Name: SPDX license identifier
// Inline: empty
// ListVersion: SPDX license list version
//
// example:
//
// Name: AGPL-3.0-or-later
// Inline: ""
// ListVersion: 3.21 2023-06-18
//
// If the license is not on the SPDX license list, then a new guid should be
// created and the license text placed inline:
//
// Name: LicenseRef-<guid>
// Inline: Full license text
// ListVersion: empty
//
// example:
//
// Name: LicenseRef-1a2b3c
// Inline: Permission to use, copy, modify, and/or distribute ...
// ListVersion: ""
type AllCertifyLegalTreeDeclaredLicensesLicense struct {
	AllLicenseTree `json:"-"`
}

// GetId returns AllCertifyLegalTreeDeclaredLicensesLicense.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeDeclaredLicensesLicense) GetId() string { return v.AllLicenseTree.Id }

// GetName returns AllCertifyLegalTreeDeclaredLicensesLicense.Name, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeDeclaredLicensesLicense) GetName() string { return v.AllLicenseTree.Name }

// GetInline returns AllCertifyLegalTreeDeclaredLicensesLicense.Inline, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeDeclaredLicensesLicense) GetInline() *string {
	return v.AllLicenseTree.Inline
}

// GetListVersion returns AllCertifyLegalTreeDeclaredLicensesLicense.ListVersion, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeDeclaredLicensesLicense) GetListVersion() *string {
	return v.AllLicenseTree.ListVersion
}

func (v *AllCertifyLegalTreeDeclaredLicensesLicense) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyLegalTreeDeclaredLicensesLicense
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyLegalTreeDeclaredLicensesLicense = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllLicenseTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyLegalTreeDeclaredLicensesLicense struct {
	Id string `json:"id"`

	Name string `json:"name"`

	Inline *string `json:"inline"`

	ListVersion *string `json:"listVersion"`
}

func (v *AllCertifyLegalTreeDeclaredLicensesLicense) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyLegalTreeDeclaredLicensesLicense) __premarshalJSON() (*__premarshalAllCertifyLegalTreeDeclaredLicensesLicense, error) {
	var retval __premarshalAllCertifyLegalTreeDeclaredLicensesLicense

	retval.Id = v.AllLicenseTree.Id
	retval.Name = v.AllLicenseTree.Name
	retval.Inline = v.AllLicenseTree.Inline
	retval.ListVersion = v.AllLicenseTree.ListVersion
	return &retval, nil
}

// AllCertifyLegalTreeDiscoveredLicensesLicense includes the requested fields of the GraphQL type License.
// The GraphQL type's documentation follows.
//
// License represents a particular license. If the license is found on the SPDX
// license list (https://spdx.org/licenses/) then the fields should be:
//
// Name: SPDX license identifier
// Inline: empty
// ListVersion: SPDX license list version
//
// example:
//
// Name: AGPL-3.0-or-later
// Inline: ""
// ListVersion: 3.21 2023-06-18
//
// If the license is not on the SPDX license list, then a new guid should be
// created and the license text placed inline:
//
// Name: LicenseRef-<guid>
// Inline: Full license text
// ListVersion: empty
//
// example:
//
// Name: LicenseRef-1a2b3c
// Inline: Permission to use, copy, modify, and/or distribute ...
// ListVersion: ""
type AllCertifyLegalTreeDiscoveredLicensesLicense struct {
	AllLicenseTree `json:"-"`
}

// GetId returns AllCertifyLegalTreeDiscoveredLicensesLicense.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeDiscoveredLicensesLicense) GetId() string { return v.AllLicenseTree.Id }

// GetName returns AllCertifyLegalTreeDiscoveredLicensesLicense.Name, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeDiscoveredLicensesLicense) GetName() string { return v.AllLicenseTree.Name }

// GetInline returns AllCertifyLegalTreeDiscoveredLicensesLicense.Inline, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeDiscoveredLicensesLicense) GetInline() *string {
	return v.AllLicenseTree.Inline
}

// GetListVersion returns AllCertifyLegalTreeDiscoveredLicensesLicense.ListVersion, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeDiscoveredLicensesLicense) GetListVersion() *string {
	return v.AllLicenseTree.ListVersion
}

func (v *AllCertifyLegalTreeDiscoveredLicensesLicense) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyLegalTreeDiscoveredLicensesLicense
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyLegalTreeDiscoveredLicensesLicense = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllLicenseTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyLegalTreeDiscoveredLicensesLicense struct {
	Id string `json:"id"`

	Name string `json:"name"`

	Inline *string `json:"inline"`

	ListVersion *string `json:"listVersion"`
}

func (v *AllCertifyLegalTreeDiscoveredLicensesLicense) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyLegalTreeDiscoveredLicensesLicense) __premarshalJSON() (*__premarshalAllCertifyLegalTreeDiscoveredLicensesLicense, error) {
	var retval __premarshalAllCertifyLegalTreeDiscoveredLicensesLicense

	retval.Id = v.AllLicenseTree.Id
	retval.Name = v.AllLicenseTree.Name
	retval.Inline = v.AllLicenseTree.Inline
	retval.ListVersion = v.AllLicenseTree.ListVersion
	return &retval, nil
}

// AllCertifyLegalTreeSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllCertifyLegalTreeSubjectPackage struct {
	Typename   *string `json:"__typename"`
	AllPkgTree `json:"-"`
}

// GetTypename returns AllCertifyLegalTreeSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeSubjectPackage) GetTypename() *string { return v.Typename }

// GetId returns AllCertifyLegalTreeSubjectPackage.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeSubjectPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns AllCertifyLegalTreeSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeSubjectPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns AllCertifyLegalTreeSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeSubjectPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *AllCertifyLegalTreeSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyLegalTreeSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyLegalTreeSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyLegalTreeSubjectPackage struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *AllCertifyLegalTreeSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyLegalTreeSubjectPackage) __premarshalJSON() (*__premarshalAllCertifyLegalTreeSubjectPackage, error) {
	var retval __premarshalAllCertifyLegalTreeSubjectPackage

	retval.Typename = v.Typename
	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// AllCertifyLegalTreeSubjectPackageOrSource includes the requested fields of the GraphQL interface PackageOrSource.
//
// AllCertifyLegalTreeSubjectPackageOrSource is implemented by the following types:
// AllCertifyLegalTreeSubjectPackage
// AllCertifyLegalTreeSubjectSource
// The GraphQL type's documentation follows.
//
// PackageOrSource is a union of Package and Source.
type AllCertifyLegalTreeSubjectPackageOrSource interface {
	implementsGraphQLInterfaceAllCertifyLegalTreeSubjectPackageOrSource()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *AllCertifyLegalTreeSubjectPackage) implementsGraphQLInterfaceAllCertifyLegalTreeSubjectPackageOrSource() {
}
func (v *AllCertifyLegalTreeSubjectSource) implementsGraphQLInterfaceAllCertifyLegalTreeSubjectPackageOrSource() {
}

func __unmarshalAllCertifyLegalTreeSubjectPackageOrSource(b []byte, v *AllCertifyLegalTreeSubjectPackageOrSource) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(AllCertifyLegalTreeSubjectPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(AllCertifyLegalTreeSubjectSource)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageOrSource.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for AllCertifyLegalTreeSubjectPackageOrSource: "%v"`, tn.TypeName)
	}
}

func __marshalAllCertifyLegalTreeSubjectPackageOrSource(v *AllCertifyLegalTreeSubjectPackageOrSource) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *AllCertifyLegalTreeSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllCertifyLegalTreeSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *AllCertifyLegalTreeSubjectSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllCertifyLegalTreeSubjectSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for AllCertifyLegalTreeSubjectPackageOrSource: "%T"`, v)
	}
}

// AllCertifyLegalTreeSubjectSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type AllCertifyLegalTreeSubjectSource struct {
	Typename      *string `json:"__typename"`
	AllSourceTree `json:"-"`
}

// GetTypename returns AllCertifyLegalTreeSubjectSource.Typename, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeSubjectSource) GetTypename() *string { return v.Typename }

// GetId returns AllCertifyLegalTreeSubjectSource.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeSubjectSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns AllCertifyLegalTreeSubjectSource.Type, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeSubjectSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns AllCertifyLegalTreeSubjectSource.Namespaces, and is useful for accessing the field via an interface.
func (v *AllCertifyLegalTreeSubjectSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *AllCertifyLegalTreeSubjectSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyLegalTreeSubjectSource
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyLegalTreeSubjectSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyLegalTreeSubjectSource struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *AllCertifyLegalTreeSubjectSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyLegalTreeSubjectSource) __premarshalJSON() (*__premarshalAllCertifyLegalTreeSubjectSource, error) {
	var retval __premarshalAllCertifyLegalTreeSubjectSource

	retval.Typename = v.Typename
	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// AllCertifyScorecard includes the GraphQL fields of CertifyScorecard requested by the fragment AllCertifyScorecard.
// The GraphQL type's documentation follows.
//
// CertifyScorecard is an attestation to attach a Scorecard analysis to a
// particular source repository.
type AllCertifyScorecard struct {
	Id string `json:"id"`
	// The source repository that is being scanned (attestation subject)
	Source AllCertifyScorecardSource `json:"source"`
	// The Scorecard attached to the repository (attestation object)
	Scorecard AllCertifyScorecardScorecard `json:"scorecard"`
}

// GetId returns AllCertifyScorecard.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecard) GetId() string { return v.Id }

// GetSource returns AllCertifyScorecard.Source, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecard) GetSource() AllCertifyScorecardSource { return v.Source }

// GetScorecard returns AllCertifyScorecard.Scorecard, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecard) GetScorecard() AllCertifyScorecardScorecard { return v.Scorecard }

// AllCertifyScorecardScorecard includes the requested fields of the GraphQL type Scorecard.
// The GraphQL type's documentation follows.
//
// Scorecard contains all of the fields present in a Scorecard attestation.
//
// We also include fields to specify under what conditions the check was performed
// (time of scan, version of scanners, etc.) as well as how this information got
// included into GUAC (origin document and the collector for that document).
type AllCertifyScorecardScorecard struct {
	// Exact timestamp when the source was last scanned (in RFC 3339 format)
	TimeScanned time.Time `json:"timeScanned"`
	// Overall Scorecard score for the source
	AggregateScore float64 `json:"aggregateScore"`
	// Individual Scorecard check scores (Branch-Protection, Code-Review, ...)
	Checks []AllCertifyScorecardScorecardChecksScorecardCheck `json:"checks"`
	// Version of the Scorecard scanner used to analyze the source
	ScorecardVersion string `json:"scorecardVersion"`
	// Commit of the Scorecards repository at the time of scanning the source
	ScorecardCommit string `json:"scorecardCommit"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetTimeScanned returns AllCertifyScorecardScorecard.TimeScanned, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecardScorecard) GetTimeScanned() time.Time { return v.TimeScanned }

// GetAggregateScore returns AllCertifyScorecardScorecard.AggregateScore, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecardScorecard) GetAggregateScore() float64 { return v.AggregateScore }

// GetChecks returns AllCertifyScorecardScorecard.Checks, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecardScorecard) GetChecks() []AllCertifyScorecardScorecardChecksScorecardCheck {
	return v.Checks
}

// GetScorecardVersion returns AllCertifyScorecardScorecard.ScorecardVersion, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecardScorecard) GetScorecardVersion() string { return v.ScorecardVersion }

// GetScorecardCommit returns AllCertifyScorecardScorecard.ScorecardCommit, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecardScorecard) GetScorecardCommit() string { return v.ScorecardCommit }

// GetOrigin returns AllCertifyScorecardScorecard.Origin, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecardScorecard) GetOrigin() string { return v.Origin }

// GetCollector returns AllCertifyScorecardScorecard.Collector, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecardScorecard) GetCollector() string { return v.Collector }

// AllCertifyScorecardScorecardChecksScorecardCheck includes the requested fields of the GraphQL type ScorecardCheck.
// The GraphQL type's documentation follows.
//
// ScorecardCheck are the individual checks from scorecard and their values as a
// key-value pair.
//
// For example:  Branch-Protection, Code-Review...etc
//
// Based off scorecard's:
// type jsonCheckResultV2 struct {
// Details []string                 `json:"details"`
// Score   int                      `json:"score"`
// Reason  string                   `json:"reason"`
// Name    string                   `json:"name"`
// Doc     jsonCheckDocumentationV2 `json:"documentation"`
// }
// This node cannot be directly referred by other parts of GUAC.
type AllCertifyScorecardScorecardChecksScorecardCheck struct {
	Check string `json:"check"`
	Score int    `json:"score"`
}

// GetCheck returns AllCertifyScorecardScorecardChecksScorecardCheck.Check, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecardScorecardChecksScorecardCheck) GetCheck() string { return v.Check }

// GetScore returns AllCertifyScorecardScorecardChecksScorecardCheck.Score, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecardScorecardChecksScorecardCheck) GetScore() int { return v.Score }

// AllCertifyScorecardSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type AllCertifyScorecardSource struct {
	AllSourceTree `json:"-"`
}

// GetId returns AllCertifyScorecardSource.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecardSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns AllCertifyScorecardSource.Type, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecardSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns AllCertifyScorecardSource.Namespaces, and is useful for accessing the field via an interface.
func (v *AllCertifyScorecardSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *AllCertifyScorecardSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyScorecardSource
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyScorecardSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyScorecardSource struct {
	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *AllCertifyScorecardSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyScorecardSource) __premarshalJSON() (*__premarshalAllCertifyScorecardSource, error) {
	var retval __premarshalAllCertifyScorecardSource

	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// AllCertifyVEXStatement includes the GraphQL fields of CertifyVEXStatement requested by the fragment AllCertifyVEXStatement.
// The GraphQL type's documentation follows.
//
// CertifyVEXStatement is an attestation to attach VEX statements to a package or
// artifact to clarify the impact of a specific vulnerability.
type AllCertifyVEXStatement struct {
	Id string `json:"id"`
	// Subject of attestation
	Subject AllCertifyVEXStatementSubjectPackageOrArtifact `json:"-"`
	// Attested vulnerability
	Vulnerability AllCertifyVEXStatementVulnerability `json:"vulnerability"`
	// Status of the vulnerabilities with respect to the subject
	Status VexStatus `json:"status"`
	// Justification from VEX statement
	VexJustification VexJustification `json:"vexJustification"`
	// VEX statement: impact_statement or action_statement depending on status
	Statement string `json:"statement"`
	// statusNotes may convey information about how status was determined
	StatusNotes string `json:"statusNotes"`
	// Timestamp (exact time in RFC 3339 format) for the VEX statement
	KnownSince time.Time `json:"knownSince"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetId returns AllCertifyVEXStatement.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatement) GetId() string { return v.Id }

// GetSubject returns AllCertifyVEXStatement.Subject, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatement) GetSubject() AllCertifyVEXStatementSubjectPackageOrArtifact {
	return v.Subject
}

// GetVulnerability returns AllCertifyVEXStatement.Vulnerability, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatement) GetVulnerability() AllCertifyVEXStatementVulnerability {
	return v.Vulnerability
}

// GetStatus returns AllCertifyVEXStatement.Status, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatement) GetStatus() VexStatus { return v.Status }

// GetVexJustification returns AllCertifyVEXStatement.VexJustification, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatement) GetVexJustification() VexJustification { return v.VexJustification }

// GetStatement returns AllCertifyVEXStatement.Statement, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatement) GetStatement() string { return v.Statement }

// GetStatusNotes returns AllCertifyVEXStatement.StatusNotes, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatement) GetStatusNotes() string { return v.StatusNotes }

// GetKnownSince returns AllCertifyVEXStatement.KnownSince, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatement) GetKnownSince() time.Time { return v.KnownSince }

// GetOrigin returns AllCertifyVEXStatement.Origin, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatement) GetOrigin() string { return v.Origin }

// GetCollector returns AllCertifyVEXStatement.Collector, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatement) GetCollector() string { return v.Collector }

func (v *AllCertifyVEXStatement) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyVEXStatement
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyVEXStatement = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalAllCertifyVEXStatementSubjectPackageOrArtifact(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal AllCertifyVEXStatement.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalAllCertifyVEXStatement struct {
	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Vulnerability AllCertifyVEXStatementVulnerability `json:"vulnerability"`

	Status VexStatus `json:"status"`

	VexJustification VexJustification `json:"vexJustification"`

	Statement string `json:"statement"`

	StatusNotes string `json:"statusNotes"`

	KnownSince time.Time `json:"knownSince"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *AllCertifyVEXStatement) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyVEXStatement) __premarshalJSON() (*__premarshalAllCertifyVEXStatement, error) {
	var retval __premarshalAllCertifyVEXStatement

	retval.Id = v.Id
	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalAllCertifyVEXStatementSubjectPackageOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal AllCertifyVEXStatement.Subject: %w", err)
		}
	}
	retval.Vulnerability = v.Vulnerability
	retval.Status = v.Status
	retval.VexJustification = v.VexJustification
	retval.Statement = v.Statement
	retval.StatusNotes = v.StatusNotes
	retval.KnownSince = v.KnownSince
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// AllCertifyVEXStatementSubjectArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type AllCertifyVEXStatementSubjectArtifact struct {
	Typename        *string `json:"__typename"`
	AllArtifactTree `json:"-"`
}

// GetTypename returns AllCertifyVEXStatementSubjectArtifact.Typename, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatementSubjectArtifact) GetTypename() *string { return v.Typename }

// GetId returns AllCertifyVEXStatementSubjectArtifact.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatementSubjectArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns AllCertifyVEXStatementSubjectArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatementSubjectArtifact) GetAlgorithm() string {
	return v.AllArtifactTree.Algorithm
}

// GetDigest returns AllCertifyVEXStatementSubjectArtifact.Digest, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatementSubjectArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *AllCertifyVEXStatementSubjectArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyVEXStatementSubjectArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyVEXStatementSubjectArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyVEXStatementSubjectArtifact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *AllCertifyVEXStatementSubjectArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyVEXStatementSubjectArtifact) __premarshalJSON() (*__premarshalAllCertifyVEXStatementSubjectArtifact, error) {
	var retval __premarshalAllCertifyVEXStatementSubjectArtifact

	retval.Typename = v.Typename
	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// AllCertifyVEXStatementSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllCertifyVEXStatementSubjectPackage struct {
	Typename   *string `json:"__typename"`
	AllPkgTree `json:"-"`
}

// GetTypename returns AllCertifyVEXStatementSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatementSubjectPackage) GetTypename() *string { return v.Typename }

// GetId returns AllCertifyVEXStatementSubjectPackage.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatementSubjectPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns AllCertifyVEXStatementSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatementSubjectPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns AllCertifyVEXStatementSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatementSubjectPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *AllCertifyVEXStatementSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyVEXStatementSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyVEXStatementSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyVEXStatementSubjectPackage struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *AllCertifyVEXStatementSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyVEXStatementSubjectPackage) __premarshalJSON() (*__premarshalAllCertifyVEXStatementSubjectPackage, error) {
	var retval __premarshalAllCertifyVEXStatementSubjectPackage

	retval.Typename = v.Typename
	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// AllCertifyVEXStatementSubjectPackageOrArtifact includes the requested fields of the GraphQL interface PackageOrArtifact.
//
// AllCertifyVEXStatementSubjectPackageOrArtifact is implemented by the following types:
// AllCertifyVEXStatementSubjectArtifact
// AllCertifyVEXStatementSubjectPackage
// The GraphQL type's documentation follows.
//
// PackageOrArtifact is a union of Package and Artifact.
type AllCertifyVEXStatementSubjectPackageOrArtifact interface {
	implementsGraphQLInterfaceAllCertifyVEXStatementSubjectPackageOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *AllCertifyVEXStatementSubjectArtifact) implementsGraphQLInterfaceAllCertifyVEXStatementSubjectPackageOrArtifact() {
}
func (v *AllCertifyVEXStatementSubjectPackage) implementsGraphQLInterfaceAllCertifyVEXStatementSubjectPackageOrArtifact() {
}

func __unmarshalAllCertifyVEXStatementSubjectPackageOrArtifact(b []byte, v *AllCertifyVEXStatementSubjectPackageOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Artifact":
		*v = new(AllCertifyVEXStatementSubjectArtifact)
		return json.Unmarshal(b, *v)
	case "Package":
		*v = new(AllCertifyVEXStatementSubjectPackage)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for AllCertifyVEXStatementSubjectPackageOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalAllCertifyVEXStatementSubjectPackageOrArtifact(v *AllCertifyVEXStatementSubjectPackageOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *AllCertifyVEXStatementSubjectArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllCertifyVEXStatementSubjectArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *AllCertifyVEXStatementSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllCertifyVEXStatementSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for AllCertifyVEXStatementSubjectPackageOrArtifact: "%T"`, v)
	}
}

// AllCertifyVEXStatementVulnerability includes the requested fields of the GraphQL type Vulnerability.
// The GraphQL type's documentation follows.
//
// Vulnerability represents the root of the vulnerability trie/tree.
//
// We map vulnerability information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type and a vulnerability ID. This allows for generic
// representation of the various vulnerabilities and does not limit to just cve, ghsa or osv.
// This would be in the general format: vuln://<general-type>/<vuln-id>
//
// Examples:
//
// CVE, using path separator: vuln://cve/cve-2023-20753
// OSV, representing its knowledge of a GHSA: vuln://osv/ghsa-205hk
// Random vendor: vuln://snyk/sn-whatever
// NoVuln: vuln://novuln/
//
// This node represents the type part of the trie path. It is used to represent
// the specific type of the vulnerability: cve, ghsa, osv or some other vendor specific
//
// Since this node is at the root of the vulnerability trie, it is named Vulnerability, not
// VulnerabilityType.
//
// NoVuln is a special vulnerability node to attest that no vulnerability has been
// found during a vulnerability scan. It will have the type "novuln" and contain an empty string
// for vulnerabilityID
//
// The resolvers will enforce that both the type and vulnerability IDs are lower case.
type AllCertifyVEXStatementVulnerability struct {
	AllVulnerabilityTree `json:"-"`
}

// GetId returns AllCertifyVEXStatementVulnerability.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatementVulnerability) GetId() string { return v.AllVulnerabilityTree.Id }

// GetType returns AllCertifyVEXStatementVulnerability.Type, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatementVulnerability) GetType() string { return v.AllVulnerabilityTree.Type }

// GetVulnerabilityIDs returns AllCertifyVEXStatementVulnerability.VulnerabilityIDs, and is useful for accessing the field via an interface.
func (v *AllCertifyVEXStatementVulnerability) GetVulnerabilityIDs() []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID {
	return v.AllVulnerabilityTree.VulnerabilityIDs
}

func (v *AllCertifyVEXStatementVulnerability) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyVEXStatementVulnerability
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyVEXStatementVulnerability = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnerabilityTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyVEXStatementVulnerability struct {
	Id string `json:"id"`

	Type string `json:"type"`

	VulnerabilityIDs []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID `json:"vulnerabilityIDs"`
}

func (v *AllCertifyVEXStatementVulnerability) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyVEXStatementVulnerability) __premarshalJSON() (*__premarshalAllCertifyVEXStatementVulnerability, error) {
	var retval __premarshalAllCertifyVEXStatementVulnerability

	retval.Id = v.AllVulnerabilityTree.Id
	retval.Type = v.AllVulnerabilityTree.Type
	retval.VulnerabilityIDs = v.AllVulnerabilityTree.VulnerabilityIDs
	return &retval, nil
}

// AllCertifyVuln includes the GraphQL fields of CertifyVuln requested by the fragment AllCertifyVuln.
// The GraphQL type's documentation follows.
//
// CertifyVuln is an attestation to attach vulnerability information to a package.
//
// This information is obtained via a scanner. If there is no vulnerability
// detected, we attach the a vulnerability with "NoVuln" type and an empty string
// for the vulnerability ID.
type AllCertifyVuln struct {
	Id string `json:"id"`
	// The package that is attested
	Package AllCertifyVulnPackage `json:"package"`
	// The vulnerability can be an be a specific vulnerability or NoVuln type.
	Vulnerability AllCertifyVulnVulnerability `json:"vulnerability"`
	// Metadata attached to the certification
	Metadata AllCertifyVulnMetadataScanMetadata `json:"metadata"`
}

// GetId returns AllCertifyVuln.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyVuln) GetId() string { return v.Id }

// GetPackage returns AllCertifyVuln.Package, and is useful for accessing the field via an interface.
func (v *AllCertifyVuln) GetPackage() AllCertifyVulnPackage { return v.Package }

// GetVulnerability returns AllCertifyVuln.Vulnerability, and is useful for accessing the field via an interface.
func (v *AllCertifyVuln) GetVulnerability() AllCertifyVulnVulnerability { return v.Vulnerability }

// GetMetadata returns AllCertifyVuln.Metadata, and is useful for accessing the field via an interface.
func (v *AllCertifyVuln) GetMetadata() AllCertifyVulnMetadataScanMetadata { return v.Metadata }

// AllCertifyVulnMetadataScanMetadata includes the requested fields of the GraphQL type ScanMetadata.
// The GraphQL type's documentation follows.
//
// ScanMetadata is the metadata attached to vulnerability certification.
//
// It contains metadata about the scanner process that created the certification.
type AllCertifyVulnMetadataScanMetadata struct {
	// URI of the vulnerability database used by the scanner
	DbUri string `json:"dbUri"`
	// Version of the vulnerability database used by the scanner
	DbVersion string `json:"dbVersion"`
	// URI of the scanner
	ScannerUri string `json:"scannerUri"`
	// Version of the scanner
	ScannerVersion string `json:"scannerVersion"`
	// Time of scan (in RFC 3339 format)
	TimeScanned time.Time `json:"timeScanned"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetDbUri returns AllCertifyVulnMetadataScanMetadata.DbUri, and is useful for accessing the field via an interface.
func (v *AllCertifyVulnMetadataScanMetadata) GetDbUri() string { return v.DbUri }

// GetDbVersion returns AllCertifyVulnMetadataScanMetadata.DbVersion, and is useful for accessing the field via an interface.
func (v *AllCertifyVulnMetadataScanMetadata) GetDbVersion() string { return v.DbVersion }

// GetScannerUri returns AllCertifyVulnMetadataScanMetadata.ScannerUri, and is useful for accessing the field via an interface.
func (v *AllCertifyVulnMetadataScanMetadata) GetScannerUri() string { return v.ScannerUri }

// GetScannerVersion returns AllCertifyVulnMetadataScanMetadata.ScannerVersion, and is useful for accessing the field via an interface.
func (v *AllCertifyVulnMetadataScanMetadata) GetScannerVersion() string { return v.ScannerVersion }

// GetTimeScanned returns AllCertifyVulnMetadataScanMetadata.TimeScanned, and is useful for accessing the field via an interface.
func (v *AllCertifyVulnMetadataScanMetadata) GetTimeScanned() time.Time { return v.TimeScanned }

// GetOrigin returns AllCertifyVulnMetadataScanMetadata.Origin, and is useful for accessing the field via an interface.
func (v *AllCertifyVulnMetadataScanMetadata) GetOrigin() string { return v.Origin }

// GetCollector returns AllCertifyVulnMetadataScanMetadata.Collector, and is useful for accessing the field via an interface.
func (v *AllCertifyVulnMetadataScanMetadata) GetCollector() string { return v.Collector }

// AllCertifyVulnPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllCertifyVulnPackage struct {
	AllPkgTree `json:"-"`
}

// GetId returns AllCertifyVulnPackage.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyVulnPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns AllCertifyVulnPackage.Type, and is useful for accessing the field via an interface.
func (v *AllCertifyVulnPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns AllCertifyVulnPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *AllCertifyVulnPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *AllCertifyVulnPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyVulnPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyVulnPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyVulnPackage struct {
	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *AllCertifyVulnPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyVulnPackage) __premarshalJSON() (*__premarshalAllCertifyVulnPackage, error) {
	var retval __premarshalAllCertifyVulnPackage

	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// AllCertifyVulnVulnerability includes the requested fields of the GraphQL type Vulnerability.
// The GraphQL type's documentation follows.
//
// Vulnerability represents the root of the vulnerability trie/tree.
//
// We map vulnerability information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type and a vulnerability ID. This allows for generic
// representation of the various vulnerabilities and does not limit to just cve, ghsa or osv.
// This would be in the general format: vuln://<general-type>/<vuln-id>
//
// Examples:
//
// CVE, using path separator: vuln://cve/cve-2023-20753
// OSV, representing its knowledge of a GHSA: vuln://osv/ghsa-205hk
// Random vendor: vuln://snyk/sn-whatever
// NoVuln: vuln://novuln/
//
// This node represents the type part of the trie path. It is used to represent
// the specific type of the vulnerability: cve, ghsa, osv or some other vendor specific
//
// Since this node is at the root of the vulnerability trie, it is named Vulnerability, not
// VulnerabilityType.
//
// NoVuln is a special vulnerability node to attest that no vulnerability has been
// found during a vulnerability scan. It will have the type "novuln" and contain an empty string
// for vulnerabilityID
//
// The resolvers will enforce that both the type and vulnerability IDs are lower case.
type AllCertifyVulnVulnerability struct {
	AllVulnerabilityTree `json:"-"`
}

// GetId returns AllCertifyVulnVulnerability.Id, and is useful for accessing the field via an interface.
func (v *AllCertifyVulnVulnerability) GetId() string { return v.AllVulnerabilityTree.Id }

// GetType returns AllCertifyVulnVulnerability.Type, and is useful for accessing the field via an interface.
func (v *AllCertifyVulnVulnerability) GetType() string { return v.AllVulnerabilityTree.Type }

// GetVulnerabilityIDs returns AllCertifyVulnVulnerability.VulnerabilityIDs, and is useful for accessing the field via an interface.
func (v *AllCertifyVulnVulnerability) GetVulnerabilityIDs() []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID {
	return v.AllVulnerabilityTree.VulnerabilityIDs
}

func (v *AllCertifyVulnVulnerability) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllCertifyVulnVulnerability
		graphql.NoUnmarshalJSON
	}
	firstPass.AllCertifyVulnVulnerability = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnerabilityTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllCertifyVulnVulnerability struct {
	Id string `json:"id"`

	Type string `json:"type"`

	VulnerabilityIDs []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID `json:"vulnerabilityIDs"`
}

func (v *AllCertifyVulnVulnerability) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllCertifyVulnVulnerability) __premarshalJSON() (*__premarshalAllCertifyVulnVulnerability, error) {
	var retval __premarshalAllCertifyVulnVulnerability

	retval.Id = v.AllVulnerabilityTree.Id
	retval.Type = v.AllVulnerabilityTree.Type
	retval.VulnerabilityIDs = v.AllVulnerabilityTree.VulnerabilityIDs
	return &retval, nil
}

// AllHasMetadata includes the GraphQL fields of HasMetadata requested by the fragment AllHasMetadata.
// The GraphQL type's documentation follows.
//
// HasMetadata is an attestation that a package, source, or artifact has a certain
// attested property (key) with value (value). For example, a source may have
// metadata "SourceRepo2FAEnabled=true".
//
// The intent of this evidence tree predicate is to allow extensibility of metadata
// expressible within the GUAC ontology. Metadata that is commonly used will then
// be promoted to a predicate on its own.
//
// Justification indicates how the metadata was determined.
//
// The metadata applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type AllHasMetadata struct {
	Id            string                                       `json:"id"`
	Subject       AllHasMetadataSubjectPackageSourceOrArtifact `json:"-"`
	Key           string                                       `json:"key"`
	Value         string                                       `json:"value"`
	Timestamp     time.Time                                    `json:"timestamp"`
	Justification string                                       `json:"justification"`
	Origin        string                                       `json:"origin"`
	Collector     string                                       `json:"collector"`
}

// GetId returns AllHasMetadata.Id, and is useful for accessing the field via an interface.
func (v *AllHasMetadata) GetId() string { return v.Id }

// GetSubject returns AllHasMetadata.Subject, and is useful for accessing the field via an interface.
func (v *AllHasMetadata) GetSubject() AllHasMetadataSubjectPackageSourceOrArtifact { return v.Subject }

// GetKey returns AllHasMetadata.Key, and is useful for accessing the field via an interface.
func (v *AllHasMetadata) GetKey() string { return v.Key }

// GetValue returns AllHasMetadata.Value, and is useful for accessing the field via an interface.
func (v *AllHasMetadata) GetValue() string { return v.Value }

// GetTimestamp returns AllHasMetadata.Timestamp, and is useful for accessing the field via an interface.
func (v *AllHasMetadata) GetTimestamp() time.Time { return v.Timestamp }

// GetJustification returns AllHasMetadata.Justification, and is useful for accessing the field via an interface.
func (v *AllHasMetadata) GetJustification() string { return v.Justification }

// GetOrigin returns AllHasMetadata.Origin, and is useful for accessing the field via an interface.
func (v *AllHasMetadata) GetOrigin() string { return v.Origin }

// GetCollector returns AllHasMetadata.Collector, and is useful for accessing the field via an interface.
func (v *AllHasMetadata) GetCollector() string { return v.Collector }

func (v *AllHasMetadata) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllHasMetadata
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.AllHasMetadata = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalAllHasMetadataSubjectPackageSourceOrArtifact(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal AllHasMetadata.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalAllHasMetadata struct {
	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Key string `json:"key"`

	Value string `json:"value"`

	Timestamp time.Time `json:"timestamp"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *AllHasMetadata) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllHasMetadata) __premarshalJSON() (*__premarshalAllHasMetadata, error) {
	var retval __premarshalAllHasMetadata

	retval.Id = v.Id
	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalAllHasMetadataSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal AllHasMetadata.Subject: %w", err)
		}
	}
	retval.Key = v.Key
	retval.Value = v.Value
	retval.Timestamp = v.Timestamp
	retval.Justification = v.Justification
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// AllHasMetadataSubjectArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type AllHasMetadataSubjectArtifact struct {
	Typename        *string `json:"__typename"`
	AllArtifactTree `json:"-"`
}

// GetTypename returns AllHasMetadataSubjectArtifact.Typename, and is useful for accessing the field via an interface.
func (v *AllHasMetadataSubjectArtifact) GetTypename() *string { return v.Typename }

// GetId returns AllHasMetadataSubjectArtifact.Id, and is useful for accessing the field via an interface.
func (v *AllHasMetadataSubjectArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns AllHasMetadataSubjectArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *AllHasMetadataSubjectArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns AllHasMetadataSubjectArtifact.Digest, and is useful for accessing the field via an interface.
func (v *AllHasMetadataSubjectArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *AllHasMetadataSubjectArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllHasMetadataSubjectArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.AllHasMetadataSubjectArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllHasMetadataSubjectArtifact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *AllHasMetadataSubjectArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllHasMetadataSubjectArtifact) __premarshalJSON() (*__premarshalAllHasMetadataSubjectArtifact, error) {
	var retval __premarshalAllHasMetadataSubjectArtifact

	retval.Typename = v.Typename
	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// AllHasMetadataSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllHasMetadataSubjectPackage struct {
	Typename   *string `json:"__typename"`
	AllPkgTree `json:"-"`
}

// GetTypename returns AllHasMetadataSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *AllHasMetadataSubjectPackage) GetTypename() *string { return v.Typename }

// GetId returns AllHasMetadataSubjectPackage.Id, and is useful for accessing the field via an interface.
func (v *AllHasMetadataSubjectPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns AllHasMetadataSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *AllHasMetadataSubjectPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns AllHasMetadataSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *AllHasMetadataSubjectPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *AllHasMetadataSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllHasMetadataSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.AllHasMetadataSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllHasMetadataSubjectPackage struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *AllHasMetadataSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllHasMetadataSubjectPackage) __premarshalJSON() (*__premarshalAllHasMetadataSubjectPackage, error) {
	var retval __premarshalAllHasMetadataSubjectPackage

	retval.Typename = v.Typename
	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// AllHasMetadataSubjectPackageSourceOrArtifact includes the requested fields of the GraphQL interface PackageSourceOrArtifact.
//
// AllHasMetadataSubjectPackageSourceOrArtifact is implemented by the following types:
// AllHasMetadataSubjectArtifact
// AllHasMetadataSubjectPackage
// AllHasMetadataSubjectSource
// The GraphQL type's documentation follows.
//
// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type AllHasMetadataSubjectPackageSourceOrArtifact interface {
	implementsGraphQLInterfaceAllHasMetadataSubjectPackageSourceOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *AllHasMetadataSubjectArtifact) implementsGraphQLInterfaceAllHasMetadataSubjectPackageSourceOrArtifact() {
}
func (v *AllHasMetadataSubjectPackage) implementsGraphQLInterfaceAllHasMetadataSubjectPackageSourceOrArtifact() {
}
func (v *AllHasMetadataSubjectSource) implementsGraphQLInterfaceAllHasMetadataSubjectPackageSourceOrArtifact() {
}

func __unmarshalAllHasMetadataSubjectPackageSourceOrArtifact(b []byte, v *AllHasMetadataSubjectPackageSourceOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Artifact":
		*v = new(AllHasMetadataSubjectArtifact)
		return json.Unmarshal(b, *v)
	case "Package":
		*v = new(AllHasMetadataSubjectPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(AllHasMetadataSubjectSource)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageSourceOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for AllHasMetadataSubjectPackageSourceOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalAllHasMetadataSubjectPackageSourceOrArtifact(v *AllHasMetadataSubjectPackageSourceOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *AllHasMetadataSubjectArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllHasMetadataSubjectArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *AllHasMetadataSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllHasMetadataSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *AllHasMetadataSubjectSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllHasMetadataSubjectSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for AllHasMetadataSubjectPackageSourceOrArtifact: "%T"`, v)
	}
}

// AllHasMetadataSubjectSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type AllHasMetadataSubjectSource struct {
	Typename      *string `json:"__typename"`
	AllSourceTree `json:"-"`
}

// GetTypename returns AllHasMetadataSubjectSource.Typename, and is useful for accessing the field via an interface.
func (v *AllHasMetadataSubjectSource) GetTypename() *string { return v.Typename }

// GetId returns AllHasMetadataSubjectSource.Id, and is useful for accessing the field via an interface.
func (v *AllHasMetadataSubjectSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns AllHasMetadataSubjectSource.Type, and is useful for accessing the field via an interface.
func (v *AllHasMetadataSubjectSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns AllHasMetadataSubjectSource.Namespaces, and is useful for accessing the field via an interface.
func (v *AllHasMetadataSubjectSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *AllHasMetadataSubjectSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllHasMetadataSubjectSource
		graphql.NoUnmarshalJSON
	}
	firstPass.AllHasMetadataSubjectSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllHasMetadataSubjectSource struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *AllHasMetadataSubjectSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllHasMetadataSubjectSource) __premarshalJSON() (*__premarshalAllHasMetadataSubjectSource, error) {
	var retval __premarshalAllHasMetadataSubjectSource

	retval.Typename = v.Typename
	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// AllHasSBOMTree includes the GraphQL fields of HasSBOM requested by the fragment AllHasSBOMTree.
type AllHasSBOMTree struct {
	Id string `json:"id"`
	// SBOM subject
	Subject AllHasSBOMTreeSubjectPackageOrArtifact `json:"-"`
	// Identifier for the SBOM document
	Uri string `json:"uri"`
	// Algorithm by which SBOMs digest was computed
	Algorithm string `json:"algorithm"`
	// Digest of SBOM
	Digest string `json:"digest"`
	// Location from which the SBOM can be downloaded
	DownloadLocation string `json:"downloadLocation"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetId returns AllHasSBOMTree.Id, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTree) GetId() string { return v.Id }

// GetSubject returns AllHasSBOMTree.Subject, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTree) GetSubject() AllHasSBOMTreeSubjectPackageOrArtifact { return v.Subject }

// GetUri returns AllHasSBOMTree.Uri, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTree) GetUri() string { return v.Uri }

// GetAlgorithm returns AllHasSBOMTree.Algorithm, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTree) GetAlgorithm() string { return v.Algorithm }

// GetDigest returns AllHasSBOMTree.Digest, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTree) GetDigest() string { return v.Digest }

// GetDownloadLocation returns AllHasSBOMTree.DownloadLocation, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTree) GetDownloadLocation() string { return v.DownloadLocation }

// GetOrigin returns AllHasSBOMTree.Origin, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTree) GetOrigin() string { return v.Origin }

// GetCollector returns AllHasSBOMTree.Collector, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTree) GetCollector() string { return v.Collector }

func (v *AllHasSBOMTree) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllHasSBOMTree
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.AllHasSBOMTree = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalAllHasSBOMTreeSubjectPackageOrArtifact(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal AllHasSBOMTree.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalAllHasSBOMTree struct {
	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Uri string `json:"uri"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`

	DownloadLocation string `json:"downloadLocation"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *AllHasSBOMTree) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllHasSBOMTree) __premarshalJSON() (*__premarshalAllHasSBOMTree, error) {
	var retval __premarshalAllHasSBOMTree

	retval.Id = v.Id
	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalAllHasSBOMTreeSubjectPackageOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal AllHasSBOMTree.Subject: %w", err)
		}
	}
	retval.Uri = v.Uri
	retval.Algorithm = v.Algorithm
	retval.Digest = v.Digest
	retval.DownloadLocation = v.DownloadLocation
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// AllHasSBOMTreeSubjectArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type AllHasSBOMTreeSubjectArtifact struct {
	Typename        *string `json:"__typename"`
	AllArtifactTree `json:"-"`
}

// GetTypename returns AllHasSBOMTreeSubjectArtifact.Typename, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTreeSubjectArtifact) GetTypename() *string { return v.Typename }

// GetId returns AllHasSBOMTreeSubjectArtifact.Id, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTreeSubjectArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns AllHasSBOMTreeSubjectArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTreeSubjectArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns AllHasSBOMTreeSubjectArtifact.Digest, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTreeSubjectArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *AllHasSBOMTreeSubjectArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllHasSBOMTreeSubjectArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.AllHasSBOMTreeSubjectArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllHasSBOMTreeSubjectArtifact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *AllHasSBOMTreeSubjectArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllHasSBOMTreeSubjectArtifact) __premarshalJSON() (*__premarshalAllHasSBOMTreeSubjectArtifact, error) {
	var retval __premarshalAllHasSBOMTreeSubjectArtifact

	retval.Typename = v.Typename
	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// AllHasSBOMTreeSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllHasSBOMTreeSubjectPackage struct {
	Typename   *string `json:"__typename"`
	AllPkgTree `json:"-"`
}

// GetTypename returns AllHasSBOMTreeSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTreeSubjectPackage) GetTypename() *string { return v.Typename }

// GetId returns AllHasSBOMTreeSubjectPackage.Id, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTreeSubjectPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns AllHasSBOMTreeSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTreeSubjectPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns AllHasSBOMTreeSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *AllHasSBOMTreeSubjectPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *AllHasSBOMTreeSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllHasSBOMTreeSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.AllHasSBOMTreeSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllHasSBOMTreeSubjectPackage struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *AllHasSBOMTreeSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllHasSBOMTreeSubjectPackage) __premarshalJSON() (*__premarshalAllHasSBOMTreeSubjectPackage, error) {
	var retval __premarshalAllHasSBOMTreeSubjectPackage

	retval.Typename = v.Typename
	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// AllHasSBOMTreeSubjectPackageOrArtifact includes the requested fields of the GraphQL interface PackageOrArtifact.
//
// AllHasSBOMTreeSubjectPackageOrArtifact is implemented by the following types:
// AllHasSBOMTreeSubjectArtifact
// AllHasSBOMTreeSubjectPackage
// The GraphQL type's documentation follows.
//
// PackageOrArtifact is a union of Package and Artifact.
type AllHasSBOMTreeSubjectPackageOrArtifact interface {
	implementsGraphQLInterfaceAllHasSBOMTreeSubjectPackageOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *AllHasSBOMTreeSubjectArtifact) implementsGraphQLInterfaceAllHasSBOMTreeSubjectPackageOrArtifact() {
}
func (v *AllHasSBOMTreeSubjectPackage) implementsGraphQLInterfaceAllHasSBOMTreeSubjectPackageOrArtifact() {
}

func __unmarshalAllHasSBOMTreeSubjectPackageOrArtifact(b []byte, v *AllHasSBOMTreeSubjectPackageOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Artifact":
		*v = new(AllHasSBOMTreeSubjectArtifact)
		return json.Unmarshal(b, *v)
	case "Package":
		*v = new(AllHasSBOMTreeSubjectPackage)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for AllHasSBOMTreeSubjectPackageOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalAllHasSBOMTreeSubjectPackageOrArtifact(v *AllHasSBOMTreeSubjectPackageOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *AllHasSBOMTreeSubjectArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllHasSBOMTreeSubjectArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *AllHasSBOMTreeSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllHasSBOMTreeSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for AllHasSBOMTreeSubjectPackageOrArtifact: "%T"`, v)
	}
}

// AllHasSourceAt includes the GraphQL fields of HasSourceAt requested by the fragment AllHasSourceAt.
// The GraphQL type's documentation follows.
//
// HasSourceAt records that a package's repository is a given source.
type AllHasSourceAt struct {
	Id string `json:"id"`
	// Justification for the attested relationship
	Justification string `json:"justification"`
	// Timestamp since this link between package and source was certified
	KnownSince time.Time `json:"knownSince"`
	// The subject of the attestation: can be a PackageName or a PackageVersion
	Package AllHasSourceAtPackage `json:"package"`
	// Source repository from which the package is built
	Source AllHasSourceAtSource `json:"source"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetId returns AllHasSourceAt.Id, and is useful for accessing the field via an interface.
func (v *AllHasSourceAt) GetId() string { return v.Id }

// GetJustification returns AllHasSourceAt.Justification, and is useful for accessing the field via an interface.
func (v *AllHasSourceAt) GetJustification() string { return v.Justification }

// GetKnownSince returns AllHasSourceAt.KnownSince, and is useful for accessing the field via an interface.
func (v *AllHasSourceAt) GetKnownSince() time.Time { return v.KnownSince }

// GetPackage returns AllHasSourceAt.Package, and is useful for accessing the field via an interface.
func (v *AllHasSourceAt) GetPackage() AllHasSourceAtPackage { return v.Package }

// GetSource returns AllHasSourceAt.Source, and is useful for accessing the field via an interface.
func (v *AllHasSourceAt) GetSource() AllHasSourceAtSource { return v.Source }

// GetOrigin returns AllHasSourceAt.Origin, and is useful for accessing the field via an interface.
func (v *AllHasSourceAt) GetOrigin() string { return v.Origin }

// GetCollector returns AllHasSourceAt.Collector, and is useful for accessing the field via an interface.
func (v *AllHasSourceAt) GetCollector() string { return v.Collector }

// AllHasSourceAtPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllHasSourceAtPackage struct {
	AllPkgTree `json:"-"`
}

// GetId returns AllHasSourceAtPackage.Id, and is useful for accessing the field via an interface.
func (v *AllHasSourceAtPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns AllHasSourceAtPackage.Type, and is useful for accessing the field via an interface.
func (v *AllHasSourceAtPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns AllHasSourceAtPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *AllHasSourceAtPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *AllHasSourceAtPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllHasSourceAtPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.AllHasSourceAtPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllHasSourceAtPackage struct {
	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *AllHasSourceAtPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllHasSourceAtPackage) __premarshalJSON() (*__premarshalAllHasSourceAtPackage, error) {
	var retval __premarshalAllHasSourceAtPackage

	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// AllHasSourceAtSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type AllHasSourceAtSource struct {
	AllSourceTree `json:"-"`
}

// GetId returns AllHasSourceAtSource.Id, and is useful for accessing the field via an interface.
func (v *AllHasSourceAtSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns AllHasSourceAtSource.Type, and is useful for accessing the field via an interface.
func (v *AllHasSourceAtSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns AllHasSourceAtSource.Namespaces, and is useful for accessing the field via an interface.
func (v *AllHasSourceAtSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *AllHasSourceAtSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllHasSourceAtSource
		graphql.NoUnmarshalJSON
	}
	firstPass.AllHasSourceAtSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllHasSourceAtSource struct {
	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *AllHasSourceAtSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllHasSourceAtSource) __premarshalJSON() (*__premarshalAllHasSourceAtSource, error) {
	var retval __premarshalAllHasSourceAtSource

	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// AllHashEqualTree includes the GraphQL fields of HashEqual requested by the fragment AllHashEqualTree.
// The GraphQL type's documentation follows.
//
// HashEqual is an attestation that a set of artifacts are identical.
type AllHashEqualTree struct {
	Id string `json:"id"`
	// Justification for the claim that the artifacts are similar
	Justification string `json:"justification"`
	// Collection of artifacts that are similar
	Artifacts []AllHashEqualTreeArtifactsArtifact `json:"artifacts"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetId returns AllHashEqualTree.Id, and is useful for accessing the field via an interface.
func (v *AllHashEqualTree) GetId() string { return v.Id }

// GetJustification returns AllHashEqualTree.Justification, and is useful for accessing the field via an interface.
func (v *AllHashEqualTree) GetJustification() string { return v.Justification }

// GetArtifacts returns AllHashEqualTree.Artifacts, and is useful for accessing the field via an interface.
func (v *AllHashEqualTree) GetArtifacts() []AllHashEqualTreeArtifactsArtifact { return v.Artifacts }

// GetOrigin returns AllHashEqualTree.Origin, and is useful for accessing the field via an interface.
func (v *AllHashEqualTree) GetOrigin() string { return v.Origin }

// GetCollector returns AllHashEqualTree.Collector, and is useful for accessing the field via an interface.
func (v *AllHashEqualTree) GetCollector() string { return v.Collector }

// AllHashEqualTreeArtifactsArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type AllHashEqualTreeArtifactsArtifact struct {
	AllArtifactTree `json:"-"`
}

// GetId returns AllHashEqualTreeArtifactsArtifact.Id, and is useful for accessing the field via an interface.
func (v *AllHashEqualTreeArtifactsArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns AllHashEqualTreeArtifactsArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *AllHashEqualTreeArtifactsArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns AllHashEqualTreeArtifactsArtifact.Digest, and is useful for accessing the field via an interface.
func (v *AllHashEqualTreeArtifactsArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *AllHashEqualTreeArtifactsArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllHashEqualTreeArtifactsArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.AllHashEqualTreeArtifactsArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllHashEqualTreeArtifactsArtifact struct {
	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *AllHashEqualTreeArtifactsArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllHashEqualTreeArtifactsArtifact) __premarshalJSON() (*__premarshalAllHashEqualTreeArtifactsArtifact, error) {
	var retval __premarshalAllHashEqualTreeArtifactsArtifact

	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// AllIsDependencyTree includes the GraphQL fields of IsDependency requested by the fragment AllIsDependencyTree.
// The GraphQL type's documentation follows.
//
// IsDependency is an attestation to record that a package depends on another.
type AllIsDependencyTree struct {
	Id string `json:"id"`
	// Justification for the attested relationship
	Justification string `json:"justification"`
	// Package that has the dependency
	Package AllIsDependencyTreePackage `json:"package"`
	// Package for the dependency; MUST be PackageName or PackageVersion
	DependentPackage AllIsDependencyTreeDependentPackage `json:"dependentPackage"`
	// Type of dependency
	DependencyType DependencyType `json:"dependencyType"`
	// Version range for the dependency link, required if depedentPackage points to PackageName
	VersionRange string `json:"versionRange"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetId returns AllIsDependencyTree.Id, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTree) GetId() string { return v.Id }

// GetJustification returns AllIsDependencyTree.Justification, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTree) GetJustification() string { return v.Justification }

// GetPackage returns AllIsDependencyTree.Package, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTree) GetPackage() AllIsDependencyTreePackage { return v.Package }

// GetDependentPackage returns AllIsDependencyTree.DependentPackage, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTree) GetDependentPackage() AllIsDependencyTreeDependentPackage {
	return v.DependentPackage
}

// GetDependencyType returns AllIsDependencyTree.DependencyType, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTree) GetDependencyType() DependencyType { return v.DependencyType }

// GetVersionRange returns AllIsDependencyTree.VersionRange, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTree) GetVersionRange() string { return v.VersionRange }

// GetOrigin returns AllIsDependencyTree.Origin, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTree) GetOrigin() string { return v.Origin }

// GetCollector returns AllIsDependencyTree.Collector, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTree) GetCollector() string { return v.Collector }

// AllIsDependencyTreeDependentPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllIsDependencyTreeDependentPackage struct {
	AllPkgTree `json:"-"`
}

// GetId returns AllIsDependencyTreeDependentPackage.Id, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTreeDependentPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns AllIsDependencyTreeDependentPackage.Type, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTreeDependentPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns AllIsDependencyTreeDependentPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTreeDependentPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *AllIsDependencyTreeDependentPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllIsDependencyTreeDependentPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.AllIsDependencyTreeDependentPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllIsDependencyTreeDependentPackage struct {
	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *AllIsDependencyTreeDependentPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllIsDependencyTreeDependentPackage) __premarshalJSON() (*__premarshalAllIsDependencyTreeDependentPackage, error) {
	var retval __premarshalAllIsDependencyTreeDependentPackage

	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// AllIsDependencyTreePackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllIsDependencyTreePackage struct {
	AllPkgTree `json:"-"`
}

// GetId returns AllIsDependencyTreePackage.Id, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTreePackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns AllIsDependencyTreePackage.Type, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTreePackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns AllIsDependencyTreePackage.Namespaces, and is useful for accessing the field via an interface.
func (v *AllIsDependencyTreePackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *AllIsDependencyTreePackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllIsDependencyTreePackage
		graphql.NoUnmarshalJSON
	}
	firstPass.AllIsDependencyTreePackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllIsDependencyTreePackage struct {
	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *AllIsDependencyTreePackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllIsDependencyTreePackage) __premarshalJSON() (*__premarshalAllIsDependencyTreePackage, error) {
	var retval __premarshalAllIsDependencyTreePackage

	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// AllIsOccurrencesTree includes the GraphQL fields of IsOccurrence requested by the fragment AllIsOccurrencesTree.
// The GraphQL type's documentation follows.
//
// IsOccurrence is an attestation to link an artifact to a package or source.
//
// Attestation must occur at the PackageVersion or at the SourceName.
type AllIsOccurrencesTree struct {
	Id string `json:"id"`
	// Package or source from which the artifact originates
	Subject AllIsOccurrencesTreeSubjectPackageOrSource `json:"-"`
	// The artifact in the relationship
	Artifact AllIsOccurrencesTreeArtifact `json:"artifact"`
	// Justification for the attested relationship
	Justification string `json:"justification"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetId returns AllIsOccurrencesTree.Id, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTree) GetId() string { return v.Id }

// GetSubject returns AllIsOccurrencesTree.Subject, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTree) GetSubject() AllIsOccurrencesTreeSubjectPackageOrSource {
	return v.Subject
}

// GetArtifact returns AllIsOccurrencesTree.Artifact, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTree) GetArtifact() AllIsOccurrencesTreeArtifact { return v.Artifact }

// GetJustification returns AllIsOccurrencesTree.Justification, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTree) GetJustification() string { return v.Justification }

// GetOrigin returns AllIsOccurrencesTree.Origin, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTree) GetOrigin() string { return v.Origin }

// GetCollector returns AllIsOccurrencesTree.Collector, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTree) GetCollector() string { return v.Collector }

func (v *AllIsOccurrencesTree) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllIsOccurrencesTree
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.AllIsOccurrencesTree = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalAllIsOccurrencesTreeSubjectPackageOrSource(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal AllIsOccurrencesTree.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalAllIsOccurrencesTree struct {
	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Artifact AllIsOccurrencesTreeArtifact `json:"artifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *AllIsOccurrencesTree) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllIsOccurrencesTree) __premarshalJSON() (*__premarshalAllIsOccurrencesTree, error) {
	var retval __premarshalAllIsOccurrencesTree

	retval.Id = v.Id
	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalAllIsOccurrencesTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal AllIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.Artifact = v.Artifact
	retval.Justification = v.Justification
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// AllIsOccurrencesTreeArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type AllIsOccurrencesTreeArtifact struct {
	AllArtifactTree `json:"-"`
}

// GetId returns AllIsOccurrencesTreeArtifact.Id, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTreeArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns AllIsOccurrencesTreeArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTreeArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns AllIsOccurrencesTreeArtifact.Digest, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTreeArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *AllIsOccurrencesTreeArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllIsOccurrencesTreeArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.AllIsOccurrencesTreeArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllIsOccurrencesTreeArtifact struct {
	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *AllIsOccurrencesTreeArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllIsOccurrencesTreeArtifact) __premarshalJSON() (*__premarshalAllIsOccurrencesTreeArtifact, error) {
	var retval __premarshalAllIsOccurrencesTreeArtifact

	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// AllIsOccurrencesTreeSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllIsOccurrencesTreeSubjectPackage struct {
	Typename   *string `json:"__typename"`
	AllPkgTree `json:"-"`
}

// GetTypename returns AllIsOccurrencesTreeSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTreeSubjectPackage) GetTypename() *string { return v.Typename }

// GetId returns AllIsOccurrencesTreeSubjectPackage.Id, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTreeSubjectPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns AllIsOccurrencesTreeSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTreeSubjectPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns AllIsOccurrencesTreeSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTreeSubjectPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *AllIsOccurrencesTreeSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllIsOccurrencesTreeSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.AllIsOccurrencesTreeSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllIsOccurrencesTreeSubjectPackage struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *AllIsOccurrencesTreeSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllIsOccurrencesTreeSubjectPackage) __premarshalJSON() (*__premarshalAllIsOccurrencesTreeSubjectPackage, error) {
	var retval __premarshalAllIsOccurrencesTreeSubjectPackage

	retval.Typename = v.Typename
	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// AllIsOccurrencesTreeSubjectPackageOrSource includes the requested fields of the GraphQL interface PackageOrSource.
//
// AllIsOccurrencesTreeSubjectPackageOrSource is implemented by the following types:
// AllIsOccurrencesTreeSubjectPackage
// AllIsOccurrencesTreeSubjectSource
// The GraphQL type's documentation follows.
//
// PackageOrSource is a union of Package and Source.
type AllIsOccurrencesTreeSubjectPackageOrSource interface {
	implementsGraphQLInterfaceAllIsOccurrencesTreeSubjectPackageOrSource()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *AllIsOccurrencesTreeSubjectPackage) implementsGraphQLInterfaceAllIsOccurrencesTreeSubjectPackageOrSource() {
}
func (v *AllIsOccurrencesTreeSubjectSource) implementsGraphQLInterfaceAllIsOccurrencesTreeSubjectPackageOrSource() {
}

func __unmarshalAllIsOccurrencesTreeSubjectPackageOrSource(b []byte, v *AllIsOccurrencesTreeSubjectPackageOrSource) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(AllIsOccurrencesTreeSubjectPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(AllIsOccurrencesTreeSubjectSource)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageOrSource.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for AllIsOccurrencesTreeSubjectPackageOrSource: "%v"`, tn.TypeName)
	}
}

func __marshalAllIsOccurrencesTreeSubjectPackageOrSource(v *AllIsOccurrencesTreeSubjectPackageOrSource) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *AllIsOccurrencesTreeSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllIsOccurrencesTreeSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *AllIsOccurrencesTreeSubjectSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllIsOccurrencesTreeSubjectSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for AllIsOccurrencesTreeSubjectPackageOrSource: "%T"`, v)
	}
}

// AllIsOccurrencesTreeSubjectSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type AllIsOccurrencesTreeSubjectSource struct {
	Typename      *string `json:"__typename"`
	AllSourceTree `json:"-"`
}

// GetTypename returns AllIsOccurrencesTreeSubjectSource.Typename, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTreeSubjectSource) GetTypename() *string { return v.Typename }

// GetId returns AllIsOccurrencesTreeSubjectSource.Id, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTreeSubjectSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns AllIsOccurrencesTreeSubjectSource.Type, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTreeSubjectSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns AllIsOccurrencesTreeSubjectSource.Namespaces, and is useful for accessing the field via an interface.
func (v *AllIsOccurrencesTreeSubjectSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *AllIsOccurrencesTreeSubjectSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllIsOccurrencesTreeSubjectSource
		graphql.NoUnmarshalJSON
	}
	firstPass.AllIsOccurrencesTreeSubjectSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllIsOccurrencesTreeSubjectSource struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *AllIsOccurrencesTreeSubjectSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllIsOccurrencesTreeSubjectSource) __premarshalJSON() (*__premarshalAllIsOccurrencesTreeSubjectSource, error) {
	var retval __premarshalAllIsOccurrencesTreeSubjectSource

	retval.Typename = v.Typename
	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// AllLicenseTree includes the GraphQL fields of License requested by the fragment AllLicenseTree.
// The GraphQL type's documentation follows.
//
// License represents a particular license. If the license is found on the SPDX
// license list (https://spdx.org/licenses/) then the fields should be:
//
// Name: SPDX license identifier
// Inline: empty
// ListVersion: SPDX license list version
//
// example:
//
// Name: AGPL-3.0-or-later
// Inline: ""
// ListVersion: 3.21 2023-06-18
//
// If the license is not on the SPDX license list, then a new guid should be
// created and the license text placed inline:
//
// Name: LicenseRef-<guid>
// Inline: Full license text
// ListVersion: empty
//
// example:
//
// Name: LicenseRef-1a2b3c
// Inline: Permission to use, copy, modify, and/or distribute ...
// ListVersion: ""
type AllLicenseTree struct {
	Id          string  `json:"id"`
	Name        string  `json:"name"`
	Inline      *string `json:"inline"`
	ListVersion *string `json:"listVersion"`
}

// GetId returns AllLicenseTree.Id, and is useful for accessing the field via an interface.
func (v *AllLicenseTree) GetId() string { return v.Id }

// GetName returns AllLicenseTree.Name, and is useful for accessing the field via an interface.
func (v *AllLicenseTree) GetName() string { return v.Name }

// GetInline returns AllLicenseTree.Inline, and is useful for accessing the field via an interface.
func (v *AllLicenseTree) GetInline() *string { return v.Inline }

// GetListVersion returns AllLicenseTree.ListVersion, and is useful for accessing the field via an interface.
func (v *AllLicenseTree) GetListVersion() *string { return v.ListVersion }

// AllPkgEqual includes the GraphQL fields of PkgEqual requested by the fragment AllPkgEqual.
// The GraphQL type's documentation follows.
//
// PkgEqual is an attestation that a set of packages are similar.
type AllPkgEqual struct {
	Id string `json:"id"`
	// Justification for the claim that the packages are similar
	Justification string `json:"justification"`
	// Collection of packages that are similar
	Packages []AllPkgEqualPackagesPackage `json:"packages"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetId returns AllPkgEqual.Id, and is useful for accessing the field via an interface.
func (v *AllPkgEqual) GetId() string { return v.Id }

// GetJustification returns AllPkgEqual.Justification, and is useful for accessing the field via an interface.
func (v *AllPkgEqual) GetJustification() string { return v.Justification }

// GetPackages returns AllPkgEqual.Packages, and is useful for accessing the field via an interface.
func (v *AllPkgEqual) GetPackages() []AllPkgEqualPackagesPackage { return v.Packages }

// GetOrigin returns AllPkgEqual.Origin, and is useful for accessing the field via an interface.
func (v *AllPkgEqual) GetOrigin() string { return v.Origin }

// GetCollector returns AllPkgEqual.Collector, and is useful for accessing the field via an interface.
func (v *AllPkgEqual) GetCollector() string { return v.Collector }

// AllPkgEqualPackagesPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllPkgEqualPackagesPackage struct {
	AllPkgTree `json:"-"`
}

// GetId returns AllPkgEqualPackagesPackage.Id, and is useful for accessing the field via an interface.
func (v *AllPkgEqualPackagesPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns AllPkgEqualPackagesPackage.Type, and is useful for accessing the field via an interface.
func (v *AllPkgEqualPackagesPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns AllPkgEqualPackagesPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *AllPkgEqualPackagesPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *AllPkgEqualPackagesPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllPkgEqualPackagesPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.AllPkgEqualPackagesPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllPkgEqualPackagesPackage struct {
	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *AllPkgEqualPackagesPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllPkgEqualPackagesPackage) __premarshalJSON() (*__premarshalAllPkgEqualPackagesPackage, error) {
	var retval __premarshalAllPkgEqualPackagesPackage

	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// AllPkgTree includes the GraphQL fields of Package requested by the fragment AllPkgTree.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllPkgTree struct {
	Id         string                                 `json:"id"`
	Type       string                                 `json:"type"`
	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

// GetId returns AllPkgTree.Id, and is useful for accessing the field via an interface.
func (v *AllPkgTree) GetId() string { return v.Id }

// GetType returns AllPkgTree.Type, and is useful for accessing the field via an interface.
func (v *AllPkgTree) GetType() string { return v.Type }

// GetNamespaces returns AllPkgTree.Namespaces, and is useful for accessing the field via an interface.
func (v *AllPkgTree) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace { return v.Namespaces }

// AllPkgTreeNamespacesPackageNamespace includes the requested fields of the GraphQL type PackageNamespace.
// The GraphQL type's documentation follows.
//
// PackageNamespace is a namespace for packages.
//
// In the pURL representation, each PackageNamespace matches the
// pkg:<type>/<namespace>/ partial pURL.
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type AllPkgTreeNamespacesPackageNamespace struct {
	Id        string                                                 `json:"id"`
	Namespace string                                                 `json:"namespace"`
	Names     []AllPkgTreeNamespacesPackageNamespaceNamesPackageName `json:"names"`
}

// GetId returns AllPkgTreeNamespacesPackageNamespace.Id, and is useful for accessing the field via an interface.
func (v *AllPkgTreeNamespacesPackageNamespace) GetId() string { return v.Id }

// GetNamespace returns AllPkgTreeNamespacesPackageNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *AllPkgTreeNamespacesPackageNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns AllPkgTreeNamespacesPackageNamespace.Names, and is useful for accessing the field via an interface.
func (v *AllPkgTreeNamespacesPackageNamespace) GetNames() []AllPkgTreeNamespacesPackageNamespaceNamesPackageName {
	return v.Names
}

// AllPkgTreeNamespacesPackageNamespaceNamesPackageName includes the requested fields of the GraphQL type PackageName.
// The GraphQL type's documentation follows.
//
// PackageName is a name for packages.
//
// In the pURL representation, each PackageName matches the
// pkg:<type>/<namespace>/<name> pURL.
//
// Names are always mandatory.
//
// This is the first node in the trie that can be referred to by other parts of
// GUAC.
type AllPkgTreeNamespacesPackageNamespaceNamesPackageName struct {
	Id       string                                                                       `json:"id"`
	Name     string                                                                       `json:"name"`
	Versions []AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion `json:"versions"`
}

// GetId returns AllPkgTreeNamespacesPackageNamespaceNamesPackageName.Id, and is useful for accessing the field via an interface.
func (v *AllPkgTreeNamespacesPackageNamespaceNamesPackageName) GetId() string { return v.Id }

// GetName returns AllPkgTreeNamespacesPackageNamespaceNamesPackageName.Name, and is useful for accessing the field via an interface.
func (v *AllPkgTreeNamespacesPackageNamespaceNamesPackageName) GetName() string { return v.Name }

// GetVersions returns AllPkgTreeNamespacesPackageNamespaceNamesPackageName.Versions, and is useful for accessing the field via an interface.
func (v *AllPkgTreeNamespacesPackageNamespaceNamesPackageName) GetVersions() []AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion {
	return v.Versions
}

// AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion includes the requested fields of the GraphQL type PackageVersion.
// The GraphQL type's documentation follows.
//
// PackageVersion is a package version.
//
// In the pURL representation, each PackageName matches the
// pkg:<type>/<namespace>/<name>@<version> pURL.
//
// Versions are optional and each Package type defines own rules for handling
// them. For this level of GUAC, these are just opaque strings.
//
// NOTE: The handling of versions might change before this schema becomes stable.
//
// This node can be referred to by other parts of GUAC.
//
// Subpath and qualifiers are optional. Lack of qualifiers is represented by an
// empty list and lack of subpath by empty string (to be consistent with
// optionality of namespace and version). Two nodes that have different qualifiers
// and/or subpath but the same version mean two different packages in the trie
// (they are different). Two nodes that have same version but qualifiers of one
// are a subset of the qualifier of the other also mean two different packages in
// the trie.
type AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion struct {
	Id         string                                                                                                 `json:"id"`
	Version    string                                                                                                 `json:"version"`
	Qualifiers []AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier `json:"qualifiers"`
	Subpath    string                                                                                                 `json:"subpath"`
}

// GetId returns AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Id, and is useful for accessing the field via an interface.
func (v *AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetId() string {
	return v.Id
}

// GetVersion returns AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Version, and is useful for accessing the field via an interface.
func (v *AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetVersion() string {
	return v.Version
}

// GetQualifiers returns AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Qualifiers, and is useful for accessing the field via an interface.
func (v *AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetQualifiers() []AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier {
	return v.Qualifiers
}

// GetSubpath returns AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Subpath, and is useful for accessing the field via an interface.
func (v *AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetSubpath() string {
	return v.Subpath
}

// AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier includes the requested fields of the GraphQL type PackageQualifier.
// The GraphQL type's documentation follows.
//
// PackageQualifier is a qualifier for a package, a key-value pair.
//
// In the pURL representation, it is a part of the <qualifiers> part of the
// pkg:<type>/<namespace>/<name>@<version>?<qualifiers> pURL.
//
// Qualifiers are optional, each Package type defines own rules for handling them,
// and multiple qualifiers could be attached to the same package.
//
// This node cannot be directly referred by other parts of GUAC.
type AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Key, and is useful for accessing the field via an interface.
func (v *AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetKey() string {
	return v.Key
}

// GetValue returns AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Value, and is useful for accessing the field via an interface.
func (v *AllPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetValue() string {
	return v.Value
}

// AllPointOfContact includes the GraphQL fields of PointOfContact requested by the fragment AllPointOfContact.
// The GraphQL type's documentation follows.
//
// PointOfContact is an attestation of how to get in touch with the person(s) responsible
// for a package, source, or artifact.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The attestation applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
//
// email is the email address (singular) of the point of contact.
//
// info is additional contact information other than email address. This is free
// form.
//
// NOTE: the identifiers for point of contact should be part of software trees.
// This will benefit from identifier look up and traversal as well as organization
// hierarchy. However, until the use case arises, PointOfContact will be a flat
// reference to the contact details.
type AllPointOfContact struct {
	Id            string                                          `json:"id"`
	Subject       AllPointOfContactSubjectPackageSourceOrArtifact `json:"-"`
	Email         string                                          `json:"email"`
	Info          string                                          `json:"info"`
	Since         time.Time                                       `json:"since"`
	Justification string                                          `json:"justification"`
	Origin        string                                          `json:"origin"`
	Collector     string                                          `json:"collector"`
}

// GetId returns AllPointOfContact.Id, and is useful for accessing the field via an interface.
func (v *AllPointOfContact) GetId() string { return v.Id }

// GetSubject returns AllPointOfContact.Subject, and is useful for accessing the field via an interface.
func (v *AllPointOfContact) GetSubject() AllPointOfContactSubjectPackageSourceOrArtifact {
	return v.Subject
}

// GetEmail returns AllPointOfContact.Email, and is useful for accessing the field via an interface.
func (v *AllPointOfContact) GetEmail() string { return v.Email }

// GetInfo returns AllPointOfContact.Info, and is useful for accessing the field via an interface.
func (v *AllPointOfContact) GetInfo() string { return v.Info }

// GetSince returns AllPointOfContact.Since, and is useful for accessing the field via an interface.
func (v *AllPointOfContact) GetSince() time.Time { return v.Since }

// GetJustification returns AllPointOfContact.Justification, and is useful for accessing the field via an interface.
func (v *AllPointOfContact) GetJustification() string { return v.Justification }

// GetOrigin returns AllPointOfContact.Origin, and is useful for accessing the field via an interface.
func (v *AllPointOfContact) GetOrigin() string { return v.Origin }

// GetCollector returns AllPointOfContact.Collector, and is useful for accessing the field via an interface.
func (v *AllPointOfContact) GetCollector() string { return v.Collector }

func (v *AllPointOfContact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllPointOfContact
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.AllPointOfContact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalAllPointOfContactSubjectPackageSourceOrArtifact(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal AllPointOfContact.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalAllPointOfContact struct {
	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Email string `json:"email"`

	Info string `json:"info"`

	Since time.Time `json:"since"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *AllPointOfContact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllPointOfContact) __premarshalJSON() (*__premarshalAllPointOfContact, error) {
	var retval __premarshalAllPointOfContact

	retval.Id = v.Id
	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalAllPointOfContactSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal AllPointOfContact.Subject: %w", err)
		}
	}
	retval.Email = v.Email
	retval.Info = v.Info
	retval.Since = v.Since
	retval.Justification = v.Justification
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// AllPointOfContactSubjectArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type AllPointOfContactSubjectArtifact struct {
	Typename        *string `json:"__typename"`
	AllArtifactTree `json:"-"`
}

// GetTypename returns AllPointOfContactSubjectArtifact.Typename, and is useful for accessing the field via an interface.
func (v *AllPointOfContactSubjectArtifact) GetTypename() *string { return v.Typename }

// GetId returns AllPointOfContactSubjectArtifact.Id, and is useful for accessing the field via an interface.
func (v *AllPointOfContactSubjectArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns AllPointOfContactSubjectArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *AllPointOfContactSubjectArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns AllPointOfContactSubjectArtifact.Digest, and is useful for accessing the field via an interface.
func (v *AllPointOfContactSubjectArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *AllPointOfContactSubjectArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllPointOfContactSubjectArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.AllPointOfContactSubjectArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllPointOfContactSubjectArtifact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *AllPointOfContactSubjectArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllPointOfContactSubjectArtifact) __premarshalJSON() (*__premarshalAllPointOfContactSubjectArtifact, error) {
	var retval __premarshalAllPointOfContactSubjectArtifact

	retval.Typename = v.Typename
	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// AllPointOfContactSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type AllPointOfContactSubjectPackage struct {
	Typename   *string `json:"__typename"`
	AllPkgTree `json:"-"`
}

// GetTypename returns AllPointOfContactSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *AllPointOfContactSubjectPackage) GetTypename() *string { return v.Typename }

// GetId returns AllPointOfContactSubjectPackage.Id, and is useful for accessing the field via an interface.
func (v *AllPointOfContactSubjectPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns AllPointOfContactSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *AllPointOfContactSubjectPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns AllPointOfContactSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *AllPointOfContactSubjectPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *AllPointOfContactSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllPointOfContactSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.AllPointOfContactSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllPointOfContactSubjectPackage struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *AllPointOfContactSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllPointOfContactSubjectPackage) __premarshalJSON() (*__premarshalAllPointOfContactSubjectPackage, error) {
	var retval __premarshalAllPointOfContactSubjectPackage

	retval.Typename = v.Typename
	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// AllPointOfContactSubjectPackageSourceOrArtifact includes the requested fields of the GraphQL interface PackageSourceOrArtifact.
//
// AllPointOfContactSubjectPackageSourceOrArtifact is implemented by the following types:
// AllPointOfContactSubjectArtifact
// AllPointOfContactSubjectPackage
// AllPointOfContactSubjectSource
// The GraphQL type's documentation follows.
//
// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type AllPointOfContactSubjectPackageSourceOrArtifact interface {
	implementsGraphQLInterfaceAllPointOfContactSubjectPackageSourceOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *AllPointOfContactSubjectArtifact) implementsGraphQLInterfaceAllPointOfContactSubjectPackageSourceOrArtifact() {
}
func (v *AllPointOfContactSubjectPackage) implementsGraphQLInterfaceAllPointOfContactSubjectPackageSourceOrArtifact() {
}
func (v *AllPointOfContactSubjectSource) implementsGraphQLInterfaceAllPointOfContactSubjectPackageSourceOrArtifact() {
}

func __unmarshalAllPointOfContactSubjectPackageSourceOrArtifact(b []byte, v *AllPointOfContactSubjectPackageSourceOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Artifact":
		*v = new(AllPointOfContactSubjectArtifact)
		return json.Unmarshal(b, *v)
	case "Package":
		*v = new(AllPointOfContactSubjectPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(AllPointOfContactSubjectSource)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageSourceOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for AllPointOfContactSubjectPackageSourceOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalAllPointOfContactSubjectPackageSourceOrArtifact(v *AllPointOfContactSubjectPackageSourceOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *AllPointOfContactSubjectArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllPointOfContactSubjectArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *AllPointOfContactSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllPointOfContactSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *AllPointOfContactSubjectSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalAllPointOfContactSubjectSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for AllPointOfContactSubjectPackageSourceOrArtifact: "%T"`, v)
	}
}

// AllPointOfContactSubjectSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type AllPointOfContactSubjectSource struct {
	Typename      *string `json:"__typename"`
	AllSourceTree `json:"-"`
}

// GetTypename returns AllPointOfContactSubjectSource.Typename, and is useful for accessing the field via an interface.
func (v *AllPointOfContactSubjectSource) GetTypename() *string { return v.Typename }

// GetId returns AllPointOfContactSubjectSource.Id, and is useful for accessing the field via an interface.
func (v *AllPointOfContactSubjectSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns AllPointOfContactSubjectSource.Type, and is useful for accessing the field via an interface.
func (v *AllPointOfContactSubjectSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns AllPointOfContactSubjectSource.Namespaces, and is useful for accessing the field via an interface.
func (v *AllPointOfContactSubjectSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *AllPointOfContactSubjectSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllPointOfContactSubjectSource
		graphql.NoUnmarshalJSON
	}
	firstPass.AllPointOfContactSubjectSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllPointOfContactSubjectSource struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *AllPointOfContactSubjectSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllPointOfContactSubjectSource) __premarshalJSON() (*__premarshalAllPointOfContactSubjectSource, error) {
	var retval __premarshalAllPointOfContactSubjectSource

	retval.Typename = v.Typename
	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// AllSLSATree includes the GraphQL fields of HasSLSA requested by the fragment AllSLSATree.
// The GraphQL type's documentation follows.
//
// HasSLSA records that a subject node has a SLSA attestation.
type AllSLSATree struct {
	Id string `json:"id"`
	// The subject of SLSA attestation
	Subject AllSLSATreeSubjectArtifact `json:"subject"`
	// The SLSA attestation
	Slsa AllSLSATreeSlsaSLSA `json:"slsa"`
}

// GetId returns AllSLSATree.Id, and is useful for accessing the field via an interface.
func (v *AllSLSATree) GetId() string { return v.Id }

// GetSubject returns AllSLSATree.Subject, and is useful for accessing the field via an interface.
func (v *AllSLSATree) GetSubject() AllSLSATreeSubjectArtifact { return v.Subject }

// GetSlsa returns AllSLSATree.Slsa, and is useful for accessing the field via an interface.
func (v *AllSLSATree) GetSlsa() AllSLSATreeSlsaSLSA { return v.Slsa }

// AllSLSATreeSlsaSLSA includes the requested fields of the GraphQL type SLSA.
// The GraphQL type's documentation follows.
//
// SLSA contains all of the fields present in a SLSA attestation.
//
// The materials and builders are objects of the HasSLSA predicate, everything
// else are properties extracted from the attestation.
//
// We also include fields to specify under what conditions the check was performed
// (time of scan, version of scanners, etc.) as well as how this information got
// included into GUAC (origin document and the collector for that document).
type AllSLSATreeSlsaSLSA struct {
	// Materials of the build resulting in subject
	BuiltFrom []AllSLSATreeSlsaSLSABuiltFromArtifact `json:"builtFrom"`
	// Builder performing the build
	BuiltBy AllSLSATreeSlsaSLSABuiltByBuilder `json:"builtBy"`
	// Type of the builder
	BuildType string `json:"buildType"`
	// Individual predicates found in the attestation
	SlsaPredicate []AllSLSATreeSlsaSLSASlsaPredicateSLSAPredicate `json:"slsaPredicate"`
	// Version of the SLSA predicate
	SlsaVersion string `json:"slsaVersion"`
	// Timestamp (RFC3339Nano format) of build start time
	StartedOn *time.Time `json:"startedOn"`
	// Timestamp (RFC3339Nano format) of build end time
	FinishedOn *time.Time `json:"finishedOn"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetBuiltFrom returns AllSLSATreeSlsaSLSA.BuiltFrom, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSA) GetBuiltFrom() []AllSLSATreeSlsaSLSABuiltFromArtifact {
	return v.BuiltFrom
}

// GetBuiltBy returns AllSLSATreeSlsaSLSA.BuiltBy, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSA) GetBuiltBy() AllSLSATreeSlsaSLSABuiltByBuilder { return v.BuiltBy }

// GetBuildType returns AllSLSATreeSlsaSLSA.BuildType, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSA) GetBuildType() string { return v.BuildType }

// GetSlsaPredicate returns AllSLSATreeSlsaSLSA.SlsaPredicate, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSA) GetSlsaPredicate() []AllSLSATreeSlsaSLSASlsaPredicateSLSAPredicate {
	return v.SlsaPredicate
}

// GetSlsaVersion returns AllSLSATreeSlsaSLSA.SlsaVersion, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSA) GetSlsaVersion() string { return v.SlsaVersion }

// GetStartedOn returns AllSLSATreeSlsaSLSA.StartedOn, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSA) GetStartedOn() *time.Time { return v.StartedOn }

// GetFinishedOn returns AllSLSATreeSlsaSLSA.FinishedOn, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSA) GetFinishedOn() *time.Time { return v.FinishedOn }

// GetOrigin returns AllSLSATreeSlsaSLSA.Origin, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSA) GetOrigin() string { return v.Origin }

// GetCollector returns AllSLSATreeSlsaSLSA.Collector, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSA) GetCollector() string { return v.Collector }

// AllSLSATreeSlsaSLSABuiltByBuilder includes the requested fields of the GraphQL type Builder.
// The GraphQL type's documentation follows.
//
// Builder represents the builder (e.g., FRSCA or GitHub Actions).
//
// Currently builders are identified by the uri field.
type AllSLSATreeSlsaSLSABuiltByBuilder struct {
	Id  string `json:"id"`
	Uri string `json:"uri"`
}

// GetId returns AllSLSATreeSlsaSLSABuiltByBuilder.Id, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSABuiltByBuilder) GetId() string { return v.Id }

// GetUri returns AllSLSATreeSlsaSLSABuiltByBuilder.Uri, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSABuiltByBuilder) GetUri() string { return v.Uri }

// AllSLSATreeSlsaSLSABuiltFromArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type AllSLSATreeSlsaSLSABuiltFromArtifact struct {
	AllArtifactTree `json:"-"`
}

// GetId returns AllSLSATreeSlsaSLSABuiltFromArtifact.Id, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSABuiltFromArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns AllSLSATreeSlsaSLSABuiltFromArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSABuiltFromArtifact) GetAlgorithm() string {
	return v.AllArtifactTree.Algorithm
}

// GetDigest returns AllSLSATreeSlsaSLSABuiltFromArtifact.Digest, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSABuiltFromArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *AllSLSATreeSlsaSLSABuiltFromArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllSLSATreeSlsaSLSABuiltFromArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.AllSLSATreeSlsaSLSABuiltFromArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllSLSATreeSlsaSLSABuiltFromArtifact struct {
	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *AllSLSATreeSlsaSLSABuiltFromArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllSLSATreeSlsaSLSABuiltFromArtifact) __premarshalJSON() (*__premarshalAllSLSATreeSlsaSLSABuiltFromArtifact, error) {
	var retval __premarshalAllSLSATreeSlsaSLSABuiltFromArtifact

	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// AllSLSATreeSlsaSLSASlsaPredicateSLSAPredicate includes the requested fields of the GraphQL type SLSAPredicate.
// The GraphQL type's documentation follows.
//
// SLSAPredicate are the values from the SLSA predicate in key-value pair form.
//
// # For example, given the following predicate
//
// ```
// "predicate": {
// "buildDefinition": {
// "externalParameters": {
// "repository": "https://github.com/octocat/hello-world",
// ...
// },
// ...
// },
// ...
// }
// ```
//
// we have
//
// ```
// key   = "buildDefinition.externalParameters.repository"
// value = "https://github.com/octocat/hello-world"
// ```
//
// This node cannot be directly referred by other parts of GUAC.
type AllSLSATreeSlsaSLSASlsaPredicateSLSAPredicate struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns AllSLSATreeSlsaSLSASlsaPredicateSLSAPredicate.Key, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSASlsaPredicateSLSAPredicate) GetKey() string { return v.Key }

// GetValue returns AllSLSATreeSlsaSLSASlsaPredicateSLSAPredicate.Value, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSlsaSLSASlsaPredicateSLSAPredicate) GetValue() string { return v.Value }

// AllSLSATreeSubjectArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type AllSLSATreeSubjectArtifact struct {
	AllArtifactTree `json:"-"`
}

// GetId returns AllSLSATreeSubjectArtifact.Id, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSubjectArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns AllSLSATreeSubjectArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSubjectArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns AllSLSATreeSubjectArtifact.Digest, and is useful for accessing the field via an interface.
func (v *AllSLSATreeSubjectArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *AllSLSATreeSubjectArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllSLSATreeSubjectArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.AllSLSATreeSubjectArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllSLSATreeSubjectArtifact struct {
	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *AllSLSATreeSubjectArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllSLSATreeSubjectArtifact) __premarshalJSON() (*__premarshalAllSLSATreeSubjectArtifact, error) {
	var retval __premarshalAllSLSATreeSubjectArtifact

	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// AllSourceTree includes the GraphQL fields of Source requested by the fragment AllSourceTree.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type AllSourceTree struct {
	Id         string                                   `json:"id"`
	Type       string                                   `json:"type"`
	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

// GetId returns AllSourceTree.Id, and is useful for accessing the field via an interface.
func (v *AllSourceTree) GetId() string { return v.Id }

// GetType returns AllSourceTree.Type, and is useful for accessing the field via an interface.
func (v *AllSourceTree) GetType() string { return v.Type }

// GetNamespaces returns AllSourceTree.Namespaces, and is useful for accessing the field via an interface.
func (v *AllSourceTree) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace { return v.Namespaces }

// AllSourceTreeNamespacesSourceNamespace includes the requested fields of the GraphQL type SourceNamespace.
// The GraphQL type's documentation follows.
//
// SourceNamespace is a namespace for sources.
//
// This is the location of the repository (such as github/gitlab/bitbucket).
//
// The namespace field is mandatory.
type AllSourceTreeNamespacesSourceNamespace struct {
	Id        string                                                  `json:"id"`
	Namespace string                                                  `json:"namespace"`
	Names     []AllSourceTreeNamespacesSourceNamespaceNamesSourceName `json:"names"`
}

// GetId returns AllSourceTreeNamespacesSourceNamespace.Id, and is useful for accessing the field via an interface.
func (v *AllSourceTreeNamespacesSourceNamespace) GetId() string { return v.Id }

// GetNamespace returns AllSourceTreeNamespacesSourceNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *AllSourceTreeNamespacesSourceNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns AllSourceTreeNamespacesSourceNamespace.Names, and is useful for accessing the field via an interface.
func (v *AllSourceTreeNamespacesSourceNamespace) GetNames() []AllSourceTreeNamespacesSourceNamespaceNamesSourceName {
	return v.Names
}

// AllSourceTreeNamespacesSourceNamespaceNamesSourceName includes the requested fields of the GraphQL type SourceName.
// The GraphQL type's documentation follows.
//
// SourceName represents the url of the repository.
//
// The name field is mandatory. The tag and commit fields are optional, but it is
// an error to specify both.
//
// This is the only source trie node that can be referenced by other parts of GUAC.
type AllSourceTreeNamespacesSourceNamespaceNamesSourceName struct {
	Id     string  `json:"id"`
	Name   string  `json:"name"`
	Tag    *string `json:"tag"`
	Commit *string `json:"commit"`
}

// GetId returns AllSourceTreeNamespacesSourceNamespaceNamesSourceName.Id, and is useful for accessing the field via an interface.
func (v *AllSourceTreeNamespacesSourceNamespaceNamesSourceName) GetId() string { return v.Id }

// GetName returns AllSourceTreeNamespacesSourceNamespaceNamesSourceName.Name, and is useful for accessing the field via an interface.
func (v *AllSourceTreeNamespacesSourceNamespaceNamesSourceName) GetName() string { return v.Name }

// GetTag returns AllSourceTreeNamespacesSourceNamespaceNamesSourceName.Tag, and is useful for accessing the field via an interface.
func (v *AllSourceTreeNamespacesSourceNamespaceNamesSourceName) GetTag() *string { return v.Tag }

// GetCommit returns AllSourceTreeNamespacesSourceNamespaceNamesSourceName.Commit, and is useful for accessing the field via an interface.
func (v *AllSourceTreeNamespacesSourceNamespaceNamesSourceName) GetCommit() *string { return v.Commit }

// AllVulnEqual includes the GraphQL fields of VulnEqual requested by the fragment AllVulnEqual.
// The GraphQL type's documentation follows.
//
// VulnEqual is an attestation to link two vulnerabilities together as being equal"
//
// Note that setting noVuln vulnerability type is invalid for VulnEqual!
type AllVulnEqual struct {
	Id string `json:"id"`
	// Collection of vulnerabilities that are similar
	Vulnerabilities []AllVulnEqualVulnerabilitiesVulnerability `json:"vulnerabilities"`
	// Justification for the attested relationship
	Justification string `json:"justification"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetId returns AllVulnEqual.Id, and is useful for accessing the field via an interface.
func (v *AllVulnEqual) GetId() string { return v.Id }

// GetVulnerabilities returns AllVulnEqual.Vulnerabilities, and is useful for accessing the field via an interface.
func (v *AllVulnEqual) GetVulnerabilities() []AllVulnEqualVulnerabilitiesVulnerability {
	return v.Vulnerabilities
}

// GetJustification returns AllVulnEqual.Justification, and is useful for accessing the field via an interface.
func (v *AllVulnEqual) GetJustification() string { return v.Justification }

// GetOrigin returns AllVulnEqual.Origin, and is useful for accessing the field via an interface.
func (v *AllVulnEqual) GetOrigin() string { return v.Origin }

// GetCollector returns AllVulnEqual.Collector, and is useful for accessing the field via an interface.
func (v *AllVulnEqual) GetCollector() string { return v.Collector }

// AllVulnEqualVulnerabilitiesVulnerability includes the requested fields of the GraphQL type Vulnerability.
// The GraphQL type's documentation follows.
//
// Vulnerability represents the root of the vulnerability trie/tree.
//
// We map vulnerability information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type and a vulnerability ID. This allows for generic
// representation of the various vulnerabilities and does not limit to just cve, ghsa or osv.
// This would be in the general format: vuln://<general-type>/<vuln-id>
//
// Examples:
//
// CVE, using path separator: vuln://cve/cve-2023-20753
// OSV, representing its knowledge of a GHSA: vuln://osv/ghsa-205hk
// Random vendor: vuln://snyk/sn-whatever
// NoVuln: vuln://novuln/
//
// This node represents the type part of the trie path. It is used to represent
// the specific type of the vulnerability: cve, ghsa, osv or some other vendor specific
//
// Since this node is at the root of the vulnerability trie, it is named Vulnerability, not
// VulnerabilityType.
//
// NoVuln is a special vulnerability node to attest that no vulnerability has been
// found during a vulnerability scan. It will have the type "novuln" and contain an empty string
// for vulnerabilityID
//
// The resolvers will enforce that both the type and vulnerability IDs are lower case.
type AllVulnEqualVulnerabilitiesVulnerability struct {
	AllVulnerabilityTree `json:"-"`
}

// GetId returns AllVulnEqualVulnerabilitiesVulnerability.Id, and is useful for accessing the field via an interface.
func (v *AllVulnEqualVulnerabilitiesVulnerability) GetId() string { return v.AllVulnerabilityTree.Id }

// GetType returns AllVulnEqualVulnerabilitiesVulnerability.Type, and is useful for accessing the field via an interface.
func (v *AllVulnEqualVulnerabilitiesVulnerability) GetType() string {
	return v.AllVulnerabilityTree.Type
}

// GetVulnerabilityIDs returns AllVulnEqualVulnerabilitiesVulnerability.VulnerabilityIDs, and is useful for accessing the field via an interface.
func (v *AllVulnEqualVulnerabilitiesVulnerability) GetVulnerabilityIDs() []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID {
	return v.AllVulnerabilityTree.VulnerabilityIDs
}

func (v *AllVulnEqualVulnerabilitiesVulnerability) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*AllVulnEqualVulnerabilitiesVulnerability
		graphql.NoUnmarshalJSON
	}
	firstPass.AllVulnEqualVulnerabilitiesVulnerability = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnerabilityTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalAllVulnEqualVulnerabilitiesVulnerability struct {
	Id string `json:"id"`

	Type string `json:"type"`

	VulnerabilityIDs []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID `json:"vulnerabilityIDs"`
}

func (v *AllVulnEqualVulnerabilitiesVulnerability) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *AllVulnEqualVulnerabilitiesVulnerability) __premarshalJSON() (*__premarshalAllVulnEqualVulnerabilitiesVulnerability, error) {
	var retval __premarshalAllVulnEqualVulnerabilitiesVulnerability

	retval.Id = v.AllVulnerabilityTree.Id
	retval.Type = v.AllVulnerabilityTree.Type
	retval.VulnerabilityIDs = v.AllVulnerabilityTree.VulnerabilityIDs
	return &retval, nil
}

// AllVulnMetadataTree includes the GraphQL fields of VulnerabilityMetadata requested by the fragment AllVulnMetadataTree.
// The GraphQL type's documentation follows.
//
// VulnerabilityMetadata is an attestation that a vulnerability has a related score
// associated with it.
//
// The intent of this evidence tree predicate is to allow extensibility of vulnerability
// score (one-to-one mapping) with a specific vulnerability ID.
//
// A vulnerability ID can have a one-to-many relationship with the VulnerabilityMetadata
// node as a vulnerability ID can have multiple scores (in various frameworks).
//
// Examples:
//
// scoreType: EPSSv1
// scoreValue: 0.960760000
//
// scoreType: CVSSv2
// scoreValue: 5.0
//
// scoreType: CVSSv3
// scoreValue: 7.5
//
// The timestamp is used to determine when the score was evaluated for the specific vulnerability.
type AllVulnMetadataTree struct {
	Id            string                           `json:"id"`
	Vulnerability AllVulnMetadataTreeVulnerability `json:"vulnerability"`
	ScoreType     VulnerabilityScoreType           `json:"scoreType"`
	ScoreValue    float64                          `json:"scoreValue"`
	Timestamp     time.Time                        `json:"timestamp"`
	Origin        string                           `json:"origin"`
	Collector     string                           `json:"collector"`
}

// GetId returns AllVulnMetadataTree.Id, and is useful for accessing the field via an interface.
func (v *AllVulnMetadataTree) GetId() string { return v.Id }

// GetVulnerability returns AllVulnMetadataTree.Vulnerability, and is useful for accessing the field via an interface.
func (v *AllVulnMetadataTree) GetVulnerability() AllVulnMetadataTreeVulnerability {
	return v.Vulnerability
}

// GetScoreType returns AllVulnMetadataTree.ScoreType, and is useful for accessing the field via an interface.
func (v *AllVulnMetadataTree) GetScoreType() VulnerabilityScoreType { return v.ScoreType }

// GetScoreValue returns AllVulnMetadataTree.ScoreValue, and is useful for accessing the field via an interface.
func (v *AllVulnMetadataTree) GetScoreValue() float64 { return v.ScoreValue }

// GetTimestamp returns AllVulnMetadataTree.Timestamp, and is useful for accessing the field via an interface.
func (v *AllVulnMetadataTree) GetTimestamp() time.Time { return v.Timestamp }

// GetOrigin returns AllVulnMetadataTree.Origin, and is useful for accessing the field via an interface.
func (v *AllVulnMetadataTree) GetOrigin() string { return v.Origin }

// GetCollector returns AllVulnMetadataTree.Collector, and is useful for accessing the field via an interface.
func (v *AllVulnMetadataTree) GetCollector() string { return v.Collector }

// AllVulnMetadataTreeVulnerability includes the requested fields of the GraphQL type Vulnerability.
// The GraphQL type's documentation follows.
//
// Vulnerability represents the root of the vulnerability trie/tree.
//
// We map vulnerability information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type and a vulnerability ID. This allows for generic
// representation of the various vulnerabilities and does not limit to just cve, ghsa or osv.
// This would be in the general format: vuln://<general-type>/<vuln-id>
//
// Examples:
//
// CVE, using path separator: vuln://cve/cve-2023-20753
// OSV, representing its knowledge of a GHSA: vuln://osv/ghsa-205hk
// Random vendor: vuln://snyk/sn-whatever
// NoVuln: vuln://novuln/
//
// This node represents the type part of the trie path. It is used to represent
// the specific type of the vulnerability: cve, ghsa, osv or some other vendor specific
//
// Since this node is at the root of the vulnerability trie, it is named Vulnerability, not
// VulnerabilityType.
//
// NoVuln is a special vulnerability node to attest that no vulnerability has been
// found during a vulnerability scan. It will have the type "novuln" and contain an empty string
// for vulnerabilityID
//
// The resolvers will enforce that both the type and vulnerability IDs are lower case.
type AllVulnMetadataTreeVulnerability struct {
	Id               string                                                            `json:"id"`
	Type             string                                                            `json:"type"`
	VulnerabilityIDs []AllVulnMetadataTreeVulnerabilityVulnerabilityIDsVulnerabilityID `json:"vulnerabilityIDs"`
}

// GetId returns AllVulnMetadataTreeVulnerability.Id, and is useful for accessing the field via an interface.
func (v *AllVulnMetadataTreeVulnerability) GetId() string { return v.Id }

// GetType returns AllVulnMetadataTreeVulnerability.Type, and is useful for accessing the field via an interface.
func (v *AllVulnMetadataTreeVulnerability) GetType() string { return v.Type }

// GetVulnerabilityIDs returns AllVulnMetadataTreeVulnerability.VulnerabilityIDs, and is useful for accessing the field via an interface.
func (v *AllVulnMetadataTreeVulnerability) GetVulnerabilityIDs() []AllVulnMetadataTreeVulnerabilityVulnerabilityIDsVulnerabilityID {
	return v.VulnerabilityIDs
}

// AllVulnMetadataTreeVulnerabilityVulnerabilityIDsVulnerabilityID includes the requested fields of the GraphQL type VulnerabilityID.
// The GraphQL type's documentation follows.
//
// VulnerabilityID is a specific vulnerability ID associated with the type of the vulnerability.
//
// This will be enforced to be all lowercase.
//
// The namespace field is mandatory.
type AllVulnMetadataTreeVulnerabilityVulnerabilityIDsVulnerabilityID struct {
	Id              string `json:"id"`
	VulnerabilityID string `json:"vulnerabilityID"`
}

// GetId returns AllVulnMetadataTreeVulnerabilityVulnerabilityIDsVulnerabilityID.Id, and is useful for accessing the field via an interface.
func (v *AllVulnMetadataTreeVulnerabilityVulnerabilityIDsVulnerabilityID) GetId() string { return v.Id }

// GetVulnerabilityID returns AllVulnMetadataTreeVulnerabilityVulnerabilityIDsVulnerabilityID.VulnerabilityID, and is useful for accessing the field via an interface.
func (v *AllVulnMetadataTreeVulnerabilityVulnerabilityIDsVulnerabilityID) GetVulnerabilityID() string {
	return v.VulnerabilityID
}

// AllVulnerabilityTree includes the GraphQL fields of Vulnerability requested by the fragment AllVulnerabilityTree.
// The GraphQL type's documentation follows.
//
// Vulnerability represents the root of the vulnerability trie/tree.
//
// We map vulnerability information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type and a vulnerability ID. This allows for generic
// representation of the various vulnerabilities and does not limit to just cve, ghsa or osv.
// This would be in the general format: vuln://<general-type>/<vuln-id>
//
// Examples:
//
// CVE, using path separator: vuln://cve/cve-2023-20753
// OSV, representing its knowledge of a GHSA: vuln://osv/ghsa-205hk
// Random vendor: vuln://snyk/sn-whatever
// NoVuln: vuln://novuln/
//
// This node represents the type part of the trie path. It is used to represent
// the specific type of the vulnerability: cve, ghsa, osv or some other vendor specific
//
// Since this node is at the root of the vulnerability trie, it is named Vulnerability, not
// VulnerabilityType.
//
// NoVuln is a special vulnerability node to attest that no vulnerability has been
// found during a vulnerability scan. It will have the type "novuln" and contain an empty string
// for vulnerabilityID
//
// The resolvers will enforce that both the type and vulnerability IDs are lower case.
type AllVulnerabilityTree struct {
	Id               string                                                `json:"id"`
	Type             string                                                `json:"type"`
	VulnerabilityIDs []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID `json:"vulnerabilityIDs"`
}

// GetId returns AllVulnerabilityTree.Id, and is useful for accessing the field via an interface.
func (v *AllVulnerabilityTree) GetId() string { return v.Id }

// GetType returns AllVulnerabilityTree.Type, and is useful for accessing the field via an interface.
func (v *AllVulnerabilityTree) GetType() string { return v.Type }

// GetVulnerabilityIDs returns AllVulnerabilityTree.VulnerabilityIDs, and is useful for accessing the field via an interface.
func (v *AllVulnerabilityTree) GetVulnerabilityIDs() []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID {
	return v.VulnerabilityIDs
}

// AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID includes the requested fields of the GraphQL type VulnerabilityID.
// The GraphQL type's documentation follows.
//
// VulnerabilityID is a specific vulnerability ID associated with the type of the vulnerability.
//
// This will be enforced to be all lowercase.
//
// The namespace field is mandatory.
type AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID struct {
	Id              string `json:"id"`
	VulnerabilityID string `json:"vulnerabilityID"`
}

// GetId returns AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID.Id, and is useful for accessing the field via an interface.
func (v *AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID) GetId() string { return v.Id }

// GetVulnerabilityID returns AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID.VulnerabilityID, and is useful for accessing the field via an interface.
func (v *AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID) GetVulnerabilityID() string {
	return v.VulnerabilityID
}

// ArtifactInputSpec specifies an artifact for mutations.
//
// The checksum fields are canonicalized to be lowercase.
type ArtifactInputSpec struct {
	Algorithm string `json:"algorithm"`
	Digest    string `json:"digest"`
}

// GetAlgorithm returns ArtifactInputSpec.Algorithm, and is useful for accessing the field via an interface.
func (v *ArtifactInputSpec) GetAlgorithm() string { return v.Algorithm }

// GetDigest returns ArtifactInputSpec.Digest, and is useful for accessing the field via an interface.
func (v *ArtifactInputSpec) GetDigest() string { return v.Digest }

// ArtifactSpec allows filtering the list of artifacts to return in a query.
//
// The checksum fields are canonicalized to be lowercase.
type ArtifactSpec struct {
	Id        *string `json:"id"`
	Algorithm *string `json:"algorithm"`
	Digest    *string `json:"digest"`
}

// GetId returns ArtifactSpec.Id, and is useful for accessing the field via an interface.
func (v *ArtifactSpec) GetId() *string { return v.Id }

// GetAlgorithm returns ArtifactSpec.Algorithm, and is useful for accessing the field via an interface.
func (v *ArtifactSpec) GetAlgorithm() *string { return v.Algorithm }

// GetDigest returns ArtifactSpec.Digest, and is useful for accessing the field via an interface.
func (v *ArtifactSpec) GetDigest() *string { return v.Digest }

// ArtifactsArtifactsArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type ArtifactsArtifactsArtifact struct {
	AllArtifactTree `json:"-"`
}

// GetId returns ArtifactsArtifactsArtifact.Id, and is useful for accessing the field via an interface.
func (v *ArtifactsArtifactsArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns ArtifactsArtifactsArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *ArtifactsArtifactsArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns ArtifactsArtifactsArtifact.Digest, and is useful for accessing the field via an interface.
func (v *ArtifactsArtifactsArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *ArtifactsArtifactsArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*ArtifactsArtifactsArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.ArtifactsArtifactsArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalArtifactsArtifactsArtifact struct {
	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *ArtifactsArtifactsArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *ArtifactsArtifactsArtifact) __premarshalJSON() (*__premarshalArtifactsArtifactsArtifact, error) {
	var retval __premarshalArtifactsArtifactsArtifact

	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// ArtifactsResponse is returned by Artifacts on success.
type ArtifactsResponse struct {
	// Returns all artifacts matching a filter.
	Artifacts []ArtifactsArtifactsArtifact `json:"artifacts"`
}

// GetArtifacts returns ArtifactsResponse.Artifacts, and is useful for accessing the field via an interface.
func (v *ArtifactsResponse) GetArtifacts() []ArtifactsArtifactsArtifact { return v.Artifacts }

// BuilderInputSpec specifies a builder for mutations.
type BuilderInputSpec struct {
	Uri string `json:"uri"`
}

// GetUri returns BuilderInputSpec.Uri, and is useful for accessing the field via an interface.
func (v *BuilderInputSpec) GetUri() string { return v.Uri }

// BulkVulnHasMetadataResponse is returned by BulkVulnHasMetadata on success.
type BulkVulnHasMetadataResponse struct {
	// Bulk add certifications that vulnerability has a specific score. The returned array of IDs can be a an array of empty string.
	IngestBulkVulnerabilityMetadata []string `json:"ingestBulkVulnerabilityMetadata"`
}

// GetIngestBulkVulnerabilityMetadata returns BulkVulnHasMetadataResponse.IngestBulkVulnerabilityMetadata, and is useful for accessing the field via an interface.
func (v *BulkVulnHasMetadataResponse) GetIngestBulkVulnerabilityMetadata() []string {
	return v.IngestBulkVulnerabilityMetadata
}

// CertifyBadArtifactResponse is returned by CertifyBadArtifact on success.
type CertifyBadArtifactResponse struct {
	// Adds a certification that a package, source or artifact is considered bad. The returned ID can be empty string.
	IngestCertifyBad string `json:"ingestCertifyBad"`
}

// GetIngestCertifyBad returns CertifyBadArtifactResponse.IngestCertifyBad, and is useful for accessing the field via an interface.
func (v *CertifyBadArtifactResponse) GetIngestCertifyBad() string { return v.IngestCertifyBad }

// CertifyBadArtifactsResponse is returned by CertifyBadArtifacts on success.
type CertifyBadArtifactsResponse struct {
	// Adds bulk certifications that a package, source or artifact is considered bad. The returned array of IDs can be a an array of empty string.
	IngestCertifyBads []string `json:"ingestCertifyBads"`
}

// GetIngestCertifyBads returns CertifyBadArtifactsResponse.IngestCertifyBads, and is useful for accessing the field via an interface.
func (v *CertifyBadArtifactsResponse) GetIngestCertifyBads() []string { return v.IngestCertifyBads }

// CertifyBadInputSpec represents the mutation input to ingest a CertifyBad
// evidence.
type CertifyBadInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetJustification returns CertifyBadInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *CertifyBadInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns CertifyBadInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *CertifyBadInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns CertifyBadInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *CertifyBadInputSpec) GetCollector() string { return v.Collector }

// CertifyBadPkgResponse is returned by CertifyBadPkg on success.
type CertifyBadPkgResponse struct {
	// Adds a certification that a package, source or artifact is considered bad. The returned ID can be empty string.
	IngestCertifyBad string `json:"ingestCertifyBad"`
}

// GetIngestCertifyBad returns CertifyBadPkgResponse.IngestCertifyBad, and is useful for accessing the field via an interface.
func (v *CertifyBadPkgResponse) GetIngestCertifyBad() string { return v.IngestCertifyBad }

// CertifyBadPkgsResponse is returned by CertifyBadPkgs on success.
type CertifyBadPkgsResponse struct {
	// Adds bulk certifications that a package, source or artifact is considered bad. The returned array of IDs can be a an array of empty string.
	IngestCertifyBads []string `json:"ingestCertifyBads"`
}

// GetIngestCertifyBads returns CertifyBadPkgsResponse.IngestCertifyBads, and is useful for accessing the field via an interface.
func (v *CertifyBadPkgsResponse) GetIngestCertifyBads() []string { return v.IngestCertifyBads }

// CertifyBadSpec allows filtering the list of CertifyBad evidence to return in a
// query.
//
// If a package is specified in the subject filter, then it must be specified up
// to PackageName or PackageVersion. That is, user must specify package name, or
// name and one of version, qualifiers, or subpath.
//
// If a source is specified in the subject filter, then it must specify a name,
// and optionally a tag and a commit.
type CertifyBadSpec struct {
	Id            *string                      `json:"id"`
	Subject       *PackageSourceOrArtifactSpec `json:"subject"`
	Justification *string                      `json:"justification"`
	Origin        *string                      `json:"origin"`
	Collector     *string                      `json:"collector"`
}

// GetId returns CertifyBadSpec.Id, and is useful for accessing the field via an interface.
func (v *CertifyBadSpec) GetId() *string { return v.Id }

// GetSubject returns CertifyBadSpec.Subject, and is useful for accessing the field via an interface.
func (v *CertifyBadSpec) GetSubject() *PackageSourceOrArtifactSpec { return v.Subject }

// GetJustification returns CertifyBadSpec.Justification, and is useful for accessing the field via an interface.
func (v *CertifyBadSpec) GetJustification() *string { return v.Justification }

// GetOrigin returns CertifyBadSpec.Origin, and is useful for accessing the field via an interface.
func (v *CertifyBadSpec) GetOrigin() *string { return v.Origin }

// GetCollector returns CertifyBadSpec.Collector, and is useful for accessing the field via an interface.
func (v *CertifyBadSpec) GetCollector() *string { return v.Collector }

// CertifyBadSrcResponse is returned by CertifyBadSrc on success.
type CertifyBadSrcResponse struct {
	// Adds a certification that a package, source or artifact is considered bad. The returned ID can be empty string.
	IngestCertifyBad string `json:"ingestCertifyBad"`
}

// GetIngestCertifyBad returns CertifyBadSrcResponse.IngestCertifyBad, and is useful for accessing the field via an interface.
func (v *CertifyBadSrcResponse) GetIngestCertifyBad() string { return v.IngestCertifyBad }

// CertifyBadSrcsResponse is returned by CertifyBadSrcs on success.
type CertifyBadSrcsResponse struct {
	// Adds bulk certifications that a package, source or artifact is considered bad. The returned array of IDs can be a an array of empty string.
	IngestCertifyBads []string `json:"ingestCertifyBads"`
}

// GetIngestCertifyBads returns CertifyBadSrcsResponse.IngestCertifyBads, and is useful for accessing the field via an interface.
func (v *CertifyBadSrcsResponse) GetIngestCertifyBads() []string { return v.IngestCertifyBads }

// CertifyBadsCertifyBad includes the requested fields of the GraphQL type CertifyBad.
// The GraphQL type's documentation follows.
//
// CertifyBad is an attestation that a package, source, or artifact is considered
// bad.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The certification applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type CertifyBadsCertifyBad struct {
	AllCertifyBad `json:"-"`
}

// GetId returns CertifyBadsCertifyBad.Id, and is useful for accessing the field via an interface.
func (v *CertifyBadsCertifyBad) GetId() string { return v.AllCertifyBad.Id }

// GetJustification returns CertifyBadsCertifyBad.Justification, and is useful for accessing the field via an interface.
func (v *CertifyBadsCertifyBad) GetJustification() string { return v.AllCertifyBad.Justification }

// GetSubject returns CertifyBadsCertifyBad.Subject, and is useful for accessing the field via an interface.
func (v *CertifyBadsCertifyBad) GetSubject() AllCertifyBadSubjectPackageSourceOrArtifact {
	return v.AllCertifyBad.Subject
}

// GetOrigin returns CertifyBadsCertifyBad.Origin, and is useful for accessing the field via an interface.
func (v *CertifyBadsCertifyBad) GetOrigin() string { return v.AllCertifyBad.Origin }

// GetCollector returns CertifyBadsCertifyBad.Collector, and is useful for accessing the field via an interface.
func (v *CertifyBadsCertifyBad) GetCollector() string { return v.AllCertifyBad.Collector }

func (v *CertifyBadsCertifyBad) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyBadsCertifyBad
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyBadsCertifyBad = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyBad)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyBadsCertifyBad struct {
	Id string `json:"id"`

	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *CertifyBadsCertifyBad) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyBadsCertifyBad) __premarshalJSON() (*__premarshalCertifyBadsCertifyBad, error) {
	var retval __premarshalCertifyBadsCertifyBad

	retval.Id = v.AllCertifyBad.Id
	retval.Justification = v.AllCertifyBad.Justification
	{

		dst := &retval.Subject
		src := v.AllCertifyBad.Subject
		var err error
		*dst, err = __marshalAllCertifyBadSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal CertifyBadsCertifyBad.AllCertifyBad.Subject: %w", err)
		}
	}
	retval.Origin = v.AllCertifyBad.Origin
	retval.Collector = v.AllCertifyBad.Collector
	return &retval, nil
}

// CertifyBadsResponse is returned by CertifyBads on success.
type CertifyBadsResponse struct {
	// Returns all CertifyBad attestations matching a filter.
	CertifyBad []CertifyBadsCertifyBad `json:"CertifyBad"`
}

// GetCertifyBad returns CertifyBadsResponse.CertifyBad, and is useful for accessing the field via an interface.
func (v *CertifyBadsResponse) GetCertifyBad() []CertifyBadsCertifyBad { return v.CertifyBad }

// CertifyGoodArtifactResponse is returned by CertifyGoodArtifact on success.
type CertifyGoodArtifactResponse struct {
	// Adds a certification that a package, source or artifact is considered good. The returned ID can be empty string.
	IngestCertifyGood string `json:"ingestCertifyGood"`
}

// GetIngestCertifyGood returns CertifyGoodArtifactResponse.IngestCertifyGood, and is useful for accessing the field via an interface.
func (v *CertifyGoodArtifactResponse) GetIngestCertifyGood() string { return v.IngestCertifyGood }

// CertifyGoodArtifactsResponse is returned by CertifyGoodArtifacts on success.
type CertifyGoodArtifactsResponse struct {
	// Adds bulk certifications that a package, source or artifact is considered good. The returned array of IDs can be a an array of empty string.
	IngestCertifyGoods []string `json:"ingestCertifyGoods"`
}

// GetIngestCertifyGoods returns CertifyGoodArtifactsResponse.IngestCertifyGoods, and is useful for accessing the field via an interface.
func (v *CertifyGoodArtifactsResponse) GetIngestCertifyGoods() []string { return v.IngestCertifyGoods }

// CertifyGoodInputSpec represents the mutation input to ingest a CertifyGood evidence.
type CertifyGoodInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetJustification returns CertifyGoodInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *CertifyGoodInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns CertifyGoodInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *CertifyGoodInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns CertifyGoodInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *CertifyGoodInputSpec) GetCollector() string { return v.Collector }

// CertifyGoodPkgResponse is returned by CertifyGoodPkg on success.
type CertifyGoodPkgResponse struct {
	// Adds a certification that a package, source or artifact is considered good. The returned ID can be empty string.
	IngestCertifyGood string `json:"ingestCertifyGood"`
}

// GetIngestCertifyGood returns CertifyGoodPkgResponse.IngestCertifyGood, and is useful for accessing the field via an interface.
func (v *CertifyGoodPkgResponse) GetIngestCertifyGood() string { return v.IngestCertifyGood }

// CertifyGoodPkgsResponse is returned by CertifyGoodPkgs on success.
type CertifyGoodPkgsResponse struct {
	// Adds bulk certifications that a package, source or artifact is considered good. The returned array of IDs can be a an array of empty string.
	IngestCertifyGoods []string `json:"ingestCertifyGoods"`
}

// GetIngestCertifyGoods returns CertifyGoodPkgsResponse.IngestCertifyGoods, and is useful for accessing the field via an interface.
func (v *CertifyGoodPkgsResponse) GetIngestCertifyGoods() []string { return v.IngestCertifyGoods }

// CertifyGoodSrcResponse is returned by CertifyGoodSrc on success.
type CertifyGoodSrcResponse struct {
	// Adds a certification that a package, source or artifact is considered good. The returned ID can be empty string.
	IngestCertifyGood string `json:"ingestCertifyGood"`
}

// GetIngestCertifyGood returns CertifyGoodSrcResponse.IngestCertifyGood, and is useful for accessing the field via an interface.
func (v *CertifyGoodSrcResponse) GetIngestCertifyGood() string { return v.IngestCertifyGood }

// CertifyGoodSrcsResponse is returned by CertifyGoodSrcs on success.
type CertifyGoodSrcsResponse struct {
	// Adds bulk certifications that a package, source or artifact is considered good. The returned array of IDs can be a an array of empty string.
	IngestCertifyGoods []string `json:"ingestCertifyGoods"`
}

// GetIngestCertifyGoods returns CertifyGoodSrcsResponse.IngestCertifyGoods, and is useful for accessing the field via an interface.
func (v *CertifyGoodSrcsResponse) GetIngestCertifyGoods() []string { return v.IngestCertifyGoods }

// CertifyLegalInputSpec represents the input for certifying legal information in
// mutations.
type CertifyLegalInputSpec struct {
	DeclaredLicense   string    `json:"declaredLicense"`
	DiscoveredLicense string    `json:"discoveredLicense"`
	Attribution       string    `json:"attribution"`
	Justification     string    `json:"justification"`
	TimeScanned       time.Time `json:"timeScanned"`
	Origin            string    `json:"origin"`
	Collector         string    `json:"collector"`
}

// GetDeclaredLicense returns CertifyLegalInputSpec.DeclaredLicense, and is useful for accessing the field via an interface.
func (v *CertifyLegalInputSpec) GetDeclaredLicense() string { return v.DeclaredLicense }

// GetDiscoveredLicense returns CertifyLegalInputSpec.DiscoveredLicense, and is useful for accessing the field via an interface.
func (v *CertifyLegalInputSpec) GetDiscoveredLicense() string { return v.DiscoveredLicense }

// GetAttribution returns CertifyLegalInputSpec.Attribution, and is useful for accessing the field via an interface.
func (v *CertifyLegalInputSpec) GetAttribution() string { return v.Attribution }

// GetJustification returns CertifyLegalInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *CertifyLegalInputSpec) GetJustification() string { return v.Justification }

// GetTimeScanned returns CertifyLegalInputSpec.TimeScanned, and is useful for accessing the field via an interface.
func (v *CertifyLegalInputSpec) GetTimeScanned() time.Time { return v.TimeScanned }

// GetOrigin returns CertifyLegalInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *CertifyLegalInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns CertifyLegalInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *CertifyLegalInputSpec) GetCollector() string { return v.Collector }

// CertifyLegalPkgResponse is returned by CertifyLegalPkg on success.
type CertifyLegalPkgResponse struct {
	// Adds a legal certification to a package or source.
	IngestCertifyLegal string `json:"ingestCertifyLegal"`
}

// GetIngestCertifyLegal returns CertifyLegalPkgResponse.IngestCertifyLegal, and is useful for accessing the field via an interface.
func (v *CertifyLegalPkgResponse) GetIngestCertifyLegal() string { return v.IngestCertifyLegal }

// CertifyLegalPkgsResponse is returned by CertifyLegalPkgs on success.
type CertifyLegalPkgsResponse struct {
	// Bulk add legal certifications to packages or sources, not both at same time.
	IngestCertifyLegals []string `json:"ingestCertifyLegals"`
}

// GetIngestCertifyLegals returns CertifyLegalPkgsResponse.IngestCertifyLegals, and is useful for accessing the field via an interface.
func (v *CertifyLegalPkgsResponse) GetIngestCertifyLegals() []string { return v.IngestCertifyLegals }

// CertifyLegalSpec allows filtering the list of legal certifications to
// return in a query.
//
// Specifying just the package allows to query for all certifications associated
// with the package.
type CertifyLegalSpec struct {
	Id                 *string              `json:"id"`
	Subject            *PackageOrSourceSpec `json:"subject"`
	DeclaredLicense    *string              `json:"declaredLicense"`
	DeclaredLicenses   []LicenseSpec        `json:"declaredLicenses"`
	DiscoveredLicense  *string              `json:"discoveredLicense"`
	DiscoveredLicenses []LicenseSpec        `json:"discoveredLicenses"`
	Attribution        *string              `json:"attribution"`
	Justification      *string              `json:"justification"`
	TimeScanned        *time.Time           `json:"timeScanned"`
	Origin             *string              `json:"origin"`
	Collector          *string              `json:"collector"`
}

// GetId returns CertifyLegalSpec.Id, and is useful for accessing the field via an interface.
func (v *CertifyLegalSpec) GetId() *string { return v.Id }

// GetSubject returns CertifyLegalSpec.Subject, and is useful for accessing the field via an interface.
func (v *CertifyLegalSpec) GetSubject() *PackageOrSourceSpec { return v.Subject }

// GetDeclaredLicense returns CertifyLegalSpec.DeclaredLicense, and is useful for accessing the field via an interface.
func (v *CertifyLegalSpec) GetDeclaredLicense() *string { return v.DeclaredLicense }

// GetDeclaredLicenses returns CertifyLegalSpec.DeclaredLicenses, and is useful for accessing the field via an interface.
func (v *CertifyLegalSpec) GetDeclaredLicenses() []LicenseSpec { return v.DeclaredLicenses }

// GetDiscoveredLicense returns CertifyLegalSpec.DiscoveredLicense, and is useful for accessing the field via an interface.
func (v *CertifyLegalSpec) GetDiscoveredLicense() *string { return v.DiscoveredLicense }

// GetDiscoveredLicenses returns CertifyLegalSpec.DiscoveredLicenses, and is useful for accessing the field via an interface.
func (v *CertifyLegalSpec) GetDiscoveredLicenses() []LicenseSpec { return v.DiscoveredLicenses }

// GetAttribution returns CertifyLegalSpec.Attribution, and is useful for accessing the field via an interface.
func (v *CertifyLegalSpec) GetAttribution() *string { return v.Attribution }

// GetJustification returns CertifyLegalSpec.Justification, and is useful for accessing the field via an interface.
func (v *CertifyLegalSpec) GetJustification() *string { return v.Justification }

// GetTimeScanned returns CertifyLegalSpec.TimeScanned, and is useful for accessing the field via an interface.
func (v *CertifyLegalSpec) GetTimeScanned() *time.Time { return v.TimeScanned }

// GetOrigin returns CertifyLegalSpec.Origin, and is useful for accessing the field via an interface.
func (v *CertifyLegalSpec) GetOrigin() *string { return v.Origin }

// GetCollector returns CertifyLegalSpec.Collector, and is useful for accessing the field via an interface.
func (v *CertifyLegalSpec) GetCollector() *string { return v.Collector }

// CertifyLegalSrcResponse is returned by CertifyLegalSrc on success.
type CertifyLegalSrcResponse struct {
	// Adds a legal certification to a package or source.
	IngestCertifyLegal string `json:"ingestCertifyLegal"`
}

// GetIngestCertifyLegal returns CertifyLegalSrcResponse.IngestCertifyLegal, and is useful for accessing the field via an interface.
func (v *CertifyLegalSrcResponse) GetIngestCertifyLegal() string { return v.IngestCertifyLegal }

// CertifyLegalSrcsResponse is returned by CertifyLegalSrcs on success.
type CertifyLegalSrcsResponse struct {
	// Bulk add legal certifications to packages or sources, not both at same time.
	IngestCertifyLegals []string `json:"ingestCertifyLegals"`
}

// GetIngestCertifyLegals returns CertifyLegalSrcsResponse.IngestCertifyLegals, and is useful for accessing the field via an interface.
func (v *CertifyLegalSrcsResponse) GetIngestCertifyLegals() []string { return v.IngestCertifyLegals }

// CertifyLegalsCertifyLegal includes the requested fields of the GraphQL type CertifyLegal.
// The GraphQL type's documentation follows.
//
// CertifyLegal is an attestation to attach legal information to a package or source.
//
// The certification information is either copied from an attestation found in an
// SBOM or created by a collector/scanner.
//
// Discovered license is also known as Concluded. More information:
// https://docs.clearlydefined.io/curation-guidelines#the-difference-between-declared-and-discovered-licenses
//
// Attribution is also known as Copyright Text. It is what could be displayed to
// comply with notice
// requirements. https://www.nexb.com/oss-attribution-best-practices/
//
// License expressions follow this format:
// https://spdx.github.io/spdx-spec/v2.3/SPDX-license-expressions/
type CertifyLegalsCertifyLegal struct {
	AllCertifyLegalTree `json:"-"`
}

// GetId returns CertifyLegalsCertifyLegal.Id, and is useful for accessing the field via an interface.
func (v *CertifyLegalsCertifyLegal) GetId() string { return v.AllCertifyLegalTree.Id }

// GetSubject returns CertifyLegalsCertifyLegal.Subject, and is useful for accessing the field via an interface.
func (v *CertifyLegalsCertifyLegal) GetSubject() AllCertifyLegalTreeSubjectPackageOrSource {
	return v.AllCertifyLegalTree.Subject
}

// GetDeclaredLicense returns CertifyLegalsCertifyLegal.DeclaredLicense, and is useful for accessing the field via an interface.
func (v *CertifyLegalsCertifyLegal) GetDeclaredLicense() string {
	return v.AllCertifyLegalTree.DeclaredLicense
}

// GetDeclaredLicenses returns CertifyLegalsCertifyLegal.DeclaredLicenses, and is useful for accessing the field via an interface.
func (v *CertifyLegalsCertifyLegal) GetDeclaredLicenses() []AllCertifyLegalTreeDeclaredLicensesLicense {
	return v.AllCertifyLegalTree.DeclaredLicenses
}

// GetDiscoveredLicense returns CertifyLegalsCertifyLegal.DiscoveredLicense, and is useful for accessing the field via an interface.
func (v *CertifyLegalsCertifyLegal) GetDiscoveredLicense() string {
	return v.AllCertifyLegalTree.DiscoveredLicense
}

// GetDiscoveredLicenses returns CertifyLegalsCertifyLegal.DiscoveredLicenses, and is useful for accessing the field via an interface.
func (v *CertifyLegalsCertifyLegal) GetDiscoveredLicenses() []AllCertifyLegalTreeDiscoveredLicensesLicense {
	return v.AllCertifyLegalTree.DiscoveredLicenses
}

// GetAttribution returns CertifyLegalsCertifyLegal.Attribution, and is useful for accessing the field via an interface.
func (v *CertifyLegalsCertifyLegal) GetAttribution() string { return v.AllCertifyLegalTree.Attribution }

// GetJustification returns CertifyLegalsCertifyLegal.Justification, and is useful for accessing the field via an interface.
func (v *CertifyLegalsCertifyLegal) GetJustification() string {
	return v.AllCertifyLegalTree.Justification
}

// GetTimeScanned returns CertifyLegalsCertifyLegal.TimeScanned, and is useful for accessing the field via an interface.
func (v *CertifyLegalsCertifyLegal) GetTimeScanned() time.Time {
	return v.AllCertifyLegalTree.TimeScanned
}

// GetOrigin returns CertifyLegalsCertifyLegal.Origin, and is useful for accessing the field via an interface.
func (v *CertifyLegalsCertifyLegal) GetOrigin() string { return v.AllCertifyLegalTree.Origin }

// GetCollector returns CertifyLegalsCertifyLegal.Collector, and is useful for accessing the field via an interface.
func (v *CertifyLegalsCertifyLegal) GetCollector() string { return v.AllCertifyLegalTree.Collector }

func (v *CertifyLegalsCertifyLegal) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyLegalsCertifyLegal
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyLegalsCertifyLegal = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyLegalTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyLegalsCertifyLegal struct {
	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	DeclaredLicense string `json:"declaredLicense"`

	DeclaredLicenses []AllCertifyLegalTreeDeclaredLicensesLicense `json:"declaredLicenses"`

	DiscoveredLicense string `json:"discoveredLicense"`

	DiscoveredLicenses []AllCertifyLegalTreeDiscoveredLicensesLicense `json:"discoveredLicenses"`

	Attribution string `json:"attribution"`

	Justification string `json:"justification"`

	TimeScanned time.Time `json:"timeScanned"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *CertifyLegalsCertifyLegal) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyLegalsCertifyLegal) __premarshalJSON() (*__premarshalCertifyLegalsCertifyLegal, error) {
	var retval __premarshalCertifyLegalsCertifyLegal

	retval.Id = v.AllCertifyLegalTree.Id
	{

		dst := &retval.Subject
		src := v.AllCertifyLegalTree.Subject
		var err error
		*dst, err = __marshalAllCertifyLegalTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal CertifyLegalsCertifyLegal.AllCertifyLegalTree.Subject: %w", err)
		}
	}
	retval.DeclaredLicense = v.AllCertifyLegalTree.DeclaredLicense
	retval.DeclaredLicenses = v.AllCertifyLegalTree.DeclaredLicenses
	retval.DiscoveredLicense = v.AllCertifyLegalTree.DiscoveredLicense
	retval.DiscoveredLicenses = v.AllCertifyLegalTree.DiscoveredLicenses
	retval.Attribution = v.AllCertifyLegalTree.Attribution
	retval.Justification = v.AllCertifyLegalTree.Justification
	retval.TimeScanned = v.AllCertifyLegalTree.TimeScanned
	retval.Origin = v.AllCertifyLegalTree.Origin
	retval.Collector = v.AllCertifyLegalTree.Collector
	return &retval, nil
}

// CertifyLegalsResponse is returned by CertifyLegals on success.
type CertifyLegalsResponse struct {
	// Returns all legal certifications matching the input filter.
	CertifyLegal []CertifyLegalsCertifyLegal `json:"CertifyLegal"`
}

// GetCertifyLegal returns CertifyLegalsResponse.CertifyLegal, and is useful for accessing the field via an interface.
func (v *CertifyLegalsResponse) GetCertifyLegal() []CertifyLegalsCertifyLegal { return v.CertifyLegal }

// CertifyScorecardResponse is returned by CertifyScorecard on success.
type CertifyScorecardResponse struct {
	// Adds a certification that a source repository has a Scorecard. The returned ID can be empty string.
	IngestScorecard string `json:"ingestScorecard"`
}

// GetIngestScorecard returns CertifyScorecardResponse.IngestScorecard, and is useful for accessing the field via an interface.
func (v *CertifyScorecardResponse) GetIngestScorecard() string { return v.IngestScorecard }

// CertifyScorecardsResponse is returned by CertifyScorecards on success.
type CertifyScorecardsResponse struct {
	// Adds bulk certifications that a source repository has a Scorecard. The returned array of IDs can be a an array of empty string.
	IngestScorecards []string `json:"ingestScorecards"`
}

// GetIngestScorecards returns CertifyScorecardsResponse.IngestScorecards, and is useful for accessing the field via an interface.
func (v *CertifyScorecardsResponse) GetIngestScorecards() []string { return v.IngestScorecards }

// CertifyVexArtifactResponse is returned by CertifyVexArtifact on success.
type CertifyVexArtifactResponse struct {
	// Adds a VEX certification for a package. The returned ID can be empty string.
	IngestVEXStatement string `json:"ingestVEXStatement"`
}

// GetIngestVEXStatement returns CertifyVexArtifactResponse.IngestVEXStatement, and is useful for accessing the field via an interface.
func (v *CertifyVexArtifactResponse) GetIngestVEXStatement() string { return v.IngestVEXStatement }

// CertifyVexArtifactsResponse is returned by CertifyVexArtifacts on success.
type CertifyVexArtifactsResponse struct {
	// Bulk add VEX certifications for a package and vulnerability. The returned array of IDs can be a an array of empty string.
	IngestVEXStatements []string `json:"ingestVEXStatements"`
}

// GetIngestVEXStatements returns CertifyVexArtifactsResponse.IngestVEXStatements, and is useful for accessing the field via an interface.
func (v *CertifyVexArtifactsResponse) GetIngestVEXStatements() []string { return v.IngestVEXStatements }

// CertifyVexPkgResponse is returned by CertifyVexPkg on success.
type CertifyVexPkgResponse struct {
	// Adds a VEX certification for a package. The returned ID can be empty string.
	IngestVEXStatement string `json:"ingestVEXStatement"`
}

// GetIngestVEXStatement returns CertifyVexPkgResponse.IngestVEXStatement, and is useful for accessing the field via an interface.
func (v *CertifyVexPkgResponse) GetIngestVEXStatement() string { return v.IngestVEXStatement }

// CertifyVexPkgsResponse is returned by CertifyVexPkgs on success.
type CertifyVexPkgsResponse struct {
	// Bulk add VEX certifications for a package and vulnerability. The returned array of IDs can be a an array of empty string.
	IngestVEXStatements []string `json:"ingestVEXStatements"`
}

// GetIngestVEXStatements returns CertifyVexPkgsResponse.IngestVEXStatements, and is useful for accessing the field via an interface.
func (v *CertifyVexPkgsResponse) GetIngestVEXStatements() []string { return v.IngestVEXStatements }

// CertifyVulnPkgResponse is returned by CertifyVulnPkg on success.
type CertifyVulnPkgResponse struct {
	// Adds a certification that a package has been scanned for vulnerabilities. The returned ID can be empty string.
	IngestCertifyVuln string `json:"ingestCertifyVuln"`
}

// GetIngestCertifyVuln returns CertifyVulnPkgResponse.IngestCertifyVuln, and is useful for accessing the field via an interface.
func (v *CertifyVulnPkgResponse) GetIngestCertifyVuln() string { return v.IngestCertifyVuln }

// CertifyVulnPkgsResponse is returned by CertifyVulnPkgs on success.
type CertifyVulnPkgsResponse struct {
	// Bulk add certifications that a package has been scanned for vulnerabilities. The returned array of IDs can be a an array of empty string.
	IngestCertifyVulns []string `json:"ingestCertifyVulns"`
}

// GetIngestCertifyVulns returns CertifyVulnPkgsResponse.IngestCertifyVulns, and is useful for accessing the field via an interface.
func (v *CertifyVulnPkgsResponse) GetIngestCertifyVulns() []string { return v.IngestCertifyVulns }

// DependencyType determines the type of the dependency.
type DependencyType string

const (
	// direct dependency
	DependencyTypeDirect DependencyType = "DIRECT"
	// indirect dependency
	DependencyTypeIndirect DependencyType = "INDIRECT"
	// type not known/not specified
	DependencyTypeUnknown DependencyType = "UNKNOWN"
)

// Edge allows filtering path/neighbors output to only contain a subset of all
// possible GUAC links.
//
// Each member of the enum is formed by merging two Node names with _. Each name
// is converted from CamelCase to CAPITALS_WITH_UNDERSCORES. Only valid edges
// (pairs from Node to Node) are included.
//
// The only exception to the above rule is for links out of HasSLSA. The names are
// HAS_SLSA_SUBJECT, HAS_SLSA_BUILT_BY, and HAS_SLSA_MATERIALS. This is because
// ARTIFACT_HAS_SLSA is only from subject Artifact to HasSLSA.
type Edge string

const (
	EdgeArtifactCertifyBad               Edge = "ARTIFACT_CERTIFY_BAD"
	EdgeArtifactCertifyGood              Edge = "ARTIFACT_CERTIFY_GOOD"
	EdgeArtifactCertifyVexStatement      Edge = "ARTIFACT_CERTIFY_VEX_STATEMENT"
	EdgeArtifactHashEqual                Edge = "ARTIFACT_HASH_EQUAL"
	EdgeArtifactHasMetadata              Edge = "ARTIFACT_HAS_METADATA"
	EdgeArtifactHasSbom                  Edge = "ARTIFACT_HAS_SBOM"
	EdgeArtifactHasSlsa                  Edge = "ARTIFACT_HAS_SLSA"
	EdgeArtifactIsOccurrence             Edge = "ARTIFACT_IS_OCCURRENCE"
	EdgeArtifactPointOfContact           Edge = "ARTIFACT_POINT_OF_CONTACT"
	EdgeBuilderHasSlsa                   Edge = "BUILDER_HAS_SLSA"
	EdgeLicenseCertifyLegal              Edge = "LICENSE_CERTIFY_LEGAL"
	EdgePackageCertifyBad                Edge = "PACKAGE_CERTIFY_BAD"
	EdgePackageCertifyGood               Edge = "PACKAGE_CERTIFY_GOOD"
	EdgePackageCertifyLegal              Edge = "PACKAGE_CERTIFY_LEGAL"
	EdgePackageCertifyVexStatement       Edge = "PACKAGE_CERTIFY_VEX_STATEMENT"
	EdgePackageCertifyVuln               Edge = "PACKAGE_CERTIFY_VULN"
	EdgePackageHasMetadata               Edge = "PACKAGE_HAS_METADATA"
	EdgePackageHasSbom                   Edge = "PACKAGE_HAS_SBOM"
	EdgePackageHasSourceAt               Edge = "PACKAGE_HAS_SOURCE_AT"
	EdgePackageIsDependency              Edge = "PACKAGE_IS_DEPENDENCY"
	EdgePackageIsOccurrence              Edge = "PACKAGE_IS_OCCURRENCE"
	EdgePackagePkgEqual                  Edge = "PACKAGE_PKG_EQUAL"
	EdgePackagePointOfContact            Edge = "PACKAGE_POINT_OF_CONTACT"
	EdgeSourceCertifyBad                 Edge = "SOURCE_CERTIFY_BAD"
	EdgeSourceCertifyGood                Edge = "SOURCE_CERTIFY_GOOD"
	EdgeSourceCertifyLegal               Edge = "SOURCE_CERTIFY_LEGAL"
	EdgeSourceCertifyScorecard           Edge = "SOURCE_CERTIFY_SCORECARD"
	EdgeSourceHasMetadata                Edge = "SOURCE_HAS_METADATA"
	EdgeSourceHasSourceAt                Edge = "SOURCE_HAS_SOURCE_AT"
	EdgeSourceIsOccurrence               Edge = "SOURCE_IS_OCCURRENCE"
	EdgeSourcePointOfContact             Edge = "SOURCE_POINT_OF_CONTACT"
	EdgeVulnerabilityCertifyVexStatement Edge = "VULNERABILITY_CERTIFY_VEX_STATEMENT"
	EdgeVulnerabilityCertifyVuln         Edge = "VULNERABILITY_CERTIFY_VULN"
	EdgeVulnerabilityVulnEqual           Edge = "VULNERABILITY_VULN_EQUAL"
	EdgeVulnerabilityVulnMetadata        Edge = "VULNERABILITY_VULN_METADATA"
	EdgeCertifyBadArtifact               Edge = "CERTIFY_BAD_ARTIFACT"
	EdgeCertifyBadPackage                Edge = "CERTIFY_BAD_PACKAGE"
	EdgeCertifyBadSource                 Edge = "CERTIFY_BAD_SOURCE"
	EdgeCertifyGoodArtifact              Edge = "CERTIFY_GOOD_ARTIFACT"
	EdgeCertifyGoodPackage               Edge = "CERTIFY_GOOD_PACKAGE"
	EdgeCertifyGoodSource                Edge = "CERTIFY_GOOD_SOURCE"
	EdgeCertifyLegalLicense              Edge = "CERTIFY_LEGAL_LICENSE"
	EdgeCertifyLegalPackage              Edge = "CERTIFY_LEGAL_PACKAGE"
	EdgeCertifyLegalSource               Edge = "CERTIFY_LEGAL_SOURCE"
	EdgeCertifyScorecardSource           Edge = "CERTIFY_SCORECARD_SOURCE"
	EdgeCertifyVexStatementArtifact      Edge = "CERTIFY_VEX_STATEMENT_ARTIFACT"
	EdgeCertifyVexStatementPackage       Edge = "CERTIFY_VEX_STATEMENT_PACKAGE"
	EdgeCertifyVexStatementVulnerability Edge = "CERTIFY_VEX_STATEMENT_VULNERABILITY"
	EdgeCertifyVulnPackage               Edge = "CERTIFY_VULN_PACKAGE"
	EdgeCertifyVulnVulnerability         Edge = "CERTIFY_VULN_VULNERABILITY"
	EdgeHashEqualArtifact                Edge = "HASH_EQUAL_ARTIFACT"
	EdgeHasMetadataArtifact              Edge = "HAS_METADATA_ARTIFACT"
	EdgeHasMetadataPackage               Edge = "HAS_METADATA_PACKAGE"
	EdgeHasMetadataSource                Edge = "HAS_METADATA_SOURCE"
	EdgeHasSbomArtifact                  Edge = "HAS_SBOM_ARTIFACT"
	EdgeHasSbomPackage                   Edge = "HAS_SBOM_PACKAGE"
	EdgeHasSlsaBuiltBy                   Edge = "HAS_SLSA_BUILT_BY"
	EdgeHasSlsaMaterials                 Edge = "HAS_SLSA_MATERIALS"
	EdgeHasSlsaSubject                   Edge = "HAS_SLSA_SUBJECT"
	EdgeHasSourceAtPackage               Edge = "HAS_SOURCE_AT_PACKAGE"
	EdgeHasSourceAtSource                Edge = "HAS_SOURCE_AT_SOURCE"
	EdgeIsDependencyPackage              Edge = "IS_DEPENDENCY_PACKAGE"
	EdgeIsOccurrenceArtifact             Edge = "IS_OCCURRENCE_ARTIFACT"
	EdgeIsOccurrencePackage              Edge = "IS_OCCURRENCE_PACKAGE"
	EdgeIsOccurrenceSource               Edge = "IS_OCCURRENCE_SOURCE"
	EdgePkgEqualPackage                  Edge = "PKG_EQUAL_PACKAGE"
	EdgePointOfContactArtifact           Edge = "POINT_OF_CONTACT_ARTIFACT"
	EdgePointOfContactPackage            Edge = "POINT_OF_CONTACT_PACKAGE"
	EdgePointOfContactSource             Edge = "POINT_OF_CONTACT_SOURCE"
	EdgeVulnEqualVulnerability           Edge = "VULN_EQUAL_VULNERABILITY"
	EdgeVulnMetadataVulnerability        Edge = "VULN_METADATA_VULNERABILITY"
)

// FindSoftwareFindSoftwareArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type FindSoftwareFindSoftwareArtifact struct {
	Typename        *string `json:"__typename"`
	AllArtifactTree `json:"-"`
}

// GetTypename returns FindSoftwareFindSoftwareArtifact.Typename, and is useful for accessing the field via an interface.
func (v *FindSoftwareFindSoftwareArtifact) GetTypename() *string { return v.Typename }

// GetId returns FindSoftwareFindSoftwareArtifact.Id, and is useful for accessing the field via an interface.
func (v *FindSoftwareFindSoftwareArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns FindSoftwareFindSoftwareArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *FindSoftwareFindSoftwareArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns FindSoftwareFindSoftwareArtifact.Digest, and is useful for accessing the field via an interface.
func (v *FindSoftwareFindSoftwareArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *FindSoftwareFindSoftwareArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*FindSoftwareFindSoftwareArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.FindSoftwareFindSoftwareArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalFindSoftwareFindSoftwareArtifact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *FindSoftwareFindSoftwareArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *FindSoftwareFindSoftwareArtifact) __premarshalJSON() (*__premarshalFindSoftwareFindSoftwareArtifact, error) {
	var retval __premarshalFindSoftwareFindSoftwareArtifact

	retval.Typename = v.Typename
	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// FindSoftwareFindSoftwarePackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type FindSoftwareFindSoftwarePackage struct {
	Typename   *string `json:"__typename"`
	AllPkgTree `json:"-"`
}

// GetTypename returns FindSoftwareFindSoftwarePackage.Typename, and is useful for accessing the field via an interface.
func (v *FindSoftwareFindSoftwarePackage) GetTypename() *string { return v.Typename }

// GetId returns FindSoftwareFindSoftwarePackage.Id, and is useful for accessing the field via an interface.
func (v *FindSoftwareFindSoftwarePackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns FindSoftwareFindSoftwarePackage.Type, and is useful for accessing the field via an interface.
func (v *FindSoftwareFindSoftwarePackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns FindSoftwareFindSoftwarePackage.Namespaces, and is useful for accessing the field via an interface.
func (v *FindSoftwareFindSoftwarePackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *FindSoftwareFindSoftwarePackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*FindSoftwareFindSoftwarePackage
		graphql.NoUnmarshalJSON
	}
	firstPass.FindSoftwareFindSoftwarePackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalFindSoftwareFindSoftwarePackage struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *FindSoftwareFindSoftwarePackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *FindSoftwareFindSoftwarePackage) __premarshalJSON() (*__premarshalFindSoftwareFindSoftwarePackage, error) {
	var retval __premarshalFindSoftwareFindSoftwarePackage

	retval.Typename = v.Typename
	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// FindSoftwareFindSoftwarePackageSourceOrArtifact includes the requested fields of the GraphQL interface PackageSourceOrArtifact.
//
// FindSoftwareFindSoftwarePackageSourceOrArtifact is implemented by the following types:
// FindSoftwareFindSoftwareArtifact
// FindSoftwareFindSoftwarePackage
// FindSoftwareFindSoftwareSource
// The GraphQL type's documentation follows.
//
// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type FindSoftwareFindSoftwarePackageSourceOrArtifact interface {
	implementsGraphQLInterfaceFindSoftwareFindSoftwarePackageSourceOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *FindSoftwareFindSoftwareArtifact) implementsGraphQLInterfaceFindSoftwareFindSoftwarePackageSourceOrArtifact() {
}
func (v *FindSoftwareFindSoftwarePackage) implementsGraphQLInterfaceFindSoftwareFindSoftwarePackageSourceOrArtifact() {
}
func (v *FindSoftwareFindSoftwareSource) implementsGraphQLInterfaceFindSoftwareFindSoftwarePackageSourceOrArtifact() {
}

func __unmarshalFindSoftwareFindSoftwarePackageSourceOrArtifact(b []byte, v *FindSoftwareFindSoftwarePackageSourceOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Artifact":
		*v = new(FindSoftwareFindSoftwareArtifact)
		return json.Unmarshal(b, *v)
	case "Package":
		*v = new(FindSoftwareFindSoftwarePackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(FindSoftwareFindSoftwareSource)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageSourceOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for FindSoftwareFindSoftwarePackageSourceOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalFindSoftwareFindSoftwarePackageSourceOrArtifact(v *FindSoftwareFindSoftwarePackageSourceOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *FindSoftwareFindSoftwareArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalFindSoftwareFindSoftwareArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *FindSoftwareFindSoftwarePackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalFindSoftwareFindSoftwarePackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *FindSoftwareFindSoftwareSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalFindSoftwareFindSoftwareSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for FindSoftwareFindSoftwarePackageSourceOrArtifact: "%T"`, v)
	}
}

// FindSoftwareFindSoftwareSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type FindSoftwareFindSoftwareSource struct {
	Typename      *string `json:"__typename"`
	AllSourceTree `json:"-"`
}

// GetTypename returns FindSoftwareFindSoftwareSource.Typename, and is useful for accessing the field via an interface.
func (v *FindSoftwareFindSoftwareSource) GetTypename() *string { return v.Typename }

// GetId returns FindSoftwareFindSoftwareSource.Id, and is useful for accessing the field via an interface.
func (v *FindSoftwareFindSoftwareSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns FindSoftwareFindSoftwareSource.Type, and is useful for accessing the field via an interface.
func (v *FindSoftwareFindSoftwareSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns FindSoftwareFindSoftwareSource.Namespaces, and is useful for accessing the field via an interface.
func (v *FindSoftwareFindSoftwareSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *FindSoftwareFindSoftwareSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*FindSoftwareFindSoftwareSource
		graphql.NoUnmarshalJSON
	}
	firstPass.FindSoftwareFindSoftwareSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalFindSoftwareFindSoftwareSource struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *FindSoftwareFindSoftwareSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *FindSoftwareFindSoftwareSource) __premarshalJSON() (*__premarshalFindSoftwareFindSoftwareSource, error) {
	var retval __premarshalFindSoftwareFindSoftwareSource

	retval.Typename = v.Typename
	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// FindSoftwareResponse is returned by FindSoftware on success.
type FindSoftwareResponse struct {
	// findSoftware takes in a searchText string and looks for software
	// that may be relevant for the input text. This can be seen as fuzzy search
	// function for Packages, Sources and Artifacts. findSoftware returns a list
	// of Packages, Sources and Artifacts that it determines to be relevant to
	// the input searchText.
	//
	// Due to the nature of full text search being implemented differently on
	// different db platforms, the behavior of findSoftware is not guaranteed
	// to be the same. In addition, their statistical nature may result in
	// results being different per call and not reproducible.
	//
	// All that is asked in the implementation of this API is that it follows
	// the spirit of helping to retrieve the right nodes with best effort.
	//
	// Warning: This is an EXPERIMENTAL feature. This is subject to change.
	// Warning: This is an OPTIONAL feature. Backends are not required to
	// implement this API.
	FindSoftware []FindSoftwareFindSoftwarePackageSourceOrArtifact `json:"-"`
}

// GetFindSoftware returns FindSoftwareResponse.FindSoftware, and is useful for accessing the field via an interface.
func (v *FindSoftwareResponse) GetFindSoftware() []FindSoftwareFindSoftwarePackageSourceOrArtifact {
	return v.FindSoftware
}

func (v *FindSoftwareResponse) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*FindSoftwareResponse
		FindSoftware []json.RawMessage `json:"findSoftware"`
		graphql.NoUnmarshalJSON
	}
	firstPass.FindSoftwareResponse = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.FindSoftware
		src := firstPass.FindSoftware
		*dst = make(
			[]FindSoftwareFindSoftwarePackageSourceOrArtifact,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				err = __unmarshalFindSoftwareFindSoftwarePackageSourceOrArtifact(
					src, dst)
				if err != nil {
					return fmt.Errorf(
						"unable to unmarshal FindSoftwareResponse.FindSoftware: %w", err)
				}
			}
		}
	}
	return nil
}

type __premarshalFindSoftwareResponse struct {
	FindSoftware []json.RawMessage `json:"findSoftware"`
}

func (v *FindSoftwareResponse) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *FindSoftwareResponse) __premarshalJSON() (*__premarshalFindSoftwareResponse, error) {
	var retval __premarshalFindSoftwareResponse

	{

		dst := &retval.FindSoftware
		src := v.FindSoftware
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			var err error
			*dst, err = __marshalFindSoftwareFindSoftwarePackageSourceOrArtifact(
				&src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal FindSoftwareResponse.FindSoftware: %w", err)
			}
		}
	}
	return &retval, nil
}

// HasMetadataArtifactResponse is returned by HasMetadataArtifact on success.
type HasMetadataArtifactResponse struct {
	// Adds metadata about a package, source or artifact. The returned ID can be empty string.
	IngestHasMetadata string `json:"ingestHasMetadata"`
}

// GetIngestHasMetadata returns HasMetadataArtifactResponse.IngestHasMetadata, and is useful for accessing the field via an interface.
func (v *HasMetadataArtifactResponse) GetIngestHasMetadata() string { return v.IngestHasMetadata }

// HasMetadataArtifactsResponse is returned by HasMetadataArtifacts on success.
type HasMetadataArtifactsResponse struct {
	// Adds bulk metadata about a package, source or artifact. The returned array of IDs can be a an array of empty string.
	IngestBulkHasMetadata []string `json:"ingestBulkHasMetadata"`
}

// GetIngestBulkHasMetadata returns HasMetadataArtifactsResponse.IngestBulkHasMetadata, and is useful for accessing the field via an interface.
func (v *HasMetadataArtifactsResponse) GetIngestBulkHasMetadata() []string {
	return v.IngestBulkHasMetadata
}

// HasMetadataInputSpec represents the mutation input to ingest a CertifyGood evidence.
type HasMetadataInputSpec struct {
	Key           string    `json:"key"`
	Value         string    `json:"value"`
	Timestamp     time.Time `json:"timestamp"`
	Justification string    `json:"justification"`
	Origin        string    `json:"origin"`
	Collector     string    `json:"collector"`
}

// GetKey returns HasMetadataInputSpec.Key, and is useful for accessing the field via an interface.
func (v *HasMetadataInputSpec) GetKey() string { return v.Key }

// GetValue returns HasMetadataInputSpec.Value, and is useful for accessing the field via an interface.
func (v *HasMetadataInputSpec) GetValue() string { return v.Value }

// GetTimestamp returns HasMetadataInputSpec.Timestamp, and is useful for accessing the field via an interface.
func (v *HasMetadataInputSpec) GetTimestamp() time.Time { return v.Timestamp }

// GetJustification returns HasMetadataInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *HasMetadataInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns HasMetadataInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *HasMetadataInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns HasMetadataInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *HasMetadataInputSpec) GetCollector() string { return v.Collector }

// HasMetadataPkgResponse is returned by HasMetadataPkg on success.
type HasMetadataPkgResponse struct {
	// Adds metadata about a package, source or artifact. The returned ID can be empty string.
	IngestHasMetadata string `json:"ingestHasMetadata"`
}

// GetIngestHasMetadata returns HasMetadataPkgResponse.IngestHasMetadata, and is useful for accessing the field via an interface.
func (v *HasMetadataPkgResponse) GetIngestHasMetadata() string { return v.IngestHasMetadata }

// HasMetadataPkgsResponse is returned by HasMetadataPkgs on success.
type HasMetadataPkgsResponse struct {
	// Adds bulk metadata about a package, source or artifact. The returned array of IDs can be a an array of empty string.
	IngestBulkHasMetadata []string `json:"ingestBulkHasMetadata"`
}

// GetIngestBulkHasMetadata returns HasMetadataPkgsResponse.IngestBulkHasMetadata, and is useful for accessing the field via an interface.
func (v *HasMetadataPkgsResponse) GetIngestBulkHasMetadata() []string { return v.IngestBulkHasMetadata }

// HasMetadataSrcResponse is returned by HasMetadataSrc on success.
type HasMetadataSrcResponse struct {
	// Adds metadata about a package, source or artifact. The returned ID can be empty string.
	IngestHasMetadata string `json:"ingestHasMetadata"`
}

// GetIngestHasMetadata returns HasMetadataSrcResponse.IngestHasMetadata, and is useful for accessing the field via an interface.
func (v *HasMetadataSrcResponse) GetIngestHasMetadata() string { return v.IngestHasMetadata }

// HasMetadataSrcsResponse is returned by HasMetadataSrcs on success.
type HasMetadataSrcsResponse struct {
	// Adds bulk metadata about a package, source or artifact. The returned array of IDs can be a an array of empty string.
	IngestBulkHasMetadata []string `json:"ingestBulkHasMetadata"`
}

// GetIngestBulkHasMetadata returns HasMetadataSrcsResponse.IngestBulkHasMetadata, and is useful for accessing the field via an interface.
func (v *HasMetadataSrcsResponse) GetIngestBulkHasMetadata() []string { return v.IngestBulkHasMetadata }

// HasSBOMArtifactResponse is returned by HasSBOMArtifact on success.
type HasSBOMArtifactResponse struct {
	// Certifies that a package or artifact has an SBOM. The returned ID can be empty string.
	IngestHasSBOM string `json:"ingestHasSBOM"`
}

// GetIngestHasSBOM returns HasSBOMArtifactResponse.IngestHasSBOM, and is useful for accessing the field via an interface.
func (v *HasSBOMArtifactResponse) GetIngestHasSBOM() string { return v.IngestHasSBOM }

// HasSBOMArtifactsResponse is returned by HasSBOMArtifacts on success.
type HasSBOMArtifactsResponse struct {
	// Bulk ingest that package or artifact has an SBOM. The returned array of IDs can be a an array of empty string.
	IngestHasSBOMs []string `json:"ingestHasSBOMs"`
}

// GetIngestHasSBOMs returns HasSBOMArtifactsResponse.IngestHasSBOMs, and is useful for accessing the field via an interface.
func (v *HasSBOMArtifactsResponse) GetIngestHasSBOMs() []string { return v.IngestHasSBOMs }

// HasSBOMInputSpec is the same as HasSBOM but for mutation input.
type HasSBOMInputSpec struct {
	Uri              string `json:"uri"`
	Algorithm        string `json:"algorithm"`
	Digest           string `json:"digest"`
	DownloadLocation string `json:"downloadLocation"`
	Origin           string `json:"origin"`
	Collector        string `json:"collector"`
}

// GetUri returns HasSBOMInputSpec.Uri, and is useful for accessing the field via an interface.
func (v *HasSBOMInputSpec) GetUri() string { return v.Uri }

// GetAlgorithm returns HasSBOMInputSpec.Algorithm, and is useful for accessing the field via an interface.
func (v *HasSBOMInputSpec) GetAlgorithm() string { return v.Algorithm }

// GetDigest returns HasSBOMInputSpec.Digest, and is useful for accessing the field via an interface.
func (v *HasSBOMInputSpec) GetDigest() string { return v.Digest }

// GetDownloadLocation returns HasSBOMInputSpec.DownloadLocation, and is useful for accessing the field via an interface.
func (v *HasSBOMInputSpec) GetDownloadLocation() string { return v.DownloadLocation }

// GetOrigin returns HasSBOMInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *HasSBOMInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns HasSBOMInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *HasSBOMInputSpec) GetCollector() string { return v.Collector }

// HasSBOMPkgResponse is returned by HasSBOMPkg on success.
type HasSBOMPkgResponse struct {
	// Certifies that a package or artifact has an SBOM. The returned ID can be empty string.
	IngestHasSBOM string `json:"ingestHasSBOM"`
}

// GetIngestHasSBOM returns HasSBOMPkgResponse.IngestHasSBOM, and is useful for accessing the field via an interface.
func (v *HasSBOMPkgResponse) GetIngestHasSBOM() string { return v.IngestHasSBOM }

// HasSBOMPkgsResponse is returned by HasSBOMPkgs on success.
type HasSBOMPkgsResponse struct {
	// Bulk ingest that package or artifact has an SBOM. The returned array of IDs can be a an array of empty string.
	IngestHasSBOMs []string `json:"ingestHasSBOMs"`
}

// GetIngestHasSBOMs returns HasSBOMPkgsResponse.IngestHasSBOMs, and is useful for accessing the field via an interface.
func (v *HasSBOMPkgsResponse) GetIngestHasSBOMs() []string { return v.IngestHasSBOMs }

// HasSourceAtInputSpec is the same as HasSourceAt but for mutation input.
type HasSourceAtInputSpec struct {
	KnownSince    time.Time `json:"knownSince"`
	Justification string    `json:"justification"`
	Origin        string    `json:"origin"`
	Collector     string    `json:"collector"`
}

// GetKnownSince returns HasSourceAtInputSpec.KnownSince, and is useful for accessing the field via an interface.
func (v *HasSourceAtInputSpec) GetKnownSince() time.Time { return v.KnownSince }

// GetJustification returns HasSourceAtInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *HasSourceAtInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns HasSourceAtInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *HasSourceAtInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns HasSourceAtInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *HasSourceAtInputSpec) GetCollector() string { return v.Collector }

// HasSourceAtResponse is returned by HasSourceAt on success.
type HasSourceAtResponse struct {
	// Adds a certification that a package (PackageName or PackageVersion) is built from the source. The returned ID can be empty string.
	IngestHasSourceAt string `json:"ingestHasSourceAt"`
}

// GetIngestHasSourceAt returns HasSourceAtResponse.IngestHasSourceAt, and is useful for accessing the field via an interface.
func (v *HasSourceAtResponse) GetIngestHasSourceAt() string { return v.IngestHasSourceAt }

// HashEqualInputSpec represents the input to certify that packages are similar.
type HashEqualInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetJustification returns HashEqualInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *HashEqualInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns HashEqualInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *HashEqualInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns HashEqualInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *HashEqualInputSpec) GetCollector() string { return v.Collector }

// IngestArtifactResponse is returned by IngestArtifact on success.
type IngestArtifactResponse struct {
	// Ingests a new artifact and returns it. The returned ID can be empty string.
	IngestArtifact string `json:"ingestArtifact"`
}

// GetIngestArtifact returns IngestArtifactResponse.IngestArtifact, and is useful for accessing the field via an interface.
func (v *IngestArtifactResponse) GetIngestArtifact() string { return v.IngestArtifact }

// IngestArtifactsResponse is returned by IngestArtifacts on success.
type IngestArtifactsResponse struct {
	// Bulk ingests new artifacts and returns a list of them. The returned array of IDs can be a an array of empty string.
	IngestArtifacts []string `json:"ingestArtifacts"`
}

// GetIngestArtifacts returns IngestArtifactsResponse.IngestArtifacts, and is useful for accessing the field via an interface.
func (v *IngestArtifactsResponse) GetIngestArtifacts() []string { return v.IngestArtifacts }

// IngestBuilderResponse is returned by IngestBuilder on success.
type IngestBuilderResponse struct {
	// Ingests a new builder and returns it. The returned ID can be empty string.
	IngestBuilder string `json:"ingestBuilder"`
}

// GetIngestBuilder returns IngestBuilderResponse.IngestBuilder, and is useful for accessing the field via an interface.
func (v *IngestBuilderResponse) GetIngestBuilder() string { return v.IngestBuilder }

// IngestBuildersResponse is returned by IngestBuilders on success.
type IngestBuildersResponse struct {
	// Bulk ingests new builders and returns a list of them. The returned array of IDs can be a an array of empty string.
	IngestBuilders []string `json:"ingestBuilders"`
}

// GetIngestBuilders returns IngestBuildersResponse.IngestBuilders, and is useful for accessing the field via an interface.
func (v *IngestBuildersResponse) GetIngestBuilders() []string { return v.IngestBuilders }

// IngestHashEqualResponse is returned by IngestHashEqual on success.
type IngestHashEqualResponse struct {
	// Adds a certification that two artifacts are equal. The returned ID can be empty string.
	IngestHashEqual string `json:"ingestHashEqual"`
}

// GetIngestHashEqual returns IngestHashEqualResponse.IngestHashEqual, and is useful for accessing the field via an interface.
func (v *IngestHashEqualResponse) GetIngestHashEqual() string { return v.IngestHashEqual }

// IngestHashEqualsResponse is returned by IngestHashEquals on success.
type IngestHashEqualsResponse struct {
	// Bulk ingest certifications that two artifacts are equal. The returned array of IDs can be a an array of empty string.
	IngestHashEquals []string `json:"ingestHashEquals"`
}

// GetIngestHashEquals returns IngestHashEqualsResponse.IngestHashEquals, and is useful for accessing the field via an interface.
func (v *IngestHashEqualsResponse) GetIngestHashEquals() []string { return v.IngestHashEquals }

// IngestLicenseResponse is returned by IngestLicense on success.
type IngestLicenseResponse struct {
	// Ingests a new license and returns it.
	IngestLicense string `json:"ingestLicense"`
}

// GetIngestLicense returns IngestLicenseResponse.IngestLicense, and is useful for accessing the field via an interface.
func (v *IngestLicenseResponse) GetIngestLicense() string { return v.IngestLicense }

// IngestLicensesResponse is returned by IngestLicenses on success.
type IngestLicensesResponse struct {
	// Bulk ingests new licenses and returns a list of them.
	IngestLicenses []string `json:"ingestLicenses"`
}

// GetIngestLicenses returns IngestLicensesResponse.IngestLicenses, and is useful for accessing the field via an interface.
func (v *IngestLicensesResponse) GetIngestLicenses() []string { return v.IngestLicenses }

// IngestPackageResponse is returned by IngestPackage on success.
type IngestPackageResponse struct {
	// Ingests a new package and returns the corresponding package trie path. The returned ID can be empty string.
	IngestPackage string `json:"ingestPackage"`
}

// GetIngestPackage returns IngestPackageResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *IngestPackageResponse) GetIngestPackage() string { return v.IngestPackage }

// IngestPackagesResponse is returned by IngestPackages on success.
type IngestPackagesResponse struct {
	// Bulk ingests packages and returns the list of corresponding package trie path. The returned array of IDs can be a an array of empty string.
	IngestPackages []string `json:"ingestPackages"`
}

// GetIngestPackages returns IngestPackagesResponse.IngestPackages, and is useful for accessing the field via an interface.
func (v *IngestPackagesResponse) GetIngestPackages() []string { return v.IngestPackages }

// IngestPkgEqualResponse is returned by IngestPkgEqual on success.
type IngestPkgEqualResponse struct {
	// Adds a certification that two packages are similar. The returned ID can be empty string.
	IngestPkgEqual string `json:"ingestPkgEqual"`
}

// GetIngestPkgEqual returns IngestPkgEqualResponse.IngestPkgEqual, and is useful for accessing the field via an interface.
func (v *IngestPkgEqualResponse) GetIngestPkgEqual() string { return v.IngestPkgEqual }

// IngestPkgEqualsResponse is returned by IngestPkgEquals on success.
type IngestPkgEqualsResponse struct {
	// Bulk ingest mapping between packages. The returned array of IDs can be a an array of empty string.
	IngestPkgEquals []string `json:"ingestPkgEquals"`
}

// GetIngestPkgEquals returns IngestPkgEqualsResponse.IngestPkgEquals, and is useful for accessing the field via an interface.
func (v *IngestPkgEqualsResponse) GetIngestPkgEquals() []string { return v.IngestPkgEquals }

// IngestSourceResponse is returned by IngestSource on success.
type IngestSourceResponse struct {
	// Ingests a new source and returns the corresponding source trie path. The returned ID can be empty string.
	IngestSource string `json:"ingestSource"`
}

// GetIngestSource returns IngestSourceResponse.IngestSource, and is useful for accessing the field via an interface.
func (v *IngestSourceResponse) GetIngestSource() string { return v.IngestSource }

// IngestSourcesResponse is returned by IngestSources on success.
type IngestSourcesResponse struct {
	// Bulk ingests sources and returns the list of corresponding source trie path. The returned array of IDs can be a an array of empty string.
	IngestSources []string `json:"ingestSources"`
}

// GetIngestSources returns IngestSourcesResponse.IngestSources, and is useful for accessing the field via an interface.
func (v *IngestSourcesResponse) GetIngestSources() []string { return v.IngestSources }

// IngestVulnEqualResponse is returned by IngestVulnEqual on success.
type IngestVulnEqualResponse struct {
	// Ingest a mapping between vulnerabilities. The returned ID can be empty string.
	IngestVulnEqual string `json:"ingestVulnEqual"`
}

// GetIngestVulnEqual returns IngestVulnEqualResponse.IngestVulnEqual, and is useful for accessing the field via an interface.
func (v *IngestVulnEqualResponse) GetIngestVulnEqual() string { return v.IngestVulnEqual }

// IngestVulnEqualsResponse is returned by IngestVulnEquals on success.
type IngestVulnEqualsResponse struct {
	// Bulk ingest mapping between vulnerabilities. The returned array of IDs can be a an array of empty string.
	IngestVulnEquals []string `json:"ingestVulnEquals"`
}

// GetIngestVulnEquals returns IngestVulnEqualsResponse.IngestVulnEquals, and is useful for accessing the field via an interface.
func (v *IngestVulnEqualsResponse) GetIngestVulnEquals() []string { return v.IngestVulnEquals }

// IngestVulnerabilitiesResponse is returned by IngestVulnerabilities on success.
type IngestVulnerabilitiesResponse struct {
	// Bulk ingests vulnerabilities and returns the list of corresponding vulnerability trie path. The returned array of IDs can be a an array of empty string.
	IngestVulnerabilities []string `json:"ingestVulnerabilities"`
}

// GetIngestVulnerabilities returns IngestVulnerabilitiesResponse.IngestVulnerabilities, and is useful for accessing the field via an interface.
func (v *IngestVulnerabilitiesResponse) GetIngestVulnerabilities() []string {
	return v.IngestVulnerabilities
}

// IngestVulnerabilityResponse is returned by IngestVulnerability on success.
type IngestVulnerabilityResponse struct {
	// Ingests a new vulnerability and returns the corresponding vulnerability trie path. The returned ID can be empty string.
	IngestVulnerability string `json:"ingestVulnerability"`
}

// GetIngestVulnerability returns IngestVulnerabilityResponse.IngestVulnerability, and is useful for accessing the field via an interface.
func (v *IngestVulnerabilityResponse) GetIngestVulnerability() string { return v.IngestVulnerability }

// IsDependenciesResponse is returned by IsDependencies on success.
type IsDependenciesResponse struct {
	// Bulk adds a dependency between two packages. The returned array of IDs can be a an array of empty string.
	IngestDependencies []string `json:"ingestDependencies"`
}

// GetIngestDependencies returns IsDependenciesResponse.IngestDependencies, and is useful for accessing the field via an interface.
func (v *IsDependenciesResponse) GetIngestDependencies() []string { return v.IngestDependencies }

// IsDependencyInputSpec is the input to record a new dependency.
type IsDependencyInputSpec struct {
	// versionRange should be specified for depedentPackages that point to PackageName
	VersionRange   string         `json:"versionRange"`
	DependencyType DependencyType `json:"dependencyType"`
	Justification  string         `json:"justification"`
	Origin         string         `json:"origin"`
	Collector      string         `json:"collector"`
}

// GetVersionRange returns IsDependencyInputSpec.VersionRange, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetVersionRange() string { return v.VersionRange }

// GetDependencyType returns IsDependencyInputSpec.DependencyType, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetDependencyType() DependencyType { return v.DependencyType }

// GetJustification returns IsDependencyInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns IsDependencyInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns IsDependencyInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetCollector() string { return v.Collector }

// IsDependencyResponse is returned by IsDependency on success.
type IsDependencyResponse struct {
	// Adds a dependency between two packages. The returned ID can be empty string.
	IngestDependency string `json:"ingestDependency"`
}

// GetIngestDependency returns IsDependencyResponse.IngestDependency, and is useful for accessing the field via an interface.
func (v *IsDependencyResponse) GetIngestDependency() string { return v.IngestDependency }

// IsOccurrenceInputSpec represents the input to record an artifact's origin.
type IsOccurrenceInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetJustification returns IsOccurrenceInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *IsOccurrenceInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns IsOccurrenceInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *IsOccurrenceInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns IsOccurrenceInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *IsOccurrenceInputSpec) GetCollector() string { return v.Collector }

// IsOccurrencePkgResponse is returned by IsOccurrencePkg on success.
type IsOccurrencePkgResponse struct {
	// Ingest that an artifact is produced from a package or source. The returned ID can be empty string.
	IngestOccurrence string `json:"ingestOccurrence"`
}

// GetIngestOccurrence returns IsOccurrencePkgResponse.IngestOccurrence, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgResponse) GetIngestOccurrence() string { return v.IngestOccurrence }

// IsOccurrenceSrcResponse is returned by IsOccurrenceSrc on success.
type IsOccurrenceSrcResponse struct {
	// Ingest that an artifact is produced from a package or source. The returned ID can be empty string.
	IngestOccurrence string `json:"ingestOccurrence"`
}

// GetIngestOccurrence returns IsOccurrenceSrcResponse.IngestOccurrence, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcResponse) GetIngestOccurrence() string { return v.IngestOccurrence }

// IsOccurrencesPkgResponse is returned by IsOccurrencesPkg on success.
type IsOccurrencesPkgResponse struct {
	// Bulk ingest that an artifact is produced from a package or source. The returned array of IDs can be a an array of empty string.
	IngestOccurrences []string `json:"ingestOccurrences"`
}

// GetIngestOccurrences returns IsOccurrencesPkgResponse.IngestOccurrences, and is useful for accessing the field via an interface.
func (v *IsOccurrencesPkgResponse) GetIngestOccurrences() []string { return v.IngestOccurrences }

// IsOccurrencesSrcResponse is returned by IsOccurrencesSrc on success.
type IsOccurrencesSrcResponse struct {
	// Bulk ingest that an artifact is produced from a package or source. The returned array of IDs can be a an array of empty string.
	IngestOccurrences []string `json:"ingestOccurrences"`
}

// GetIngestOccurrences returns IsOccurrencesSrcResponse.IngestOccurrences, and is useful for accessing the field via an interface.
func (v *IsOccurrencesSrcResponse) GetIngestOccurrences() []string { return v.IngestOccurrences }

// LicenseInputSpec specifies an license for mutations. One of inline or
// listVersion should be empty or missing.
type LicenseInputSpec struct {
	Name        string  `json:"name"`
	Inline      *string `json:"inline"`
	ListVersion *string `json:"listVersion"`
}

// GetName returns LicenseInputSpec.Name, and is useful for accessing the field via an interface.
func (v *LicenseInputSpec) GetName() string { return v.Name }

// GetInline returns LicenseInputSpec.Inline, and is useful for accessing the field via an interface.
func (v *LicenseInputSpec) GetInline() *string { return v.Inline }

// GetListVersion returns LicenseInputSpec.ListVersion, and is useful for accessing the field via an interface.
func (v *LicenseInputSpec) GetListVersion() *string { return v.ListVersion }

// LicenseSpec allows filtering the list of licenses to return in a query.
type LicenseSpec struct {
	Id          *string `json:"id"`
	Name        *string `json:"name"`
	Inline      *string `json:"inline"`
	ListVersion *string `json:"listVersion"`
}

// GetId returns LicenseSpec.Id, and is useful for accessing the field via an interface.
func (v *LicenseSpec) GetId() *string { return v.Id }

// GetName returns LicenseSpec.Name, and is useful for accessing the field via an interface.
func (v *LicenseSpec) GetName() *string { return v.Name }

// GetInline returns LicenseSpec.Inline, and is useful for accessing the field via an interface.
func (v *LicenseSpec) GetInline() *string { return v.Inline }

// GetListVersion returns LicenseSpec.ListVersion, and is useful for accessing the field via an interface.
func (v *LicenseSpec) GetListVersion() *string { return v.ListVersion }

// LicensesLicensesLicense includes the requested fields of the GraphQL type License.
// The GraphQL type's documentation follows.
//
// License represents a particular license. If the license is found on the SPDX
// license list (https://spdx.org/licenses/) then the fields should be:
//
// Name: SPDX license identifier
// Inline: empty
// ListVersion: SPDX license list version
//
// example:
//
// Name: AGPL-3.0-or-later
// Inline: ""
// ListVersion: 3.21 2023-06-18
//
// If the license is not on the SPDX license list, then a new guid should be
// created and the license text placed inline:
//
// Name: LicenseRef-<guid>
// Inline: Full license text
// ListVersion: empty
//
// example:
//
// Name: LicenseRef-1a2b3c
// Inline: Permission to use, copy, modify, and/or distribute ...
// ListVersion: ""
type LicensesLicensesLicense struct {
	AllLicenseTree `json:"-"`
}

// GetId returns LicensesLicensesLicense.Id, and is useful for accessing the field via an interface.
func (v *LicensesLicensesLicense) GetId() string { return v.AllLicenseTree.Id }

// GetName returns LicensesLicensesLicense.Name, and is useful for accessing the field via an interface.
func (v *LicensesLicensesLicense) GetName() string { return v.AllLicenseTree.Name }

// GetInline returns LicensesLicensesLicense.Inline, and is useful for accessing the field via an interface.
func (v *LicensesLicensesLicense) GetInline() *string { return v.AllLicenseTree.Inline }

// GetListVersion returns LicensesLicensesLicense.ListVersion, and is useful for accessing the field via an interface.
func (v *LicensesLicensesLicense) GetListVersion() *string { return v.AllLicenseTree.ListVersion }

func (v *LicensesLicensesLicense) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*LicensesLicensesLicense
		graphql.NoUnmarshalJSON
	}
	firstPass.LicensesLicensesLicense = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllLicenseTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalLicensesLicensesLicense struct {
	Id string `json:"id"`

	Name string `json:"name"`

	Inline *string `json:"inline"`

	ListVersion *string `json:"listVersion"`
}

func (v *LicensesLicensesLicense) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *LicensesLicensesLicense) __premarshalJSON() (*__premarshalLicensesLicensesLicense, error) {
	var retval __premarshalLicensesLicensesLicense

	retval.Id = v.AllLicenseTree.Id
	retval.Name = v.AllLicenseTree.Name
	retval.Inline = v.AllLicenseTree.Inline
	retval.ListVersion = v.AllLicenseTree.ListVersion
	return &retval, nil
}

// LicensesResponse is returned by Licenses on success.
type LicensesResponse struct {
	// Returns all licenses matching a filter.
	Licenses []LicensesLicensesLicense `json:"licenses"`
}

// GetLicenses returns LicensesResponse.Licenses, and is useful for accessing the field via an interface.
func (v *LicensesResponse) GetLicenses() []LicensesLicensesLicense { return v.Licenses }

// MatchFlags is used to input the PkgMatchType enum.
type MatchFlags struct {
	Pkg PkgMatchType `json:"pkg"`
}

// GetPkg returns MatchFlags.Pkg, and is useful for accessing the field via an interface.
func (v *MatchFlags) GetPkg() PkgMatchType { return v.Pkg }

// NeighborsNeighborsArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type NeighborsNeighborsArtifact struct {
	Typename        *string `json:"__typename"`
	AllArtifactTree `json:"-"`
}

// GetTypename returns NeighborsNeighborsArtifact.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsArtifact) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsArtifact.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns NeighborsNeighborsArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns NeighborsNeighborsArtifact.Digest, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *NeighborsNeighborsArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsArtifact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *NeighborsNeighborsArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsArtifact) __premarshalJSON() (*__premarshalNeighborsNeighborsArtifact, error) {
	var retval __premarshalNeighborsNeighborsArtifact

	retval.Typename = v.Typename
	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// NeighborsNeighborsBuilder includes the requested fields of the GraphQL type Builder.
// The GraphQL type's documentation follows.
//
// Builder represents the builder (e.g., FRSCA or GitHub Actions).
//
// Currently builders are identified by the uri field.
type NeighborsNeighborsBuilder struct {
	Typename       *string `json:"__typename"`
	AllBuilderTree `json:"-"`
}

// GetTypename returns NeighborsNeighborsBuilder.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsBuilder) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsBuilder.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsBuilder) GetId() string { return v.AllBuilderTree.Id }

// GetUri returns NeighborsNeighborsBuilder.Uri, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsBuilder) GetUri() string { return v.AllBuilderTree.Uri }

func (v *NeighborsNeighborsBuilder) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsBuilder
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsBuilder = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllBuilderTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsBuilder struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Uri string `json:"uri"`
}

func (v *NeighborsNeighborsBuilder) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsBuilder) __premarshalJSON() (*__premarshalNeighborsNeighborsBuilder, error) {
	var retval __premarshalNeighborsNeighborsBuilder

	retval.Typename = v.Typename
	retval.Id = v.AllBuilderTree.Id
	retval.Uri = v.AllBuilderTree.Uri
	return &retval, nil
}

// NeighborsNeighborsCertifyBad includes the requested fields of the GraphQL type CertifyBad.
// The GraphQL type's documentation follows.
//
// CertifyBad is an attestation that a package, source, or artifact is considered
// bad.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The certification applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type NeighborsNeighborsCertifyBad struct {
	Typename      *string `json:"__typename"`
	AllCertifyBad `json:"-"`
}

// GetTypename returns NeighborsNeighborsCertifyBad.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyBad) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsCertifyBad.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyBad) GetId() string { return v.AllCertifyBad.Id }

// GetJustification returns NeighborsNeighborsCertifyBad.Justification, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyBad) GetJustification() string {
	return v.AllCertifyBad.Justification
}

// GetSubject returns NeighborsNeighborsCertifyBad.Subject, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyBad) GetSubject() AllCertifyBadSubjectPackageSourceOrArtifact {
	return v.AllCertifyBad.Subject
}

// GetOrigin returns NeighborsNeighborsCertifyBad.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyBad) GetOrigin() string { return v.AllCertifyBad.Origin }

// GetCollector returns NeighborsNeighborsCertifyBad.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyBad) GetCollector() string { return v.AllCertifyBad.Collector }

func (v *NeighborsNeighborsCertifyBad) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsCertifyBad
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsCertifyBad = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyBad)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsCertifyBad struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsCertifyBad) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsCertifyBad) __premarshalJSON() (*__premarshalNeighborsNeighborsCertifyBad, error) {
	var retval __premarshalNeighborsNeighborsCertifyBad

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyBad.Id
	retval.Justification = v.AllCertifyBad.Justification
	{

		dst := &retval.Subject
		src := v.AllCertifyBad.Subject
		var err error
		*dst, err = __marshalAllCertifyBadSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NeighborsNeighborsCertifyBad.AllCertifyBad.Subject: %w", err)
		}
	}
	retval.Origin = v.AllCertifyBad.Origin
	retval.Collector = v.AllCertifyBad.Collector
	return &retval, nil
}

// NeighborsNeighborsCertifyGood includes the requested fields of the GraphQL type CertifyGood.
// The GraphQL type's documentation follows.
//
// CertifyGood is an attestation that a package, source, or artifact is considered
// good.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The certification applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type NeighborsNeighborsCertifyGood struct {
	Typename       *string `json:"__typename"`
	AllCertifyGood `json:"-"`
}

// GetTypename returns NeighborsNeighborsCertifyGood.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyGood) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsCertifyGood.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyGood) GetId() string { return v.AllCertifyGood.Id }

// GetJustification returns NeighborsNeighborsCertifyGood.Justification, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyGood) GetJustification() string {
	return v.AllCertifyGood.Justification
}

// GetSubject returns NeighborsNeighborsCertifyGood.Subject, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyGood) GetSubject() AllCertifyGoodSubjectPackageSourceOrArtifact {
	return v.AllCertifyGood.Subject
}

// GetOrigin returns NeighborsNeighborsCertifyGood.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyGood) GetOrigin() string { return v.AllCertifyGood.Origin }

// GetCollector returns NeighborsNeighborsCertifyGood.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyGood) GetCollector() string { return v.AllCertifyGood.Collector }

func (v *NeighborsNeighborsCertifyGood) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsCertifyGood
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsCertifyGood = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyGood)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsCertifyGood struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsCertifyGood) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsCertifyGood) __premarshalJSON() (*__premarshalNeighborsNeighborsCertifyGood, error) {
	var retval __premarshalNeighborsNeighborsCertifyGood

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyGood.Id
	retval.Justification = v.AllCertifyGood.Justification
	{

		dst := &retval.Subject
		src := v.AllCertifyGood.Subject
		var err error
		*dst, err = __marshalAllCertifyGoodSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NeighborsNeighborsCertifyGood.AllCertifyGood.Subject: %w", err)
		}
	}
	retval.Origin = v.AllCertifyGood.Origin
	retval.Collector = v.AllCertifyGood.Collector
	return &retval, nil
}

// NeighborsNeighborsCertifyLegal includes the requested fields of the GraphQL type CertifyLegal.
// The GraphQL type's documentation follows.
//
// CertifyLegal is an attestation to attach legal information to a package or source.
//
// The certification information is either copied from an attestation found in an
// SBOM or created by a collector/scanner.
//
// Discovered license is also known as Concluded. More information:
// https://docs.clearlydefined.io/curation-guidelines#the-difference-between-declared-and-discovered-licenses
//
// Attribution is also known as Copyright Text. It is what could be displayed to
// comply with notice
// requirements. https://www.nexb.com/oss-attribution-best-practices/
//
// License expressions follow this format:
// https://spdx.github.io/spdx-spec/v2.3/SPDX-license-expressions/
type NeighborsNeighborsCertifyLegal struct {
	Typename            *string `json:"__typename"`
	AllCertifyLegalTree `json:"-"`
}

// GetTypename returns NeighborsNeighborsCertifyLegal.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyLegal) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsCertifyLegal.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyLegal) GetId() string { return v.AllCertifyLegalTree.Id }

// GetSubject returns NeighborsNeighborsCertifyLegal.Subject, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyLegal) GetSubject() AllCertifyLegalTreeSubjectPackageOrSource {
	return v.AllCertifyLegalTree.Subject
}

// GetDeclaredLicense returns NeighborsNeighborsCertifyLegal.DeclaredLicense, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyLegal) GetDeclaredLicense() string {
	return v.AllCertifyLegalTree.DeclaredLicense
}

// GetDeclaredLicenses returns NeighborsNeighborsCertifyLegal.DeclaredLicenses, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyLegal) GetDeclaredLicenses() []AllCertifyLegalTreeDeclaredLicensesLicense {
	return v.AllCertifyLegalTree.DeclaredLicenses
}

// GetDiscoveredLicense returns NeighborsNeighborsCertifyLegal.DiscoveredLicense, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyLegal) GetDiscoveredLicense() string {
	return v.AllCertifyLegalTree.DiscoveredLicense
}

// GetDiscoveredLicenses returns NeighborsNeighborsCertifyLegal.DiscoveredLicenses, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyLegal) GetDiscoveredLicenses() []AllCertifyLegalTreeDiscoveredLicensesLicense {
	return v.AllCertifyLegalTree.DiscoveredLicenses
}

// GetAttribution returns NeighborsNeighborsCertifyLegal.Attribution, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyLegal) GetAttribution() string {
	return v.AllCertifyLegalTree.Attribution
}

// GetJustification returns NeighborsNeighborsCertifyLegal.Justification, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyLegal) GetJustification() string {
	return v.AllCertifyLegalTree.Justification
}

// GetTimeScanned returns NeighborsNeighborsCertifyLegal.TimeScanned, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyLegal) GetTimeScanned() time.Time {
	return v.AllCertifyLegalTree.TimeScanned
}

// GetOrigin returns NeighborsNeighborsCertifyLegal.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyLegal) GetOrigin() string { return v.AllCertifyLegalTree.Origin }

// GetCollector returns NeighborsNeighborsCertifyLegal.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyLegal) GetCollector() string {
	return v.AllCertifyLegalTree.Collector
}

func (v *NeighborsNeighborsCertifyLegal) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsCertifyLegal
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsCertifyLegal = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyLegalTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsCertifyLegal struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	DeclaredLicense string `json:"declaredLicense"`

	DeclaredLicenses []AllCertifyLegalTreeDeclaredLicensesLicense `json:"declaredLicenses"`

	DiscoveredLicense string `json:"discoveredLicense"`

	DiscoveredLicenses []AllCertifyLegalTreeDiscoveredLicensesLicense `json:"discoveredLicenses"`

	Attribution string `json:"attribution"`

	Justification string `json:"justification"`

	TimeScanned time.Time `json:"timeScanned"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsCertifyLegal) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsCertifyLegal) __premarshalJSON() (*__premarshalNeighborsNeighborsCertifyLegal, error) {
	var retval __premarshalNeighborsNeighborsCertifyLegal

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyLegalTree.Id
	{

		dst := &retval.Subject
		src := v.AllCertifyLegalTree.Subject
		var err error
		*dst, err = __marshalAllCertifyLegalTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NeighborsNeighborsCertifyLegal.AllCertifyLegalTree.Subject: %w", err)
		}
	}
	retval.DeclaredLicense = v.AllCertifyLegalTree.DeclaredLicense
	retval.DeclaredLicenses = v.AllCertifyLegalTree.DeclaredLicenses
	retval.DiscoveredLicense = v.AllCertifyLegalTree.DiscoveredLicense
	retval.DiscoveredLicenses = v.AllCertifyLegalTree.DiscoveredLicenses
	retval.Attribution = v.AllCertifyLegalTree.Attribution
	retval.Justification = v.AllCertifyLegalTree.Justification
	retval.TimeScanned = v.AllCertifyLegalTree.TimeScanned
	retval.Origin = v.AllCertifyLegalTree.Origin
	retval.Collector = v.AllCertifyLegalTree.Collector
	return &retval, nil
}

// NeighborsNeighborsCertifyScorecard includes the requested fields of the GraphQL type CertifyScorecard.
// The GraphQL type's documentation follows.
//
// CertifyScorecard is an attestation to attach a Scorecard analysis to a
// particular source repository.
type NeighborsNeighborsCertifyScorecard struct {
	Typename            *string `json:"__typename"`
	AllCertifyScorecard `json:"-"`
}

// GetTypename returns NeighborsNeighborsCertifyScorecard.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyScorecard) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsCertifyScorecard.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyScorecard) GetId() string { return v.AllCertifyScorecard.Id }

// GetSource returns NeighborsNeighborsCertifyScorecard.Source, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyScorecard) GetSource() AllCertifyScorecardSource {
	return v.AllCertifyScorecard.Source
}

// GetScorecard returns NeighborsNeighborsCertifyScorecard.Scorecard, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyScorecard) GetScorecard() AllCertifyScorecardScorecard {
	return v.AllCertifyScorecard.Scorecard
}

func (v *NeighborsNeighborsCertifyScorecard) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsCertifyScorecard
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsCertifyScorecard = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyScorecard)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsCertifyScorecard struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Source AllCertifyScorecardSource `json:"source"`

	Scorecard AllCertifyScorecardScorecard `json:"scorecard"`
}

func (v *NeighborsNeighborsCertifyScorecard) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsCertifyScorecard) __premarshalJSON() (*__premarshalNeighborsNeighborsCertifyScorecard, error) {
	var retval __premarshalNeighborsNeighborsCertifyScorecard

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyScorecard.Id
	retval.Source = v.AllCertifyScorecard.Source
	retval.Scorecard = v.AllCertifyScorecard.Scorecard
	return &retval, nil
}

// NeighborsNeighborsCertifyVEXStatement includes the requested fields of the GraphQL type CertifyVEXStatement.
// The GraphQL type's documentation follows.
//
// CertifyVEXStatement is an attestation to attach VEX statements to a package or
// artifact to clarify the impact of a specific vulnerability.
type NeighborsNeighborsCertifyVEXStatement struct {
	Typename               *string `json:"__typename"`
	AllCertifyVEXStatement `json:"-"`
}

// GetTypename returns NeighborsNeighborsCertifyVEXStatement.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVEXStatement) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsCertifyVEXStatement.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVEXStatement) GetId() string { return v.AllCertifyVEXStatement.Id }

// GetSubject returns NeighborsNeighborsCertifyVEXStatement.Subject, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVEXStatement) GetSubject() AllCertifyVEXStatementSubjectPackageOrArtifact {
	return v.AllCertifyVEXStatement.Subject
}

// GetVulnerability returns NeighborsNeighborsCertifyVEXStatement.Vulnerability, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVEXStatement) GetVulnerability() AllCertifyVEXStatementVulnerability {
	return v.AllCertifyVEXStatement.Vulnerability
}

// GetStatus returns NeighborsNeighborsCertifyVEXStatement.Status, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVEXStatement) GetStatus() VexStatus {
	return v.AllCertifyVEXStatement.Status
}

// GetVexJustification returns NeighborsNeighborsCertifyVEXStatement.VexJustification, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVEXStatement) GetVexJustification() VexJustification {
	return v.AllCertifyVEXStatement.VexJustification
}

// GetStatement returns NeighborsNeighborsCertifyVEXStatement.Statement, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVEXStatement) GetStatement() string {
	return v.AllCertifyVEXStatement.Statement
}

// GetStatusNotes returns NeighborsNeighborsCertifyVEXStatement.StatusNotes, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVEXStatement) GetStatusNotes() string {
	return v.AllCertifyVEXStatement.StatusNotes
}

// GetKnownSince returns NeighborsNeighborsCertifyVEXStatement.KnownSince, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVEXStatement) GetKnownSince() time.Time {
	return v.AllCertifyVEXStatement.KnownSince
}

// GetOrigin returns NeighborsNeighborsCertifyVEXStatement.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVEXStatement) GetOrigin() string {
	return v.AllCertifyVEXStatement.Origin
}

// GetCollector returns NeighborsNeighborsCertifyVEXStatement.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVEXStatement) GetCollector() string {
	return v.AllCertifyVEXStatement.Collector
}

func (v *NeighborsNeighborsCertifyVEXStatement) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsCertifyVEXStatement
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsCertifyVEXStatement = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyVEXStatement)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsCertifyVEXStatement struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Vulnerability AllCertifyVEXStatementVulnerability `json:"vulnerability"`

	Status VexStatus `json:"status"`

	VexJustification VexJustification `json:"vexJustification"`

	Statement string `json:"statement"`

	StatusNotes string `json:"statusNotes"`

	KnownSince time.Time `json:"knownSince"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsCertifyVEXStatement) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsCertifyVEXStatement) __premarshalJSON() (*__premarshalNeighborsNeighborsCertifyVEXStatement, error) {
	var retval __premarshalNeighborsNeighborsCertifyVEXStatement

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyVEXStatement.Id
	{

		dst := &retval.Subject
		src := v.AllCertifyVEXStatement.Subject
		var err error
		*dst, err = __marshalAllCertifyVEXStatementSubjectPackageOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NeighborsNeighborsCertifyVEXStatement.AllCertifyVEXStatement.Subject: %w", err)
		}
	}
	retval.Vulnerability = v.AllCertifyVEXStatement.Vulnerability
	retval.Status = v.AllCertifyVEXStatement.Status
	retval.VexJustification = v.AllCertifyVEXStatement.VexJustification
	retval.Statement = v.AllCertifyVEXStatement.Statement
	retval.StatusNotes = v.AllCertifyVEXStatement.StatusNotes
	retval.KnownSince = v.AllCertifyVEXStatement.KnownSince
	retval.Origin = v.AllCertifyVEXStatement.Origin
	retval.Collector = v.AllCertifyVEXStatement.Collector
	return &retval, nil
}

// NeighborsNeighborsCertifyVuln includes the requested fields of the GraphQL type CertifyVuln.
// The GraphQL type's documentation follows.
//
// CertifyVuln is an attestation to attach vulnerability information to a package.
//
// This information is obtained via a scanner. If there is no vulnerability
// detected, we attach the a vulnerability with "NoVuln" type and an empty string
// for the vulnerability ID.
type NeighborsNeighborsCertifyVuln struct {
	Typename       *string `json:"__typename"`
	AllCertifyVuln `json:"-"`
}

// GetTypename returns NeighborsNeighborsCertifyVuln.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVuln) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsCertifyVuln.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVuln) GetId() string { return v.AllCertifyVuln.Id }

// GetPackage returns NeighborsNeighborsCertifyVuln.Package, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVuln) GetPackage() AllCertifyVulnPackage {
	return v.AllCertifyVuln.Package
}

// GetVulnerability returns NeighborsNeighborsCertifyVuln.Vulnerability, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVuln) GetVulnerability() AllCertifyVulnVulnerability {
	return v.AllCertifyVuln.Vulnerability
}

// GetMetadata returns NeighborsNeighborsCertifyVuln.Metadata, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsCertifyVuln) GetMetadata() AllCertifyVulnMetadataScanMetadata {
	return v.AllCertifyVuln.Metadata
}

func (v *NeighborsNeighborsCertifyVuln) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsCertifyVuln
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsCertifyVuln = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyVuln)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsCertifyVuln struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Package AllCertifyVulnPackage `json:"package"`

	Vulnerability AllCertifyVulnVulnerability `json:"vulnerability"`

	Metadata AllCertifyVulnMetadataScanMetadata `json:"metadata"`
}

func (v *NeighborsNeighborsCertifyVuln) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsCertifyVuln) __premarshalJSON() (*__premarshalNeighborsNeighborsCertifyVuln, error) {
	var retval __premarshalNeighborsNeighborsCertifyVuln

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyVuln.Id
	retval.Package = v.AllCertifyVuln.Package
	retval.Vulnerability = v.AllCertifyVuln.Vulnerability
	retval.Metadata = v.AllCertifyVuln.Metadata
	return &retval, nil
}

// NeighborsNeighborsHasMetadata includes the requested fields of the GraphQL type HasMetadata.
// The GraphQL type's documentation follows.
//
// HasMetadata is an attestation that a package, source, or artifact has a certain
// attested property (key) with value (value). For example, a source may have
// metadata "SourceRepo2FAEnabled=true".
//
// The intent of this evidence tree predicate is to allow extensibility of metadata
// expressible within the GUAC ontology. Metadata that is commonly used will then
// be promoted to a predicate on its own.
//
// Justification indicates how the metadata was determined.
//
// The metadata applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type NeighborsNeighborsHasMetadata struct {
	Typename       *string `json:"__typename"`
	AllHasMetadata `json:"-"`
}

// GetTypename returns NeighborsNeighborsHasMetadata.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasMetadata) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsHasMetadata.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasMetadata) GetId() string { return v.AllHasMetadata.Id }

// GetSubject returns NeighborsNeighborsHasMetadata.Subject, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasMetadata) GetSubject() AllHasMetadataSubjectPackageSourceOrArtifact {
	return v.AllHasMetadata.Subject
}

// GetKey returns NeighborsNeighborsHasMetadata.Key, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasMetadata) GetKey() string { return v.AllHasMetadata.Key }

// GetValue returns NeighborsNeighborsHasMetadata.Value, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasMetadata) GetValue() string { return v.AllHasMetadata.Value }

// GetTimestamp returns NeighborsNeighborsHasMetadata.Timestamp, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasMetadata) GetTimestamp() time.Time { return v.AllHasMetadata.Timestamp }

// GetJustification returns NeighborsNeighborsHasMetadata.Justification, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasMetadata) GetJustification() string {
	return v.AllHasMetadata.Justification
}

// GetOrigin returns NeighborsNeighborsHasMetadata.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasMetadata) GetOrigin() string { return v.AllHasMetadata.Origin }

// GetCollector returns NeighborsNeighborsHasMetadata.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasMetadata) GetCollector() string { return v.AllHasMetadata.Collector }

func (v *NeighborsNeighborsHasMetadata) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsHasMetadata
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsHasMetadata = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHasMetadata)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsHasMetadata struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Key string `json:"key"`

	Value string `json:"value"`

	Timestamp time.Time `json:"timestamp"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsHasMetadata) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsHasMetadata) __premarshalJSON() (*__premarshalNeighborsNeighborsHasMetadata, error) {
	var retval __premarshalNeighborsNeighborsHasMetadata

	retval.Typename = v.Typename
	retval.Id = v.AllHasMetadata.Id
	{

		dst := &retval.Subject
		src := v.AllHasMetadata.Subject
		var err error
		*dst, err = __marshalAllHasMetadataSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NeighborsNeighborsHasMetadata.AllHasMetadata.Subject: %w", err)
		}
	}
	retval.Key = v.AllHasMetadata.Key
	retval.Value = v.AllHasMetadata.Value
	retval.Timestamp = v.AllHasMetadata.Timestamp
	retval.Justification = v.AllHasMetadata.Justification
	retval.Origin = v.AllHasMetadata.Origin
	retval.Collector = v.AllHasMetadata.Collector
	return &retval, nil
}

// NeighborsNeighborsHasSBOM includes the requested fields of the GraphQL type HasSBOM.
type NeighborsNeighborsHasSBOM struct {
	Typename       *string `json:"__typename"`
	AllHasSBOMTree `json:"-"`
}

// GetTypename returns NeighborsNeighborsHasSBOM.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSBOM) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsHasSBOM.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSBOM) GetId() string { return v.AllHasSBOMTree.Id }

// GetSubject returns NeighborsNeighborsHasSBOM.Subject, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSBOM) GetSubject() AllHasSBOMTreeSubjectPackageOrArtifact {
	return v.AllHasSBOMTree.Subject
}

// GetUri returns NeighborsNeighborsHasSBOM.Uri, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSBOM) GetUri() string { return v.AllHasSBOMTree.Uri }

// GetAlgorithm returns NeighborsNeighborsHasSBOM.Algorithm, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSBOM) GetAlgorithm() string { return v.AllHasSBOMTree.Algorithm }

// GetDigest returns NeighborsNeighborsHasSBOM.Digest, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSBOM) GetDigest() string { return v.AllHasSBOMTree.Digest }

// GetDownloadLocation returns NeighborsNeighborsHasSBOM.DownloadLocation, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSBOM) GetDownloadLocation() string {
	return v.AllHasSBOMTree.DownloadLocation
}

// GetOrigin returns NeighborsNeighborsHasSBOM.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSBOM) GetOrigin() string { return v.AllHasSBOMTree.Origin }

// GetCollector returns NeighborsNeighborsHasSBOM.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSBOM) GetCollector() string { return v.AllHasSBOMTree.Collector }

func (v *NeighborsNeighborsHasSBOM) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsHasSBOM
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsHasSBOM = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHasSBOMTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsHasSBOM struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Uri string `json:"uri"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`

	DownloadLocation string `json:"downloadLocation"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsHasSBOM) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsHasSBOM) __premarshalJSON() (*__premarshalNeighborsNeighborsHasSBOM, error) {
	var retval __premarshalNeighborsNeighborsHasSBOM

	retval.Typename = v.Typename
	retval.Id = v.AllHasSBOMTree.Id
	{

		dst := &retval.Subject
		src := v.AllHasSBOMTree.Subject
		var err error
		*dst, err = __marshalAllHasSBOMTreeSubjectPackageOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NeighborsNeighborsHasSBOM.AllHasSBOMTree.Subject: %w", err)
		}
	}
	retval.Uri = v.AllHasSBOMTree.Uri
	retval.Algorithm = v.AllHasSBOMTree.Algorithm
	retval.Digest = v.AllHasSBOMTree.Digest
	retval.DownloadLocation = v.AllHasSBOMTree.DownloadLocation
	retval.Origin = v.AllHasSBOMTree.Origin
	retval.Collector = v.AllHasSBOMTree.Collector
	return &retval, nil
}

// NeighborsNeighborsHasSLSA includes the requested fields of the GraphQL type HasSLSA.
// The GraphQL type's documentation follows.
//
// HasSLSA records that a subject node has a SLSA attestation.
type NeighborsNeighborsHasSLSA struct {
	Typename    *string `json:"__typename"`
	AllSLSATree `json:"-"`
}

// GetTypename returns NeighborsNeighborsHasSLSA.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSLSA) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsHasSLSA.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSLSA) GetId() string { return v.AllSLSATree.Id }

// GetSubject returns NeighborsNeighborsHasSLSA.Subject, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSLSA) GetSubject() AllSLSATreeSubjectArtifact {
	return v.AllSLSATree.Subject
}

// GetSlsa returns NeighborsNeighborsHasSLSA.Slsa, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSLSA) GetSlsa() AllSLSATreeSlsaSLSA { return v.AllSLSATree.Slsa }

func (v *NeighborsNeighborsHasSLSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsHasSLSA
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsHasSLSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSLSATree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsHasSLSA struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject AllSLSATreeSubjectArtifact `json:"subject"`

	Slsa AllSLSATreeSlsaSLSA `json:"slsa"`
}

func (v *NeighborsNeighborsHasSLSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsHasSLSA) __premarshalJSON() (*__premarshalNeighborsNeighborsHasSLSA, error) {
	var retval __premarshalNeighborsNeighborsHasSLSA

	retval.Typename = v.Typename
	retval.Id = v.AllSLSATree.Id
	retval.Subject = v.AllSLSATree.Subject
	retval.Slsa = v.AllSLSATree.Slsa
	return &retval, nil
}

// NeighborsNeighborsHasSourceAt includes the requested fields of the GraphQL type HasSourceAt.
// The GraphQL type's documentation follows.
//
// HasSourceAt records that a package's repository is a given source.
type NeighborsNeighborsHasSourceAt struct {
	Typename       *string `json:"__typename"`
	AllHasSourceAt `json:"-"`
}

// GetTypename returns NeighborsNeighborsHasSourceAt.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSourceAt) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsHasSourceAt.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSourceAt) GetId() string { return v.AllHasSourceAt.Id }

// GetJustification returns NeighborsNeighborsHasSourceAt.Justification, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSourceAt) GetJustification() string {
	return v.AllHasSourceAt.Justification
}

// GetKnownSince returns NeighborsNeighborsHasSourceAt.KnownSince, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSourceAt) GetKnownSince() time.Time { return v.AllHasSourceAt.KnownSince }

// GetPackage returns NeighborsNeighborsHasSourceAt.Package, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSourceAt) GetPackage() AllHasSourceAtPackage {
	return v.AllHasSourceAt.Package
}

// GetSource returns NeighborsNeighborsHasSourceAt.Source, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSourceAt) GetSource() AllHasSourceAtSource {
	return v.AllHasSourceAt.Source
}

// GetOrigin returns NeighborsNeighborsHasSourceAt.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSourceAt) GetOrigin() string { return v.AllHasSourceAt.Origin }

// GetCollector returns NeighborsNeighborsHasSourceAt.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHasSourceAt) GetCollector() string { return v.AllHasSourceAt.Collector }

func (v *NeighborsNeighborsHasSourceAt) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsHasSourceAt
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsHasSourceAt = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHasSourceAt)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsHasSourceAt struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	KnownSince time.Time `json:"knownSince"`

	Package AllHasSourceAtPackage `json:"package"`

	Source AllHasSourceAtSource `json:"source"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsHasSourceAt) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsHasSourceAt) __premarshalJSON() (*__premarshalNeighborsNeighborsHasSourceAt, error) {
	var retval __premarshalNeighborsNeighborsHasSourceAt

	retval.Typename = v.Typename
	retval.Id = v.AllHasSourceAt.Id
	retval.Justification = v.AllHasSourceAt.Justification
	retval.KnownSince = v.AllHasSourceAt.KnownSince
	retval.Package = v.AllHasSourceAt.Package
	retval.Source = v.AllHasSourceAt.Source
	retval.Origin = v.AllHasSourceAt.Origin
	retval.Collector = v.AllHasSourceAt.Collector
	return &retval, nil
}

// NeighborsNeighborsHashEqual includes the requested fields of the GraphQL type HashEqual.
// The GraphQL type's documentation follows.
//
// HashEqual is an attestation that a set of artifacts are identical.
type NeighborsNeighborsHashEqual struct {
	Typename         *string `json:"__typename"`
	AllHashEqualTree `json:"-"`
}

// GetTypename returns NeighborsNeighborsHashEqual.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHashEqual) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsHashEqual.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHashEqual) GetId() string { return v.AllHashEqualTree.Id }

// GetJustification returns NeighborsNeighborsHashEqual.Justification, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHashEqual) GetJustification() string {
	return v.AllHashEqualTree.Justification
}

// GetArtifacts returns NeighborsNeighborsHashEqual.Artifacts, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHashEqual) GetArtifacts() []AllHashEqualTreeArtifactsArtifact {
	return v.AllHashEqualTree.Artifacts
}

// GetOrigin returns NeighborsNeighborsHashEqual.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHashEqual) GetOrigin() string { return v.AllHashEqualTree.Origin }

// GetCollector returns NeighborsNeighborsHashEqual.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsHashEqual) GetCollector() string { return v.AllHashEqualTree.Collector }

func (v *NeighborsNeighborsHashEqual) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsHashEqual
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsHashEqual = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHashEqualTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsHashEqual struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Artifacts []AllHashEqualTreeArtifactsArtifact `json:"artifacts"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsHashEqual) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsHashEqual) __premarshalJSON() (*__premarshalNeighborsNeighborsHashEqual, error) {
	var retval __premarshalNeighborsNeighborsHashEqual

	retval.Typename = v.Typename
	retval.Id = v.AllHashEqualTree.Id
	retval.Justification = v.AllHashEqualTree.Justification
	retval.Artifacts = v.AllHashEqualTree.Artifacts
	retval.Origin = v.AllHashEqualTree.Origin
	retval.Collector = v.AllHashEqualTree.Collector
	return &retval, nil
}

// NeighborsNeighborsIsDependency includes the requested fields of the GraphQL type IsDependency.
// The GraphQL type's documentation follows.
//
// IsDependency is an attestation to record that a package depends on another.
type NeighborsNeighborsIsDependency struct {
	Typename            *string `json:"__typename"`
	AllIsDependencyTree `json:"-"`
}

// GetTypename returns NeighborsNeighborsIsDependency.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsDependency) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsIsDependency.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsDependency) GetId() string { return v.AllIsDependencyTree.Id }

// GetJustification returns NeighborsNeighborsIsDependency.Justification, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsDependency) GetJustification() string {
	return v.AllIsDependencyTree.Justification
}

// GetPackage returns NeighborsNeighborsIsDependency.Package, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsDependency) GetPackage() AllIsDependencyTreePackage {
	return v.AllIsDependencyTree.Package
}

// GetDependentPackage returns NeighborsNeighborsIsDependency.DependentPackage, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsDependency) GetDependentPackage() AllIsDependencyTreeDependentPackage {
	return v.AllIsDependencyTree.DependentPackage
}

// GetDependencyType returns NeighborsNeighborsIsDependency.DependencyType, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsDependency) GetDependencyType() DependencyType {
	return v.AllIsDependencyTree.DependencyType
}

// GetVersionRange returns NeighborsNeighborsIsDependency.VersionRange, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsDependency) GetVersionRange() string {
	return v.AllIsDependencyTree.VersionRange
}

// GetOrigin returns NeighborsNeighborsIsDependency.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsDependency) GetOrigin() string { return v.AllIsDependencyTree.Origin }

// GetCollector returns NeighborsNeighborsIsDependency.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsDependency) GetCollector() string {
	return v.AllIsDependencyTree.Collector
}

func (v *NeighborsNeighborsIsDependency) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsIsDependency
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsIsDependency = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllIsDependencyTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsIsDependency struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Package AllIsDependencyTreePackage `json:"package"`

	DependentPackage AllIsDependencyTreeDependentPackage `json:"dependentPackage"`

	DependencyType DependencyType `json:"dependencyType"`

	VersionRange string `json:"versionRange"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsIsDependency) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsIsDependency) __premarshalJSON() (*__premarshalNeighborsNeighborsIsDependency, error) {
	var retval __premarshalNeighborsNeighborsIsDependency

	retval.Typename = v.Typename
	retval.Id = v.AllIsDependencyTree.Id
	retval.Justification = v.AllIsDependencyTree.Justification
	retval.Package = v.AllIsDependencyTree.Package
	retval.DependentPackage = v.AllIsDependencyTree.DependentPackage
	retval.DependencyType = v.AllIsDependencyTree.DependencyType
	retval.VersionRange = v.AllIsDependencyTree.VersionRange
	retval.Origin = v.AllIsDependencyTree.Origin
	retval.Collector = v.AllIsDependencyTree.Collector
	return &retval, nil
}

// NeighborsNeighborsIsOccurrence includes the requested fields of the GraphQL type IsOccurrence.
// The GraphQL type's documentation follows.
//
// IsOccurrence is an attestation to link an artifact to a package or source.
//
// Attestation must occur at the PackageVersion or at the SourceName.
type NeighborsNeighborsIsOccurrence struct {
	Typename             *string `json:"__typename"`
	AllIsOccurrencesTree `json:"-"`
}

// GetTypename returns NeighborsNeighborsIsOccurrence.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsOccurrence) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsIsOccurrence.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsOccurrence) GetId() string { return v.AllIsOccurrencesTree.Id }

// GetSubject returns NeighborsNeighborsIsOccurrence.Subject, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsOccurrence) GetSubject() AllIsOccurrencesTreeSubjectPackageOrSource {
	return v.AllIsOccurrencesTree.Subject
}

// GetArtifact returns NeighborsNeighborsIsOccurrence.Artifact, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsOccurrence) GetArtifact() AllIsOccurrencesTreeArtifact {
	return v.AllIsOccurrencesTree.Artifact
}

// GetJustification returns NeighborsNeighborsIsOccurrence.Justification, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsOccurrence) GetJustification() string {
	return v.AllIsOccurrencesTree.Justification
}

// GetOrigin returns NeighborsNeighborsIsOccurrence.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsOccurrence) GetOrigin() string { return v.AllIsOccurrencesTree.Origin }

// GetCollector returns NeighborsNeighborsIsOccurrence.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsIsOccurrence) GetCollector() string {
	return v.AllIsOccurrencesTree.Collector
}

func (v *NeighborsNeighborsIsOccurrence) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsIsOccurrence
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsIsOccurrence = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllIsOccurrencesTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsIsOccurrence struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Artifact AllIsOccurrencesTreeArtifact `json:"artifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsIsOccurrence) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsIsOccurrence) __premarshalJSON() (*__premarshalNeighborsNeighborsIsOccurrence, error) {
	var retval __premarshalNeighborsNeighborsIsOccurrence

	retval.Typename = v.Typename
	retval.Id = v.AllIsOccurrencesTree.Id
	{

		dst := &retval.Subject
		src := v.AllIsOccurrencesTree.Subject
		var err error
		*dst, err = __marshalAllIsOccurrencesTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NeighborsNeighborsIsOccurrence.AllIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.Artifact = v.AllIsOccurrencesTree.Artifact
	retval.Justification = v.AllIsOccurrencesTree.Justification
	retval.Origin = v.AllIsOccurrencesTree.Origin
	retval.Collector = v.AllIsOccurrencesTree.Collector
	return &retval, nil
}

// NeighborsNeighborsLicense includes the requested fields of the GraphQL type License.
// The GraphQL type's documentation follows.
//
// License represents a particular license. If the license is found on the SPDX
// license list (https://spdx.org/licenses/) then the fields should be:
//
// Name: SPDX license identifier
// Inline: empty
// ListVersion: SPDX license list version
//
// example:
//
// Name: AGPL-3.0-or-later
// Inline: ""
// ListVersion: 3.21 2023-06-18
//
// If the license is not on the SPDX license list, then a new guid should be
// created and the license text placed inline:
//
// Name: LicenseRef-<guid>
// Inline: Full license text
// ListVersion: empty
//
// example:
//
// Name: LicenseRef-1a2b3c
// Inline: Permission to use, copy, modify, and/or distribute ...
// ListVersion: ""
type NeighborsNeighborsLicense struct {
	Typename       *string `json:"__typename"`
	AllLicenseTree `json:"-"`
}

// GetTypename returns NeighborsNeighborsLicense.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsLicense) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsLicense.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsLicense) GetId() string { return v.AllLicenseTree.Id }

// GetName returns NeighborsNeighborsLicense.Name, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsLicense) GetName() string { return v.AllLicenseTree.Name }

// GetInline returns NeighborsNeighborsLicense.Inline, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsLicense) GetInline() *string { return v.AllLicenseTree.Inline }

// GetListVersion returns NeighborsNeighborsLicense.ListVersion, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsLicense) GetListVersion() *string { return v.AllLicenseTree.ListVersion }

func (v *NeighborsNeighborsLicense) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsLicense
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsLicense = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllLicenseTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsLicense struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Name string `json:"name"`

	Inline *string `json:"inline"`

	ListVersion *string `json:"listVersion"`
}

func (v *NeighborsNeighborsLicense) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsLicense) __premarshalJSON() (*__premarshalNeighborsNeighborsLicense, error) {
	var retval __premarshalNeighborsNeighborsLicense

	retval.Typename = v.Typename
	retval.Id = v.AllLicenseTree.Id
	retval.Name = v.AllLicenseTree.Name
	retval.Inline = v.AllLicenseTree.Inline
	retval.ListVersion = v.AllLicenseTree.ListVersion
	return &retval, nil
}

// NeighborsNeighborsNode includes the requested fields of the GraphQL interface Node.
//
// NeighborsNeighborsNode is implemented by the following types:
// NeighborsNeighborsArtifact
// NeighborsNeighborsBuilder
// NeighborsNeighborsCertifyBad
// NeighborsNeighborsCertifyGood
// NeighborsNeighborsCertifyLegal
// NeighborsNeighborsCertifyScorecard
// NeighborsNeighborsCertifyVEXStatement
// NeighborsNeighborsCertifyVuln
// NeighborsNeighborsHasMetadata
// NeighborsNeighborsHasSBOM
// NeighborsNeighborsHasSLSA
// NeighborsNeighborsHasSourceAt
// NeighborsNeighborsHashEqual
// NeighborsNeighborsIsDependency
// NeighborsNeighborsIsOccurrence
// NeighborsNeighborsLicense
// NeighborsNeighborsPackage
// NeighborsNeighborsPkgEqual
// NeighborsNeighborsPointOfContact
// NeighborsNeighborsSource
// NeighborsNeighborsVulnEqual
// NeighborsNeighborsVulnerability
// NeighborsNeighborsVulnerabilityMetadata
// The GraphQL type's documentation follows.
//
// Node is a union type of all the possible nodes.
//
// It encapsulates the software tree nodes along with the evidence nodes. In a
// path query, all connecting evidence nodes along with their intermediate subject
// nodes need to be returned in order to create a complete graph.
type NeighborsNeighborsNode interface {
	implementsGraphQLInterfaceNeighborsNeighborsNode()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *NeighborsNeighborsArtifact) implementsGraphQLInterfaceNeighborsNeighborsNode()            {}
func (v *NeighborsNeighborsBuilder) implementsGraphQLInterfaceNeighborsNeighborsNode()             {}
func (v *NeighborsNeighborsCertifyBad) implementsGraphQLInterfaceNeighborsNeighborsNode()          {}
func (v *NeighborsNeighborsCertifyGood) implementsGraphQLInterfaceNeighborsNeighborsNode()         {}
func (v *NeighborsNeighborsCertifyLegal) implementsGraphQLInterfaceNeighborsNeighborsNode()        {}
func (v *NeighborsNeighborsCertifyScorecard) implementsGraphQLInterfaceNeighborsNeighborsNode()    {}
func (v *NeighborsNeighborsCertifyVEXStatement) implementsGraphQLInterfaceNeighborsNeighborsNode() {}
func (v *NeighborsNeighborsCertifyVuln) implementsGraphQLInterfaceNeighborsNeighborsNode()         {}
func (v *NeighborsNeighborsHasMetadata) implementsGraphQLInterfaceNeighborsNeighborsNode()         {}
func (v *NeighborsNeighborsHasSBOM) implementsGraphQLInterfaceNeighborsNeighborsNode()             {}
func (v *NeighborsNeighborsHasSLSA) implementsGraphQLInterfaceNeighborsNeighborsNode()             {}
func (v *NeighborsNeighborsHasSourceAt) implementsGraphQLInterfaceNeighborsNeighborsNode()         {}
func (v *NeighborsNeighborsHashEqual) implementsGraphQLInterfaceNeighborsNeighborsNode()           {}
func (v *NeighborsNeighborsIsDependency) implementsGraphQLInterfaceNeighborsNeighborsNode()        {}
func (v *NeighborsNeighborsIsOccurrence) implementsGraphQLInterfaceNeighborsNeighborsNode()        {}
func (v *NeighborsNeighborsLicense) implementsGraphQLInterfaceNeighborsNeighborsNode()             {}
func (v *NeighborsNeighborsPackage) implementsGraphQLInterfaceNeighborsNeighborsNode()             {}
func (v *NeighborsNeighborsPkgEqual) implementsGraphQLInterfaceNeighborsNeighborsNode()            {}
func (v *NeighborsNeighborsPointOfContact) implementsGraphQLInterfaceNeighborsNeighborsNode()      {}
func (v *NeighborsNeighborsSource) implementsGraphQLInterfaceNeighborsNeighborsNode()              {}
func (v *NeighborsNeighborsVulnEqual) implementsGraphQLInterfaceNeighborsNeighborsNode()           {}
func (v *NeighborsNeighborsVulnerability) implementsGraphQLInterfaceNeighborsNeighborsNode()       {}
func (v *NeighborsNeighborsVulnerabilityMetadata) implementsGraphQLInterfaceNeighborsNeighborsNode() {
}

func __unmarshalNeighborsNeighborsNode(b []byte, v *NeighborsNeighborsNode) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Artifact":
		*v = new(NeighborsNeighborsArtifact)
		return json.Unmarshal(b, *v)
	case "Builder":
		*v = new(NeighborsNeighborsBuilder)
		return json.Unmarshal(b, *v)
	case "CertifyBad":
		*v = new(NeighborsNeighborsCertifyBad)
		return json.Unmarshal(b, *v)
	case "CertifyGood":
		*v = new(NeighborsNeighborsCertifyGood)
		return json.Unmarshal(b, *v)
	case "CertifyLegal":
		*v = new(NeighborsNeighborsCertifyLegal)
		return json.Unmarshal(b, *v)
	case "CertifyScorecard":
		*v = new(NeighborsNeighborsCertifyScorecard)
		return json.Unmarshal(b, *v)
	case "CertifyVEXStatement":
		*v = new(NeighborsNeighborsCertifyVEXStatement)
		return json.Unmarshal(b, *v)
	case "CertifyVuln":
		*v = new(NeighborsNeighborsCertifyVuln)
		return json.Unmarshal(b, *v)
	case "HasMetadata":
		*v = new(NeighborsNeighborsHasMetadata)
		return json.Unmarshal(b, *v)
	case "HasSBOM":
		*v = new(NeighborsNeighborsHasSBOM)
		return json.Unmarshal(b, *v)
	case "HasSLSA":
		*v = new(NeighborsNeighborsHasSLSA)
		return json.Unmarshal(b, *v)
	case "HasSourceAt":
		*v = new(NeighborsNeighborsHasSourceAt)
		return json.Unmarshal(b, *v)
	case "HashEqual":
		*v = new(NeighborsNeighborsHashEqual)
		return json.Unmarshal(b, *v)
	case "IsDependency":
		*v = new(NeighborsNeighborsIsDependency)
		return json.Unmarshal(b, *v)
	case "IsOccurrence":
		*v = new(NeighborsNeighborsIsOccurrence)
		return json.Unmarshal(b, *v)
	case "License":
		*v = new(NeighborsNeighborsLicense)
		return json.Unmarshal(b, *v)
	case "Package":
		*v = new(NeighborsNeighborsPackage)
		return json.Unmarshal(b, *v)
	case "PkgEqual":
		*v = new(NeighborsNeighborsPkgEqual)
		return json.Unmarshal(b, *v)
	case "PointOfContact":
		*v = new(NeighborsNeighborsPointOfContact)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(NeighborsNeighborsSource)
		return json.Unmarshal(b, *v)
	case "VulnEqual":
		*v = new(NeighborsNeighborsVulnEqual)
		return json.Unmarshal(b, *v)
	case "Vulnerability":
		*v = new(NeighborsNeighborsVulnerability)
		return json.Unmarshal(b, *v)
	case "VulnerabilityMetadata":
		*v = new(NeighborsNeighborsVulnerabilityMetadata)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing Node.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for NeighborsNeighborsNode: "%v"`, tn.TypeName)
	}
}

func __marshalNeighborsNeighborsNode(v *NeighborsNeighborsNode) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *NeighborsNeighborsArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsBuilder:
		typename = "Builder"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsBuilder
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsCertifyBad:
		typename = "CertifyBad"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsCertifyBad
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsCertifyGood:
		typename = "CertifyGood"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsCertifyGood
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsCertifyLegal:
		typename = "CertifyLegal"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsCertifyLegal
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsCertifyScorecard:
		typename = "CertifyScorecard"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsCertifyScorecard
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsCertifyVEXStatement:
		typename = "CertifyVEXStatement"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsCertifyVEXStatement
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsCertifyVuln:
		typename = "CertifyVuln"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsCertifyVuln
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsHasMetadata:
		typename = "HasMetadata"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsHasMetadata
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsHasSBOM:
		typename = "HasSBOM"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsHasSBOM
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsHasSLSA:
		typename = "HasSLSA"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsHasSLSA
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsHasSourceAt:
		typename = "HasSourceAt"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsHasSourceAt
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsHashEqual:
		typename = "HashEqual"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsHashEqual
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsIsDependency:
		typename = "IsDependency"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsIsDependency
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsIsOccurrence:
		typename = "IsOccurrence"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsIsOccurrence
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsLicense:
		typename = "License"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsLicense
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsPkgEqual:
		typename = "PkgEqual"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsPkgEqual
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsPointOfContact:
		typename = "PointOfContact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsPointOfContact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsVulnEqual:
		typename = "VulnEqual"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsVulnEqual
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsVulnerability:
		typename = "Vulnerability"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsVulnerability
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NeighborsNeighborsVulnerabilityMetadata:
		typename = "VulnerabilityMetadata"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNeighborsNeighborsVulnerabilityMetadata
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for NeighborsNeighborsNode: "%T"`, v)
	}
}

// NeighborsNeighborsPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type NeighborsNeighborsPackage struct {
	Typename   *string `json:"__typename"`
	AllPkgTree `json:"-"`
}

// GetTypename returns NeighborsNeighborsPackage.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPackage) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsPackage.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns NeighborsNeighborsPackage.Type, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns NeighborsNeighborsPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *NeighborsNeighborsPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsPackage struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *NeighborsNeighborsPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsPackage) __premarshalJSON() (*__premarshalNeighborsNeighborsPackage, error) {
	var retval __premarshalNeighborsNeighborsPackage

	retval.Typename = v.Typename
	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// NeighborsNeighborsPkgEqual includes the requested fields of the GraphQL type PkgEqual.
// The GraphQL type's documentation follows.
//
// PkgEqual is an attestation that a set of packages are similar.
type NeighborsNeighborsPkgEqual struct {
	Typename    *string `json:"__typename"`
	AllPkgEqual `json:"-"`
}

// GetTypename returns NeighborsNeighborsPkgEqual.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPkgEqual) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsPkgEqual.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPkgEqual) GetId() string { return v.AllPkgEqual.Id }

// GetJustification returns NeighborsNeighborsPkgEqual.Justification, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPkgEqual) GetJustification() string { return v.AllPkgEqual.Justification }

// GetPackages returns NeighborsNeighborsPkgEqual.Packages, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPkgEqual) GetPackages() []AllPkgEqualPackagesPackage {
	return v.AllPkgEqual.Packages
}

// GetOrigin returns NeighborsNeighborsPkgEqual.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPkgEqual) GetOrigin() string { return v.AllPkgEqual.Origin }

// GetCollector returns NeighborsNeighborsPkgEqual.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPkgEqual) GetCollector() string { return v.AllPkgEqual.Collector }

func (v *NeighborsNeighborsPkgEqual) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsPkgEqual
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsPkgEqual = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgEqual)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsPkgEqual struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Packages []AllPkgEqualPackagesPackage `json:"packages"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsPkgEqual) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsPkgEqual) __premarshalJSON() (*__premarshalNeighborsNeighborsPkgEqual, error) {
	var retval __premarshalNeighborsNeighborsPkgEqual

	retval.Typename = v.Typename
	retval.Id = v.AllPkgEqual.Id
	retval.Justification = v.AllPkgEqual.Justification
	retval.Packages = v.AllPkgEqual.Packages
	retval.Origin = v.AllPkgEqual.Origin
	retval.Collector = v.AllPkgEqual.Collector
	return &retval, nil
}

// NeighborsNeighborsPointOfContact includes the requested fields of the GraphQL type PointOfContact.
// The GraphQL type's documentation follows.
//
// PointOfContact is an attestation of how to get in touch with the person(s) responsible
// for a package, source, or artifact.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The attestation applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
//
// email is the email address (singular) of the point of contact.
//
// info is additional contact information other than email address. This is free
// form.
//
// NOTE: the identifiers for point of contact should be part of software trees.
// This will benefit from identifier look up and traversal as well as organization
// hierarchy. However, until the use case arises, PointOfContact will be a flat
// reference to the contact details.
type NeighborsNeighborsPointOfContact struct {
	Typename          *string `json:"__typename"`
	AllPointOfContact `json:"-"`
}

// GetTypename returns NeighborsNeighborsPointOfContact.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPointOfContact) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsPointOfContact.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPointOfContact) GetId() string { return v.AllPointOfContact.Id }

// GetSubject returns NeighborsNeighborsPointOfContact.Subject, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPointOfContact) GetSubject() AllPointOfContactSubjectPackageSourceOrArtifact {
	return v.AllPointOfContact.Subject
}

// GetEmail returns NeighborsNeighborsPointOfContact.Email, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPointOfContact) GetEmail() string { return v.AllPointOfContact.Email }

// GetInfo returns NeighborsNeighborsPointOfContact.Info, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPointOfContact) GetInfo() string { return v.AllPointOfContact.Info }

// GetSince returns NeighborsNeighborsPointOfContact.Since, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPointOfContact) GetSince() time.Time { return v.AllPointOfContact.Since }

// GetJustification returns NeighborsNeighborsPointOfContact.Justification, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPointOfContact) GetJustification() string {
	return v.AllPointOfContact.Justification
}

// GetOrigin returns NeighborsNeighborsPointOfContact.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPointOfContact) GetOrigin() string { return v.AllPointOfContact.Origin }

// GetCollector returns NeighborsNeighborsPointOfContact.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsPointOfContact) GetCollector() string {
	return v.AllPointOfContact.Collector
}

func (v *NeighborsNeighborsPointOfContact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsPointOfContact
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsPointOfContact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPointOfContact)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsPointOfContact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Email string `json:"email"`

	Info string `json:"info"`

	Since time.Time `json:"since"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsPointOfContact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsPointOfContact) __premarshalJSON() (*__premarshalNeighborsNeighborsPointOfContact, error) {
	var retval __premarshalNeighborsNeighborsPointOfContact

	retval.Typename = v.Typename
	retval.Id = v.AllPointOfContact.Id
	{

		dst := &retval.Subject
		src := v.AllPointOfContact.Subject
		var err error
		*dst, err = __marshalAllPointOfContactSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NeighborsNeighborsPointOfContact.AllPointOfContact.Subject: %w", err)
		}
	}
	retval.Email = v.AllPointOfContact.Email
	retval.Info = v.AllPointOfContact.Info
	retval.Since = v.AllPointOfContact.Since
	retval.Justification = v.AllPointOfContact.Justification
	retval.Origin = v.AllPointOfContact.Origin
	retval.Collector = v.AllPointOfContact.Collector
	return &retval, nil
}

// NeighborsNeighborsSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type NeighborsNeighborsSource struct {
	Typename      *string `json:"__typename"`
	AllSourceTree `json:"-"`
}

// GetTypename returns NeighborsNeighborsSource.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsSource) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsSource.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns NeighborsNeighborsSource.Type, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns NeighborsNeighborsSource.Namespaces, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *NeighborsNeighborsSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsSource
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsSource struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *NeighborsNeighborsSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsSource) __premarshalJSON() (*__premarshalNeighborsNeighborsSource, error) {
	var retval __premarshalNeighborsNeighborsSource

	retval.Typename = v.Typename
	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// NeighborsNeighborsVulnEqual includes the requested fields of the GraphQL type VulnEqual.
// The GraphQL type's documentation follows.
//
// VulnEqual is an attestation to link two vulnerabilities together as being equal"
//
// Note that setting noVuln vulnerability type is invalid for VulnEqual!
type NeighborsNeighborsVulnEqual struct {
	Typename     *string `json:"__typename"`
	AllVulnEqual `json:"-"`
}

// GetTypename returns NeighborsNeighborsVulnEqual.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnEqual) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsVulnEqual.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnEqual) GetId() string { return v.AllVulnEqual.Id }

// GetVulnerabilities returns NeighborsNeighborsVulnEqual.Vulnerabilities, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnEqual) GetVulnerabilities() []AllVulnEqualVulnerabilitiesVulnerability {
	return v.AllVulnEqual.Vulnerabilities
}

// GetJustification returns NeighborsNeighborsVulnEqual.Justification, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnEqual) GetJustification() string { return v.AllVulnEqual.Justification }

// GetOrigin returns NeighborsNeighborsVulnEqual.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnEqual) GetOrigin() string { return v.AllVulnEqual.Origin }

// GetCollector returns NeighborsNeighborsVulnEqual.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnEqual) GetCollector() string { return v.AllVulnEqual.Collector }

func (v *NeighborsNeighborsVulnEqual) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsVulnEqual
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsVulnEqual = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnEqual)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsVulnEqual struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Vulnerabilities []AllVulnEqualVulnerabilitiesVulnerability `json:"vulnerabilities"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsVulnEqual) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsVulnEqual) __premarshalJSON() (*__premarshalNeighborsNeighborsVulnEqual, error) {
	var retval __premarshalNeighborsNeighborsVulnEqual

	retval.Typename = v.Typename
	retval.Id = v.AllVulnEqual.Id
	retval.Vulnerabilities = v.AllVulnEqual.Vulnerabilities
	retval.Justification = v.AllVulnEqual.Justification
	retval.Origin = v.AllVulnEqual.Origin
	retval.Collector = v.AllVulnEqual.Collector
	return &retval, nil
}

// NeighborsNeighborsVulnerability includes the requested fields of the GraphQL type Vulnerability.
// The GraphQL type's documentation follows.
//
// Vulnerability represents the root of the vulnerability trie/tree.
//
// We map vulnerability information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type and a vulnerability ID. This allows for generic
// representation of the various vulnerabilities and does not limit to just cve, ghsa or osv.
// This would be in the general format: vuln://<general-type>/<vuln-id>
//
// Examples:
//
// CVE, using path separator: vuln://cve/cve-2023-20753
// OSV, representing its knowledge of a GHSA: vuln://osv/ghsa-205hk
// Random vendor: vuln://snyk/sn-whatever
// NoVuln: vuln://novuln/
//
// This node represents the type part of the trie path. It is used to represent
// the specific type of the vulnerability: cve, ghsa, osv or some other vendor specific
//
// Since this node is at the root of the vulnerability trie, it is named Vulnerability, not
// VulnerabilityType.
//
// NoVuln is a special vulnerability node to attest that no vulnerability has been
// found during a vulnerability scan. It will have the type "novuln" and contain an empty string
// for vulnerabilityID
//
// The resolvers will enforce that both the type and vulnerability IDs are lower case.
type NeighborsNeighborsVulnerability struct {
	Typename             *string `json:"__typename"`
	AllVulnerabilityTree `json:"-"`
}

// GetTypename returns NeighborsNeighborsVulnerability.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnerability) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsVulnerability.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnerability) GetId() string { return v.AllVulnerabilityTree.Id }

// GetType returns NeighborsNeighborsVulnerability.Type, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnerability) GetType() string { return v.AllVulnerabilityTree.Type }

// GetVulnerabilityIDs returns NeighborsNeighborsVulnerability.VulnerabilityIDs, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnerability) GetVulnerabilityIDs() []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID {
	return v.AllVulnerabilityTree.VulnerabilityIDs
}

func (v *NeighborsNeighborsVulnerability) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsVulnerability
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsVulnerability = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnerabilityTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsVulnerability struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	VulnerabilityIDs []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID `json:"vulnerabilityIDs"`
}

func (v *NeighborsNeighborsVulnerability) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsVulnerability) __premarshalJSON() (*__premarshalNeighborsNeighborsVulnerability, error) {
	var retval __premarshalNeighborsNeighborsVulnerability

	retval.Typename = v.Typename
	retval.Id = v.AllVulnerabilityTree.Id
	retval.Type = v.AllVulnerabilityTree.Type
	retval.VulnerabilityIDs = v.AllVulnerabilityTree.VulnerabilityIDs
	return &retval, nil
}

// NeighborsNeighborsVulnerabilityMetadata includes the requested fields of the GraphQL type VulnerabilityMetadata.
// The GraphQL type's documentation follows.
//
// VulnerabilityMetadata is an attestation that a vulnerability has a related score
// associated with it.
//
// The intent of this evidence tree predicate is to allow extensibility of vulnerability
// score (one-to-one mapping) with a specific vulnerability ID.
//
// A vulnerability ID can have a one-to-many relationship with the VulnerabilityMetadata
// node as a vulnerability ID can have multiple scores (in various frameworks).
//
// Examples:
//
// scoreType: EPSSv1
// scoreValue: 0.960760000
//
// scoreType: CVSSv2
// scoreValue: 5.0
//
// scoreType: CVSSv3
// scoreValue: 7.5
//
// The timestamp is used to determine when the score was evaluated for the specific vulnerability.
type NeighborsNeighborsVulnerabilityMetadata struct {
	Typename            *string `json:"__typename"`
	AllVulnMetadataTree `json:"-"`
}

// GetTypename returns NeighborsNeighborsVulnerabilityMetadata.Typename, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnerabilityMetadata) GetTypename() *string { return v.Typename }

// GetId returns NeighborsNeighborsVulnerabilityMetadata.Id, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnerabilityMetadata) GetId() string { return v.AllVulnMetadataTree.Id }

// GetVulnerability returns NeighborsNeighborsVulnerabilityMetadata.Vulnerability, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnerabilityMetadata) GetVulnerability() AllVulnMetadataTreeVulnerability {
	return v.AllVulnMetadataTree.Vulnerability
}

// GetScoreType returns NeighborsNeighborsVulnerabilityMetadata.ScoreType, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnerabilityMetadata) GetScoreType() VulnerabilityScoreType {
	return v.AllVulnMetadataTree.ScoreType
}

// GetScoreValue returns NeighborsNeighborsVulnerabilityMetadata.ScoreValue, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnerabilityMetadata) GetScoreValue() float64 {
	return v.AllVulnMetadataTree.ScoreValue
}

// GetTimestamp returns NeighborsNeighborsVulnerabilityMetadata.Timestamp, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnerabilityMetadata) GetTimestamp() time.Time {
	return v.AllVulnMetadataTree.Timestamp
}

// GetOrigin returns NeighborsNeighborsVulnerabilityMetadata.Origin, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnerabilityMetadata) GetOrigin() string {
	return v.AllVulnMetadataTree.Origin
}

// GetCollector returns NeighborsNeighborsVulnerabilityMetadata.Collector, and is useful for accessing the field via an interface.
func (v *NeighborsNeighborsVulnerabilityMetadata) GetCollector() string {
	return v.AllVulnMetadataTree.Collector
}

func (v *NeighborsNeighborsVulnerabilityMetadata) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsNeighborsVulnerabilityMetadata
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsNeighborsVulnerabilityMetadata = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnMetadataTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNeighborsNeighborsVulnerabilityMetadata struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Vulnerability AllVulnMetadataTreeVulnerability `json:"vulnerability"`

	ScoreType VulnerabilityScoreType `json:"scoreType"`

	ScoreValue float64 `json:"scoreValue"`

	Timestamp time.Time `json:"timestamp"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NeighborsNeighborsVulnerabilityMetadata) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsNeighborsVulnerabilityMetadata) __premarshalJSON() (*__premarshalNeighborsNeighborsVulnerabilityMetadata, error) {
	var retval __premarshalNeighborsNeighborsVulnerabilityMetadata

	retval.Typename = v.Typename
	retval.Id = v.AllVulnMetadataTree.Id
	retval.Vulnerability = v.AllVulnMetadataTree.Vulnerability
	retval.ScoreType = v.AllVulnMetadataTree.ScoreType
	retval.ScoreValue = v.AllVulnMetadataTree.ScoreValue
	retval.Timestamp = v.AllVulnMetadataTree.Timestamp
	retval.Origin = v.AllVulnMetadataTree.Origin
	retval.Collector = v.AllVulnMetadataTree.Collector
	return &retval, nil
}

// NeighborsResponse is returned by Neighbors on success.
type NeighborsResponse struct {
	// neighbors returns all the direct neighbors of a node.
	//
	// Similarly, the input is only specified by its ID.
	//
	// Specifying any Edge value in `usingOnly` will make the neighbors list only
	// contain the corresponding GUAC evidence trees (GUAC verbs).
	Neighbors []NeighborsNeighborsNode `json:"-"`
}

// GetNeighbors returns NeighborsResponse.Neighbors, and is useful for accessing the field via an interface.
func (v *NeighborsResponse) GetNeighbors() []NeighborsNeighborsNode { return v.Neighbors }

func (v *NeighborsResponse) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NeighborsResponse
		Neighbors []json.RawMessage `json:"neighbors"`
		graphql.NoUnmarshalJSON
	}
	firstPass.NeighborsResponse = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Neighbors
		src := firstPass.Neighbors
		*dst = make(
			[]NeighborsNeighborsNode,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				err = __unmarshalNeighborsNeighborsNode(
					src, dst)
				if err != nil {
					return fmt.Errorf(
						"unable to unmarshal NeighborsResponse.Neighbors: %w", err)
				}
			}
		}
	}
	return nil
}

type __premarshalNeighborsResponse struct {
	Neighbors []json.RawMessage `json:"neighbors"`
}

func (v *NeighborsResponse) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NeighborsResponse) __premarshalJSON() (*__premarshalNeighborsResponse, error) {
	var retval __premarshalNeighborsResponse

	{

		dst := &retval.Neighbors
		src := v.Neighbors
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			var err error
			*dst, err = __marshalNeighborsNeighborsNode(
				&src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NeighborsResponse.Neighbors: %w", err)
			}
		}
	}
	return &retval, nil
}

// NodeNode includes the requested fields of the GraphQL interface Node.
//
// NodeNode is implemented by the following types:
// NodeNodeArtifact
// NodeNodeBuilder
// NodeNodeCertifyBad
// NodeNodeCertifyGood
// NodeNodeCertifyLegal
// NodeNodeCertifyScorecard
// NodeNodeCertifyVEXStatement
// NodeNodeCertifyVuln
// NodeNodeHasMetadata
// NodeNodeHasSBOM
// NodeNodeHasSLSA
// NodeNodeHasSourceAt
// NodeNodeHashEqual
// NodeNodeIsDependency
// NodeNodeIsOccurrence
// NodeNodeLicense
// NodeNodePackage
// NodeNodePkgEqual
// NodeNodePointOfContact
// NodeNodeSource
// NodeNodeVulnEqual
// NodeNodeVulnerability
// NodeNodeVulnerabilityMetadata
// The GraphQL type's documentation follows.
//
// Node is a union type of all the possible nodes.
//
// It encapsulates the software tree nodes along with the evidence nodes. In a
// path query, all connecting evidence nodes along with their intermediate subject
// nodes need to be returned in order to create a complete graph.
type NodeNode interface {
	implementsGraphQLInterfaceNodeNode()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *NodeNodeArtifact) implementsGraphQLInterfaceNodeNode()              {}
func (v *NodeNodeBuilder) implementsGraphQLInterfaceNodeNode()               {}
func (v *NodeNodeCertifyBad) implementsGraphQLInterfaceNodeNode()            {}
func (v *NodeNodeCertifyGood) implementsGraphQLInterfaceNodeNode()           {}
func (v *NodeNodeCertifyLegal) implementsGraphQLInterfaceNodeNode()          {}
func (v *NodeNodeCertifyScorecard) implementsGraphQLInterfaceNodeNode()      {}
func (v *NodeNodeCertifyVEXStatement) implementsGraphQLInterfaceNodeNode()   {}
func (v *NodeNodeCertifyVuln) implementsGraphQLInterfaceNodeNode()           {}
func (v *NodeNodeHasMetadata) implementsGraphQLInterfaceNodeNode()           {}
func (v *NodeNodeHasSBOM) implementsGraphQLInterfaceNodeNode()               {}
func (v *NodeNodeHasSLSA) implementsGraphQLInterfaceNodeNode()               {}
func (v *NodeNodeHasSourceAt) implementsGraphQLInterfaceNodeNode()           {}
func (v *NodeNodeHashEqual) implementsGraphQLInterfaceNodeNode()             {}
func (v *NodeNodeIsDependency) implementsGraphQLInterfaceNodeNode()          {}
func (v *NodeNodeIsOccurrence) implementsGraphQLInterfaceNodeNode()          {}
func (v *NodeNodeLicense) implementsGraphQLInterfaceNodeNode()               {}
func (v *NodeNodePackage) implementsGraphQLInterfaceNodeNode()               {}
func (v *NodeNodePkgEqual) implementsGraphQLInterfaceNodeNode()              {}
func (v *NodeNodePointOfContact) implementsGraphQLInterfaceNodeNode()        {}
func (v *NodeNodeSource) implementsGraphQLInterfaceNodeNode()                {}
func (v *NodeNodeVulnEqual) implementsGraphQLInterfaceNodeNode()             {}
func (v *NodeNodeVulnerability) implementsGraphQLInterfaceNodeNode()         {}
func (v *NodeNodeVulnerabilityMetadata) implementsGraphQLInterfaceNodeNode() {}

func __unmarshalNodeNode(b []byte, v *NodeNode) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Artifact":
		*v = new(NodeNodeArtifact)
		return json.Unmarshal(b, *v)
	case "Builder":
		*v = new(NodeNodeBuilder)
		return json.Unmarshal(b, *v)
	case "CertifyBad":
		*v = new(NodeNodeCertifyBad)
		return json.Unmarshal(b, *v)
	case "CertifyGood":
		*v = new(NodeNodeCertifyGood)
		return json.Unmarshal(b, *v)
	case "CertifyLegal":
		*v = new(NodeNodeCertifyLegal)
		return json.Unmarshal(b, *v)
	case "CertifyScorecard":
		*v = new(NodeNodeCertifyScorecard)
		return json.Unmarshal(b, *v)
	case "CertifyVEXStatement":
		*v = new(NodeNodeCertifyVEXStatement)
		return json.Unmarshal(b, *v)
	case "CertifyVuln":
		*v = new(NodeNodeCertifyVuln)
		return json.Unmarshal(b, *v)
	case "HasMetadata":
		*v = new(NodeNodeHasMetadata)
		return json.Unmarshal(b, *v)
	case "HasSBOM":
		*v = new(NodeNodeHasSBOM)
		return json.Unmarshal(b, *v)
	case "HasSLSA":
		*v = new(NodeNodeHasSLSA)
		return json.Unmarshal(b, *v)
	case "HasSourceAt":
		*v = new(NodeNodeHasSourceAt)
		return json.Unmarshal(b, *v)
	case "HashEqual":
		*v = new(NodeNodeHashEqual)
		return json.Unmarshal(b, *v)
	case "IsDependency":
		*v = new(NodeNodeIsDependency)
		return json.Unmarshal(b, *v)
	case "IsOccurrence":
		*v = new(NodeNodeIsOccurrence)
		return json.Unmarshal(b, *v)
	case "License":
		*v = new(NodeNodeLicense)
		return json.Unmarshal(b, *v)
	case "Package":
		*v = new(NodeNodePackage)
		return json.Unmarshal(b, *v)
	case "PkgEqual":
		*v = new(NodeNodePkgEqual)
		return json.Unmarshal(b, *v)
	case "PointOfContact":
		*v = new(NodeNodePointOfContact)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(NodeNodeSource)
		return json.Unmarshal(b, *v)
	case "VulnEqual":
		*v = new(NodeNodeVulnEqual)
		return json.Unmarshal(b, *v)
	case "Vulnerability":
		*v = new(NodeNodeVulnerability)
		return json.Unmarshal(b, *v)
	case "VulnerabilityMetadata":
		*v = new(NodeNodeVulnerabilityMetadata)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing Node.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for NodeNode: "%v"`, tn.TypeName)
	}
}

func __marshalNodeNode(v *NodeNode) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *NodeNodeArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeBuilder:
		typename = "Builder"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeBuilder
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeCertifyBad:
		typename = "CertifyBad"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeCertifyBad
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeCertifyGood:
		typename = "CertifyGood"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeCertifyGood
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeCertifyLegal:
		typename = "CertifyLegal"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeCertifyLegal
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeCertifyScorecard:
		typename = "CertifyScorecard"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeCertifyScorecard
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeCertifyVEXStatement:
		typename = "CertifyVEXStatement"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeCertifyVEXStatement
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeCertifyVuln:
		typename = "CertifyVuln"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeCertifyVuln
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeHasMetadata:
		typename = "HasMetadata"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeHasMetadata
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeHasSBOM:
		typename = "HasSBOM"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeHasSBOM
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeHasSLSA:
		typename = "HasSLSA"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeHasSLSA
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeHasSourceAt:
		typename = "HasSourceAt"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeHasSourceAt
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeHashEqual:
		typename = "HashEqual"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeHashEqual
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeIsDependency:
		typename = "IsDependency"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeIsDependency
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeIsOccurrence:
		typename = "IsOccurrence"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeIsOccurrence
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeLicense:
		typename = "License"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeLicense
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodePackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodePackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodePkgEqual:
		typename = "PkgEqual"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodePkgEqual
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodePointOfContact:
		typename = "PointOfContact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodePointOfContact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeVulnEqual:
		typename = "VulnEqual"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeVulnEqual
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeVulnerability:
		typename = "Vulnerability"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeVulnerability
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodeNodeVulnerabilityMetadata:
		typename = "VulnerabilityMetadata"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodeNodeVulnerabilityMetadata
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for NodeNode: "%T"`, v)
	}
}

// NodeNodeArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type NodeNodeArtifact struct {
	Typename        *string `json:"__typename"`
	AllArtifactTree `json:"-"`
}

// GetTypename returns NodeNodeArtifact.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeArtifact) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeArtifact.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns NodeNodeArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *NodeNodeArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns NodeNodeArtifact.Digest, and is useful for accessing the field via an interface.
func (v *NodeNodeArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *NodeNodeArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeArtifact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *NodeNodeArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeArtifact) __premarshalJSON() (*__premarshalNodeNodeArtifact, error) {
	var retval __premarshalNodeNodeArtifact

	retval.Typename = v.Typename
	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// NodeNodeBuilder includes the requested fields of the GraphQL type Builder.
// The GraphQL type's documentation follows.
//
// Builder represents the builder (e.g., FRSCA or GitHub Actions).
//
// Currently builders are identified by the uri field.
type NodeNodeBuilder struct {
	Typename       *string `json:"__typename"`
	AllBuilderTree `json:"-"`
}

// GetTypename returns NodeNodeBuilder.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeBuilder) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeBuilder.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeBuilder) GetId() string { return v.AllBuilderTree.Id }

// GetUri returns NodeNodeBuilder.Uri, and is useful for accessing the field via an interface.
func (v *NodeNodeBuilder) GetUri() string { return v.AllBuilderTree.Uri }

func (v *NodeNodeBuilder) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeBuilder
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeBuilder = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllBuilderTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeBuilder struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Uri string `json:"uri"`
}

func (v *NodeNodeBuilder) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeBuilder) __premarshalJSON() (*__premarshalNodeNodeBuilder, error) {
	var retval __premarshalNodeNodeBuilder

	retval.Typename = v.Typename
	retval.Id = v.AllBuilderTree.Id
	retval.Uri = v.AllBuilderTree.Uri
	return &retval, nil
}

// NodeNodeCertifyBad includes the requested fields of the GraphQL type CertifyBad.
// The GraphQL type's documentation follows.
//
// CertifyBad is an attestation that a package, source, or artifact is considered
// bad.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The certification applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type NodeNodeCertifyBad struct {
	Typename      *string `json:"__typename"`
	AllCertifyBad `json:"-"`
}

// GetTypename returns NodeNodeCertifyBad.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyBad) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeCertifyBad.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyBad) GetId() string { return v.AllCertifyBad.Id }

// GetJustification returns NodeNodeCertifyBad.Justification, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyBad) GetJustification() string { return v.AllCertifyBad.Justification }

// GetSubject returns NodeNodeCertifyBad.Subject, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyBad) GetSubject() AllCertifyBadSubjectPackageSourceOrArtifact {
	return v.AllCertifyBad.Subject
}

// GetOrigin returns NodeNodeCertifyBad.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyBad) GetOrigin() string { return v.AllCertifyBad.Origin }

// GetCollector returns NodeNodeCertifyBad.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyBad) GetCollector() string { return v.AllCertifyBad.Collector }

func (v *NodeNodeCertifyBad) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeCertifyBad
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeCertifyBad = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyBad)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeCertifyBad struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodeCertifyBad) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeCertifyBad) __premarshalJSON() (*__premarshalNodeNodeCertifyBad, error) {
	var retval __premarshalNodeNodeCertifyBad

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyBad.Id
	retval.Justification = v.AllCertifyBad.Justification
	{

		dst := &retval.Subject
		src := v.AllCertifyBad.Subject
		var err error
		*dst, err = __marshalAllCertifyBadSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodeNodeCertifyBad.AllCertifyBad.Subject: %w", err)
		}
	}
	retval.Origin = v.AllCertifyBad.Origin
	retval.Collector = v.AllCertifyBad.Collector
	return &retval, nil
}

// NodeNodeCertifyGood includes the requested fields of the GraphQL type CertifyGood.
// The GraphQL type's documentation follows.
//
// CertifyGood is an attestation that a package, source, or artifact is considered
// good.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The certification applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type NodeNodeCertifyGood struct {
	Typename       *string `json:"__typename"`
	AllCertifyGood `json:"-"`
}

// GetTypename returns NodeNodeCertifyGood.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyGood) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeCertifyGood.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyGood) GetId() string { return v.AllCertifyGood.Id }

// GetJustification returns NodeNodeCertifyGood.Justification, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyGood) GetJustification() string { return v.AllCertifyGood.Justification }

// GetSubject returns NodeNodeCertifyGood.Subject, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyGood) GetSubject() AllCertifyGoodSubjectPackageSourceOrArtifact {
	return v.AllCertifyGood.Subject
}

// GetOrigin returns NodeNodeCertifyGood.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyGood) GetOrigin() string { return v.AllCertifyGood.Origin }

// GetCollector returns NodeNodeCertifyGood.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyGood) GetCollector() string { return v.AllCertifyGood.Collector }

func (v *NodeNodeCertifyGood) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeCertifyGood
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeCertifyGood = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyGood)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeCertifyGood struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodeCertifyGood) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeCertifyGood) __premarshalJSON() (*__premarshalNodeNodeCertifyGood, error) {
	var retval __premarshalNodeNodeCertifyGood

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyGood.Id
	retval.Justification = v.AllCertifyGood.Justification
	{

		dst := &retval.Subject
		src := v.AllCertifyGood.Subject
		var err error
		*dst, err = __marshalAllCertifyGoodSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodeNodeCertifyGood.AllCertifyGood.Subject: %w", err)
		}
	}
	retval.Origin = v.AllCertifyGood.Origin
	retval.Collector = v.AllCertifyGood.Collector
	return &retval, nil
}

// NodeNodeCertifyLegal includes the requested fields of the GraphQL type CertifyLegal.
// The GraphQL type's documentation follows.
//
// CertifyLegal is an attestation to attach legal information to a package or source.
//
// The certification information is either copied from an attestation found in an
// SBOM or created by a collector/scanner.
//
// Discovered license is also known as Concluded. More information:
// https://docs.clearlydefined.io/curation-guidelines#the-difference-between-declared-and-discovered-licenses
//
// Attribution is also known as Copyright Text. It is what could be displayed to
// comply with notice
// requirements. https://www.nexb.com/oss-attribution-best-practices/
//
// License expressions follow this format:
// https://spdx.github.io/spdx-spec/v2.3/SPDX-license-expressions/
type NodeNodeCertifyLegal struct {
	Typename            *string `json:"__typename"`
	AllCertifyLegalTree `json:"-"`
}

// GetTypename returns NodeNodeCertifyLegal.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyLegal) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeCertifyLegal.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyLegal) GetId() string { return v.AllCertifyLegalTree.Id }

// GetSubject returns NodeNodeCertifyLegal.Subject, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyLegal) GetSubject() AllCertifyLegalTreeSubjectPackageOrSource {
	return v.AllCertifyLegalTree.Subject
}

// GetDeclaredLicense returns NodeNodeCertifyLegal.DeclaredLicense, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyLegal) GetDeclaredLicense() string {
	return v.AllCertifyLegalTree.DeclaredLicense
}

// GetDeclaredLicenses returns NodeNodeCertifyLegal.DeclaredLicenses, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyLegal) GetDeclaredLicenses() []AllCertifyLegalTreeDeclaredLicensesLicense {
	return v.AllCertifyLegalTree.DeclaredLicenses
}

// GetDiscoveredLicense returns NodeNodeCertifyLegal.DiscoveredLicense, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyLegal) GetDiscoveredLicense() string {
	return v.AllCertifyLegalTree.DiscoveredLicense
}

// GetDiscoveredLicenses returns NodeNodeCertifyLegal.DiscoveredLicenses, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyLegal) GetDiscoveredLicenses() []AllCertifyLegalTreeDiscoveredLicensesLicense {
	return v.AllCertifyLegalTree.DiscoveredLicenses
}

// GetAttribution returns NodeNodeCertifyLegal.Attribution, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyLegal) GetAttribution() string { return v.AllCertifyLegalTree.Attribution }

// GetJustification returns NodeNodeCertifyLegal.Justification, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyLegal) GetJustification() string { return v.AllCertifyLegalTree.Justification }

// GetTimeScanned returns NodeNodeCertifyLegal.TimeScanned, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyLegal) GetTimeScanned() time.Time { return v.AllCertifyLegalTree.TimeScanned }

// GetOrigin returns NodeNodeCertifyLegal.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyLegal) GetOrigin() string { return v.AllCertifyLegalTree.Origin }

// GetCollector returns NodeNodeCertifyLegal.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyLegal) GetCollector() string { return v.AllCertifyLegalTree.Collector }

func (v *NodeNodeCertifyLegal) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeCertifyLegal
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeCertifyLegal = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyLegalTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeCertifyLegal struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	DeclaredLicense string `json:"declaredLicense"`

	DeclaredLicenses []AllCertifyLegalTreeDeclaredLicensesLicense `json:"declaredLicenses"`

	DiscoveredLicense string `json:"discoveredLicense"`

	DiscoveredLicenses []AllCertifyLegalTreeDiscoveredLicensesLicense `json:"discoveredLicenses"`

	Attribution string `json:"attribution"`

	Justification string `json:"justification"`

	TimeScanned time.Time `json:"timeScanned"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodeCertifyLegal) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeCertifyLegal) __premarshalJSON() (*__premarshalNodeNodeCertifyLegal, error) {
	var retval __premarshalNodeNodeCertifyLegal

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyLegalTree.Id
	{

		dst := &retval.Subject
		src := v.AllCertifyLegalTree.Subject
		var err error
		*dst, err = __marshalAllCertifyLegalTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodeNodeCertifyLegal.AllCertifyLegalTree.Subject: %w", err)
		}
	}
	retval.DeclaredLicense = v.AllCertifyLegalTree.DeclaredLicense
	retval.DeclaredLicenses = v.AllCertifyLegalTree.DeclaredLicenses
	retval.DiscoveredLicense = v.AllCertifyLegalTree.DiscoveredLicense
	retval.DiscoveredLicenses = v.AllCertifyLegalTree.DiscoveredLicenses
	retval.Attribution = v.AllCertifyLegalTree.Attribution
	retval.Justification = v.AllCertifyLegalTree.Justification
	retval.TimeScanned = v.AllCertifyLegalTree.TimeScanned
	retval.Origin = v.AllCertifyLegalTree.Origin
	retval.Collector = v.AllCertifyLegalTree.Collector
	return &retval, nil
}

// NodeNodeCertifyScorecard includes the requested fields of the GraphQL type CertifyScorecard.
// The GraphQL type's documentation follows.
//
// CertifyScorecard is an attestation to attach a Scorecard analysis to a
// particular source repository.
type NodeNodeCertifyScorecard struct {
	Typename            *string `json:"__typename"`
	AllCertifyScorecard `json:"-"`
}

// GetTypename returns NodeNodeCertifyScorecard.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyScorecard) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeCertifyScorecard.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyScorecard) GetId() string { return v.AllCertifyScorecard.Id }

// GetSource returns NodeNodeCertifyScorecard.Source, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyScorecard) GetSource() AllCertifyScorecardSource {
	return v.AllCertifyScorecard.Source
}

// GetScorecard returns NodeNodeCertifyScorecard.Scorecard, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyScorecard) GetScorecard() AllCertifyScorecardScorecard {
	return v.AllCertifyScorecard.Scorecard
}

func (v *NodeNodeCertifyScorecard) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeCertifyScorecard
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeCertifyScorecard = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyScorecard)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeCertifyScorecard struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Source AllCertifyScorecardSource `json:"source"`

	Scorecard AllCertifyScorecardScorecard `json:"scorecard"`
}

func (v *NodeNodeCertifyScorecard) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeCertifyScorecard) __premarshalJSON() (*__premarshalNodeNodeCertifyScorecard, error) {
	var retval __premarshalNodeNodeCertifyScorecard

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyScorecard.Id
	retval.Source = v.AllCertifyScorecard.Source
	retval.Scorecard = v.AllCertifyScorecard.Scorecard
	return &retval, nil
}

// NodeNodeCertifyVEXStatement includes the requested fields of the GraphQL type CertifyVEXStatement.
// The GraphQL type's documentation follows.
//
// CertifyVEXStatement is an attestation to attach VEX statements to a package or
// artifact to clarify the impact of a specific vulnerability.
type NodeNodeCertifyVEXStatement struct {
	Typename               *string `json:"__typename"`
	AllCertifyVEXStatement `json:"-"`
}

// GetTypename returns NodeNodeCertifyVEXStatement.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVEXStatement) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeCertifyVEXStatement.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVEXStatement) GetId() string { return v.AllCertifyVEXStatement.Id }

// GetSubject returns NodeNodeCertifyVEXStatement.Subject, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVEXStatement) GetSubject() AllCertifyVEXStatementSubjectPackageOrArtifact {
	return v.AllCertifyVEXStatement.Subject
}

// GetVulnerability returns NodeNodeCertifyVEXStatement.Vulnerability, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVEXStatement) GetVulnerability() AllCertifyVEXStatementVulnerability {
	return v.AllCertifyVEXStatement.Vulnerability
}

// GetStatus returns NodeNodeCertifyVEXStatement.Status, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVEXStatement) GetStatus() VexStatus { return v.AllCertifyVEXStatement.Status }

// GetVexJustification returns NodeNodeCertifyVEXStatement.VexJustification, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVEXStatement) GetVexJustification() VexJustification {
	return v.AllCertifyVEXStatement.VexJustification
}

// GetStatement returns NodeNodeCertifyVEXStatement.Statement, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVEXStatement) GetStatement() string {
	return v.AllCertifyVEXStatement.Statement
}

// GetStatusNotes returns NodeNodeCertifyVEXStatement.StatusNotes, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVEXStatement) GetStatusNotes() string {
	return v.AllCertifyVEXStatement.StatusNotes
}

// GetKnownSince returns NodeNodeCertifyVEXStatement.KnownSince, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVEXStatement) GetKnownSince() time.Time {
	return v.AllCertifyVEXStatement.KnownSince
}

// GetOrigin returns NodeNodeCertifyVEXStatement.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVEXStatement) GetOrigin() string { return v.AllCertifyVEXStatement.Origin }

// GetCollector returns NodeNodeCertifyVEXStatement.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVEXStatement) GetCollector() string {
	return v.AllCertifyVEXStatement.Collector
}

func (v *NodeNodeCertifyVEXStatement) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeCertifyVEXStatement
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeCertifyVEXStatement = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyVEXStatement)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeCertifyVEXStatement struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Vulnerability AllCertifyVEXStatementVulnerability `json:"vulnerability"`

	Status VexStatus `json:"status"`

	VexJustification VexJustification `json:"vexJustification"`

	Statement string `json:"statement"`

	StatusNotes string `json:"statusNotes"`

	KnownSince time.Time `json:"knownSince"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodeCertifyVEXStatement) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeCertifyVEXStatement) __premarshalJSON() (*__premarshalNodeNodeCertifyVEXStatement, error) {
	var retval __premarshalNodeNodeCertifyVEXStatement

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyVEXStatement.Id
	{

		dst := &retval.Subject
		src := v.AllCertifyVEXStatement.Subject
		var err error
		*dst, err = __marshalAllCertifyVEXStatementSubjectPackageOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodeNodeCertifyVEXStatement.AllCertifyVEXStatement.Subject: %w", err)
		}
	}
	retval.Vulnerability = v.AllCertifyVEXStatement.Vulnerability
	retval.Status = v.AllCertifyVEXStatement.Status
	retval.VexJustification = v.AllCertifyVEXStatement.VexJustification
	retval.Statement = v.AllCertifyVEXStatement.Statement
	retval.StatusNotes = v.AllCertifyVEXStatement.StatusNotes
	retval.KnownSince = v.AllCertifyVEXStatement.KnownSince
	retval.Origin = v.AllCertifyVEXStatement.Origin
	retval.Collector = v.AllCertifyVEXStatement.Collector
	return &retval, nil
}

// NodeNodeCertifyVuln includes the requested fields of the GraphQL type CertifyVuln.
// The GraphQL type's documentation follows.
//
// CertifyVuln is an attestation to attach vulnerability information to a package.
//
// This information is obtained via a scanner. If there is no vulnerability
// detected, we attach the a vulnerability with "NoVuln" type and an empty string
// for the vulnerability ID.
type NodeNodeCertifyVuln struct {
	Typename       *string `json:"__typename"`
	AllCertifyVuln `json:"-"`
}

// GetTypename returns NodeNodeCertifyVuln.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVuln) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeCertifyVuln.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVuln) GetId() string { return v.AllCertifyVuln.Id }

// GetPackage returns NodeNodeCertifyVuln.Package, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVuln) GetPackage() AllCertifyVulnPackage { return v.AllCertifyVuln.Package }

// GetVulnerability returns NodeNodeCertifyVuln.Vulnerability, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVuln) GetVulnerability() AllCertifyVulnVulnerability {
	return v.AllCertifyVuln.Vulnerability
}

// GetMetadata returns NodeNodeCertifyVuln.Metadata, and is useful for accessing the field via an interface.
func (v *NodeNodeCertifyVuln) GetMetadata() AllCertifyVulnMetadataScanMetadata {
	return v.AllCertifyVuln.Metadata
}

func (v *NodeNodeCertifyVuln) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeCertifyVuln
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeCertifyVuln = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyVuln)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeCertifyVuln struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Package AllCertifyVulnPackage `json:"package"`

	Vulnerability AllCertifyVulnVulnerability `json:"vulnerability"`

	Metadata AllCertifyVulnMetadataScanMetadata `json:"metadata"`
}

func (v *NodeNodeCertifyVuln) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeCertifyVuln) __premarshalJSON() (*__premarshalNodeNodeCertifyVuln, error) {
	var retval __premarshalNodeNodeCertifyVuln

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyVuln.Id
	retval.Package = v.AllCertifyVuln.Package
	retval.Vulnerability = v.AllCertifyVuln.Vulnerability
	retval.Metadata = v.AllCertifyVuln.Metadata
	return &retval, nil
}

// NodeNodeHasMetadata includes the requested fields of the GraphQL type HasMetadata.
// The GraphQL type's documentation follows.
//
// HasMetadata is an attestation that a package, source, or artifact has a certain
// attested property (key) with value (value). For example, a source may have
// metadata "SourceRepo2FAEnabled=true".
//
// The intent of this evidence tree predicate is to allow extensibility of metadata
// expressible within the GUAC ontology. Metadata that is commonly used will then
// be promoted to a predicate on its own.
//
// Justification indicates how the metadata was determined.
//
// The metadata applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type NodeNodeHasMetadata struct {
	Typename       *string `json:"__typename"`
	AllHasMetadata `json:"-"`
}

// GetTypename returns NodeNodeHasMetadata.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeHasMetadata) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeHasMetadata.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeHasMetadata) GetId() string { return v.AllHasMetadata.Id }

// GetSubject returns NodeNodeHasMetadata.Subject, and is useful for accessing the field via an interface.
func (v *NodeNodeHasMetadata) GetSubject() AllHasMetadataSubjectPackageSourceOrArtifact {
	return v.AllHasMetadata.Subject
}

// GetKey returns NodeNodeHasMetadata.Key, and is useful for accessing the field via an interface.
func (v *NodeNodeHasMetadata) GetKey() string { return v.AllHasMetadata.Key }

// GetValue returns NodeNodeHasMetadata.Value, and is useful for accessing the field via an interface.
func (v *NodeNodeHasMetadata) GetValue() string { return v.AllHasMetadata.Value }

// GetTimestamp returns NodeNodeHasMetadata.Timestamp, and is useful for accessing the field via an interface.
func (v *NodeNodeHasMetadata) GetTimestamp() time.Time { return v.AllHasMetadata.Timestamp }

// GetJustification returns NodeNodeHasMetadata.Justification, and is useful for accessing the field via an interface.
func (v *NodeNodeHasMetadata) GetJustification() string { return v.AllHasMetadata.Justification }

// GetOrigin returns NodeNodeHasMetadata.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodeHasMetadata) GetOrigin() string { return v.AllHasMetadata.Origin }

// GetCollector returns NodeNodeHasMetadata.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodeHasMetadata) GetCollector() string { return v.AllHasMetadata.Collector }

func (v *NodeNodeHasMetadata) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeHasMetadata
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeHasMetadata = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHasMetadata)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeHasMetadata struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Key string `json:"key"`

	Value string `json:"value"`

	Timestamp time.Time `json:"timestamp"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodeHasMetadata) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeHasMetadata) __premarshalJSON() (*__premarshalNodeNodeHasMetadata, error) {
	var retval __premarshalNodeNodeHasMetadata

	retval.Typename = v.Typename
	retval.Id = v.AllHasMetadata.Id
	{

		dst := &retval.Subject
		src := v.AllHasMetadata.Subject
		var err error
		*dst, err = __marshalAllHasMetadataSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodeNodeHasMetadata.AllHasMetadata.Subject: %w", err)
		}
	}
	retval.Key = v.AllHasMetadata.Key
	retval.Value = v.AllHasMetadata.Value
	retval.Timestamp = v.AllHasMetadata.Timestamp
	retval.Justification = v.AllHasMetadata.Justification
	retval.Origin = v.AllHasMetadata.Origin
	retval.Collector = v.AllHasMetadata.Collector
	return &retval, nil
}

// NodeNodeHasSBOM includes the requested fields of the GraphQL type HasSBOM.
type NodeNodeHasSBOM struct {
	Typename       *string `json:"__typename"`
	AllHasSBOMTree `json:"-"`
}

// GetTypename returns NodeNodeHasSBOM.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSBOM) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeHasSBOM.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSBOM) GetId() string { return v.AllHasSBOMTree.Id }

// GetSubject returns NodeNodeHasSBOM.Subject, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSBOM) GetSubject() AllHasSBOMTreeSubjectPackageOrArtifact {
	return v.AllHasSBOMTree.Subject
}

// GetUri returns NodeNodeHasSBOM.Uri, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSBOM) GetUri() string { return v.AllHasSBOMTree.Uri }

// GetAlgorithm returns NodeNodeHasSBOM.Algorithm, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSBOM) GetAlgorithm() string { return v.AllHasSBOMTree.Algorithm }

// GetDigest returns NodeNodeHasSBOM.Digest, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSBOM) GetDigest() string { return v.AllHasSBOMTree.Digest }

// GetDownloadLocation returns NodeNodeHasSBOM.DownloadLocation, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSBOM) GetDownloadLocation() string { return v.AllHasSBOMTree.DownloadLocation }

// GetOrigin returns NodeNodeHasSBOM.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSBOM) GetOrigin() string { return v.AllHasSBOMTree.Origin }

// GetCollector returns NodeNodeHasSBOM.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSBOM) GetCollector() string { return v.AllHasSBOMTree.Collector }

func (v *NodeNodeHasSBOM) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeHasSBOM
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeHasSBOM = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHasSBOMTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeHasSBOM struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Uri string `json:"uri"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`

	DownloadLocation string `json:"downloadLocation"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodeHasSBOM) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeHasSBOM) __premarshalJSON() (*__premarshalNodeNodeHasSBOM, error) {
	var retval __premarshalNodeNodeHasSBOM

	retval.Typename = v.Typename
	retval.Id = v.AllHasSBOMTree.Id
	{

		dst := &retval.Subject
		src := v.AllHasSBOMTree.Subject
		var err error
		*dst, err = __marshalAllHasSBOMTreeSubjectPackageOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodeNodeHasSBOM.AllHasSBOMTree.Subject: %w", err)
		}
	}
	retval.Uri = v.AllHasSBOMTree.Uri
	retval.Algorithm = v.AllHasSBOMTree.Algorithm
	retval.Digest = v.AllHasSBOMTree.Digest
	retval.DownloadLocation = v.AllHasSBOMTree.DownloadLocation
	retval.Origin = v.AllHasSBOMTree.Origin
	retval.Collector = v.AllHasSBOMTree.Collector
	return &retval, nil
}

// NodeNodeHasSLSA includes the requested fields of the GraphQL type HasSLSA.
// The GraphQL type's documentation follows.
//
// HasSLSA records that a subject node has a SLSA attestation.
type NodeNodeHasSLSA struct {
	Typename    *string `json:"__typename"`
	AllSLSATree `json:"-"`
}

// GetTypename returns NodeNodeHasSLSA.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSLSA) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeHasSLSA.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSLSA) GetId() string { return v.AllSLSATree.Id }

// GetSubject returns NodeNodeHasSLSA.Subject, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSLSA) GetSubject() AllSLSATreeSubjectArtifact { return v.AllSLSATree.Subject }

// GetSlsa returns NodeNodeHasSLSA.Slsa, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSLSA) GetSlsa() AllSLSATreeSlsaSLSA { return v.AllSLSATree.Slsa }

func (v *NodeNodeHasSLSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeHasSLSA
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeHasSLSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSLSATree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeHasSLSA struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject AllSLSATreeSubjectArtifact `json:"subject"`

	Slsa AllSLSATreeSlsaSLSA `json:"slsa"`
}

func (v *NodeNodeHasSLSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeHasSLSA) __premarshalJSON() (*__premarshalNodeNodeHasSLSA, error) {
	var retval __premarshalNodeNodeHasSLSA

	retval.Typename = v.Typename
	retval.Id = v.AllSLSATree.Id
	retval.Subject = v.AllSLSATree.Subject
	retval.Slsa = v.AllSLSATree.Slsa
	return &retval, nil
}

// NodeNodeHasSourceAt includes the requested fields of the GraphQL type HasSourceAt.
// The GraphQL type's documentation follows.
//
// HasSourceAt records that a package's repository is a given source.
type NodeNodeHasSourceAt struct {
	Typename       *string `json:"__typename"`
	AllHasSourceAt `json:"-"`
}

// GetTypename returns NodeNodeHasSourceAt.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSourceAt) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeHasSourceAt.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSourceAt) GetId() string { return v.AllHasSourceAt.Id }

// GetJustification returns NodeNodeHasSourceAt.Justification, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSourceAt) GetJustification() string { return v.AllHasSourceAt.Justification }

// GetKnownSince returns NodeNodeHasSourceAt.KnownSince, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSourceAt) GetKnownSince() time.Time { return v.AllHasSourceAt.KnownSince }

// GetPackage returns NodeNodeHasSourceAt.Package, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSourceAt) GetPackage() AllHasSourceAtPackage { return v.AllHasSourceAt.Package }

// GetSource returns NodeNodeHasSourceAt.Source, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSourceAt) GetSource() AllHasSourceAtSource { return v.AllHasSourceAt.Source }

// GetOrigin returns NodeNodeHasSourceAt.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSourceAt) GetOrigin() string { return v.AllHasSourceAt.Origin }

// GetCollector returns NodeNodeHasSourceAt.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodeHasSourceAt) GetCollector() string { return v.AllHasSourceAt.Collector }

func (v *NodeNodeHasSourceAt) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeHasSourceAt
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeHasSourceAt = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHasSourceAt)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeHasSourceAt struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	KnownSince time.Time `json:"knownSince"`

	Package AllHasSourceAtPackage `json:"package"`

	Source AllHasSourceAtSource `json:"source"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodeHasSourceAt) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeHasSourceAt) __premarshalJSON() (*__premarshalNodeNodeHasSourceAt, error) {
	var retval __premarshalNodeNodeHasSourceAt

	retval.Typename = v.Typename
	retval.Id = v.AllHasSourceAt.Id
	retval.Justification = v.AllHasSourceAt.Justification
	retval.KnownSince = v.AllHasSourceAt.KnownSince
	retval.Package = v.AllHasSourceAt.Package
	retval.Source = v.AllHasSourceAt.Source
	retval.Origin = v.AllHasSourceAt.Origin
	retval.Collector = v.AllHasSourceAt.Collector
	return &retval, nil
}

// NodeNodeHashEqual includes the requested fields of the GraphQL type HashEqual.
// The GraphQL type's documentation follows.
//
// HashEqual is an attestation that a set of artifacts are identical.
type NodeNodeHashEqual struct {
	Typename         *string `json:"__typename"`
	AllHashEqualTree `json:"-"`
}

// GetTypename returns NodeNodeHashEqual.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeHashEqual) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeHashEqual.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeHashEqual) GetId() string { return v.AllHashEqualTree.Id }

// GetJustification returns NodeNodeHashEqual.Justification, and is useful for accessing the field via an interface.
func (v *NodeNodeHashEqual) GetJustification() string { return v.AllHashEqualTree.Justification }

// GetArtifacts returns NodeNodeHashEqual.Artifacts, and is useful for accessing the field via an interface.
func (v *NodeNodeHashEqual) GetArtifacts() []AllHashEqualTreeArtifactsArtifact {
	return v.AllHashEqualTree.Artifacts
}

// GetOrigin returns NodeNodeHashEqual.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodeHashEqual) GetOrigin() string { return v.AllHashEqualTree.Origin }

// GetCollector returns NodeNodeHashEqual.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodeHashEqual) GetCollector() string { return v.AllHashEqualTree.Collector }

func (v *NodeNodeHashEqual) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeHashEqual
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeHashEqual = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHashEqualTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeHashEqual struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Artifacts []AllHashEqualTreeArtifactsArtifact `json:"artifacts"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodeHashEqual) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeHashEqual) __premarshalJSON() (*__premarshalNodeNodeHashEqual, error) {
	var retval __premarshalNodeNodeHashEqual

	retval.Typename = v.Typename
	retval.Id = v.AllHashEqualTree.Id
	retval.Justification = v.AllHashEqualTree.Justification
	retval.Artifacts = v.AllHashEqualTree.Artifacts
	retval.Origin = v.AllHashEqualTree.Origin
	retval.Collector = v.AllHashEqualTree.Collector
	return &retval, nil
}

// NodeNodeIsDependency includes the requested fields of the GraphQL type IsDependency.
// The GraphQL type's documentation follows.
//
// IsDependency is an attestation to record that a package depends on another.
type NodeNodeIsDependency struct {
	Typename            *string `json:"__typename"`
	AllIsDependencyTree `json:"-"`
}

// GetTypename returns NodeNodeIsDependency.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeIsDependency) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeIsDependency.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeIsDependency) GetId() string { return v.AllIsDependencyTree.Id }

// GetJustification returns NodeNodeIsDependency.Justification, and is useful for accessing the field via an interface.
func (v *NodeNodeIsDependency) GetJustification() string { return v.AllIsDependencyTree.Justification }

// GetPackage returns NodeNodeIsDependency.Package, and is useful for accessing the field via an interface.
func (v *NodeNodeIsDependency) GetPackage() AllIsDependencyTreePackage {
	return v.AllIsDependencyTree.Package
}

// GetDependentPackage returns NodeNodeIsDependency.DependentPackage, and is useful for accessing the field via an interface.
func (v *NodeNodeIsDependency) GetDependentPackage() AllIsDependencyTreeDependentPackage {
	return v.AllIsDependencyTree.DependentPackage
}

// GetDependencyType returns NodeNodeIsDependency.DependencyType, and is useful for accessing the field via an interface.
func (v *NodeNodeIsDependency) GetDependencyType() DependencyType {
	return v.AllIsDependencyTree.DependencyType
}

// GetVersionRange returns NodeNodeIsDependency.VersionRange, and is useful for accessing the field via an interface.
func (v *NodeNodeIsDependency) GetVersionRange() string { return v.AllIsDependencyTree.VersionRange }

// GetOrigin returns NodeNodeIsDependency.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodeIsDependency) GetOrigin() string { return v.AllIsDependencyTree.Origin }

// GetCollector returns NodeNodeIsDependency.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodeIsDependency) GetCollector() string { return v.AllIsDependencyTree.Collector }

func (v *NodeNodeIsDependency) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeIsDependency
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeIsDependency = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllIsDependencyTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeIsDependency struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Package AllIsDependencyTreePackage `json:"package"`

	DependentPackage AllIsDependencyTreeDependentPackage `json:"dependentPackage"`

	DependencyType DependencyType `json:"dependencyType"`

	VersionRange string `json:"versionRange"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodeIsDependency) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeIsDependency) __premarshalJSON() (*__premarshalNodeNodeIsDependency, error) {
	var retval __premarshalNodeNodeIsDependency

	retval.Typename = v.Typename
	retval.Id = v.AllIsDependencyTree.Id
	retval.Justification = v.AllIsDependencyTree.Justification
	retval.Package = v.AllIsDependencyTree.Package
	retval.DependentPackage = v.AllIsDependencyTree.DependentPackage
	retval.DependencyType = v.AllIsDependencyTree.DependencyType
	retval.VersionRange = v.AllIsDependencyTree.VersionRange
	retval.Origin = v.AllIsDependencyTree.Origin
	retval.Collector = v.AllIsDependencyTree.Collector
	return &retval, nil
}

// NodeNodeIsOccurrence includes the requested fields of the GraphQL type IsOccurrence.
// The GraphQL type's documentation follows.
//
// IsOccurrence is an attestation to link an artifact to a package or source.
//
// Attestation must occur at the PackageVersion or at the SourceName.
type NodeNodeIsOccurrence struct {
	Typename             *string `json:"__typename"`
	AllIsOccurrencesTree `json:"-"`
}

// GetTypename returns NodeNodeIsOccurrence.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeIsOccurrence) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeIsOccurrence.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeIsOccurrence) GetId() string { return v.AllIsOccurrencesTree.Id }

// GetSubject returns NodeNodeIsOccurrence.Subject, and is useful for accessing the field via an interface.
func (v *NodeNodeIsOccurrence) GetSubject() AllIsOccurrencesTreeSubjectPackageOrSource {
	return v.AllIsOccurrencesTree.Subject
}

// GetArtifact returns NodeNodeIsOccurrence.Artifact, and is useful for accessing the field via an interface.
func (v *NodeNodeIsOccurrence) GetArtifact() AllIsOccurrencesTreeArtifact {
	return v.AllIsOccurrencesTree.Artifact
}

// GetJustification returns NodeNodeIsOccurrence.Justification, and is useful for accessing the field via an interface.
func (v *NodeNodeIsOccurrence) GetJustification() string { return v.AllIsOccurrencesTree.Justification }

// GetOrigin returns NodeNodeIsOccurrence.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodeIsOccurrence) GetOrigin() string { return v.AllIsOccurrencesTree.Origin }

// GetCollector returns NodeNodeIsOccurrence.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodeIsOccurrence) GetCollector() string { return v.AllIsOccurrencesTree.Collector }

func (v *NodeNodeIsOccurrence) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeIsOccurrence
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeIsOccurrence = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllIsOccurrencesTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeIsOccurrence struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Artifact AllIsOccurrencesTreeArtifact `json:"artifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodeIsOccurrence) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeIsOccurrence) __premarshalJSON() (*__premarshalNodeNodeIsOccurrence, error) {
	var retval __premarshalNodeNodeIsOccurrence

	retval.Typename = v.Typename
	retval.Id = v.AllIsOccurrencesTree.Id
	{

		dst := &retval.Subject
		src := v.AllIsOccurrencesTree.Subject
		var err error
		*dst, err = __marshalAllIsOccurrencesTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodeNodeIsOccurrence.AllIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.Artifact = v.AllIsOccurrencesTree.Artifact
	retval.Justification = v.AllIsOccurrencesTree.Justification
	retval.Origin = v.AllIsOccurrencesTree.Origin
	retval.Collector = v.AllIsOccurrencesTree.Collector
	return &retval, nil
}

// NodeNodeLicense includes the requested fields of the GraphQL type License.
// The GraphQL type's documentation follows.
//
// License represents a particular license. If the license is found on the SPDX
// license list (https://spdx.org/licenses/) then the fields should be:
//
// Name: SPDX license identifier
// Inline: empty
// ListVersion: SPDX license list version
//
// example:
//
// Name: AGPL-3.0-or-later
// Inline: ""
// ListVersion: 3.21 2023-06-18
//
// If the license is not on the SPDX license list, then a new guid should be
// created and the license text placed inline:
//
// Name: LicenseRef-<guid>
// Inline: Full license text
// ListVersion: empty
//
// example:
//
// Name: LicenseRef-1a2b3c
// Inline: Permission to use, copy, modify, and/or distribute ...
// ListVersion: ""
type NodeNodeLicense struct {
	Typename       *string `json:"__typename"`
	AllLicenseTree `json:"-"`
}

// GetTypename returns NodeNodeLicense.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeLicense) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeLicense.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeLicense) GetId() string { return v.AllLicenseTree.Id }

// GetName returns NodeNodeLicense.Name, and is useful for accessing the field via an interface.
func (v *NodeNodeLicense) GetName() string { return v.AllLicenseTree.Name }

// GetInline returns NodeNodeLicense.Inline, and is useful for accessing the field via an interface.
func (v *NodeNodeLicense) GetInline() *string { return v.AllLicenseTree.Inline }

// GetListVersion returns NodeNodeLicense.ListVersion, and is useful for accessing the field via an interface.
func (v *NodeNodeLicense) GetListVersion() *string { return v.AllLicenseTree.ListVersion }

func (v *NodeNodeLicense) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeLicense
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeLicense = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllLicenseTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeLicense struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Name string `json:"name"`

	Inline *string `json:"inline"`

	ListVersion *string `json:"listVersion"`
}

func (v *NodeNodeLicense) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeLicense) __premarshalJSON() (*__premarshalNodeNodeLicense, error) {
	var retval __premarshalNodeNodeLicense

	retval.Typename = v.Typename
	retval.Id = v.AllLicenseTree.Id
	retval.Name = v.AllLicenseTree.Name
	retval.Inline = v.AllLicenseTree.Inline
	retval.ListVersion = v.AllLicenseTree.ListVersion
	return &retval, nil
}

// NodeNodePackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type NodeNodePackage struct {
	Typename   *string `json:"__typename"`
	AllPkgTree `json:"-"`
}

// GetTypename returns NodeNodePackage.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodePackage) GetTypename() *string { return v.Typename }

// GetId returns NodeNodePackage.Id, and is useful for accessing the field via an interface.
func (v *NodeNodePackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns NodeNodePackage.Type, and is useful for accessing the field via an interface.
func (v *NodeNodePackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns NodeNodePackage.Namespaces, and is useful for accessing the field via an interface.
func (v *NodeNodePackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *NodeNodePackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodePackage
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodePackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodePackage struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *NodeNodePackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodePackage) __premarshalJSON() (*__premarshalNodeNodePackage, error) {
	var retval __premarshalNodeNodePackage

	retval.Typename = v.Typename
	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// NodeNodePkgEqual includes the requested fields of the GraphQL type PkgEqual.
// The GraphQL type's documentation follows.
//
// PkgEqual is an attestation that a set of packages are similar.
type NodeNodePkgEqual struct {
	Typename    *string `json:"__typename"`
	AllPkgEqual `json:"-"`
}

// GetTypename returns NodeNodePkgEqual.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodePkgEqual) GetTypename() *string { return v.Typename }

// GetId returns NodeNodePkgEqual.Id, and is useful for accessing the field via an interface.
func (v *NodeNodePkgEqual) GetId() string { return v.AllPkgEqual.Id }

// GetJustification returns NodeNodePkgEqual.Justification, and is useful for accessing the field via an interface.
func (v *NodeNodePkgEqual) GetJustification() string { return v.AllPkgEqual.Justification }

// GetPackages returns NodeNodePkgEqual.Packages, and is useful for accessing the field via an interface.
func (v *NodeNodePkgEqual) GetPackages() []AllPkgEqualPackagesPackage { return v.AllPkgEqual.Packages }

// GetOrigin returns NodeNodePkgEqual.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodePkgEqual) GetOrigin() string { return v.AllPkgEqual.Origin }

// GetCollector returns NodeNodePkgEqual.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodePkgEqual) GetCollector() string { return v.AllPkgEqual.Collector }

func (v *NodeNodePkgEqual) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodePkgEqual
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodePkgEqual = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgEqual)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodePkgEqual struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Packages []AllPkgEqualPackagesPackage `json:"packages"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodePkgEqual) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodePkgEqual) __premarshalJSON() (*__premarshalNodeNodePkgEqual, error) {
	var retval __premarshalNodeNodePkgEqual

	retval.Typename = v.Typename
	retval.Id = v.AllPkgEqual.Id
	retval.Justification = v.AllPkgEqual.Justification
	retval.Packages = v.AllPkgEqual.Packages
	retval.Origin = v.AllPkgEqual.Origin
	retval.Collector = v.AllPkgEqual.Collector
	return &retval, nil
}

// NodeNodePointOfContact includes the requested fields of the GraphQL type PointOfContact.
// The GraphQL type's documentation follows.
//
// PointOfContact is an attestation of how to get in touch with the person(s) responsible
// for a package, source, or artifact.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The attestation applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
//
// email is the email address (singular) of the point of contact.
//
// info is additional contact information other than email address. This is free
// form.
//
// NOTE: the identifiers for point of contact should be part of software trees.
// This will benefit from identifier look up and traversal as well as organization
// hierarchy. However, until the use case arises, PointOfContact will be a flat
// reference to the contact details.
type NodeNodePointOfContact struct {
	Typename          *string `json:"__typename"`
	AllPointOfContact `json:"-"`
}

// GetTypename returns NodeNodePointOfContact.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodePointOfContact) GetTypename() *string { return v.Typename }

// GetId returns NodeNodePointOfContact.Id, and is useful for accessing the field via an interface.
func (v *NodeNodePointOfContact) GetId() string { return v.AllPointOfContact.Id }

// GetSubject returns NodeNodePointOfContact.Subject, and is useful for accessing the field via an interface.
func (v *NodeNodePointOfContact) GetSubject() AllPointOfContactSubjectPackageSourceOrArtifact {
	return v.AllPointOfContact.Subject
}

// GetEmail returns NodeNodePointOfContact.Email, and is useful for accessing the field via an interface.
func (v *NodeNodePointOfContact) GetEmail() string { return v.AllPointOfContact.Email }

// GetInfo returns NodeNodePointOfContact.Info, and is useful for accessing the field via an interface.
func (v *NodeNodePointOfContact) GetInfo() string { return v.AllPointOfContact.Info }

// GetSince returns NodeNodePointOfContact.Since, and is useful for accessing the field via an interface.
func (v *NodeNodePointOfContact) GetSince() time.Time { return v.AllPointOfContact.Since }

// GetJustification returns NodeNodePointOfContact.Justification, and is useful for accessing the field via an interface.
func (v *NodeNodePointOfContact) GetJustification() string { return v.AllPointOfContact.Justification }

// GetOrigin returns NodeNodePointOfContact.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodePointOfContact) GetOrigin() string { return v.AllPointOfContact.Origin }

// GetCollector returns NodeNodePointOfContact.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodePointOfContact) GetCollector() string { return v.AllPointOfContact.Collector }

func (v *NodeNodePointOfContact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodePointOfContact
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodePointOfContact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPointOfContact)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodePointOfContact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Email string `json:"email"`

	Info string `json:"info"`

	Since time.Time `json:"since"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodePointOfContact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodePointOfContact) __premarshalJSON() (*__premarshalNodeNodePointOfContact, error) {
	var retval __premarshalNodeNodePointOfContact

	retval.Typename = v.Typename
	retval.Id = v.AllPointOfContact.Id
	{

		dst := &retval.Subject
		src := v.AllPointOfContact.Subject
		var err error
		*dst, err = __marshalAllPointOfContactSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodeNodePointOfContact.AllPointOfContact.Subject: %w", err)
		}
	}
	retval.Email = v.AllPointOfContact.Email
	retval.Info = v.AllPointOfContact.Info
	retval.Since = v.AllPointOfContact.Since
	retval.Justification = v.AllPointOfContact.Justification
	retval.Origin = v.AllPointOfContact.Origin
	retval.Collector = v.AllPointOfContact.Collector
	return &retval, nil
}

// NodeNodeSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type NodeNodeSource struct {
	Typename      *string `json:"__typename"`
	AllSourceTree `json:"-"`
}

// GetTypename returns NodeNodeSource.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeSource) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeSource.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns NodeNodeSource.Type, and is useful for accessing the field via an interface.
func (v *NodeNodeSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns NodeNodeSource.Namespaces, and is useful for accessing the field via an interface.
func (v *NodeNodeSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *NodeNodeSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeSource
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeSource struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *NodeNodeSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeSource) __premarshalJSON() (*__premarshalNodeNodeSource, error) {
	var retval __premarshalNodeNodeSource

	retval.Typename = v.Typename
	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// NodeNodeVulnEqual includes the requested fields of the GraphQL type VulnEqual.
// The GraphQL type's documentation follows.
//
// VulnEqual is an attestation to link two vulnerabilities together as being equal"
//
// Note that setting noVuln vulnerability type is invalid for VulnEqual!
type NodeNodeVulnEqual struct {
	Typename     *string `json:"__typename"`
	AllVulnEqual `json:"-"`
}

// GetTypename returns NodeNodeVulnEqual.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnEqual) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeVulnEqual.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnEqual) GetId() string { return v.AllVulnEqual.Id }

// GetVulnerabilities returns NodeNodeVulnEqual.Vulnerabilities, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnEqual) GetVulnerabilities() []AllVulnEqualVulnerabilitiesVulnerability {
	return v.AllVulnEqual.Vulnerabilities
}

// GetJustification returns NodeNodeVulnEqual.Justification, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnEqual) GetJustification() string { return v.AllVulnEqual.Justification }

// GetOrigin returns NodeNodeVulnEqual.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnEqual) GetOrigin() string { return v.AllVulnEqual.Origin }

// GetCollector returns NodeNodeVulnEqual.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnEqual) GetCollector() string { return v.AllVulnEqual.Collector }

func (v *NodeNodeVulnEqual) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeVulnEqual
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeVulnEqual = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnEqual)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeVulnEqual struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Vulnerabilities []AllVulnEqualVulnerabilitiesVulnerability `json:"vulnerabilities"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodeVulnEqual) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeVulnEqual) __premarshalJSON() (*__premarshalNodeNodeVulnEqual, error) {
	var retval __premarshalNodeNodeVulnEqual

	retval.Typename = v.Typename
	retval.Id = v.AllVulnEqual.Id
	retval.Vulnerabilities = v.AllVulnEqual.Vulnerabilities
	retval.Justification = v.AllVulnEqual.Justification
	retval.Origin = v.AllVulnEqual.Origin
	retval.Collector = v.AllVulnEqual.Collector
	return &retval, nil
}

// NodeNodeVulnerability includes the requested fields of the GraphQL type Vulnerability.
// The GraphQL type's documentation follows.
//
// Vulnerability represents the root of the vulnerability trie/tree.
//
// We map vulnerability information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type and a vulnerability ID. This allows for generic
// representation of the various vulnerabilities and does not limit to just cve, ghsa or osv.
// This would be in the general format: vuln://<general-type>/<vuln-id>
//
// Examples:
//
// CVE, using path separator: vuln://cve/cve-2023-20753
// OSV, representing its knowledge of a GHSA: vuln://osv/ghsa-205hk
// Random vendor: vuln://snyk/sn-whatever
// NoVuln: vuln://novuln/
//
// This node represents the type part of the trie path. It is used to represent
// the specific type of the vulnerability: cve, ghsa, osv or some other vendor specific
//
// Since this node is at the root of the vulnerability trie, it is named Vulnerability, not
// VulnerabilityType.
//
// NoVuln is a special vulnerability node to attest that no vulnerability has been
// found during a vulnerability scan. It will have the type "novuln" and contain an empty string
// for vulnerabilityID
//
// The resolvers will enforce that both the type and vulnerability IDs are lower case.
type NodeNodeVulnerability struct {
	Typename             *string `json:"__typename"`
	AllVulnerabilityTree `json:"-"`
}

// GetTypename returns NodeNodeVulnerability.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnerability) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeVulnerability.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnerability) GetId() string { return v.AllVulnerabilityTree.Id }

// GetType returns NodeNodeVulnerability.Type, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnerability) GetType() string { return v.AllVulnerabilityTree.Type }

// GetVulnerabilityIDs returns NodeNodeVulnerability.VulnerabilityIDs, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnerability) GetVulnerabilityIDs() []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID {
	return v.AllVulnerabilityTree.VulnerabilityIDs
}

func (v *NodeNodeVulnerability) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeVulnerability
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeVulnerability = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnerabilityTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeVulnerability struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	VulnerabilityIDs []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID `json:"vulnerabilityIDs"`
}

func (v *NodeNodeVulnerability) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeVulnerability) __premarshalJSON() (*__premarshalNodeNodeVulnerability, error) {
	var retval __premarshalNodeNodeVulnerability

	retval.Typename = v.Typename
	retval.Id = v.AllVulnerabilityTree.Id
	retval.Type = v.AllVulnerabilityTree.Type
	retval.VulnerabilityIDs = v.AllVulnerabilityTree.VulnerabilityIDs
	return &retval, nil
}

// NodeNodeVulnerabilityMetadata includes the requested fields of the GraphQL type VulnerabilityMetadata.
// The GraphQL type's documentation follows.
//
// VulnerabilityMetadata is an attestation that a vulnerability has a related score
// associated with it.
//
// The intent of this evidence tree predicate is to allow extensibility of vulnerability
// score (one-to-one mapping) with a specific vulnerability ID.
//
// A vulnerability ID can have a one-to-many relationship with the VulnerabilityMetadata
// node as a vulnerability ID can have multiple scores (in various frameworks).
//
// Examples:
//
// scoreType: EPSSv1
// scoreValue: 0.960760000
//
// scoreType: CVSSv2
// scoreValue: 5.0
//
// scoreType: CVSSv3
// scoreValue: 7.5
//
// The timestamp is used to determine when the score was evaluated for the specific vulnerability.
type NodeNodeVulnerabilityMetadata struct {
	Typename            *string `json:"__typename"`
	AllVulnMetadataTree `json:"-"`
}

// GetTypename returns NodeNodeVulnerabilityMetadata.Typename, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnerabilityMetadata) GetTypename() *string { return v.Typename }

// GetId returns NodeNodeVulnerabilityMetadata.Id, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnerabilityMetadata) GetId() string { return v.AllVulnMetadataTree.Id }

// GetVulnerability returns NodeNodeVulnerabilityMetadata.Vulnerability, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnerabilityMetadata) GetVulnerability() AllVulnMetadataTreeVulnerability {
	return v.AllVulnMetadataTree.Vulnerability
}

// GetScoreType returns NodeNodeVulnerabilityMetadata.ScoreType, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnerabilityMetadata) GetScoreType() VulnerabilityScoreType {
	return v.AllVulnMetadataTree.ScoreType
}

// GetScoreValue returns NodeNodeVulnerabilityMetadata.ScoreValue, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnerabilityMetadata) GetScoreValue() float64 {
	return v.AllVulnMetadataTree.ScoreValue
}

// GetTimestamp returns NodeNodeVulnerabilityMetadata.Timestamp, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnerabilityMetadata) GetTimestamp() time.Time {
	return v.AllVulnMetadataTree.Timestamp
}

// GetOrigin returns NodeNodeVulnerabilityMetadata.Origin, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnerabilityMetadata) GetOrigin() string { return v.AllVulnMetadataTree.Origin }

// GetCollector returns NodeNodeVulnerabilityMetadata.Collector, and is useful for accessing the field via an interface.
func (v *NodeNodeVulnerabilityMetadata) GetCollector() string { return v.AllVulnMetadataTree.Collector }

func (v *NodeNodeVulnerabilityMetadata) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeNodeVulnerabilityMetadata
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeNodeVulnerabilityMetadata = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnMetadataTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodeNodeVulnerabilityMetadata struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Vulnerability AllVulnMetadataTreeVulnerability `json:"vulnerability"`

	ScoreType VulnerabilityScoreType `json:"scoreType"`

	ScoreValue float64 `json:"scoreValue"`

	Timestamp time.Time `json:"timestamp"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodeNodeVulnerabilityMetadata) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeNodeVulnerabilityMetadata) __premarshalJSON() (*__premarshalNodeNodeVulnerabilityMetadata, error) {
	var retval __premarshalNodeNodeVulnerabilityMetadata

	retval.Typename = v.Typename
	retval.Id = v.AllVulnMetadataTree.Id
	retval.Vulnerability = v.AllVulnMetadataTree.Vulnerability
	retval.ScoreType = v.AllVulnMetadataTree.ScoreType
	retval.ScoreValue = v.AllVulnMetadataTree.ScoreValue
	retval.Timestamp = v.AllVulnMetadataTree.Timestamp
	retval.Origin = v.AllVulnMetadataTree.Origin
	retval.Collector = v.AllVulnMetadataTree.Collector
	return &retval, nil
}

// NodeResponse is returned by Node on success.
type NodeResponse struct {
	// node returns a single node, regardless of type.
	//
	// The input is only specified by its ID.
	Node NodeNode `json:"-"`
}

// GetNode returns NodeResponse.Node, and is useful for accessing the field via an interface.
func (v *NodeResponse) GetNode() NodeNode { return v.Node }

func (v *NodeResponse) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodeResponse
		Node json.RawMessage `json:"node"`
		graphql.NoUnmarshalJSON
	}
	firstPass.NodeResponse = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Node
		src := firstPass.Node
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalNodeNode(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"unable to unmarshal NodeResponse.Node: %w", err)
			}
		}
	}
	return nil
}

type __premarshalNodeResponse struct {
	Node json.RawMessage `json:"node"`
}

func (v *NodeResponse) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodeResponse) __premarshalJSON() (*__premarshalNodeResponse, error) {
	var retval __premarshalNodeResponse

	{

		dst := &retval.Node
		src := v.Node
		var err error
		*dst, err = __marshalNodeNode(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodeResponse.Node: %w", err)
		}
	}
	return &retval, nil
}

// NodesNodesArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type NodesNodesArtifact struct {
	Typename        *string `json:"__typename"`
	AllArtifactTree `json:"-"`
}

// GetTypename returns NodesNodesArtifact.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesArtifact) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesArtifact.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns NodesNodesArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *NodesNodesArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns NodesNodesArtifact.Digest, and is useful for accessing the field via an interface.
func (v *NodesNodesArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *NodesNodesArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesArtifact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *NodesNodesArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesArtifact) __premarshalJSON() (*__premarshalNodesNodesArtifact, error) {
	var retval __premarshalNodesNodesArtifact

	retval.Typename = v.Typename
	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// NodesNodesBuilder includes the requested fields of the GraphQL type Builder.
// The GraphQL type's documentation follows.
//
// Builder represents the builder (e.g., FRSCA or GitHub Actions).
//
// Currently builders are identified by the uri field.
type NodesNodesBuilder struct {
	Typename       *string `json:"__typename"`
	AllBuilderTree `json:"-"`
}

// GetTypename returns NodesNodesBuilder.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesBuilder) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesBuilder.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesBuilder) GetId() string { return v.AllBuilderTree.Id }

// GetUri returns NodesNodesBuilder.Uri, and is useful for accessing the field via an interface.
func (v *NodesNodesBuilder) GetUri() string { return v.AllBuilderTree.Uri }

func (v *NodesNodesBuilder) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesBuilder
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesBuilder = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllBuilderTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesBuilder struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Uri string `json:"uri"`
}

func (v *NodesNodesBuilder) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesBuilder) __premarshalJSON() (*__premarshalNodesNodesBuilder, error) {
	var retval __premarshalNodesNodesBuilder

	retval.Typename = v.Typename
	retval.Id = v.AllBuilderTree.Id
	retval.Uri = v.AllBuilderTree.Uri
	return &retval, nil
}

// NodesNodesCertifyBad includes the requested fields of the GraphQL type CertifyBad.
// The GraphQL type's documentation follows.
//
// CertifyBad is an attestation that a package, source, or artifact is considered
// bad.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The certification applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type NodesNodesCertifyBad struct {
	Typename      *string `json:"__typename"`
	AllCertifyBad `json:"-"`
}

// GetTypename returns NodesNodesCertifyBad.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyBad) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesCertifyBad.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyBad) GetId() string { return v.AllCertifyBad.Id }

// GetJustification returns NodesNodesCertifyBad.Justification, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyBad) GetJustification() string { return v.AllCertifyBad.Justification }

// GetSubject returns NodesNodesCertifyBad.Subject, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyBad) GetSubject() AllCertifyBadSubjectPackageSourceOrArtifact {
	return v.AllCertifyBad.Subject
}

// GetOrigin returns NodesNodesCertifyBad.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyBad) GetOrigin() string { return v.AllCertifyBad.Origin }

// GetCollector returns NodesNodesCertifyBad.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyBad) GetCollector() string { return v.AllCertifyBad.Collector }

func (v *NodesNodesCertifyBad) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesCertifyBad
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesCertifyBad = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyBad)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesCertifyBad struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesCertifyBad) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesCertifyBad) __premarshalJSON() (*__premarshalNodesNodesCertifyBad, error) {
	var retval __premarshalNodesNodesCertifyBad

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyBad.Id
	retval.Justification = v.AllCertifyBad.Justification
	{

		dst := &retval.Subject
		src := v.AllCertifyBad.Subject
		var err error
		*dst, err = __marshalAllCertifyBadSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodesNodesCertifyBad.AllCertifyBad.Subject: %w", err)
		}
	}
	retval.Origin = v.AllCertifyBad.Origin
	retval.Collector = v.AllCertifyBad.Collector
	return &retval, nil
}

// NodesNodesCertifyGood includes the requested fields of the GraphQL type CertifyGood.
// The GraphQL type's documentation follows.
//
// CertifyGood is an attestation that a package, source, or artifact is considered
// good.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The certification applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type NodesNodesCertifyGood struct {
	Typename       *string `json:"__typename"`
	AllCertifyGood `json:"-"`
}

// GetTypename returns NodesNodesCertifyGood.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyGood) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesCertifyGood.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyGood) GetId() string { return v.AllCertifyGood.Id }

// GetJustification returns NodesNodesCertifyGood.Justification, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyGood) GetJustification() string { return v.AllCertifyGood.Justification }

// GetSubject returns NodesNodesCertifyGood.Subject, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyGood) GetSubject() AllCertifyGoodSubjectPackageSourceOrArtifact {
	return v.AllCertifyGood.Subject
}

// GetOrigin returns NodesNodesCertifyGood.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyGood) GetOrigin() string { return v.AllCertifyGood.Origin }

// GetCollector returns NodesNodesCertifyGood.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyGood) GetCollector() string { return v.AllCertifyGood.Collector }

func (v *NodesNodesCertifyGood) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesCertifyGood
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesCertifyGood = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyGood)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesCertifyGood struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesCertifyGood) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesCertifyGood) __premarshalJSON() (*__premarshalNodesNodesCertifyGood, error) {
	var retval __premarshalNodesNodesCertifyGood

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyGood.Id
	retval.Justification = v.AllCertifyGood.Justification
	{

		dst := &retval.Subject
		src := v.AllCertifyGood.Subject
		var err error
		*dst, err = __marshalAllCertifyGoodSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodesNodesCertifyGood.AllCertifyGood.Subject: %w", err)
		}
	}
	retval.Origin = v.AllCertifyGood.Origin
	retval.Collector = v.AllCertifyGood.Collector
	return &retval, nil
}

// NodesNodesCertifyLegal includes the requested fields of the GraphQL type CertifyLegal.
// The GraphQL type's documentation follows.
//
// CertifyLegal is an attestation to attach legal information to a package or source.
//
// The certification information is either copied from an attestation found in an
// SBOM or created by a collector/scanner.
//
// Discovered license is also known as Concluded. More information:
// https://docs.clearlydefined.io/curation-guidelines#the-difference-between-declared-and-discovered-licenses
//
// Attribution is also known as Copyright Text. It is what could be displayed to
// comply with notice
// requirements. https://www.nexb.com/oss-attribution-best-practices/
//
// License expressions follow this format:
// https://spdx.github.io/spdx-spec/v2.3/SPDX-license-expressions/
type NodesNodesCertifyLegal struct {
	Typename            *string `json:"__typename"`
	AllCertifyLegalTree `json:"-"`
}

// GetTypename returns NodesNodesCertifyLegal.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyLegal) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesCertifyLegal.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyLegal) GetId() string { return v.AllCertifyLegalTree.Id }

// GetSubject returns NodesNodesCertifyLegal.Subject, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyLegal) GetSubject() AllCertifyLegalTreeSubjectPackageOrSource {
	return v.AllCertifyLegalTree.Subject
}

// GetDeclaredLicense returns NodesNodesCertifyLegal.DeclaredLicense, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyLegal) GetDeclaredLicense() string {
	return v.AllCertifyLegalTree.DeclaredLicense
}

// GetDeclaredLicenses returns NodesNodesCertifyLegal.DeclaredLicenses, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyLegal) GetDeclaredLicenses() []AllCertifyLegalTreeDeclaredLicensesLicense {
	return v.AllCertifyLegalTree.DeclaredLicenses
}

// GetDiscoveredLicense returns NodesNodesCertifyLegal.DiscoveredLicense, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyLegal) GetDiscoveredLicense() string {
	return v.AllCertifyLegalTree.DiscoveredLicense
}

// GetDiscoveredLicenses returns NodesNodesCertifyLegal.DiscoveredLicenses, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyLegal) GetDiscoveredLicenses() []AllCertifyLegalTreeDiscoveredLicensesLicense {
	return v.AllCertifyLegalTree.DiscoveredLicenses
}

// GetAttribution returns NodesNodesCertifyLegal.Attribution, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyLegal) GetAttribution() string { return v.AllCertifyLegalTree.Attribution }

// GetJustification returns NodesNodesCertifyLegal.Justification, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyLegal) GetJustification() string {
	return v.AllCertifyLegalTree.Justification
}

// GetTimeScanned returns NodesNodesCertifyLegal.TimeScanned, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyLegal) GetTimeScanned() time.Time { return v.AllCertifyLegalTree.TimeScanned }

// GetOrigin returns NodesNodesCertifyLegal.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyLegal) GetOrigin() string { return v.AllCertifyLegalTree.Origin }

// GetCollector returns NodesNodesCertifyLegal.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyLegal) GetCollector() string { return v.AllCertifyLegalTree.Collector }

func (v *NodesNodesCertifyLegal) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesCertifyLegal
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesCertifyLegal = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyLegalTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesCertifyLegal struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	DeclaredLicense string `json:"declaredLicense"`

	DeclaredLicenses []AllCertifyLegalTreeDeclaredLicensesLicense `json:"declaredLicenses"`

	DiscoveredLicense string `json:"discoveredLicense"`

	DiscoveredLicenses []AllCertifyLegalTreeDiscoveredLicensesLicense `json:"discoveredLicenses"`

	Attribution string `json:"attribution"`

	Justification string `json:"justification"`

	TimeScanned time.Time `json:"timeScanned"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesCertifyLegal) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesCertifyLegal) __premarshalJSON() (*__premarshalNodesNodesCertifyLegal, error) {
	var retval __premarshalNodesNodesCertifyLegal

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyLegalTree.Id
	{

		dst := &retval.Subject
		src := v.AllCertifyLegalTree.Subject
		var err error
		*dst, err = __marshalAllCertifyLegalTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodesNodesCertifyLegal.AllCertifyLegalTree.Subject: %w", err)
		}
	}
	retval.DeclaredLicense = v.AllCertifyLegalTree.DeclaredLicense
	retval.DeclaredLicenses = v.AllCertifyLegalTree.DeclaredLicenses
	retval.DiscoveredLicense = v.AllCertifyLegalTree.DiscoveredLicense
	retval.DiscoveredLicenses = v.AllCertifyLegalTree.DiscoveredLicenses
	retval.Attribution = v.AllCertifyLegalTree.Attribution
	retval.Justification = v.AllCertifyLegalTree.Justification
	retval.TimeScanned = v.AllCertifyLegalTree.TimeScanned
	retval.Origin = v.AllCertifyLegalTree.Origin
	retval.Collector = v.AllCertifyLegalTree.Collector
	return &retval, nil
}

// NodesNodesCertifyScorecard includes the requested fields of the GraphQL type CertifyScorecard.
// The GraphQL type's documentation follows.
//
// CertifyScorecard is an attestation to attach a Scorecard analysis to a
// particular source repository.
type NodesNodesCertifyScorecard struct {
	Typename            *string `json:"__typename"`
	AllCertifyScorecard `json:"-"`
}

// GetTypename returns NodesNodesCertifyScorecard.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyScorecard) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesCertifyScorecard.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyScorecard) GetId() string { return v.AllCertifyScorecard.Id }

// GetSource returns NodesNodesCertifyScorecard.Source, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyScorecard) GetSource() AllCertifyScorecardSource {
	return v.AllCertifyScorecard.Source
}

// GetScorecard returns NodesNodesCertifyScorecard.Scorecard, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyScorecard) GetScorecard() AllCertifyScorecardScorecard {
	return v.AllCertifyScorecard.Scorecard
}

func (v *NodesNodesCertifyScorecard) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesCertifyScorecard
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesCertifyScorecard = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyScorecard)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesCertifyScorecard struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Source AllCertifyScorecardSource `json:"source"`

	Scorecard AllCertifyScorecardScorecard `json:"scorecard"`
}

func (v *NodesNodesCertifyScorecard) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesCertifyScorecard) __premarshalJSON() (*__premarshalNodesNodesCertifyScorecard, error) {
	var retval __premarshalNodesNodesCertifyScorecard

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyScorecard.Id
	retval.Source = v.AllCertifyScorecard.Source
	retval.Scorecard = v.AllCertifyScorecard.Scorecard
	return &retval, nil
}

// NodesNodesCertifyVEXStatement includes the requested fields of the GraphQL type CertifyVEXStatement.
// The GraphQL type's documentation follows.
//
// CertifyVEXStatement is an attestation to attach VEX statements to a package or
// artifact to clarify the impact of a specific vulnerability.
type NodesNodesCertifyVEXStatement struct {
	Typename               *string `json:"__typename"`
	AllCertifyVEXStatement `json:"-"`
}

// GetTypename returns NodesNodesCertifyVEXStatement.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVEXStatement) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesCertifyVEXStatement.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVEXStatement) GetId() string { return v.AllCertifyVEXStatement.Id }

// GetSubject returns NodesNodesCertifyVEXStatement.Subject, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVEXStatement) GetSubject() AllCertifyVEXStatementSubjectPackageOrArtifact {
	return v.AllCertifyVEXStatement.Subject
}

// GetVulnerability returns NodesNodesCertifyVEXStatement.Vulnerability, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVEXStatement) GetVulnerability() AllCertifyVEXStatementVulnerability {
	return v.AllCertifyVEXStatement.Vulnerability
}

// GetStatus returns NodesNodesCertifyVEXStatement.Status, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVEXStatement) GetStatus() VexStatus { return v.AllCertifyVEXStatement.Status }

// GetVexJustification returns NodesNodesCertifyVEXStatement.VexJustification, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVEXStatement) GetVexJustification() VexJustification {
	return v.AllCertifyVEXStatement.VexJustification
}

// GetStatement returns NodesNodesCertifyVEXStatement.Statement, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVEXStatement) GetStatement() string {
	return v.AllCertifyVEXStatement.Statement
}

// GetStatusNotes returns NodesNodesCertifyVEXStatement.StatusNotes, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVEXStatement) GetStatusNotes() string {
	return v.AllCertifyVEXStatement.StatusNotes
}

// GetKnownSince returns NodesNodesCertifyVEXStatement.KnownSince, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVEXStatement) GetKnownSince() time.Time {
	return v.AllCertifyVEXStatement.KnownSince
}

// GetOrigin returns NodesNodesCertifyVEXStatement.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVEXStatement) GetOrigin() string { return v.AllCertifyVEXStatement.Origin }

// GetCollector returns NodesNodesCertifyVEXStatement.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVEXStatement) GetCollector() string {
	return v.AllCertifyVEXStatement.Collector
}

func (v *NodesNodesCertifyVEXStatement) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesCertifyVEXStatement
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesCertifyVEXStatement = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyVEXStatement)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesCertifyVEXStatement struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Vulnerability AllCertifyVEXStatementVulnerability `json:"vulnerability"`

	Status VexStatus `json:"status"`

	VexJustification VexJustification `json:"vexJustification"`

	Statement string `json:"statement"`

	StatusNotes string `json:"statusNotes"`

	KnownSince time.Time `json:"knownSince"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesCertifyVEXStatement) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesCertifyVEXStatement) __premarshalJSON() (*__premarshalNodesNodesCertifyVEXStatement, error) {
	var retval __premarshalNodesNodesCertifyVEXStatement

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyVEXStatement.Id
	{

		dst := &retval.Subject
		src := v.AllCertifyVEXStatement.Subject
		var err error
		*dst, err = __marshalAllCertifyVEXStatementSubjectPackageOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodesNodesCertifyVEXStatement.AllCertifyVEXStatement.Subject: %w", err)
		}
	}
	retval.Vulnerability = v.AllCertifyVEXStatement.Vulnerability
	retval.Status = v.AllCertifyVEXStatement.Status
	retval.VexJustification = v.AllCertifyVEXStatement.VexJustification
	retval.Statement = v.AllCertifyVEXStatement.Statement
	retval.StatusNotes = v.AllCertifyVEXStatement.StatusNotes
	retval.KnownSince = v.AllCertifyVEXStatement.KnownSince
	retval.Origin = v.AllCertifyVEXStatement.Origin
	retval.Collector = v.AllCertifyVEXStatement.Collector
	return &retval, nil
}

// NodesNodesCertifyVuln includes the requested fields of the GraphQL type CertifyVuln.
// The GraphQL type's documentation follows.
//
// CertifyVuln is an attestation to attach vulnerability information to a package.
//
// This information is obtained via a scanner. If there is no vulnerability
// detected, we attach the a vulnerability with "NoVuln" type and an empty string
// for the vulnerability ID.
type NodesNodesCertifyVuln struct {
	Typename       *string `json:"__typename"`
	AllCertifyVuln `json:"-"`
}

// GetTypename returns NodesNodesCertifyVuln.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVuln) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesCertifyVuln.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVuln) GetId() string { return v.AllCertifyVuln.Id }

// GetPackage returns NodesNodesCertifyVuln.Package, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVuln) GetPackage() AllCertifyVulnPackage { return v.AllCertifyVuln.Package }

// GetVulnerability returns NodesNodesCertifyVuln.Vulnerability, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVuln) GetVulnerability() AllCertifyVulnVulnerability {
	return v.AllCertifyVuln.Vulnerability
}

// GetMetadata returns NodesNodesCertifyVuln.Metadata, and is useful for accessing the field via an interface.
func (v *NodesNodesCertifyVuln) GetMetadata() AllCertifyVulnMetadataScanMetadata {
	return v.AllCertifyVuln.Metadata
}

func (v *NodesNodesCertifyVuln) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesCertifyVuln
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesCertifyVuln = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyVuln)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesCertifyVuln struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Package AllCertifyVulnPackage `json:"package"`

	Vulnerability AllCertifyVulnVulnerability `json:"vulnerability"`

	Metadata AllCertifyVulnMetadataScanMetadata `json:"metadata"`
}

func (v *NodesNodesCertifyVuln) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesCertifyVuln) __premarshalJSON() (*__premarshalNodesNodesCertifyVuln, error) {
	var retval __premarshalNodesNodesCertifyVuln

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyVuln.Id
	retval.Package = v.AllCertifyVuln.Package
	retval.Vulnerability = v.AllCertifyVuln.Vulnerability
	retval.Metadata = v.AllCertifyVuln.Metadata
	return &retval, nil
}

// NodesNodesHasMetadata includes the requested fields of the GraphQL type HasMetadata.
// The GraphQL type's documentation follows.
//
// HasMetadata is an attestation that a package, source, or artifact has a certain
// attested property (key) with value (value). For example, a source may have
// metadata "SourceRepo2FAEnabled=true".
//
// The intent of this evidence tree predicate is to allow extensibility of metadata
// expressible within the GUAC ontology. Metadata that is commonly used will then
// be promoted to a predicate on its own.
//
// Justification indicates how the metadata was determined.
//
// The metadata applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type NodesNodesHasMetadata struct {
	Typename       *string `json:"__typename"`
	AllHasMetadata `json:"-"`
}

// GetTypename returns NodesNodesHasMetadata.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesHasMetadata) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesHasMetadata.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesHasMetadata) GetId() string { return v.AllHasMetadata.Id }

// GetSubject returns NodesNodesHasMetadata.Subject, and is useful for accessing the field via an interface.
func (v *NodesNodesHasMetadata) GetSubject() AllHasMetadataSubjectPackageSourceOrArtifact {
	return v.AllHasMetadata.Subject
}

// GetKey returns NodesNodesHasMetadata.Key, and is useful for accessing the field via an interface.
func (v *NodesNodesHasMetadata) GetKey() string { return v.AllHasMetadata.Key }

// GetValue returns NodesNodesHasMetadata.Value, and is useful for accessing the field via an interface.
func (v *NodesNodesHasMetadata) GetValue() string { return v.AllHasMetadata.Value }

// GetTimestamp returns NodesNodesHasMetadata.Timestamp, and is useful for accessing the field via an interface.
func (v *NodesNodesHasMetadata) GetTimestamp() time.Time { return v.AllHasMetadata.Timestamp }

// GetJustification returns NodesNodesHasMetadata.Justification, and is useful for accessing the field via an interface.
func (v *NodesNodesHasMetadata) GetJustification() string { return v.AllHasMetadata.Justification }

// GetOrigin returns NodesNodesHasMetadata.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesHasMetadata) GetOrigin() string { return v.AllHasMetadata.Origin }

// GetCollector returns NodesNodesHasMetadata.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesHasMetadata) GetCollector() string { return v.AllHasMetadata.Collector }

func (v *NodesNodesHasMetadata) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesHasMetadata
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesHasMetadata = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHasMetadata)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesHasMetadata struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Key string `json:"key"`

	Value string `json:"value"`

	Timestamp time.Time `json:"timestamp"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesHasMetadata) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesHasMetadata) __premarshalJSON() (*__premarshalNodesNodesHasMetadata, error) {
	var retval __premarshalNodesNodesHasMetadata

	retval.Typename = v.Typename
	retval.Id = v.AllHasMetadata.Id
	{

		dst := &retval.Subject
		src := v.AllHasMetadata.Subject
		var err error
		*dst, err = __marshalAllHasMetadataSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodesNodesHasMetadata.AllHasMetadata.Subject: %w", err)
		}
	}
	retval.Key = v.AllHasMetadata.Key
	retval.Value = v.AllHasMetadata.Value
	retval.Timestamp = v.AllHasMetadata.Timestamp
	retval.Justification = v.AllHasMetadata.Justification
	retval.Origin = v.AllHasMetadata.Origin
	retval.Collector = v.AllHasMetadata.Collector
	return &retval, nil
}

// NodesNodesHasSBOM includes the requested fields of the GraphQL type HasSBOM.
type NodesNodesHasSBOM struct {
	Typename       *string `json:"__typename"`
	AllHasSBOMTree `json:"-"`
}

// GetTypename returns NodesNodesHasSBOM.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSBOM) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesHasSBOM.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSBOM) GetId() string { return v.AllHasSBOMTree.Id }

// GetSubject returns NodesNodesHasSBOM.Subject, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSBOM) GetSubject() AllHasSBOMTreeSubjectPackageOrArtifact {
	return v.AllHasSBOMTree.Subject
}

// GetUri returns NodesNodesHasSBOM.Uri, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSBOM) GetUri() string { return v.AllHasSBOMTree.Uri }

// GetAlgorithm returns NodesNodesHasSBOM.Algorithm, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSBOM) GetAlgorithm() string { return v.AllHasSBOMTree.Algorithm }

// GetDigest returns NodesNodesHasSBOM.Digest, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSBOM) GetDigest() string { return v.AllHasSBOMTree.Digest }

// GetDownloadLocation returns NodesNodesHasSBOM.DownloadLocation, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSBOM) GetDownloadLocation() string { return v.AllHasSBOMTree.DownloadLocation }

// GetOrigin returns NodesNodesHasSBOM.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSBOM) GetOrigin() string { return v.AllHasSBOMTree.Origin }

// GetCollector returns NodesNodesHasSBOM.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSBOM) GetCollector() string { return v.AllHasSBOMTree.Collector }

func (v *NodesNodesHasSBOM) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesHasSBOM
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesHasSBOM = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHasSBOMTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesHasSBOM struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Uri string `json:"uri"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`

	DownloadLocation string `json:"downloadLocation"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesHasSBOM) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesHasSBOM) __premarshalJSON() (*__premarshalNodesNodesHasSBOM, error) {
	var retval __premarshalNodesNodesHasSBOM

	retval.Typename = v.Typename
	retval.Id = v.AllHasSBOMTree.Id
	{

		dst := &retval.Subject
		src := v.AllHasSBOMTree.Subject
		var err error
		*dst, err = __marshalAllHasSBOMTreeSubjectPackageOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodesNodesHasSBOM.AllHasSBOMTree.Subject: %w", err)
		}
	}
	retval.Uri = v.AllHasSBOMTree.Uri
	retval.Algorithm = v.AllHasSBOMTree.Algorithm
	retval.Digest = v.AllHasSBOMTree.Digest
	retval.DownloadLocation = v.AllHasSBOMTree.DownloadLocation
	retval.Origin = v.AllHasSBOMTree.Origin
	retval.Collector = v.AllHasSBOMTree.Collector
	return &retval, nil
}

// NodesNodesHasSLSA includes the requested fields of the GraphQL type HasSLSA.
// The GraphQL type's documentation follows.
//
// HasSLSA records that a subject node has a SLSA attestation.
type NodesNodesHasSLSA struct {
	Typename    *string `json:"__typename"`
	AllSLSATree `json:"-"`
}

// GetTypename returns NodesNodesHasSLSA.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSLSA) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesHasSLSA.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSLSA) GetId() string { return v.AllSLSATree.Id }

// GetSubject returns NodesNodesHasSLSA.Subject, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSLSA) GetSubject() AllSLSATreeSubjectArtifact { return v.AllSLSATree.Subject }

// GetSlsa returns NodesNodesHasSLSA.Slsa, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSLSA) GetSlsa() AllSLSATreeSlsaSLSA { return v.AllSLSATree.Slsa }

func (v *NodesNodesHasSLSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesHasSLSA
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesHasSLSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSLSATree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesHasSLSA struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject AllSLSATreeSubjectArtifact `json:"subject"`

	Slsa AllSLSATreeSlsaSLSA `json:"slsa"`
}

func (v *NodesNodesHasSLSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesHasSLSA) __premarshalJSON() (*__premarshalNodesNodesHasSLSA, error) {
	var retval __premarshalNodesNodesHasSLSA

	retval.Typename = v.Typename
	retval.Id = v.AllSLSATree.Id
	retval.Subject = v.AllSLSATree.Subject
	retval.Slsa = v.AllSLSATree.Slsa
	return &retval, nil
}

// NodesNodesHasSourceAt includes the requested fields of the GraphQL type HasSourceAt.
// The GraphQL type's documentation follows.
//
// HasSourceAt records that a package's repository is a given source.
type NodesNodesHasSourceAt struct {
	Typename       *string `json:"__typename"`
	AllHasSourceAt `json:"-"`
}

// GetTypename returns NodesNodesHasSourceAt.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSourceAt) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesHasSourceAt.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSourceAt) GetId() string { return v.AllHasSourceAt.Id }

// GetJustification returns NodesNodesHasSourceAt.Justification, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSourceAt) GetJustification() string { return v.AllHasSourceAt.Justification }

// GetKnownSince returns NodesNodesHasSourceAt.KnownSince, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSourceAt) GetKnownSince() time.Time { return v.AllHasSourceAt.KnownSince }

// GetPackage returns NodesNodesHasSourceAt.Package, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSourceAt) GetPackage() AllHasSourceAtPackage { return v.AllHasSourceAt.Package }

// GetSource returns NodesNodesHasSourceAt.Source, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSourceAt) GetSource() AllHasSourceAtSource { return v.AllHasSourceAt.Source }

// GetOrigin returns NodesNodesHasSourceAt.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSourceAt) GetOrigin() string { return v.AllHasSourceAt.Origin }

// GetCollector returns NodesNodesHasSourceAt.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesHasSourceAt) GetCollector() string { return v.AllHasSourceAt.Collector }

func (v *NodesNodesHasSourceAt) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesHasSourceAt
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesHasSourceAt = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHasSourceAt)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesHasSourceAt struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	KnownSince time.Time `json:"knownSince"`

	Package AllHasSourceAtPackage `json:"package"`

	Source AllHasSourceAtSource `json:"source"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesHasSourceAt) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesHasSourceAt) __premarshalJSON() (*__premarshalNodesNodesHasSourceAt, error) {
	var retval __premarshalNodesNodesHasSourceAt

	retval.Typename = v.Typename
	retval.Id = v.AllHasSourceAt.Id
	retval.Justification = v.AllHasSourceAt.Justification
	retval.KnownSince = v.AllHasSourceAt.KnownSince
	retval.Package = v.AllHasSourceAt.Package
	retval.Source = v.AllHasSourceAt.Source
	retval.Origin = v.AllHasSourceAt.Origin
	retval.Collector = v.AllHasSourceAt.Collector
	return &retval, nil
}

// NodesNodesHashEqual includes the requested fields of the GraphQL type HashEqual.
// The GraphQL type's documentation follows.
//
// HashEqual is an attestation that a set of artifacts are identical.
type NodesNodesHashEqual struct {
	Typename         *string `json:"__typename"`
	AllHashEqualTree `json:"-"`
}

// GetTypename returns NodesNodesHashEqual.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesHashEqual) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesHashEqual.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesHashEqual) GetId() string { return v.AllHashEqualTree.Id }

// GetJustification returns NodesNodesHashEqual.Justification, and is useful for accessing the field via an interface.
func (v *NodesNodesHashEqual) GetJustification() string { return v.AllHashEqualTree.Justification }

// GetArtifacts returns NodesNodesHashEqual.Artifacts, and is useful for accessing the field via an interface.
func (v *NodesNodesHashEqual) GetArtifacts() []AllHashEqualTreeArtifactsArtifact {
	return v.AllHashEqualTree.Artifacts
}

// GetOrigin returns NodesNodesHashEqual.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesHashEqual) GetOrigin() string { return v.AllHashEqualTree.Origin }

// GetCollector returns NodesNodesHashEqual.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesHashEqual) GetCollector() string { return v.AllHashEqualTree.Collector }

func (v *NodesNodesHashEqual) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesHashEqual
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesHashEqual = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHashEqualTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesHashEqual struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Artifacts []AllHashEqualTreeArtifactsArtifact `json:"artifacts"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesHashEqual) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesHashEqual) __premarshalJSON() (*__premarshalNodesNodesHashEqual, error) {
	var retval __premarshalNodesNodesHashEqual

	retval.Typename = v.Typename
	retval.Id = v.AllHashEqualTree.Id
	retval.Justification = v.AllHashEqualTree.Justification
	retval.Artifacts = v.AllHashEqualTree.Artifacts
	retval.Origin = v.AllHashEqualTree.Origin
	retval.Collector = v.AllHashEqualTree.Collector
	return &retval, nil
}

// NodesNodesIsDependency includes the requested fields of the GraphQL type IsDependency.
// The GraphQL type's documentation follows.
//
// IsDependency is an attestation to record that a package depends on another.
type NodesNodesIsDependency struct {
	Typename            *string `json:"__typename"`
	AllIsDependencyTree `json:"-"`
}

// GetTypename returns NodesNodesIsDependency.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesIsDependency) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesIsDependency.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesIsDependency) GetId() string { return v.AllIsDependencyTree.Id }

// GetJustification returns NodesNodesIsDependency.Justification, and is useful for accessing the field via an interface.
func (v *NodesNodesIsDependency) GetJustification() string {
	return v.AllIsDependencyTree.Justification
}

// GetPackage returns NodesNodesIsDependency.Package, and is useful for accessing the field via an interface.
func (v *NodesNodesIsDependency) GetPackage() AllIsDependencyTreePackage {
	return v.AllIsDependencyTree.Package
}

// GetDependentPackage returns NodesNodesIsDependency.DependentPackage, and is useful for accessing the field via an interface.
func (v *NodesNodesIsDependency) GetDependentPackage() AllIsDependencyTreeDependentPackage {
	return v.AllIsDependencyTree.DependentPackage
}

// GetDependencyType returns NodesNodesIsDependency.DependencyType, and is useful for accessing the field via an interface.
func (v *NodesNodesIsDependency) GetDependencyType() DependencyType {
	return v.AllIsDependencyTree.DependencyType
}

// GetVersionRange returns NodesNodesIsDependency.VersionRange, and is useful for accessing the field via an interface.
func (v *NodesNodesIsDependency) GetVersionRange() string { return v.AllIsDependencyTree.VersionRange }

// GetOrigin returns NodesNodesIsDependency.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesIsDependency) GetOrigin() string { return v.AllIsDependencyTree.Origin }

// GetCollector returns NodesNodesIsDependency.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesIsDependency) GetCollector() string { return v.AllIsDependencyTree.Collector }

func (v *NodesNodesIsDependency) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesIsDependency
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesIsDependency = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllIsDependencyTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesIsDependency struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Package AllIsDependencyTreePackage `json:"package"`

	DependentPackage AllIsDependencyTreeDependentPackage `json:"dependentPackage"`

	DependencyType DependencyType `json:"dependencyType"`

	VersionRange string `json:"versionRange"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesIsDependency) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesIsDependency) __premarshalJSON() (*__premarshalNodesNodesIsDependency, error) {
	var retval __premarshalNodesNodesIsDependency

	retval.Typename = v.Typename
	retval.Id = v.AllIsDependencyTree.Id
	retval.Justification = v.AllIsDependencyTree.Justification
	retval.Package = v.AllIsDependencyTree.Package
	retval.DependentPackage = v.AllIsDependencyTree.DependentPackage
	retval.DependencyType = v.AllIsDependencyTree.DependencyType
	retval.VersionRange = v.AllIsDependencyTree.VersionRange
	retval.Origin = v.AllIsDependencyTree.Origin
	retval.Collector = v.AllIsDependencyTree.Collector
	return &retval, nil
}

// NodesNodesIsOccurrence includes the requested fields of the GraphQL type IsOccurrence.
// The GraphQL type's documentation follows.
//
// IsOccurrence is an attestation to link an artifact to a package or source.
//
// Attestation must occur at the PackageVersion or at the SourceName.
type NodesNodesIsOccurrence struct {
	Typename             *string `json:"__typename"`
	AllIsOccurrencesTree `json:"-"`
}

// GetTypename returns NodesNodesIsOccurrence.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesIsOccurrence) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesIsOccurrence.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesIsOccurrence) GetId() string { return v.AllIsOccurrencesTree.Id }

// GetSubject returns NodesNodesIsOccurrence.Subject, and is useful for accessing the field via an interface.
func (v *NodesNodesIsOccurrence) GetSubject() AllIsOccurrencesTreeSubjectPackageOrSource {
	return v.AllIsOccurrencesTree.Subject
}

// GetArtifact returns NodesNodesIsOccurrence.Artifact, and is useful for accessing the field via an interface.
func (v *NodesNodesIsOccurrence) GetArtifact() AllIsOccurrencesTreeArtifact {
	return v.AllIsOccurrencesTree.Artifact
}

// GetJustification returns NodesNodesIsOccurrence.Justification, and is useful for accessing the field via an interface.
func (v *NodesNodesIsOccurrence) GetJustification() string {
	return v.AllIsOccurrencesTree.Justification
}

// GetOrigin returns NodesNodesIsOccurrence.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesIsOccurrence) GetOrigin() string { return v.AllIsOccurrencesTree.Origin }

// GetCollector returns NodesNodesIsOccurrence.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesIsOccurrence) GetCollector() string { return v.AllIsOccurrencesTree.Collector }

func (v *NodesNodesIsOccurrence) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesIsOccurrence
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesIsOccurrence = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllIsOccurrencesTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesIsOccurrence struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Artifact AllIsOccurrencesTreeArtifact `json:"artifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesIsOccurrence) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesIsOccurrence) __premarshalJSON() (*__premarshalNodesNodesIsOccurrence, error) {
	var retval __premarshalNodesNodesIsOccurrence

	retval.Typename = v.Typename
	retval.Id = v.AllIsOccurrencesTree.Id
	{

		dst := &retval.Subject
		src := v.AllIsOccurrencesTree.Subject
		var err error
		*dst, err = __marshalAllIsOccurrencesTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodesNodesIsOccurrence.AllIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.Artifact = v.AllIsOccurrencesTree.Artifact
	retval.Justification = v.AllIsOccurrencesTree.Justification
	retval.Origin = v.AllIsOccurrencesTree.Origin
	retval.Collector = v.AllIsOccurrencesTree.Collector
	return &retval, nil
}

// NodesNodesLicense includes the requested fields of the GraphQL type License.
// The GraphQL type's documentation follows.
//
// License represents a particular license. If the license is found on the SPDX
// license list (https://spdx.org/licenses/) then the fields should be:
//
// Name: SPDX license identifier
// Inline: empty
// ListVersion: SPDX license list version
//
// example:
//
// Name: AGPL-3.0-or-later
// Inline: ""
// ListVersion: 3.21 2023-06-18
//
// If the license is not on the SPDX license list, then a new guid should be
// created and the license text placed inline:
//
// Name: LicenseRef-<guid>
// Inline: Full license text
// ListVersion: empty
//
// example:
//
// Name: LicenseRef-1a2b3c
// Inline: Permission to use, copy, modify, and/or distribute ...
// ListVersion: ""
type NodesNodesLicense struct {
	Typename       *string `json:"__typename"`
	AllLicenseTree `json:"-"`
}

// GetTypename returns NodesNodesLicense.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesLicense) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesLicense.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesLicense) GetId() string { return v.AllLicenseTree.Id }

// GetName returns NodesNodesLicense.Name, and is useful for accessing the field via an interface.
func (v *NodesNodesLicense) GetName() string { return v.AllLicenseTree.Name }

// GetInline returns NodesNodesLicense.Inline, and is useful for accessing the field via an interface.
func (v *NodesNodesLicense) GetInline() *string { return v.AllLicenseTree.Inline }

// GetListVersion returns NodesNodesLicense.ListVersion, and is useful for accessing the field via an interface.
func (v *NodesNodesLicense) GetListVersion() *string { return v.AllLicenseTree.ListVersion }

func (v *NodesNodesLicense) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesLicense
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesLicense = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllLicenseTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesLicense struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Name string `json:"name"`

	Inline *string `json:"inline"`

	ListVersion *string `json:"listVersion"`
}

func (v *NodesNodesLicense) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesLicense) __premarshalJSON() (*__premarshalNodesNodesLicense, error) {
	var retval __premarshalNodesNodesLicense

	retval.Typename = v.Typename
	retval.Id = v.AllLicenseTree.Id
	retval.Name = v.AllLicenseTree.Name
	retval.Inline = v.AllLicenseTree.Inline
	retval.ListVersion = v.AllLicenseTree.ListVersion
	return &retval, nil
}

// NodesNodesNode includes the requested fields of the GraphQL interface Node.
//
// NodesNodesNode is implemented by the following types:
// NodesNodesArtifact
// NodesNodesBuilder
// NodesNodesCertifyBad
// NodesNodesCertifyGood
// NodesNodesCertifyLegal
// NodesNodesCertifyScorecard
// NodesNodesCertifyVEXStatement
// NodesNodesCertifyVuln
// NodesNodesHasMetadata
// NodesNodesHasSBOM
// NodesNodesHasSLSA
// NodesNodesHasSourceAt
// NodesNodesHashEqual
// NodesNodesIsDependency
// NodesNodesIsOccurrence
// NodesNodesLicense
// NodesNodesPackage
// NodesNodesPkgEqual
// NodesNodesPointOfContact
// NodesNodesSource
// NodesNodesVulnEqual
// NodesNodesVulnerability
// NodesNodesVulnerabilityMetadata
// The GraphQL type's documentation follows.
//
// Node is a union type of all the possible nodes.
//
// It encapsulates the software tree nodes along with the evidence nodes. In a
// path query, all connecting evidence nodes along with their intermediate subject
// nodes need to be returned in order to create a complete graph.
type NodesNodesNode interface {
	implementsGraphQLInterfaceNodesNodesNode()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *NodesNodesArtifact) implementsGraphQLInterfaceNodesNodesNode()              {}
func (v *NodesNodesBuilder) implementsGraphQLInterfaceNodesNodesNode()               {}
func (v *NodesNodesCertifyBad) implementsGraphQLInterfaceNodesNodesNode()            {}
func (v *NodesNodesCertifyGood) implementsGraphQLInterfaceNodesNodesNode()           {}
func (v *NodesNodesCertifyLegal) implementsGraphQLInterfaceNodesNodesNode()          {}
func (v *NodesNodesCertifyScorecard) implementsGraphQLInterfaceNodesNodesNode()      {}
func (v *NodesNodesCertifyVEXStatement) implementsGraphQLInterfaceNodesNodesNode()   {}
func (v *NodesNodesCertifyVuln) implementsGraphQLInterfaceNodesNodesNode()           {}
func (v *NodesNodesHasMetadata) implementsGraphQLInterfaceNodesNodesNode()           {}
func (v *NodesNodesHasSBOM) implementsGraphQLInterfaceNodesNodesNode()               {}
func (v *NodesNodesHasSLSA) implementsGraphQLInterfaceNodesNodesNode()               {}
func (v *NodesNodesHasSourceAt) implementsGraphQLInterfaceNodesNodesNode()           {}
func (v *NodesNodesHashEqual) implementsGraphQLInterfaceNodesNodesNode()             {}
func (v *NodesNodesIsDependency) implementsGraphQLInterfaceNodesNodesNode()          {}
func (v *NodesNodesIsOccurrence) implementsGraphQLInterfaceNodesNodesNode()          {}
func (v *NodesNodesLicense) implementsGraphQLInterfaceNodesNodesNode()               {}
func (v *NodesNodesPackage) implementsGraphQLInterfaceNodesNodesNode()               {}
func (v *NodesNodesPkgEqual) implementsGraphQLInterfaceNodesNodesNode()              {}
func (v *NodesNodesPointOfContact) implementsGraphQLInterfaceNodesNodesNode()        {}
func (v *NodesNodesSource) implementsGraphQLInterfaceNodesNodesNode()                {}
func (v *NodesNodesVulnEqual) implementsGraphQLInterfaceNodesNodesNode()             {}
func (v *NodesNodesVulnerability) implementsGraphQLInterfaceNodesNodesNode()         {}
func (v *NodesNodesVulnerabilityMetadata) implementsGraphQLInterfaceNodesNodesNode() {}

func __unmarshalNodesNodesNode(b []byte, v *NodesNodesNode) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Artifact":
		*v = new(NodesNodesArtifact)
		return json.Unmarshal(b, *v)
	case "Builder":
		*v = new(NodesNodesBuilder)
		return json.Unmarshal(b, *v)
	case "CertifyBad":
		*v = new(NodesNodesCertifyBad)
		return json.Unmarshal(b, *v)
	case "CertifyGood":
		*v = new(NodesNodesCertifyGood)
		return json.Unmarshal(b, *v)
	case "CertifyLegal":
		*v = new(NodesNodesCertifyLegal)
		return json.Unmarshal(b, *v)
	case "CertifyScorecard":
		*v = new(NodesNodesCertifyScorecard)
		return json.Unmarshal(b, *v)
	case "CertifyVEXStatement":
		*v = new(NodesNodesCertifyVEXStatement)
		return json.Unmarshal(b, *v)
	case "CertifyVuln":
		*v = new(NodesNodesCertifyVuln)
		return json.Unmarshal(b, *v)
	case "HasMetadata":
		*v = new(NodesNodesHasMetadata)
		return json.Unmarshal(b, *v)
	case "HasSBOM":
		*v = new(NodesNodesHasSBOM)
		return json.Unmarshal(b, *v)
	case "HasSLSA":
		*v = new(NodesNodesHasSLSA)
		return json.Unmarshal(b, *v)
	case "HasSourceAt":
		*v = new(NodesNodesHasSourceAt)
		return json.Unmarshal(b, *v)
	case "HashEqual":
		*v = new(NodesNodesHashEqual)
		return json.Unmarshal(b, *v)
	case "IsDependency":
		*v = new(NodesNodesIsDependency)
		return json.Unmarshal(b, *v)
	case "IsOccurrence":
		*v = new(NodesNodesIsOccurrence)
		return json.Unmarshal(b, *v)
	case "License":
		*v = new(NodesNodesLicense)
		return json.Unmarshal(b, *v)
	case "Package":
		*v = new(NodesNodesPackage)
		return json.Unmarshal(b, *v)
	case "PkgEqual":
		*v = new(NodesNodesPkgEqual)
		return json.Unmarshal(b, *v)
	case "PointOfContact":
		*v = new(NodesNodesPointOfContact)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(NodesNodesSource)
		return json.Unmarshal(b, *v)
	case "VulnEqual":
		*v = new(NodesNodesVulnEqual)
		return json.Unmarshal(b, *v)
	case "Vulnerability":
		*v = new(NodesNodesVulnerability)
		return json.Unmarshal(b, *v)
	case "VulnerabilityMetadata":
		*v = new(NodesNodesVulnerabilityMetadata)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing Node.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for NodesNodesNode: "%v"`, tn.TypeName)
	}
}

func __marshalNodesNodesNode(v *NodesNodesNode) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *NodesNodesArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesBuilder:
		typename = "Builder"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesBuilder
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesCertifyBad:
		typename = "CertifyBad"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesCertifyBad
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesCertifyGood:
		typename = "CertifyGood"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesCertifyGood
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesCertifyLegal:
		typename = "CertifyLegal"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesCertifyLegal
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesCertifyScorecard:
		typename = "CertifyScorecard"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesCertifyScorecard
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesCertifyVEXStatement:
		typename = "CertifyVEXStatement"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesCertifyVEXStatement
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesCertifyVuln:
		typename = "CertifyVuln"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesCertifyVuln
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesHasMetadata:
		typename = "HasMetadata"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesHasMetadata
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesHasSBOM:
		typename = "HasSBOM"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesHasSBOM
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesHasSLSA:
		typename = "HasSLSA"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesHasSLSA
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesHasSourceAt:
		typename = "HasSourceAt"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesHasSourceAt
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesHashEqual:
		typename = "HashEqual"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesHashEqual
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesIsDependency:
		typename = "IsDependency"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesIsDependency
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesIsOccurrence:
		typename = "IsOccurrence"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesIsOccurrence
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesLicense:
		typename = "License"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesLicense
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesPkgEqual:
		typename = "PkgEqual"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesPkgEqual
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesPointOfContact:
		typename = "PointOfContact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesPointOfContact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesVulnEqual:
		typename = "VulnEqual"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesVulnEqual
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesVulnerability:
		typename = "Vulnerability"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesVulnerability
		}{typename, premarshaled}
		return json.Marshal(result)
	case *NodesNodesVulnerabilityMetadata:
		typename = "VulnerabilityMetadata"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalNodesNodesVulnerabilityMetadata
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for NodesNodesNode: "%T"`, v)
	}
}

// NodesNodesPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type NodesNodesPackage struct {
	Typename   *string `json:"__typename"`
	AllPkgTree `json:"-"`
}

// GetTypename returns NodesNodesPackage.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesPackage) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesPackage.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns NodesNodesPackage.Type, and is useful for accessing the field via an interface.
func (v *NodesNodesPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns NodesNodesPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *NodesNodesPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *NodesNodesPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesPackage struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *NodesNodesPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesPackage) __premarshalJSON() (*__premarshalNodesNodesPackage, error) {
	var retval __premarshalNodesNodesPackage

	retval.Typename = v.Typename
	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// NodesNodesPkgEqual includes the requested fields of the GraphQL type PkgEqual.
// The GraphQL type's documentation follows.
//
// PkgEqual is an attestation that a set of packages are similar.
type NodesNodesPkgEqual struct {
	Typename    *string `json:"__typename"`
	AllPkgEqual `json:"-"`
}

// GetTypename returns NodesNodesPkgEqual.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesPkgEqual) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesPkgEqual.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesPkgEqual) GetId() string { return v.AllPkgEqual.Id }

// GetJustification returns NodesNodesPkgEqual.Justification, and is useful for accessing the field via an interface.
func (v *NodesNodesPkgEqual) GetJustification() string { return v.AllPkgEqual.Justification }

// GetPackages returns NodesNodesPkgEqual.Packages, and is useful for accessing the field via an interface.
func (v *NodesNodesPkgEqual) GetPackages() []AllPkgEqualPackagesPackage {
	return v.AllPkgEqual.Packages
}

// GetOrigin returns NodesNodesPkgEqual.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesPkgEqual) GetOrigin() string { return v.AllPkgEqual.Origin }

// GetCollector returns NodesNodesPkgEqual.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesPkgEqual) GetCollector() string { return v.AllPkgEqual.Collector }

func (v *NodesNodesPkgEqual) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesPkgEqual
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesPkgEqual = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgEqual)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesPkgEqual struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Packages []AllPkgEqualPackagesPackage `json:"packages"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesPkgEqual) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesPkgEqual) __premarshalJSON() (*__premarshalNodesNodesPkgEqual, error) {
	var retval __premarshalNodesNodesPkgEqual

	retval.Typename = v.Typename
	retval.Id = v.AllPkgEqual.Id
	retval.Justification = v.AllPkgEqual.Justification
	retval.Packages = v.AllPkgEqual.Packages
	retval.Origin = v.AllPkgEqual.Origin
	retval.Collector = v.AllPkgEqual.Collector
	return &retval, nil
}

// NodesNodesPointOfContact includes the requested fields of the GraphQL type PointOfContact.
// The GraphQL type's documentation follows.
//
// PointOfContact is an attestation of how to get in touch with the person(s) responsible
// for a package, source, or artifact.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The attestation applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
//
// email is the email address (singular) of the point of contact.
//
// info is additional contact information other than email address. This is free
// form.
//
// NOTE: the identifiers for point of contact should be part of software trees.
// This will benefit from identifier look up and traversal as well as organization
// hierarchy. However, until the use case arises, PointOfContact will be a flat
// reference to the contact details.
type NodesNodesPointOfContact struct {
	Typename          *string `json:"__typename"`
	AllPointOfContact `json:"-"`
}

// GetTypename returns NodesNodesPointOfContact.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesPointOfContact) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesPointOfContact.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesPointOfContact) GetId() string { return v.AllPointOfContact.Id }

// GetSubject returns NodesNodesPointOfContact.Subject, and is useful for accessing the field via an interface.
func (v *NodesNodesPointOfContact) GetSubject() AllPointOfContactSubjectPackageSourceOrArtifact {
	return v.AllPointOfContact.Subject
}

// GetEmail returns NodesNodesPointOfContact.Email, and is useful for accessing the field via an interface.
func (v *NodesNodesPointOfContact) GetEmail() string { return v.AllPointOfContact.Email }

// GetInfo returns NodesNodesPointOfContact.Info, and is useful for accessing the field via an interface.
func (v *NodesNodesPointOfContact) GetInfo() string { return v.AllPointOfContact.Info }

// GetSince returns NodesNodesPointOfContact.Since, and is useful for accessing the field via an interface.
func (v *NodesNodesPointOfContact) GetSince() time.Time { return v.AllPointOfContact.Since }

// GetJustification returns NodesNodesPointOfContact.Justification, and is useful for accessing the field via an interface.
func (v *NodesNodesPointOfContact) GetJustification() string {
	return v.AllPointOfContact.Justification
}

// GetOrigin returns NodesNodesPointOfContact.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesPointOfContact) GetOrigin() string { return v.AllPointOfContact.Origin }

// GetCollector returns NodesNodesPointOfContact.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesPointOfContact) GetCollector() string { return v.AllPointOfContact.Collector }

func (v *NodesNodesPointOfContact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesPointOfContact
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesPointOfContact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPointOfContact)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesPointOfContact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Email string `json:"email"`

	Info string `json:"info"`

	Since time.Time `json:"since"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesPointOfContact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesPointOfContact) __premarshalJSON() (*__premarshalNodesNodesPointOfContact, error) {
	var retval __premarshalNodesNodesPointOfContact

	retval.Typename = v.Typename
	retval.Id = v.AllPointOfContact.Id
	{

		dst := &retval.Subject
		src := v.AllPointOfContact.Subject
		var err error
		*dst, err = __marshalAllPointOfContactSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal NodesNodesPointOfContact.AllPointOfContact.Subject: %w", err)
		}
	}
	retval.Email = v.AllPointOfContact.Email
	retval.Info = v.AllPointOfContact.Info
	retval.Since = v.AllPointOfContact.Since
	retval.Justification = v.AllPointOfContact.Justification
	retval.Origin = v.AllPointOfContact.Origin
	retval.Collector = v.AllPointOfContact.Collector
	return &retval, nil
}

// NodesNodesSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type NodesNodesSource struct {
	Typename      *string `json:"__typename"`
	AllSourceTree `json:"-"`
}

// GetTypename returns NodesNodesSource.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesSource) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesSource.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns NodesNodesSource.Type, and is useful for accessing the field via an interface.
func (v *NodesNodesSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns NodesNodesSource.Namespaces, and is useful for accessing the field via an interface.
func (v *NodesNodesSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *NodesNodesSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesSource
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesSource struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *NodesNodesSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesSource) __premarshalJSON() (*__premarshalNodesNodesSource, error) {
	var retval __premarshalNodesNodesSource

	retval.Typename = v.Typename
	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// NodesNodesVulnEqual includes the requested fields of the GraphQL type VulnEqual.
// The GraphQL type's documentation follows.
//
// VulnEqual is an attestation to link two vulnerabilities together as being equal"
//
// Note that setting noVuln vulnerability type is invalid for VulnEqual!
type NodesNodesVulnEqual struct {
	Typename     *string `json:"__typename"`
	AllVulnEqual `json:"-"`
}

// GetTypename returns NodesNodesVulnEqual.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnEqual) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesVulnEqual.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnEqual) GetId() string { return v.AllVulnEqual.Id }

// GetVulnerabilities returns NodesNodesVulnEqual.Vulnerabilities, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnEqual) GetVulnerabilities() []AllVulnEqualVulnerabilitiesVulnerability {
	return v.AllVulnEqual.Vulnerabilities
}

// GetJustification returns NodesNodesVulnEqual.Justification, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnEqual) GetJustification() string { return v.AllVulnEqual.Justification }

// GetOrigin returns NodesNodesVulnEqual.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnEqual) GetOrigin() string { return v.AllVulnEqual.Origin }

// GetCollector returns NodesNodesVulnEqual.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnEqual) GetCollector() string { return v.AllVulnEqual.Collector }

func (v *NodesNodesVulnEqual) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesVulnEqual
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesVulnEqual = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnEqual)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesVulnEqual struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Vulnerabilities []AllVulnEqualVulnerabilitiesVulnerability `json:"vulnerabilities"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesVulnEqual) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesVulnEqual) __premarshalJSON() (*__premarshalNodesNodesVulnEqual, error) {
	var retval __premarshalNodesNodesVulnEqual

	retval.Typename = v.Typename
	retval.Id = v.AllVulnEqual.Id
	retval.Vulnerabilities = v.AllVulnEqual.Vulnerabilities
	retval.Justification = v.AllVulnEqual.Justification
	retval.Origin = v.AllVulnEqual.Origin
	retval.Collector = v.AllVulnEqual.Collector
	return &retval, nil
}

// NodesNodesVulnerability includes the requested fields of the GraphQL type Vulnerability.
// The GraphQL type's documentation follows.
//
// Vulnerability represents the root of the vulnerability trie/tree.
//
// We map vulnerability information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type and a vulnerability ID. This allows for generic
// representation of the various vulnerabilities and does not limit to just cve, ghsa or osv.
// This would be in the general format: vuln://<general-type>/<vuln-id>
//
// Examples:
//
// CVE, using path separator: vuln://cve/cve-2023-20753
// OSV, representing its knowledge of a GHSA: vuln://osv/ghsa-205hk
// Random vendor: vuln://snyk/sn-whatever
// NoVuln: vuln://novuln/
//
// This node represents the type part of the trie path. It is used to represent
// the specific type of the vulnerability: cve, ghsa, osv or some other vendor specific
//
// Since this node is at the root of the vulnerability trie, it is named Vulnerability, not
// VulnerabilityType.
//
// NoVuln is a special vulnerability node to attest that no vulnerability has been
// found during a vulnerability scan. It will have the type "novuln" and contain an empty string
// for vulnerabilityID
//
// The resolvers will enforce that both the type and vulnerability IDs are lower case.
type NodesNodesVulnerability struct {
	Typename             *string `json:"__typename"`
	AllVulnerabilityTree `json:"-"`
}

// GetTypename returns NodesNodesVulnerability.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnerability) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesVulnerability.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnerability) GetId() string { return v.AllVulnerabilityTree.Id }

// GetType returns NodesNodesVulnerability.Type, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnerability) GetType() string { return v.AllVulnerabilityTree.Type }

// GetVulnerabilityIDs returns NodesNodesVulnerability.VulnerabilityIDs, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnerability) GetVulnerabilityIDs() []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID {
	return v.AllVulnerabilityTree.VulnerabilityIDs
}

func (v *NodesNodesVulnerability) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesVulnerability
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesVulnerability = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnerabilityTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesVulnerability struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	VulnerabilityIDs []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID `json:"vulnerabilityIDs"`
}

func (v *NodesNodesVulnerability) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesVulnerability) __premarshalJSON() (*__premarshalNodesNodesVulnerability, error) {
	var retval __premarshalNodesNodesVulnerability

	retval.Typename = v.Typename
	retval.Id = v.AllVulnerabilityTree.Id
	retval.Type = v.AllVulnerabilityTree.Type
	retval.VulnerabilityIDs = v.AllVulnerabilityTree.VulnerabilityIDs
	return &retval, nil
}

// NodesNodesVulnerabilityMetadata includes the requested fields of the GraphQL type VulnerabilityMetadata.
// The GraphQL type's documentation follows.
//
// VulnerabilityMetadata is an attestation that a vulnerability has a related score
// associated with it.
//
// The intent of this evidence tree predicate is to allow extensibility of vulnerability
// score (one-to-one mapping) with a specific vulnerability ID.
//
// A vulnerability ID can have a one-to-many relationship with the VulnerabilityMetadata
// node as a vulnerability ID can have multiple scores (in various frameworks).
//
// Examples:
//
// scoreType: EPSSv1
// scoreValue: 0.960760000
//
// scoreType: CVSSv2
// scoreValue: 5.0
//
// scoreType: CVSSv3
// scoreValue: 7.5
//
// The timestamp is used to determine when the score was evaluated for the specific vulnerability.
type NodesNodesVulnerabilityMetadata struct {
	Typename            *string `json:"__typename"`
	AllVulnMetadataTree `json:"-"`
}

// GetTypename returns NodesNodesVulnerabilityMetadata.Typename, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnerabilityMetadata) GetTypename() *string { return v.Typename }

// GetId returns NodesNodesVulnerabilityMetadata.Id, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnerabilityMetadata) GetId() string { return v.AllVulnMetadataTree.Id }

// GetVulnerability returns NodesNodesVulnerabilityMetadata.Vulnerability, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnerabilityMetadata) GetVulnerability() AllVulnMetadataTreeVulnerability {
	return v.AllVulnMetadataTree.Vulnerability
}

// GetScoreType returns NodesNodesVulnerabilityMetadata.ScoreType, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnerabilityMetadata) GetScoreType() VulnerabilityScoreType {
	return v.AllVulnMetadataTree.ScoreType
}

// GetScoreValue returns NodesNodesVulnerabilityMetadata.ScoreValue, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnerabilityMetadata) GetScoreValue() float64 {
	return v.AllVulnMetadataTree.ScoreValue
}

// GetTimestamp returns NodesNodesVulnerabilityMetadata.Timestamp, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnerabilityMetadata) GetTimestamp() time.Time {
	return v.AllVulnMetadataTree.Timestamp
}

// GetOrigin returns NodesNodesVulnerabilityMetadata.Origin, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnerabilityMetadata) GetOrigin() string { return v.AllVulnMetadataTree.Origin }

// GetCollector returns NodesNodesVulnerabilityMetadata.Collector, and is useful for accessing the field via an interface.
func (v *NodesNodesVulnerabilityMetadata) GetCollector() string {
	return v.AllVulnMetadataTree.Collector
}

func (v *NodesNodesVulnerabilityMetadata) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesNodesVulnerabilityMetadata
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesNodesVulnerabilityMetadata = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnMetadataTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalNodesNodesVulnerabilityMetadata struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Vulnerability AllVulnMetadataTreeVulnerability `json:"vulnerability"`

	ScoreType VulnerabilityScoreType `json:"scoreType"`

	ScoreValue float64 `json:"scoreValue"`

	Timestamp time.Time `json:"timestamp"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *NodesNodesVulnerabilityMetadata) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesNodesVulnerabilityMetadata) __premarshalJSON() (*__premarshalNodesNodesVulnerabilityMetadata, error) {
	var retval __premarshalNodesNodesVulnerabilityMetadata

	retval.Typename = v.Typename
	retval.Id = v.AllVulnMetadataTree.Id
	retval.Vulnerability = v.AllVulnMetadataTree.Vulnerability
	retval.ScoreType = v.AllVulnMetadataTree.ScoreType
	retval.ScoreValue = v.AllVulnMetadataTree.ScoreValue
	retval.Timestamp = v.AllVulnMetadataTree.Timestamp
	retval.Origin = v.AllVulnMetadataTree.Origin
	retval.Collector = v.AllVulnMetadataTree.Collector
	return &retval, nil
}

// NodesResponse is returned by Nodes on success.
type NodesResponse struct {
	// nodes returns an array of nodes, regardless of type.
	//
	// The input is an array of IDs to retrieve.
	Nodes []NodesNodesNode `json:"-"`
}

// GetNodes returns NodesResponse.Nodes, and is useful for accessing the field via an interface.
func (v *NodesResponse) GetNodes() []NodesNodesNode { return v.Nodes }

func (v *NodesResponse) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*NodesResponse
		Nodes []json.RawMessage `json:"nodes"`
		graphql.NoUnmarshalJSON
	}
	firstPass.NodesResponse = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Nodes
		src := firstPass.Nodes
		*dst = make(
			[]NodesNodesNode,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				err = __unmarshalNodesNodesNode(
					src, dst)
				if err != nil {
					return fmt.Errorf(
						"unable to unmarshal NodesResponse.Nodes: %w", err)
				}
			}
		}
	}
	return nil
}

type __premarshalNodesResponse struct {
	Nodes []json.RawMessage `json:"nodes"`
}

func (v *NodesResponse) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *NodesResponse) __premarshalJSON() (*__premarshalNodesResponse, error) {
	var retval __premarshalNodesResponse

	{

		dst := &retval.Nodes
		src := v.Nodes
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			var err error
			*dst, err = __marshalNodesNodesNode(
				&src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal NodesResponse.Nodes: %w", err)
			}
		}
	}
	return &retval, nil
}

// PackageNamesPackagesPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type PackageNamesPackagesPackage struct {
	Id         string                                                  `json:"id"`
	Type       string                                                  `json:"type"`
	Namespaces []PackageNamesPackagesPackageNamespacesPackageNamespace `json:"namespaces"`
}

// GetId returns PackageNamesPackagesPackage.Id, and is useful for accessing the field via an interface.
func (v *PackageNamesPackagesPackage) GetId() string { return v.Id }

// GetType returns PackageNamesPackagesPackage.Type, and is useful for accessing the field via an interface.
func (v *PackageNamesPackagesPackage) GetType() string { return v.Type }

// GetNamespaces returns PackageNamesPackagesPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *PackageNamesPackagesPackage) GetNamespaces() []PackageNamesPackagesPackageNamespacesPackageNamespace {
	return v.Namespaces
}

// PackageNamesPackagesPackageNamespacesPackageNamespace includes the requested fields of the GraphQL type PackageNamespace.
// The GraphQL type's documentation follows.
//
// PackageNamespace is a namespace for packages.
//
// In the pURL representation, each PackageNamespace matches the
// pkg:<type>/<namespace>/ partial pURL.
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type PackageNamesPackagesPackageNamespacesPackageNamespace struct {
	Id        string                                                                  `json:"id"`
	Namespace string                                                                  `json:"namespace"`
	Names     []PackageNamesPackagesPackageNamespacesPackageNamespaceNamesPackageName `json:"names"`
}

// GetId returns PackageNamesPackagesPackageNamespacesPackageNamespace.Id, and is useful for accessing the field via an interface.
func (v *PackageNamesPackagesPackageNamespacesPackageNamespace) GetId() string { return v.Id }

// GetNamespace returns PackageNamesPackagesPackageNamespacesPackageNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *PackageNamesPackagesPackageNamespacesPackageNamespace) GetNamespace() string {
	return v.Namespace
}

// GetNames returns PackageNamesPackagesPackageNamespacesPackageNamespace.Names, and is useful for accessing the field via an interface.
func (v *PackageNamesPackagesPackageNamespacesPackageNamespace) GetNames() []PackageNamesPackagesPackageNamespacesPackageNamespaceNamesPackageName {
	return v.Names
}

// PackageNamesPackagesPackageNamespacesPackageNamespaceNamesPackageName includes the requested fields of the GraphQL type PackageName.
// The GraphQL type's documentation follows.
//
// PackageName is a name for packages.
//
// In the pURL representation, each PackageName matches the
// pkg:<type>/<namespace>/<name> pURL.
//
// Names are always mandatory.
//
// This is the first node in the trie that can be referred to by other parts of
// GUAC.
type PackageNamesPackagesPackageNamespacesPackageNamespaceNamesPackageName struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// GetId returns PackageNamesPackagesPackageNamespacesPackageNamespaceNamesPackageName.Id, and is useful for accessing the field via an interface.
func (v *PackageNamesPackagesPackageNamespacesPackageNamespaceNamesPackageName) GetId() string {
	return v.Id
}

// GetName returns PackageNamesPackagesPackageNamespacesPackageNamespaceNamesPackageName.Name, and is useful for accessing the field via an interface.
func (v *PackageNamesPackagesPackageNamespacesPackageNamespaceNamesPackageName) GetName() string {
	return v.Name
}

// PackageNamesResponse is returned by PackageNames on success.
type PackageNamesResponse struct {
	// Returns all packages matching a filter.
	Packages []PackageNamesPackagesPackage `json:"packages"`
}

// GetPackages returns PackageNamesResponse.Packages, and is useful for accessing the field via an interface.
func (v *PackageNamesResponse) GetPackages() []PackageNamesPackagesPackage { return v.Packages }

// PackageNamespacesPackagesPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type PackageNamespacesPackagesPackage struct {
	Id         string                                                       `json:"id"`
	Type       string                                                       `json:"type"`
	Namespaces []PackageNamespacesPackagesPackageNamespacesPackageNamespace `json:"namespaces"`
}

// GetId returns PackageNamespacesPackagesPackage.Id, and is useful for accessing the field via an interface.
func (v *PackageNamespacesPackagesPackage) GetId() string { return v.Id }

// GetType returns PackageNamespacesPackagesPackage.Type, and is useful for accessing the field via an interface.
func (v *PackageNamespacesPackagesPackage) GetType() string { return v.Type }

// GetNamespaces returns PackageNamespacesPackagesPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *PackageNamespacesPackagesPackage) GetNamespaces() []PackageNamespacesPackagesPackageNamespacesPackageNamespace {
	return v.Namespaces
}

// PackageNamespacesPackagesPackageNamespacesPackageNamespace includes the requested fields of the GraphQL type PackageNamespace.
// The GraphQL type's documentation follows.
//
// PackageNamespace is a namespace for packages.
//
// In the pURL representation, each PackageNamespace matches the
// pkg:<type>/<namespace>/ partial pURL.
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type PackageNamespacesPackagesPackageNamespacesPackageNamespace struct {
	Id        string `json:"id"`
	Namespace string `json:"namespace"`
}

// GetId returns PackageNamespacesPackagesPackageNamespacesPackageNamespace.Id, and is useful for accessing the field via an interface.
func (v *PackageNamespacesPackagesPackageNamespacesPackageNamespace) GetId() string { return v.Id }

// GetNamespace returns PackageNamespacesPackagesPackageNamespacesPackageNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *PackageNamespacesPackagesPackageNamespacesPackageNamespace) GetNamespace() string {
	return v.Namespace
}

// PackageNamespacesResponse is returned by PackageNamespaces on success.
type PackageNamespacesResponse struct {
	// Returns all packages matching a filter.
	Packages []PackageNamespacesPackagesPackage `json:"packages"`
}

// GetPackages returns PackageNamespacesResponse.Packages, and is useful for accessing the field via an interface.
func (v *PackageNamespacesResponse) GetPackages() []PackageNamespacesPackagesPackage {
	return v.Packages
}

// PackageOrSourceSpec allows using PackageOrSource union as input for queries.
//
// Exactly one field must be specified.
type PackageOrSourceSpec struct {
	Package *PkgSpec    `json:"package"`
	Source  *SourceSpec `json:"source"`
}

// GetPackage returns PackageOrSourceSpec.Package, and is useful for accessing the field via an interface.
func (v *PackageOrSourceSpec) GetPackage() *PkgSpec { return v.Package }

// GetSource returns PackageOrSourceSpec.Source, and is useful for accessing the field via an interface.
func (v *PackageOrSourceSpec) GetSource() *SourceSpec { return v.Source }

// PackageQualifierInputSpec allows specifying package qualifiers in mutations.
type PackageQualifierInputSpec struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns PackageQualifierInputSpec.Key, and is useful for accessing the field via an interface.
func (v *PackageQualifierInputSpec) GetKey() string { return v.Key }

// GetValue returns PackageQualifierInputSpec.Value, and is useful for accessing the field via an interface.
func (v *PackageQualifierInputSpec) GetValue() string { return v.Value }

// PackageQualifierSpec allows filtering package qualifiers in a query.
//
// Keys are mandatory, but values could also be null if we want to match all
// values for a specific key.
//
// NOTE: Before the schema becomes stable, we might change the nulability
// requirements of these fields.
type PackageQualifierSpec struct {
	Key   string  `json:"key"`
	Value *string `json:"value"`
}

// GetKey returns PackageQualifierSpec.Key, and is useful for accessing the field via an interface.
func (v *PackageQualifierSpec) GetKey() string { return v.Key }

// GetValue returns PackageQualifierSpec.Value, and is useful for accessing the field via an interface.
func (v *PackageQualifierSpec) GetValue() *string { return v.Value }

// PackageSourceOrArtifactSpec allows using PackageSourceOrArtifact union as
// input type to be used in read queries.
//
// Exactly one of the value must be set to non-nil.
type PackageSourceOrArtifactSpec struct {
	Package  *PkgSpec      `json:"package"`
	Source   *SourceSpec   `json:"source"`
	Artifact *ArtifactSpec `json:"artifact"`
}

// GetPackage returns PackageSourceOrArtifactSpec.Package, and is useful for accessing the field via an interface.
func (v *PackageSourceOrArtifactSpec) GetPackage() *PkgSpec { return v.Package }

// GetSource returns PackageSourceOrArtifactSpec.Source, and is useful for accessing the field via an interface.
func (v *PackageSourceOrArtifactSpec) GetSource() *SourceSpec { return v.Source }

// GetArtifact returns PackageSourceOrArtifactSpec.Artifact, and is useful for accessing the field via an interface.
func (v *PackageSourceOrArtifactSpec) GetArtifact() *ArtifactSpec { return v.Artifact }

// PackageTypesPackagesPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type PackageTypesPackagesPackage struct {
	Id   string `json:"id"`
	Type string `json:"type"`
}

// GetId returns PackageTypesPackagesPackage.Id, and is useful for accessing the field via an interface.
func (v *PackageTypesPackagesPackage) GetId() string { return v.Id }

// GetType returns PackageTypesPackagesPackage.Type, and is useful for accessing the field via an interface.
func (v *PackageTypesPackagesPackage) GetType() string { return v.Type }

// PackageTypesResponse is returned by PackageTypes on success.
type PackageTypesResponse struct {
	// Returns all packages matching a filter.
	Packages []PackageTypesPackagesPackage `json:"packages"`
}

// GetPackages returns PackageTypesResponse.Packages, and is useful for accessing the field via an interface.
func (v *PackageTypesResponse) GetPackages() []PackageTypesPackagesPackage { return v.Packages }

// PackageVersionsPackagesPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type PackageVersionsPackagesPackage struct {
	Id         string                                                     `json:"id"`
	Type       string                                                     `json:"type"`
	Namespaces []PackageVersionsPackagesPackageNamespacesPackageNamespace `json:"namespaces"`
}

// GetId returns PackageVersionsPackagesPackage.Id, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackage) GetId() string { return v.Id }

// GetType returns PackageVersionsPackagesPackage.Type, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackage) GetType() string { return v.Type }

// GetNamespaces returns PackageVersionsPackagesPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackage) GetNamespaces() []PackageVersionsPackagesPackageNamespacesPackageNamespace {
	return v.Namespaces
}

// PackageVersionsPackagesPackageNamespacesPackageNamespace includes the requested fields of the GraphQL type PackageNamespace.
// The GraphQL type's documentation follows.
//
// PackageNamespace is a namespace for packages.
//
// In the pURL representation, each PackageNamespace matches the
// pkg:<type>/<namespace>/ partial pURL.
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type PackageVersionsPackagesPackageNamespacesPackageNamespace struct {
	Id        string                                                                     `json:"id"`
	Namespace string                                                                     `json:"namespace"`
	Names     []PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageName `json:"names"`
}

// GetId returns PackageVersionsPackagesPackageNamespacesPackageNamespace.Id, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackageNamespacesPackageNamespace) GetId() string { return v.Id }

// GetNamespace returns PackageVersionsPackagesPackageNamespacesPackageNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackageNamespacesPackageNamespace) GetNamespace() string {
	return v.Namespace
}

// GetNames returns PackageVersionsPackagesPackageNamespacesPackageNamespace.Names, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackageNamespacesPackageNamespace) GetNames() []PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageName {
	return v.Names
}

// PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageName includes the requested fields of the GraphQL type PackageName.
// The GraphQL type's documentation follows.
//
// PackageName is a name for packages.
//
// In the pURL representation, each PackageName matches the
// pkg:<type>/<namespace>/<name> pURL.
//
// Names are always mandatory.
//
// This is the first node in the trie that can be referred to by other parts of
// GUAC.
type PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageName struct {
	Id       string                                                                                           `json:"id"`
	Name     string                                                                                           `json:"name"`
	Versions []PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion `json:"versions"`
}

// GetId returns PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageName.Id, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageName) GetId() string {
	return v.Id
}

// GetName returns PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageName.Name, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageName) GetName() string {
	return v.Name
}

// GetVersions returns PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageName.Versions, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageName) GetVersions() []PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion {
	return v.Versions
}

// PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion includes the requested fields of the GraphQL type PackageVersion.
// The GraphQL type's documentation follows.
//
// PackageVersion is a package version.
//
// In the pURL representation, each PackageName matches the
// pkg:<type>/<namespace>/<name>@<version> pURL.
//
// Versions are optional and each Package type defines own rules for handling
// them. For this level of GUAC, these are just opaque strings.
//
// NOTE: The handling of versions might change before this schema becomes stable.
//
// This node can be referred to by other parts of GUAC.
//
// Subpath and qualifiers are optional. Lack of qualifiers is represented by an
// empty list and lack of subpath by empty string (to be consistent with
// optionality of namespace and version). Two nodes that have different qualifiers
// and/or subpath but the same version mean two different packages in the trie
// (they are different). Two nodes that have same version but qualifiers of one
// are a subset of the qualifier of the other also mean two different packages in
// the trie.
type PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion struct {
	Id         string                                                                                                                     `json:"id"`
	Version    string                                                                                                                     `json:"version"`
	Qualifiers []PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier `json:"qualifiers"`
	Subpath    string                                                                                                                     `json:"subpath"`
}

// GetId returns PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Id, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetId() string {
	return v.Id
}

// GetVersion returns PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Version, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetVersion() string {
	return v.Version
}

// GetQualifiers returns PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Qualifiers, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetQualifiers() []PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier {
	return v.Qualifiers
}

// GetSubpath returns PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Subpath, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetSubpath() string {
	return v.Subpath
}

// PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier includes the requested fields of the GraphQL type PackageQualifier.
// The GraphQL type's documentation follows.
//
// PackageQualifier is a qualifier for a package, a key-value pair.
//
// In the pURL representation, it is a part of the <qualifiers> part of the
// pkg:<type>/<namespace>/<name>@<version>?<qualifiers> pURL.
//
// Qualifiers are optional, each Package type defines own rules for handling them,
// and multiple qualifiers could be attached to the same package.
//
// This node cannot be directly referred by other parts of GUAC.
type PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Key, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetKey() string {
	return v.Key
}

// GetValue returns PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Value, and is useful for accessing the field via an interface.
func (v *PackageVersionsPackagesPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetValue() string {
	return v.Value
}

// PackageVersionsResponse is returned by PackageVersions on success.
type PackageVersionsResponse struct {
	// Returns all packages matching a filter.
	Packages []PackageVersionsPackagesPackage `json:"packages"`
}

// GetPackages returns PackageVersionsResponse.Packages, and is useful for accessing the field via an interface.
func (v *PackageVersionsResponse) GetPackages() []PackageVersionsPackagesPackage { return v.Packages }

// PackagesPackagesPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type PackagesPackagesPackage struct {
	AllPkgTree `json:"-"`
}

// GetId returns PackagesPackagesPackage.Id, and is useful for accessing the field via an interface.
func (v *PackagesPackagesPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns PackagesPackagesPackage.Type, and is useful for accessing the field via an interface.
func (v *PackagesPackagesPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns PackagesPackagesPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *PackagesPackagesPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *PackagesPackagesPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PackagesPackagesPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.PackagesPackagesPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPackagesPackagesPackage struct {
	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *PackagesPackagesPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PackagesPackagesPackage) __premarshalJSON() (*__premarshalPackagesPackagesPackage, error) {
	var retval __premarshalPackagesPackagesPackage

	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// PackagesResponse is returned by Packages on success.
type PackagesResponse struct {
	// Returns all packages matching a filter.
	Packages []PackagesPackagesPackage `json:"packages"`
}

// GetPackages returns PackagesResponse.Packages, and is useful for accessing the field via an interface.
func (v *PackagesResponse) GetPackages() []PackagesPackagesPackage { return v.Packages }

// PathPathArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// Artifact represents an artifact identified by a checksum hash.
//
// The checksum is split into the digest value and the algorithm used to generate
// it. Both fields are mandatory and canonicalized to be lowercase.
//
// If having a checksum Go object, algorithm can be
// strings.ToLower(string(checksum.Algorithm)) and digest can be checksum.Value.
type PathPathArtifact struct {
	Typename        *string `json:"__typename"`
	AllArtifactTree `json:"-"`
}

// GetTypename returns PathPathArtifact.Typename, and is useful for accessing the field via an interface.
func (v *PathPathArtifact) GetTypename() *string { return v.Typename }

// GetId returns PathPathArtifact.Id, and is useful for accessing the field via an interface.
func (v *PathPathArtifact) GetId() string { return v.AllArtifactTree.Id }

// GetAlgorithm returns PathPathArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *PathPathArtifact) GetAlgorithm() string { return v.AllArtifactTree.Algorithm }

// GetDigest returns PathPathArtifact.Digest, and is useful for accessing the field via an interface.
func (v *PathPathArtifact) GetDigest() string { return v.AllArtifactTree.Digest }

func (v *PathPathArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathArtifact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *PathPathArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathArtifact) __premarshalJSON() (*__premarshalPathPathArtifact, error) {
	var retval __premarshalPathPathArtifact

	retval.Typename = v.Typename
	retval.Id = v.AllArtifactTree.Id
	retval.Algorithm = v.AllArtifactTree.Algorithm
	retval.Digest = v.AllArtifactTree.Digest
	return &retval, nil
}

// PathPathBuilder includes the requested fields of the GraphQL type Builder.
// The GraphQL type's documentation follows.
//
// Builder represents the builder (e.g., FRSCA or GitHub Actions).
//
// Currently builders are identified by the uri field.
type PathPathBuilder struct {
	Typename       *string `json:"__typename"`
	AllBuilderTree `json:"-"`
}

// GetTypename returns PathPathBuilder.Typename, and is useful for accessing the field via an interface.
func (v *PathPathBuilder) GetTypename() *string { return v.Typename }

// GetId returns PathPathBuilder.Id, and is useful for accessing the field via an interface.
func (v *PathPathBuilder) GetId() string { return v.AllBuilderTree.Id }

// GetUri returns PathPathBuilder.Uri, and is useful for accessing the field via an interface.
func (v *PathPathBuilder) GetUri() string { return v.AllBuilderTree.Uri }

func (v *PathPathBuilder) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathBuilder
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathBuilder = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllBuilderTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathBuilder struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Uri string `json:"uri"`
}

func (v *PathPathBuilder) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathBuilder) __premarshalJSON() (*__premarshalPathPathBuilder, error) {
	var retval __premarshalPathPathBuilder

	retval.Typename = v.Typename
	retval.Id = v.AllBuilderTree.Id
	retval.Uri = v.AllBuilderTree.Uri
	return &retval, nil
}

// PathPathCertifyBad includes the requested fields of the GraphQL type CertifyBad.
// The GraphQL type's documentation follows.
//
// CertifyBad is an attestation that a package, source, or artifact is considered
// bad.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The certification applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type PathPathCertifyBad struct {
	Typename      *string `json:"__typename"`
	AllCertifyBad `json:"-"`
}

// GetTypename returns PathPathCertifyBad.Typename, and is useful for accessing the field via an interface.
func (v *PathPathCertifyBad) GetTypename() *string { return v.Typename }

// GetId returns PathPathCertifyBad.Id, and is useful for accessing the field via an interface.
func (v *PathPathCertifyBad) GetId() string { return v.AllCertifyBad.Id }

// GetJustification returns PathPathCertifyBad.Justification, and is useful for accessing the field via an interface.
func (v *PathPathCertifyBad) GetJustification() string { return v.AllCertifyBad.Justification }

// GetSubject returns PathPathCertifyBad.Subject, and is useful for accessing the field via an interface.
func (v *PathPathCertifyBad) GetSubject() AllCertifyBadSubjectPackageSourceOrArtifact {
	return v.AllCertifyBad.Subject
}

// GetOrigin returns PathPathCertifyBad.Origin, and is useful for accessing the field via an interface.
func (v *PathPathCertifyBad) GetOrigin() string { return v.AllCertifyBad.Origin }

// GetCollector returns PathPathCertifyBad.Collector, and is useful for accessing the field via an interface.
func (v *PathPathCertifyBad) GetCollector() string { return v.AllCertifyBad.Collector }

func (v *PathPathCertifyBad) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathCertifyBad
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathCertifyBad = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyBad)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathCertifyBad struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathCertifyBad) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathCertifyBad) __premarshalJSON() (*__premarshalPathPathCertifyBad, error) {
	var retval __premarshalPathPathCertifyBad

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyBad.Id
	retval.Justification = v.AllCertifyBad.Justification
	{

		dst := &retval.Subject
		src := v.AllCertifyBad.Subject
		var err error
		*dst, err = __marshalAllCertifyBadSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal PathPathCertifyBad.AllCertifyBad.Subject: %w", err)
		}
	}
	retval.Origin = v.AllCertifyBad.Origin
	retval.Collector = v.AllCertifyBad.Collector
	return &retval, nil
}

// PathPathCertifyGood includes the requested fields of the GraphQL type CertifyGood.
// The GraphQL type's documentation follows.
//
// CertifyGood is an attestation that a package, source, or artifact is considered
// good.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The certification applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type PathPathCertifyGood struct {
	Typename       *string `json:"__typename"`
	AllCertifyGood `json:"-"`
}

// GetTypename returns PathPathCertifyGood.Typename, and is useful for accessing the field via an interface.
func (v *PathPathCertifyGood) GetTypename() *string { return v.Typename }

// GetId returns PathPathCertifyGood.Id, and is useful for accessing the field via an interface.
func (v *PathPathCertifyGood) GetId() string { return v.AllCertifyGood.Id }

// GetJustification returns PathPathCertifyGood.Justification, and is useful for accessing the field via an interface.
func (v *PathPathCertifyGood) GetJustification() string { return v.AllCertifyGood.Justification }

// GetSubject returns PathPathCertifyGood.Subject, and is useful for accessing the field via an interface.
func (v *PathPathCertifyGood) GetSubject() AllCertifyGoodSubjectPackageSourceOrArtifact {
	return v.AllCertifyGood.Subject
}

// GetOrigin returns PathPathCertifyGood.Origin, and is useful for accessing the field via an interface.
func (v *PathPathCertifyGood) GetOrigin() string { return v.AllCertifyGood.Origin }

// GetCollector returns PathPathCertifyGood.Collector, and is useful for accessing the field via an interface.
func (v *PathPathCertifyGood) GetCollector() string { return v.AllCertifyGood.Collector }

func (v *PathPathCertifyGood) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathCertifyGood
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathCertifyGood = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyGood)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathCertifyGood struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathCertifyGood) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathCertifyGood) __premarshalJSON() (*__premarshalPathPathCertifyGood, error) {
	var retval __premarshalPathPathCertifyGood

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyGood.Id
	retval.Justification = v.AllCertifyGood.Justification
	{

		dst := &retval.Subject
		src := v.AllCertifyGood.Subject
		var err error
		*dst, err = __marshalAllCertifyGoodSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal PathPathCertifyGood.AllCertifyGood.Subject: %w", err)
		}
	}
	retval.Origin = v.AllCertifyGood.Origin
	retval.Collector = v.AllCertifyGood.Collector
	return &retval, nil
}

// PathPathCertifyLegal includes the requested fields of the GraphQL type CertifyLegal.
// The GraphQL type's documentation follows.
//
// CertifyLegal is an attestation to attach legal information to a package or source.
//
// The certification information is either copied from an attestation found in an
// SBOM or created by a collector/scanner.
//
// Discovered license is also known as Concluded. More information:
// https://docs.clearlydefined.io/curation-guidelines#the-difference-between-declared-and-discovered-licenses
//
// Attribution is also known as Copyright Text. It is what could be displayed to
// comply with notice
// requirements. https://www.nexb.com/oss-attribution-best-practices/
//
// License expressions follow this format:
// https://spdx.github.io/spdx-spec/v2.3/SPDX-license-expressions/
type PathPathCertifyLegal struct {
	Typename            *string `json:"__typename"`
	AllCertifyLegalTree `json:"-"`
}

// GetTypename returns PathPathCertifyLegal.Typename, and is useful for accessing the field via an interface.
func (v *PathPathCertifyLegal) GetTypename() *string { return v.Typename }

// GetId returns PathPathCertifyLegal.Id, and is useful for accessing the field via an interface.
func (v *PathPathCertifyLegal) GetId() string { return v.AllCertifyLegalTree.Id }

// GetSubject returns PathPathCertifyLegal.Subject, and is useful for accessing the field via an interface.
func (v *PathPathCertifyLegal) GetSubject() AllCertifyLegalTreeSubjectPackageOrSource {
	return v.AllCertifyLegalTree.Subject
}

// GetDeclaredLicense returns PathPathCertifyLegal.DeclaredLicense, and is useful for accessing the field via an interface.
func (v *PathPathCertifyLegal) GetDeclaredLicense() string {
	return v.AllCertifyLegalTree.DeclaredLicense
}

// GetDeclaredLicenses returns PathPathCertifyLegal.DeclaredLicenses, and is useful for accessing the field via an interface.
func (v *PathPathCertifyLegal) GetDeclaredLicenses() []AllCertifyLegalTreeDeclaredLicensesLicense {
	return v.AllCertifyLegalTree.DeclaredLicenses
}

// GetDiscoveredLicense returns PathPathCertifyLegal.DiscoveredLicense, and is useful for accessing the field via an interface.
func (v *PathPathCertifyLegal) GetDiscoveredLicense() string {
	return v.AllCertifyLegalTree.DiscoveredLicense
}

// GetDiscoveredLicenses returns PathPathCertifyLegal.DiscoveredLicenses, and is useful for accessing the field via an interface.
func (v *PathPathCertifyLegal) GetDiscoveredLicenses() []AllCertifyLegalTreeDiscoveredLicensesLicense {
	return v.AllCertifyLegalTree.DiscoveredLicenses
}

// GetAttribution returns PathPathCertifyLegal.Attribution, and is useful for accessing the field via an interface.
func (v *PathPathCertifyLegal) GetAttribution() string { return v.AllCertifyLegalTree.Attribution }

// GetJustification returns PathPathCertifyLegal.Justification, and is useful for accessing the field via an interface.
func (v *PathPathCertifyLegal) GetJustification() string { return v.AllCertifyLegalTree.Justification }

// GetTimeScanned returns PathPathCertifyLegal.TimeScanned, and is useful for accessing the field via an interface.
func (v *PathPathCertifyLegal) GetTimeScanned() time.Time { return v.AllCertifyLegalTree.TimeScanned }

// GetOrigin returns PathPathCertifyLegal.Origin, and is useful for accessing the field via an interface.
func (v *PathPathCertifyLegal) GetOrigin() string { return v.AllCertifyLegalTree.Origin }

// GetCollector returns PathPathCertifyLegal.Collector, and is useful for accessing the field via an interface.
func (v *PathPathCertifyLegal) GetCollector() string { return v.AllCertifyLegalTree.Collector }

func (v *PathPathCertifyLegal) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathCertifyLegal
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathCertifyLegal = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyLegalTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathCertifyLegal struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	DeclaredLicense string `json:"declaredLicense"`

	DeclaredLicenses []AllCertifyLegalTreeDeclaredLicensesLicense `json:"declaredLicenses"`

	DiscoveredLicense string `json:"discoveredLicense"`

	DiscoveredLicenses []AllCertifyLegalTreeDiscoveredLicensesLicense `json:"discoveredLicenses"`

	Attribution string `json:"attribution"`

	Justification string `json:"justification"`

	TimeScanned time.Time `json:"timeScanned"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathCertifyLegal) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathCertifyLegal) __premarshalJSON() (*__premarshalPathPathCertifyLegal, error) {
	var retval __premarshalPathPathCertifyLegal

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyLegalTree.Id
	{

		dst := &retval.Subject
		src := v.AllCertifyLegalTree.Subject
		var err error
		*dst, err = __marshalAllCertifyLegalTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal PathPathCertifyLegal.AllCertifyLegalTree.Subject: %w", err)
		}
	}
	retval.DeclaredLicense = v.AllCertifyLegalTree.DeclaredLicense
	retval.DeclaredLicenses = v.AllCertifyLegalTree.DeclaredLicenses
	retval.DiscoveredLicense = v.AllCertifyLegalTree.DiscoveredLicense
	retval.DiscoveredLicenses = v.AllCertifyLegalTree.DiscoveredLicenses
	retval.Attribution = v.AllCertifyLegalTree.Attribution
	retval.Justification = v.AllCertifyLegalTree.Justification
	retval.TimeScanned = v.AllCertifyLegalTree.TimeScanned
	retval.Origin = v.AllCertifyLegalTree.Origin
	retval.Collector = v.AllCertifyLegalTree.Collector
	return &retval, nil
}

// PathPathCertifyScorecard includes the requested fields of the GraphQL type CertifyScorecard.
// The GraphQL type's documentation follows.
//
// CertifyScorecard is an attestation to attach a Scorecard analysis to a
// particular source repository.
type PathPathCertifyScorecard struct {
	Typename            *string `json:"__typename"`
	AllCertifyScorecard `json:"-"`
}

// GetTypename returns PathPathCertifyScorecard.Typename, and is useful for accessing the field via an interface.
func (v *PathPathCertifyScorecard) GetTypename() *string { return v.Typename }

// GetId returns PathPathCertifyScorecard.Id, and is useful for accessing the field via an interface.
func (v *PathPathCertifyScorecard) GetId() string { return v.AllCertifyScorecard.Id }

// GetSource returns PathPathCertifyScorecard.Source, and is useful for accessing the field via an interface.
func (v *PathPathCertifyScorecard) GetSource() AllCertifyScorecardSource {
	return v.AllCertifyScorecard.Source
}

// GetScorecard returns PathPathCertifyScorecard.Scorecard, and is useful for accessing the field via an interface.
func (v *PathPathCertifyScorecard) GetScorecard() AllCertifyScorecardScorecard {
	return v.AllCertifyScorecard.Scorecard
}

func (v *PathPathCertifyScorecard) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathCertifyScorecard
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathCertifyScorecard = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyScorecard)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathCertifyScorecard struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Source AllCertifyScorecardSource `json:"source"`

	Scorecard AllCertifyScorecardScorecard `json:"scorecard"`
}

func (v *PathPathCertifyScorecard) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathCertifyScorecard) __premarshalJSON() (*__premarshalPathPathCertifyScorecard, error) {
	var retval __premarshalPathPathCertifyScorecard

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyScorecard.Id
	retval.Source = v.AllCertifyScorecard.Source
	retval.Scorecard = v.AllCertifyScorecard.Scorecard
	return &retval, nil
}

// PathPathCertifyVEXStatement includes the requested fields of the GraphQL type CertifyVEXStatement.
// The GraphQL type's documentation follows.
//
// CertifyVEXStatement is an attestation to attach VEX statements to a package or
// artifact to clarify the impact of a specific vulnerability.
type PathPathCertifyVEXStatement struct {
	Typename               *string `json:"__typename"`
	AllCertifyVEXStatement `json:"-"`
}

// GetTypename returns PathPathCertifyVEXStatement.Typename, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVEXStatement) GetTypename() *string { return v.Typename }

// GetId returns PathPathCertifyVEXStatement.Id, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVEXStatement) GetId() string { return v.AllCertifyVEXStatement.Id }

// GetSubject returns PathPathCertifyVEXStatement.Subject, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVEXStatement) GetSubject() AllCertifyVEXStatementSubjectPackageOrArtifact {
	return v.AllCertifyVEXStatement.Subject
}

// GetVulnerability returns PathPathCertifyVEXStatement.Vulnerability, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVEXStatement) GetVulnerability() AllCertifyVEXStatementVulnerability {
	return v.AllCertifyVEXStatement.Vulnerability
}

// GetStatus returns PathPathCertifyVEXStatement.Status, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVEXStatement) GetStatus() VexStatus { return v.AllCertifyVEXStatement.Status }

// GetVexJustification returns PathPathCertifyVEXStatement.VexJustification, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVEXStatement) GetVexJustification() VexJustification {
	return v.AllCertifyVEXStatement.VexJustification
}

// GetStatement returns PathPathCertifyVEXStatement.Statement, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVEXStatement) GetStatement() string {
	return v.AllCertifyVEXStatement.Statement
}

// GetStatusNotes returns PathPathCertifyVEXStatement.StatusNotes, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVEXStatement) GetStatusNotes() string {
	return v.AllCertifyVEXStatement.StatusNotes
}

// GetKnownSince returns PathPathCertifyVEXStatement.KnownSince, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVEXStatement) GetKnownSince() time.Time {
	return v.AllCertifyVEXStatement.KnownSince
}

// GetOrigin returns PathPathCertifyVEXStatement.Origin, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVEXStatement) GetOrigin() string { return v.AllCertifyVEXStatement.Origin }

// GetCollector returns PathPathCertifyVEXStatement.Collector, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVEXStatement) GetCollector() string {
	return v.AllCertifyVEXStatement.Collector
}

func (v *PathPathCertifyVEXStatement) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathCertifyVEXStatement
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathCertifyVEXStatement = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyVEXStatement)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathCertifyVEXStatement struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Vulnerability AllCertifyVEXStatementVulnerability `json:"vulnerability"`

	Status VexStatus `json:"status"`

	VexJustification VexJustification `json:"vexJustification"`

	Statement string `json:"statement"`

	StatusNotes string `json:"statusNotes"`

	KnownSince time.Time `json:"knownSince"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathCertifyVEXStatement) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathCertifyVEXStatement) __premarshalJSON() (*__premarshalPathPathCertifyVEXStatement, error) {
	var retval __premarshalPathPathCertifyVEXStatement

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyVEXStatement.Id
	{

		dst := &retval.Subject
		src := v.AllCertifyVEXStatement.Subject
		var err error
		*dst, err = __marshalAllCertifyVEXStatementSubjectPackageOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal PathPathCertifyVEXStatement.AllCertifyVEXStatement.Subject: %w", err)
		}
	}
	retval.Vulnerability = v.AllCertifyVEXStatement.Vulnerability
	retval.Status = v.AllCertifyVEXStatement.Status
	retval.VexJustification = v.AllCertifyVEXStatement.VexJustification
	retval.Statement = v.AllCertifyVEXStatement.Statement
	retval.StatusNotes = v.AllCertifyVEXStatement.StatusNotes
	retval.KnownSince = v.AllCertifyVEXStatement.KnownSince
	retval.Origin = v.AllCertifyVEXStatement.Origin
	retval.Collector = v.AllCertifyVEXStatement.Collector
	return &retval, nil
}

// PathPathCertifyVuln includes the requested fields of the GraphQL type CertifyVuln.
// The GraphQL type's documentation follows.
//
// CertifyVuln is an attestation to attach vulnerability information to a package.
//
// This information is obtained via a scanner. If there is no vulnerability
// detected, we attach the a vulnerability with "NoVuln" type and an empty string
// for the vulnerability ID.
type PathPathCertifyVuln struct {
	Typename       *string `json:"__typename"`
	AllCertifyVuln `json:"-"`
}

// GetTypename returns PathPathCertifyVuln.Typename, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVuln) GetTypename() *string { return v.Typename }

// GetId returns PathPathCertifyVuln.Id, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVuln) GetId() string { return v.AllCertifyVuln.Id }

// GetPackage returns PathPathCertifyVuln.Package, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVuln) GetPackage() AllCertifyVulnPackage { return v.AllCertifyVuln.Package }

// GetVulnerability returns PathPathCertifyVuln.Vulnerability, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVuln) GetVulnerability() AllCertifyVulnVulnerability {
	return v.AllCertifyVuln.Vulnerability
}

// GetMetadata returns PathPathCertifyVuln.Metadata, and is useful for accessing the field via an interface.
func (v *PathPathCertifyVuln) GetMetadata() AllCertifyVulnMetadataScanMetadata {
	return v.AllCertifyVuln.Metadata
}

func (v *PathPathCertifyVuln) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathCertifyVuln
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathCertifyVuln = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllCertifyVuln)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathCertifyVuln struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Package AllCertifyVulnPackage `json:"package"`

	Vulnerability AllCertifyVulnVulnerability `json:"vulnerability"`

	Metadata AllCertifyVulnMetadataScanMetadata `json:"metadata"`
}

func (v *PathPathCertifyVuln) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathCertifyVuln) __premarshalJSON() (*__premarshalPathPathCertifyVuln, error) {
	var retval __premarshalPathPathCertifyVuln

	retval.Typename = v.Typename
	retval.Id = v.AllCertifyVuln.Id
	retval.Package = v.AllCertifyVuln.Package
	retval.Vulnerability = v.AllCertifyVuln.Vulnerability
	retval.Metadata = v.AllCertifyVuln.Metadata
	return &retval, nil
}

// PathPathHasMetadata includes the requested fields of the GraphQL type HasMetadata.
// The GraphQL type's documentation follows.
//
// HasMetadata is an attestation that a package, source, or artifact has a certain
// attested property (key) with value (value). For example, a source may have
// metadata "SourceRepo2FAEnabled=true".
//
// The intent of this evidence tree predicate is to allow extensibility of metadata
// expressible within the GUAC ontology. Metadata that is commonly used will then
// be promoted to a predicate on its own.
//
// Justification indicates how the metadata was determined.
//
// The metadata applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
type PathPathHasMetadata struct {
	Typename       *string `json:"__typename"`
	AllHasMetadata `json:"-"`
}

// GetTypename returns PathPathHasMetadata.Typename, and is useful for accessing the field via an interface.
func (v *PathPathHasMetadata) GetTypename() *string { return v.Typename }

// GetId returns PathPathHasMetadata.Id, and is useful for accessing the field via an interface.
func (v *PathPathHasMetadata) GetId() string { return v.AllHasMetadata.Id }

// GetSubject returns PathPathHasMetadata.Subject, and is useful for accessing the field via an interface.
func (v *PathPathHasMetadata) GetSubject() AllHasMetadataSubjectPackageSourceOrArtifact {
	return v.AllHasMetadata.Subject
}

// GetKey returns PathPathHasMetadata.Key, and is useful for accessing the field via an interface.
func (v *PathPathHasMetadata) GetKey() string { return v.AllHasMetadata.Key }

// GetValue returns PathPathHasMetadata.Value, and is useful for accessing the field via an interface.
func (v *PathPathHasMetadata) GetValue() string { return v.AllHasMetadata.Value }

// GetTimestamp returns PathPathHasMetadata.Timestamp, and is useful for accessing the field via an interface.
func (v *PathPathHasMetadata) GetTimestamp() time.Time { return v.AllHasMetadata.Timestamp }

// GetJustification returns PathPathHasMetadata.Justification, and is useful for accessing the field via an interface.
func (v *PathPathHasMetadata) GetJustification() string { return v.AllHasMetadata.Justification }

// GetOrigin returns PathPathHasMetadata.Origin, and is useful for accessing the field via an interface.
func (v *PathPathHasMetadata) GetOrigin() string { return v.AllHasMetadata.Origin }

// GetCollector returns PathPathHasMetadata.Collector, and is useful for accessing the field via an interface.
func (v *PathPathHasMetadata) GetCollector() string { return v.AllHasMetadata.Collector }

func (v *PathPathHasMetadata) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathHasMetadata
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathHasMetadata = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHasMetadata)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathHasMetadata struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Key string `json:"key"`

	Value string `json:"value"`

	Timestamp time.Time `json:"timestamp"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathHasMetadata) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathHasMetadata) __premarshalJSON() (*__premarshalPathPathHasMetadata, error) {
	var retval __premarshalPathPathHasMetadata

	retval.Typename = v.Typename
	retval.Id = v.AllHasMetadata.Id
	{

		dst := &retval.Subject
		src := v.AllHasMetadata.Subject
		var err error
		*dst, err = __marshalAllHasMetadataSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal PathPathHasMetadata.AllHasMetadata.Subject: %w", err)
		}
	}
	retval.Key = v.AllHasMetadata.Key
	retval.Value = v.AllHasMetadata.Value
	retval.Timestamp = v.AllHasMetadata.Timestamp
	retval.Justification = v.AllHasMetadata.Justification
	retval.Origin = v.AllHasMetadata.Origin
	retval.Collector = v.AllHasMetadata.Collector
	return &retval, nil
}

// PathPathHasSBOM includes the requested fields of the GraphQL type HasSBOM.
type PathPathHasSBOM struct {
	Typename       *string `json:"__typename"`
	AllHasSBOMTree `json:"-"`
}

// GetTypename returns PathPathHasSBOM.Typename, and is useful for accessing the field via an interface.
func (v *PathPathHasSBOM) GetTypename() *string { return v.Typename }

// GetId returns PathPathHasSBOM.Id, and is useful for accessing the field via an interface.
func (v *PathPathHasSBOM) GetId() string { return v.AllHasSBOMTree.Id }

// GetSubject returns PathPathHasSBOM.Subject, and is useful for accessing the field via an interface.
func (v *PathPathHasSBOM) GetSubject() AllHasSBOMTreeSubjectPackageOrArtifact {
	return v.AllHasSBOMTree.Subject
}

// GetUri returns PathPathHasSBOM.Uri, and is useful for accessing the field via an interface.
func (v *PathPathHasSBOM) GetUri() string { return v.AllHasSBOMTree.Uri }

// GetAlgorithm returns PathPathHasSBOM.Algorithm, and is useful for accessing the field via an interface.
func (v *PathPathHasSBOM) GetAlgorithm() string { return v.AllHasSBOMTree.Algorithm }

// GetDigest returns PathPathHasSBOM.Digest, and is useful for accessing the field via an interface.
func (v *PathPathHasSBOM) GetDigest() string { return v.AllHasSBOMTree.Digest }

// GetDownloadLocation returns PathPathHasSBOM.DownloadLocation, and is useful for accessing the field via an interface.
func (v *PathPathHasSBOM) GetDownloadLocation() string { return v.AllHasSBOMTree.DownloadLocation }

// GetOrigin returns PathPathHasSBOM.Origin, and is useful for accessing the field via an interface.
func (v *PathPathHasSBOM) GetOrigin() string { return v.AllHasSBOMTree.Origin }

// GetCollector returns PathPathHasSBOM.Collector, and is useful for accessing the field via an interface.
func (v *PathPathHasSBOM) GetCollector() string { return v.AllHasSBOMTree.Collector }

func (v *PathPathHasSBOM) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathHasSBOM
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathHasSBOM = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHasSBOMTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathHasSBOM struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Uri string `json:"uri"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`

	DownloadLocation string `json:"downloadLocation"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathHasSBOM) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathHasSBOM) __premarshalJSON() (*__premarshalPathPathHasSBOM, error) {
	var retval __premarshalPathPathHasSBOM

	retval.Typename = v.Typename
	retval.Id = v.AllHasSBOMTree.Id
	{

		dst := &retval.Subject
		src := v.AllHasSBOMTree.Subject
		var err error
		*dst, err = __marshalAllHasSBOMTreeSubjectPackageOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal PathPathHasSBOM.AllHasSBOMTree.Subject: %w", err)
		}
	}
	retval.Uri = v.AllHasSBOMTree.Uri
	retval.Algorithm = v.AllHasSBOMTree.Algorithm
	retval.Digest = v.AllHasSBOMTree.Digest
	retval.DownloadLocation = v.AllHasSBOMTree.DownloadLocation
	retval.Origin = v.AllHasSBOMTree.Origin
	retval.Collector = v.AllHasSBOMTree.Collector
	return &retval, nil
}

// PathPathHasSLSA includes the requested fields of the GraphQL type HasSLSA.
// The GraphQL type's documentation follows.
//
// HasSLSA records that a subject node has a SLSA attestation.
type PathPathHasSLSA struct {
	Typename    *string `json:"__typename"`
	AllSLSATree `json:"-"`
}

// GetTypename returns PathPathHasSLSA.Typename, and is useful for accessing the field via an interface.
func (v *PathPathHasSLSA) GetTypename() *string { return v.Typename }

// GetId returns PathPathHasSLSA.Id, and is useful for accessing the field via an interface.
func (v *PathPathHasSLSA) GetId() string { return v.AllSLSATree.Id }

// GetSubject returns PathPathHasSLSA.Subject, and is useful for accessing the field via an interface.
func (v *PathPathHasSLSA) GetSubject() AllSLSATreeSubjectArtifact { return v.AllSLSATree.Subject }

// GetSlsa returns PathPathHasSLSA.Slsa, and is useful for accessing the field via an interface.
func (v *PathPathHasSLSA) GetSlsa() AllSLSATreeSlsaSLSA { return v.AllSLSATree.Slsa }

func (v *PathPathHasSLSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathHasSLSA
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathHasSLSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSLSATree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathHasSLSA struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject AllSLSATreeSubjectArtifact `json:"subject"`

	Slsa AllSLSATreeSlsaSLSA `json:"slsa"`
}

func (v *PathPathHasSLSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathHasSLSA) __premarshalJSON() (*__premarshalPathPathHasSLSA, error) {
	var retval __premarshalPathPathHasSLSA

	retval.Typename = v.Typename
	retval.Id = v.AllSLSATree.Id
	retval.Subject = v.AllSLSATree.Subject
	retval.Slsa = v.AllSLSATree.Slsa
	return &retval, nil
}

// PathPathHasSourceAt includes the requested fields of the GraphQL type HasSourceAt.
// The GraphQL type's documentation follows.
//
// HasSourceAt records that a package's repository is a given source.
type PathPathHasSourceAt struct {
	Typename       *string `json:"__typename"`
	AllHasSourceAt `json:"-"`
}

// GetTypename returns PathPathHasSourceAt.Typename, and is useful for accessing the field via an interface.
func (v *PathPathHasSourceAt) GetTypename() *string { return v.Typename }

// GetId returns PathPathHasSourceAt.Id, and is useful for accessing the field via an interface.
func (v *PathPathHasSourceAt) GetId() string { return v.AllHasSourceAt.Id }

// GetJustification returns PathPathHasSourceAt.Justification, and is useful for accessing the field via an interface.
func (v *PathPathHasSourceAt) GetJustification() string { return v.AllHasSourceAt.Justification }

// GetKnownSince returns PathPathHasSourceAt.KnownSince, and is useful for accessing the field via an interface.
func (v *PathPathHasSourceAt) GetKnownSince() time.Time { return v.AllHasSourceAt.KnownSince }

// GetPackage returns PathPathHasSourceAt.Package, and is useful for accessing the field via an interface.
func (v *PathPathHasSourceAt) GetPackage() AllHasSourceAtPackage { return v.AllHasSourceAt.Package }

// GetSource returns PathPathHasSourceAt.Source, and is useful for accessing the field via an interface.
func (v *PathPathHasSourceAt) GetSource() AllHasSourceAtSource { return v.AllHasSourceAt.Source }

// GetOrigin returns PathPathHasSourceAt.Origin, and is useful for accessing the field via an interface.
func (v *PathPathHasSourceAt) GetOrigin() string { return v.AllHasSourceAt.Origin }

// GetCollector returns PathPathHasSourceAt.Collector, and is useful for accessing the field via an interface.
func (v *PathPathHasSourceAt) GetCollector() string { return v.AllHasSourceAt.Collector }

func (v *PathPathHasSourceAt) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathHasSourceAt
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathHasSourceAt = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHasSourceAt)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathHasSourceAt struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	KnownSince time.Time `json:"knownSince"`

	Package AllHasSourceAtPackage `json:"package"`

	Source AllHasSourceAtSource `json:"source"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathHasSourceAt) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathHasSourceAt) __premarshalJSON() (*__premarshalPathPathHasSourceAt, error) {
	var retval __premarshalPathPathHasSourceAt

	retval.Typename = v.Typename
	retval.Id = v.AllHasSourceAt.Id
	retval.Justification = v.AllHasSourceAt.Justification
	retval.KnownSince = v.AllHasSourceAt.KnownSince
	retval.Package = v.AllHasSourceAt.Package
	retval.Source = v.AllHasSourceAt.Source
	retval.Origin = v.AllHasSourceAt.Origin
	retval.Collector = v.AllHasSourceAt.Collector
	return &retval, nil
}

// PathPathHashEqual includes the requested fields of the GraphQL type HashEqual.
// The GraphQL type's documentation follows.
//
// HashEqual is an attestation that a set of artifacts are identical.
type PathPathHashEqual struct {
	Typename         *string `json:"__typename"`
	AllHashEqualTree `json:"-"`
}

// GetTypename returns PathPathHashEqual.Typename, and is useful for accessing the field via an interface.
func (v *PathPathHashEqual) GetTypename() *string { return v.Typename }

// GetId returns PathPathHashEqual.Id, and is useful for accessing the field via an interface.
func (v *PathPathHashEqual) GetId() string { return v.AllHashEqualTree.Id }

// GetJustification returns PathPathHashEqual.Justification, and is useful for accessing the field via an interface.
func (v *PathPathHashEqual) GetJustification() string { return v.AllHashEqualTree.Justification }

// GetArtifacts returns PathPathHashEqual.Artifacts, and is useful for accessing the field via an interface.
func (v *PathPathHashEqual) GetArtifacts() []AllHashEqualTreeArtifactsArtifact {
	return v.AllHashEqualTree.Artifacts
}

// GetOrigin returns PathPathHashEqual.Origin, and is useful for accessing the field via an interface.
func (v *PathPathHashEqual) GetOrigin() string { return v.AllHashEqualTree.Origin }

// GetCollector returns PathPathHashEqual.Collector, and is useful for accessing the field via an interface.
func (v *PathPathHashEqual) GetCollector() string { return v.AllHashEqualTree.Collector }

func (v *PathPathHashEqual) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathHashEqual
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathHashEqual = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllHashEqualTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathHashEqual struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Artifacts []AllHashEqualTreeArtifactsArtifact `json:"artifacts"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathHashEqual) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathHashEqual) __premarshalJSON() (*__premarshalPathPathHashEqual, error) {
	var retval __premarshalPathPathHashEqual

	retval.Typename = v.Typename
	retval.Id = v.AllHashEqualTree.Id
	retval.Justification = v.AllHashEqualTree.Justification
	retval.Artifacts = v.AllHashEqualTree.Artifacts
	retval.Origin = v.AllHashEqualTree.Origin
	retval.Collector = v.AllHashEqualTree.Collector
	return &retval, nil
}

// PathPathIsDependency includes the requested fields of the GraphQL type IsDependency.
// The GraphQL type's documentation follows.
//
// IsDependency is an attestation to record that a package depends on another.
type PathPathIsDependency struct {
	Typename            *string `json:"__typename"`
	AllIsDependencyTree `json:"-"`
}

// GetTypename returns PathPathIsDependency.Typename, and is useful for accessing the field via an interface.
func (v *PathPathIsDependency) GetTypename() *string { return v.Typename }

// GetId returns PathPathIsDependency.Id, and is useful for accessing the field via an interface.
func (v *PathPathIsDependency) GetId() string { return v.AllIsDependencyTree.Id }

// GetJustification returns PathPathIsDependency.Justification, and is useful for accessing the field via an interface.
func (v *PathPathIsDependency) GetJustification() string { return v.AllIsDependencyTree.Justification }

// GetPackage returns PathPathIsDependency.Package, and is useful for accessing the field via an interface.
func (v *PathPathIsDependency) GetPackage() AllIsDependencyTreePackage {
	return v.AllIsDependencyTree.Package
}

// GetDependentPackage returns PathPathIsDependency.DependentPackage, and is useful for accessing the field via an interface.
func (v *PathPathIsDependency) GetDependentPackage() AllIsDependencyTreeDependentPackage {
	return v.AllIsDependencyTree.DependentPackage
}

// GetDependencyType returns PathPathIsDependency.DependencyType, and is useful for accessing the field via an interface.
func (v *PathPathIsDependency) GetDependencyType() DependencyType {
	return v.AllIsDependencyTree.DependencyType
}

// GetVersionRange returns PathPathIsDependency.VersionRange, and is useful for accessing the field via an interface.
func (v *PathPathIsDependency) GetVersionRange() string { return v.AllIsDependencyTree.VersionRange }

// GetOrigin returns PathPathIsDependency.Origin, and is useful for accessing the field via an interface.
func (v *PathPathIsDependency) GetOrigin() string { return v.AllIsDependencyTree.Origin }

// GetCollector returns PathPathIsDependency.Collector, and is useful for accessing the field via an interface.
func (v *PathPathIsDependency) GetCollector() string { return v.AllIsDependencyTree.Collector }

func (v *PathPathIsDependency) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathIsDependency
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathIsDependency = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllIsDependencyTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathIsDependency struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Package AllIsDependencyTreePackage `json:"package"`

	DependentPackage AllIsDependencyTreeDependentPackage `json:"dependentPackage"`

	DependencyType DependencyType `json:"dependencyType"`

	VersionRange string `json:"versionRange"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathIsDependency) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathIsDependency) __premarshalJSON() (*__premarshalPathPathIsDependency, error) {
	var retval __premarshalPathPathIsDependency

	retval.Typename = v.Typename
	retval.Id = v.AllIsDependencyTree.Id
	retval.Justification = v.AllIsDependencyTree.Justification
	retval.Package = v.AllIsDependencyTree.Package
	retval.DependentPackage = v.AllIsDependencyTree.DependentPackage
	retval.DependencyType = v.AllIsDependencyTree.DependencyType
	retval.VersionRange = v.AllIsDependencyTree.VersionRange
	retval.Origin = v.AllIsDependencyTree.Origin
	retval.Collector = v.AllIsDependencyTree.Collector
	return &retval, nil
}

// PathPathIsOccurrence includes the requested fields of the GraphQL type IsOccurrence.
// The GraphQL type's documentation follows.
//
// IsOccurrence is an attestation to link an artifact to a package or source.
//
// Attestation must occur at the PackageVersion or at the SourceName.
type PathPathIsOccurrence struct {
	Typename             *string `json:"__typename"`
	AllIsOccurrencesTree `json:"-"`
}

// GetTypename returns PathPathIsOccurrence.Typename, and is useful for accessing the field via an interface.
func (v *PathPathIsOccurrence) GetTypename() *string { return v.Typename }

// GetId returns PathPathIsOccurrence.Id, and is useful for accessing the field via an interface.
func (v *PathPathIsOccurrence) GetId() string { return v.AllIsOccurrencesTree.Id }

// GetSubject returns PathPathIsOccurrence.Subject, and is useful for accessing the field via an interface.
func (v *PathPathIsOccurrence) GetSubject() AllIsOccurrencesTreeSubjectPackageOrSource {
	return v.AllIsOccurrencesTree.Subject
}

// GetArtifact returns PathPathIsOccurrence.Artifact, and is useful for accessing the field via an interface.
func (v *PathPathIsOccurrence) GetArtifact() AllIsOccurrencesTreeArtifact {
	return v.AllIsOccurrencesTree.Artifact
}

// GetJustification returns PathPathIsOccurrence.Justification, and is useful for accessing the field via an interface.
func (v *PathPathIsOccurrence) GetJustification() string { return v.AllIsOccurrencesTree.Justification }

// GetOrigin returns PathPathIsOccurrence.Origin, and is useful for accessing the field via an interface.
func (v *PathPathIsOccurrence) GetOrigin() string { return v.AllIsOccurrencesTree.Origin }

// GetCollector returns PathPathIsOccurrence.Collector, and is useful for accessing the field via an interface.
func (v *PathPathIsOccurrence) GetCollector() string { return v.AllIsOccurrencesTree.Collector }

func (v *PathPathIsOccurrence) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathIsOccurrence
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathIsOccurrence = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllIsOccurrencesTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathIsOccurrence struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Artifact AllIsOccurrencesTreeArtifact `json:"artifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathIsOccurrence) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathIsOccurrence) __premarshalJSON() (*__premarshalPathPathIsOccurrence, error) {
	var retval __premarshalPathPathIsOccurrence

	retval.Typename = v.Typename
	retval.Id = v.AllIsOccurrencesTree.Id
	{

		dst := &retval.Subject
		src := v.AllIsOccurrencesTree.Subject
		var err error
		*dst, err = __marshalAllIsOccurrencesTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal PathPathIsOccurrence.AllIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.Artifact = v.AllIsOccurrencesTree.Artifact
	retval.Justification = v.AllIsOccurrencesTree.Justification
	retval.Origin = v.AllIsOccurrencesTree.Origin
	retval.Collector = v.AllIsOccurrencesTree.Collector
	return &retval, nil
}

// PathPathLicense includes the requested fields of the GraphQL type License.
// The GraphQL type's documentation follows.
//
// License represents a particular license. If the license is found on the SPDX
// license list (https://spdx.org/licenses/) then the fields should be:
//
// Name: SPDX license identifier
// Inline: empty
// ListVersion: SPDX license list version
//
// example:
//
// Name: AGPL-3.0-or-later
// Inline: ""
// ListVersion: 3.21 2023-06-18
//
// If the license is not on the SPDX license list, then a new guid should be
// created and the license text placed inline:
//
// Name: LicenseRef-<guid>
// Inline: Full license text
// ListVersion: empty
//
// example:
//
// Name: LicenseRef-1a2b3c
// Inline: Permission to use, copy, modify, and/or distribute ...
// ListVersion: ""
type PathPathLicense struct {
	Typename       *string `json:"__typename"`
	AllLicenseTree `json:"-"`
}

// GetTypename returns PathPathLicense.Typename, and is useful for accessing the field via an interface.
func (v *PathPathLicense) GetTypename() *string { return v.Typename }

// GetId returns PathPathLicense.Id, and is useful for accessing the field via an interface.
func (v *PathPathLicense) GetId() string { return v.AllLicenseTree.Id }

// GetName returns PathPathLicense.Name, and is useful for accessing the field via an interface.
func (v *PathPathLicense) GetName() string { return v.AllLicenseTree.Name }

// GetInline returns PathPathLicense.Inline, and is useful for accessing the field via an interface.
func (v *PathPathLicense) GetInline() *string { return v.AllLicenseTree.Inline }

// GetListVersion returns PathPathLicense.ListVersion, and is useful for accessing the field via an interface.
func (v *PathPathLicense) GetListVersion() *string { return v.AllLicenseTree.ListVersion }

func (v *PathPathLicense) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathLicense
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathLicense = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllLicenseTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathLicense struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Name string `json:"name"`

	Inline *string `json:"inline"`

	ListVersion *string `json:"listVersion"`
}

func (v *PathPathLicense) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathLicense) __premarshalJSON() (*__premarshalPathPathLicense, error) {
	var retval __premarshalPathPathLicense

	retval.Typename = v.Typename
	retval.Id = v.AllLicenseTree.Id
	retval.Name = v.AllLicenseTree.Name
	retval.Inline = v.AllLicenseTree.Inline
	retval.ListVersion = v.AllLicenseTree.ListVersion
	return &retval, nil
}

// PathPathNode includes the requested fields of the GraphQL interface Node.
//
// PathPathNode is implemented by the following types:
// PathPathArtifact
// PathPathBuilder
// PathPathCertifyBad
// PathPathCertifyGood
// PathPathCertifyLegal
// PathPathCertifyScorecard
// PathPathCertifyVEXStatement
// PathPathCertifyVuln
// PathPathHasMetadata
// PathPathHasSBOM
// PathPathHasSLSA
// PathPathHasSourceAt
// PathPathHashEqual
// PathPathIsDependency
// PathPathIsOccurrence
// PathPathLicense
// PathPathPackage
// PathPathPkgEqual
// PathPathPointOfContact
// PathPathSource
// PathPathVulnEqual
// PathPathVulnerability
// PathPathVulnerabilityMetadata
// The GraphQL type's documentation follows.
//
// Node is a union type of all the possible nodes.
//
// It encapsulates the software tree nodes along with the evidence nodes. In a
// path query, all connecting evidence nodes along with their intermediate subject
// nodes need to be returned in order to create a complete graph.
type PathPathNode interface {
	implementsGraphQLInterfacePathPathNode()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *PathPathArtifact) implementsGraphQLInterfacePathPathNode()              {}
func (v *PathPathBuilder) implementsGraphQLInterfacePathPathNode()               {}
func (v *PathPathCertifyBad) implementsGraphQLInterfacePathPathNode()            {}
func (v *PathPathCertifyGood) implementsGraphQLInterfacePathPathNode()           {}
func (v *PathPathCertifyLegal) implementsGraphQLInterfacePathPathNode()          {}
func (v *PathPathCertifyScorecard) implementsGraphQLInterfacePathPathNode()      {}
func (v *PathPathCertifyVEXStatement) implementsGraphQLInterfacePathPathNode()   {}
func (v *PathPathCertifyVuln) implementsGraphQLInterfacePathPathNode()           {}
func (v *PathPathHasMetadata) implementsGraphQLInterfacePathPathNode()           {}
func (v *PathPathHasSBOM) implementsGraphQLInterfacePathPathNode()               {}
func (v *PathPathHasSLSA) implementsGraphQLInterfacePathPathNode()               {}
func (v *PathPathHasSourceAt) implementsGraphQLInterfacePathPathNode()           {}
func (v *PathPathHashEqual) implementsGraphQLInterfacePathPathNode()             {}
func (v *PathPathIsDependency) implementsGraphQLInterfacePathPathNode()          {}
func (v *PathPathIsOccurrence) implementsGraphQLInterfacePathPathNode()          {}
func (v *PathPathLicense) implementsGraphQLInterfacePathPathNode()               {}
func (v *PathPathPackage) implementsGraphQLInterfacePathPathNode()               {}
func (v *PathPathPkgEqual) implementsGraphQLInterfacePathPathNode()              {}
func (v *PathPathPointOfContact) implementsGraphQLInterfacePathPathNode()        {}
func (v *PathPathSource) implementsGraphQLInterfacePathPathNode()                {}
func (v *PathPathVulnEqual) implementsGraphQLInterfacePathPathNode()             {}
func (v *PathPathVulnerability) implementsGraphQLInterfacePathPathNode()         {}
func (v *PathPathVulnerabilityMetadata) implementsGraphQLInterfacePathPathNode() {}

func __unmarshalPathPathNode(b []byte, v *PathPathNode) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Artifact":
		*v = new(PathPathArtifact)
		return json.Unmarshal(b, *v)
	case "Builder":
		*v = new(PathPathBuilder)
		return json.Unmarshal(b, *v)
	case "CertifyBad":
		*v = new(PathPathCertifyBad)
		return json.Unmarshal(b, *v)
	case "CertifyGood":
		*v = new(PathPathCertifyGood)
		return json.Unmarshal(b, *v)
	case "CertifyLegal":
		*v = new(PathPathCertifyLegal)
		return json.Unmarshal(b, *v)
	case "CertifyScorecard":
		*v = new(PathPathCertifyScorecard)
		return json.Unmarshal(b, *v)
	case "CertifyVEXStatement":
		*v = new(PathPathCertifyVEXStatement)
		return json.Unmarshal(b, *v)
	case "CertifyVuln":
		*v = new(PathPathCertifyVuln)
		return json.Unmarshal(b, *v)
	case "HasMetadata":
		*v = new(PathPathHasMetadata)
		return json.Unmarshal(b, *v)
	case "HasSBOM":
		*v = new(PathPathHasSBOM)
		return json.Unmarshal(b, *v)
	case "HasSLSA":
		*v = new(PathPathHasSLSA)
		return json.Unmarshal(b, *v)
	case "HasSourceAt":
		*v = new(PathPathHasSourceAt)
		return json.Unmarshal(b, *v)
	case "HashEqual":
		*v = new(PathPathHashEqual)
		return json.Unmarshal(b, *v)
	case "IsDependency":
		*v = new(PathPathIsDependency)
		return json.Unmarshal(b, *v)
	case "IsOccurrence":
		*v = new(PathPathIsOccurrence)
		return json.Unmarshal(b, *v)
	case "License":
		*v = new(PathPathLicense)
		return json.Unmarshal(b, *v)
	case "Package":
		*v = new(PathPathPackage)
		return json.Unmarshal(b, *v)
	case "PkgEqual":
		*v = new(PathPathPkgEqual)
		return json.Unmarshal(b, *v)
	case "PointOfContact":
		*v = new(PathPathPointOfContact)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(PathPathSource)
		return json.Unmarshal(b, *v)
	case "VulnEqual":
		*v = new(PathPathVulnEqual)
		return json.Unmarshal(b, *v)
	case "Vulnerability":
		*v = new(PathPathVulnerability)
		return json.Unmarshal(b, *v)
	case "VulnerabilityMetadata":
		*v = new(PathPathVulnerabilityMetadata)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing Node.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for PathPathNode: "%v"`, tn.TypeName)
	}
}

func __marshalPathPathNode(v *PathPathNode) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *PathPathArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathBuilder:
		typename = "Builder"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathBuilder
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathCertifyBad:
		typename = "CertifyBad"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathCertifyBad
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathCertifyGood:
		typename = "CertifyGood"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathCertifyGood
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathCertifyLegal:
		typename = "CertifyLegal"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathCertifyLegal
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathCertifyScorecard:
		typename = "CertifyScorecard"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathCertifyScorecard
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathCertifyVEXStatement:
		typename = "CertifyVEXStatement"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathCertifyVEXStatement
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathCertifyVuln:
		typename = "CertifyVuln"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathCertifyVuln
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathHasMetadata:
		typename = "HasMetadata"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathHasMetadata
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathHasSBOM:
		typename = "HasSBOM"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathHasSBOM
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathHasSLSA:
		typename = "HasSLSA"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathHasSLSA
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathHasSourceAt:
		typename = "HasSourceAt"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathHasSourceAt
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathHashEqual:
		typename = "HashEqual"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathHashEqual
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathIsDependency:
		typename = "IsDependency"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathIsDependency
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathIsOccurrence:
		typename = "IsOccurrence"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathIsOccurrence
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathLicense:
		typename = "License"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathLicense
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathPkgEqual:
		typename = "PkgEqual"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathPkgEqual
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathPointOfContact:
		typename = "PointOfContact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathPointOfContact
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathVulnEqual:
		typename = "VulnEqual"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathVulnEqual
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathVulnerability:
		typename = "Vulnerability"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathVulnerability
		}{typename, premarshaled}
		return json.Marshal(result)
	case *PathPathVulnerabilityMetadata:
		typename = "VulnerabilityMetadata"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalPathPathVulnerabilityMetadata
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for PathPathNode: "%T"`, v)
	}
}

// PathPathPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents the root of the package trie/tree.
//
// We map package information to a trie, closely matching the pURL specification
// (https://github.com/package-url/purl-spec/blob/0dd92f26f8bb11956ffdf5e8acfcee71e8560407/README.rst),
// but deviating from it where GUAC heuristics allow for better representation of
// package information. Each path in the trie fully represents a package; we split
// the trie based on the pURL components.
//
// This node matches a pkg:<type> partial pURL. The type field matches the
// pURL types but we might also use "guac" for the cases where the pURL
// representation is not complete or when we have custom rules.
//
// Since this node is at the root of the package trie, it is named Package, not
// PackageType.
type PathPathPackage struct {
	Typename   *string `json:"__typename"`
	AllPkgTree `json:"-"`
}

// GetTypename returns PathPathPackage.Typename, and is useful for accessing the field via an interface.
func (v *PathPathPackage) GetTypename() *string { return v.Typename }

// GetId returns PathPathPackage.Id, and is useful for accessing the field via an interface.
func (v *PathPathPackage) GetId() string { return v.AllPkgTree.Id }

// GetType returns PathPathPackage.Type, and is useful for accessing the field via an interface.
func (v *PathPathPackage) GetType() string { return v.AllPkgTree.Type }

// GetNamespaces returns PathPathPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *PathPathPackage) GetNamespaces() []AllPkgTreeNamespacesPackageNamespace {
	return v.AllPkgTree.Namespaces
}

func (v *PathPathPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathPackage struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *PathPathPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathPackage) __premarshalJSON() (*__premarshalPathPathPackage, error) {
	var retval __premarshalPathPathPackage

	retval.Typename = v.Typename
	retval.Id = v.AllPkgTree.Id
	retval.Type = v.AllPkgTree.Type
	retval.Namespaces = v.AllPkgTree.Namespaces
	return &retval, nil
}

// PathPathPkgEqual includes the requested fields of the GraphQL type PkgEqual.
// The GraphQL type's documentation follows.
//
// PkgEqual is an attestation that a set of packages are similar.
type PathPathPkgEqual struct {
	Typename    *string `json:"__typename"`
	AllPkgEqual `json:"-"`
}

// GetTypename returns PathPathPkgEqual.Typename, and is useful for accessing the field via an interface.
func (v *PathPathPkgEqual) GetTypename() *string { return v.Typename }

// GetId returns PathPathPkgEqual.Id, and is useful for accessing the field via an interface.
func (v *PathPathPkgEqual) GetId() string { return v.AllPkgEqual.Id }

// GetJustification returns PathPathPkgEqual.Justification, and is useful for accessing the field via an interface.
func (v *PathPathPkgEqual) GetJustification() string { return v.AllPkgEqual.Justification }

// GetPackages returns PathPathPkgEqual.Packages, and is useful for accessing the field via an interface.
func (v *PathPathPkgEqual) GetPackages() []AllPkgEqualPackagesPackage { return v.AllPkgEqual.Packages }

// GetOrigin returns PathPathPkgEqual.Origin, and is useful for accessing the field via an interface.
func (v *PathPathPkgEqual) GetOrigin() string { return v.AllPkgEqual.Origin }

// GetCollector returns PathPathPkgEqual.Collector, and is useful for accessing the field via an interface.
func (v *PathPathPkgEqual) GetCollector() string { return v.AllPkgEqual.Collector }

func (v *PathPathPkgEqual) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathPkgEqual
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathPkgEqual = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPkgEqual)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathPkgEqual struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Justification string `json:"justification"`

	Packages []AllPkgEqualPackagesPackage `json:"packages"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathPkgEqual) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathPkgEqual) __premarshalJSON() (*__premarshalPathPathPkgEqual, error) {
	var retval __premarshalPathPathPkgEqual

	retval.Typename = v.Typename
	retval.Id = v.AllPkgEqual.Id
	retval.Justification = v.AllPkgEqual.Justification
	retval.Packages = v.AllPkgEqual.Packages
	retval.Origin = v.AllPkgEqual.Origin
	retval.Collector = v.AllPkgEqual.Collector
	return &retval, nil
}

// PathPathPointOfContact includes the requested fields of the GraphQL type PointOfContact.
// The GraphQL type's documentation follows.
//
// PointOfContact is an attestation of how to get in touch with the person(s) responsible
// for a package, source, or artifact.
//
// All evidence trees record a justification for the property they represent as
// well as the document that contains the attestation (origin) and the collector
// that collected the document (collector).
//
// The attestation applies to a subject which is a package, source, or artifact.
// If the attestation targets a package, it must target a PackageName or a
// PackageVersion. If the attestation targets a source, it must target a
// SourceName.
//
// email is the email address (singular) of the point of contact.
//
// info is additional contact information other than email address. This is free
// form.
//
// NOTE: the identifiers for point of contact should be part of software trees.
// This will benefit from identifier look up and traversal as well as organization
// hierarchy. However, until the use case arises, PointOfContact will be a flat
// reference to the contact details.
type PathPathPointOfContact struct {
	Typename          *string `json:"__typename"`
	AllPointOfContact `json:"-"`
}

// GetTypename returns PathPathPointOfContact.Typename, and is useful for accessing the field via an interface.
func (v *PathPathPointOfContact) GetTypename() *string { return v.Typename }

// GetId returns PathPathPointOfContact.Id, and is useful for accessing the field via an interface.
func (v *PathPathPointOfContact) GetId() string { return v.AllPointOfContact.Id }

// GetSubject returns PathPathPointOfContact.Subject, and is useful for accessing the field via an interface.
func (v *PathPathPointOfContact) GetSubject() AllPointOfContactSubjectPackageSourceOrArtifact {
	return v.AllPointOfContact.Subject
}

// GetEmail returns PathPathPointOfContact.Email, and is useful for accessing the field via an interface.
func (v *PathPathPointOfContact) GetEmail() string { return v.AllPointOfContact.Email }

// GetInfo returns PathPathPointOfContact.Info, and is useful for accessing the field via an interface.
func (v *PathPathPointOfContact) GetInfo() string { return v.AllPointOfContact.Info }

// GetSince returns PathPathPointOfContact.Since, and is useful for accessing the field via an interface.
func (v *PathPathPointOfContact) GetSince() time.Time { return v.AllPointOfContact.Since }

// GetJustification returns PathPathPointOfContact.Justification, and is useful for accessing the field via an interface.
func (v *PathPathPointOfContact) GetJustification() string { return v.AllPointOfContact.Justification }

// GetOrigin returns PathPathPointOfContact.Origin, and is useful for accessing the field via an interface.
func (v *PathPathPointOfContact) GetOrigin() string { return v.AllPointOfContact.Origin }

// GetCollector returns PathPathPointOfContact.Collector, and is useful for accessing the field via an interface.
func (v *PathPathPointOfContact) GetCollector() string { return v.AllPointOfContact.Collector }

func (v *PathPathPointOfContact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathPointOfContact
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathPointOfContact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllPointOfContact)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathPointOfContact struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Subject json.RawMessage `json:"subject"`

	Email string `json:"email"`

	Info string `json:"info"`

	Since time.Time `json:"since"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathPointOfContact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathPointOfContact) __premarshalJSON() (*__premarshalPathPathPointOfContact, error) {
	var retval __premarshalPathPathPointOfContact

	retval.Typename = v.Typename
	retval.Id = v.AllPointOfContact.Id
	{

		dst := &retval.Subject
		src := v.AllPointOfContact.Subject
		var err error
		*dst, err = __marshalAllPointOfContactSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"unable to marshal PathPathPointOfContact.AllPointOfContact.Subject: %w", err)
		}
	}
	retval.Email = v.AllPointOfContact.Email
	retval.Info = v.AllPointOfContact.Info
	retval.Since = v.AllPointOfContact.Since
	retval.Justification = v.AllPointOfContact.Justification
	retval.Origin = v.AllPointOfContact.Origin
	retval.Collector = v.AllPointOfContact.Collector
	return &retval, nil
}

// PathPathSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type PathPathSource struct {
	Typename      *string `json:"__typename"`
	AllSourceTree `json:"-"`
}

// GetTypename returns PathPathSource.Typename, and is useful for accessing the field via an interface.
func (v *PathPathSource) GetTypename() *string { return v.Typename }

// GetId returns PathPathSource.Id, and is useful for accessing the field via an interface.
func (v *PathPathSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns PathPathSource.Type, and is useful for accessing the field via an interface.
func (v *PathPathSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns PathPathSource.Namespaces, and is useful for accessing the field via an interface.
func (v *PathPathSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *PathPathSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathSource
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathSource struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *PathPathSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathSource) __premarshalJSON() (*__premarshalPathPathSource, error) {
	var retval __premarshalPathPathSource

	retval.Typename = v.Typename
	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// PathPathVulnEqual includes the requested fields of the GraphQL type VulnEqual.
// The GraphQL type's documentation follows.
//
// VulnEqual is an attestation to link two vulnerabilities together as being equal"
//
// Note that setting noVuln vulnerability type is invalid for VulnEqual!
type PathPathVulnEqual struct {
	Typename     *string `json:"__typename"`
	AllVulnEqual `json:"-"`
}

// GetTypename returns PathPathVulnEqual.Typename, and is useful for accessing the field via an interface.
func (v *PathPathVulnEqual) GetTypename() *string { return v.Typename }

// GetId returns PathPathVulnEqual.Id, and is useful for accessing the field via an interface.
func (v *PathPathVulnEqual) GetId() string { return v.AllVulnEqual.Id }

// GetVulnerabilities returns PathPathVulnEqual.Vulnerabilities, and is useful for accessing the field via an interface.
func (v *PathPathVulnEqual) GetVulnerabilities() []AllVulnEqualVulnerabilitiesVulnerability {
	return v.AllVulnEqual.Vulnerabilities
}

// GetJustification returns PathPathVulnEqual.Justification, and is useful for accessing the field via an interface.
func (v *PathPathVulnEqual) GetJustification() string { return v.AllVulnEqual.Justification }

// GetOrigin returns PathPathVulnEqual.Origin, and is useful for accessing the field via an interface.
func (v *PathPathVulnEqual) GetOrigin() string { return v.AllVulnEqual.Origin }

// GetCollector returns PathPathVulnEqual.Collector, and is useful for accessing the field via an interface.
func (v *PathPathVulnEqual) GetCollector() string { return v.AllVulnEqual.Collector }

func (v *PathPathVulnEqual) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathVulnEqual
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathVulnEqual = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnEqual)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathVulnEqual struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Vulnerabilities []AllVulnEqualVulnerabilitiesVulnerability `json:"vulnerabilities"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathVulnEqual) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathVulnEqual) __premarshalJSON() (*__premarshalPathPathVulnEqual, error) {
	var retval __premarshalPathPathVulnEqual

	retval.Typename = v.Typename
	retval.Id = v.AllVulnEqual.Id
	retval.Vulnerabilities = v.AllVulnEqual.Vulnerabilities
	retval.Justification = v.AllVulnEqual.Justification
	retval.Origin = v.AllVulnEqual.Origin
	retval.Collector = v.AllVulnEqual.Collector
	return &retval, nil
}

// PathPathVulnerability includes the requested fields of the GraphQL type Vulnerability.
// The GraphQL type's documentation follows.
//
// Vulnerability represents the root of the vulnerability trie/tree.
//
// We map vulnerability information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type and a vulnerability ID. This allows for generic
// representation of the various vulnerabilities and does not limit to just cve, ghsa or osv.
// This would be in the general format: vuln://<general-type>/<vuln-id>
//
// Examples:
//
// CVE, using path separator: vuln://cve/cve-2023-20753
// OSV, representing its knowledge of a GHSA: vuln://osv/ghsa-205hk
// Random vendor: vuln://snyk/sn-whatever
// NoVuln: vuln://novuln/
//
// This node represents the type part of the trie path. It is used to represent
// the specific type of the vulnerability: cve, ghsa, osv or some other vendor specific
//
// Since this node is at the root of the vulnerability trie, it is named Vulnerability, not
// VulnerabilityType.
//
// NoVuln is a special vulnerability node to attest that no vulnerability has been
// found during a vulnerability scan. It will have the type "novuln" and contain an empty string
// for vulnerabilityID
//
// The resolvers will enforce that both the type and vulnerability IDs are lower case.
type PathPathVulnerability struct {
	Typename             *string `json:"__typename"`
	AllVulnerabilityTree `json:"-"`
}

// GetTypename returns PathPathVulnerability.Typename, and is useful for accessing the field via an interface.
func (v *PathPathVulnerability) GetTypename() *string { return v.Typename }

// GetId returns PathPathVulnerability.Id, and is useful for accessing the field via an interface.
func (v *PathPathVulnerability) GetId() string { return v.AllVulnerabilityTree.Id }

// GetType returns PathPathVulnerability.Type, and is useful for accessing the field via an interface.
func (v *PathPathVulnerability) GetType() string { return v.AllVulnerabilityTree.Type }

// GetVulnerabilityIDs returns PathPathVulnerability.VulnerabilityIDs, and is useful for accessing the field via an interface.
func (v *PathPathVulnerability) GetVulnerabilityIDs() []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID {
	return v.AllVulnerabilityTree.VulnerabilityIDs
}

func (v *PathPathVulnerability) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathVulnerability
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathVulnerability = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnerabilityTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathVulnerability struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Type string `json:"type"`

	VulnerabilityIDs []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID `json:"vulnerabilityIDs"`
}

func (v *PathPathVulnerability) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathVulnerability) __premarshalJSON() (*__premarshalPathPathVulnerability, error) {
	var retval __premarshalPathPathVulnerability

	retval.Typename = v.Typename
	retval.Id = v.AllVulnerabilityTree.Id
	retval.Type = v.AllVulnerabilityTree.Type
	retval.VulnerabilityIDs = v.AllVulnerabilityTree.VulnerabilityIDs
	return &retval, nil
}

// PathPathVulnerabilityMetadata includes the requested fields of the GraphQL type VulnerabilityMetadata.
// The GraphQL type's documentation follows.
//
// VulnerabilityMetadata is an attestation that a vulnerability has a related score
// associated with it.
//
// The intent of this evidence tree predicate is to allow extensibility of vulnerability
// score (one-to-one mapping) with a specific vulnerability ID.
//
// A vulnerability ID can have a one-to-many relationship with the VulnerabilityMetadata
// node as a vulnerability ID can have multiple scores (in various frameworks).
//
// Examples:
//
// scoreType: EPSSv1
// scoreValue: 0.960760000
//
// scoreType: CVSSv2
// scoreValue: 5.0
//
// scoreType: CVSSv3
// scoreValue: 7.5
//
// The timestamp is used to determine when the score was evaluated for the specific vulnerability.
type PathPathVulnerabilityMetadata struct {
	Typename            *string `json:"__typename"`
	AllVulnMetadataTree `json:"-"`
}

// GetTypename returns PathPathVulnerabilityMetadata.Typename, and is useful for accessing the field via an interface.
func (v *PathPathVulnerabilityMetadata) GetTypename() *string { return v.Typename }

// GetId returns PathPathVulnerabilityMetadata.Id, and is useful for accessing the field via an interface.
func (v *PathPathVulnerabilityMetadata) GetId() string { return v.AllVulnMetadataTree.Id }

// GetVulnerability returns PathPathVulnerabilityMetadata.Vulnerability, and is useful for accessing the field via an interface.
func (v *PathPathVulnerabilityMetadata) GetVulnerability() AllVulnMetadataTreeVulnerability {
	return v.AllVulnMetadataTree.Vulnerability
}

// GetScoreType returns PathPathVulnerabilityMetadata.ScoreType, and is useful for accessing the field via an interface.
func (v *PathPathVulnerabilityMetadata) GetScoreType() VulnerabilityScoreType {
	return v.AllVulnMetadataTree.ScoreType
}

// GetScoreValue returns PathPathVulnerabilityMetadata.ScoreValue, and is useful for accessing the field via an interface.
func (v *PathPathVulnerabilityMetadata) GetScoreValue() float64 {
	return v.AllVulnMetadataTree.ScoreValue
}

// GetTimestamp returns PathPathVulnerabilityMetadata.Timestamp, and is useful for accessing the field via an interface.
func (v *PathPathVulnerabilityMetadata) GetTimestamp() time.Time {
	return v.AllVulnMetadataTree.Timestamp
}

// GetOrigin returns PathPathVulnerabilityMetadata.Origin, and is useful for accessing the field via an interface.
func (v *PathPathVulnerabilityMetadata) GetOrigin() string { return v.AllVulnMetadataTree.Origin }

// GetCollector returns PathPathVulnerabilityMetadata.Collector, and is useful for accessing the field via an interface.
func (v *PathPathVulnerabilityMetadata) GetCollector() string { return v.AllVulnMetadataTree.Collector }

func (v *PathPathVulnerabilityMetadata) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathPathVulnerabilityMetadata
		graphql.NoUnmarshalJSON
	}
	firstPass.PathPathVulnerabilityMetadata = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnMetadataTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalPathPathVulnerabilityMetadata struct {
	Typename *string `json:"__typename"`

	Id string `json:"id"`

	Vulnerability AllVulnMetadataTreeVulnerability `json:"vulnerability"`

	ScoreType VulnerabilityScoreType `json:"scoreType"`

	ScoreValue float64 `json:"scoreValue"`

	Timestamp time.Time `json:"timestamp"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *PathPathVulnerabilityMetadata) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathPathVulnerabilityMetadata) __premarshalJSON() (*__premarshalPathPathVulnerabilityMetadata, error) {
	var retval __premarshalPathPathVulnerabilityMetadata

	retval.Typename = v.Typename
	retval.Id = v.AllVulnMetadataTree.Id
	retval.Vulnerability = v.AllVulnMetadataTree.Vulnerability
	retval.ScoreType = v.AllVulnMetadataTree.ScoreType
	retval.ScoreValue = v.AllVulnMetadataTree.ScoreValue
	retval.Timestamp = v.AllVulnMetadataTree.Timestamp
	retval.Origin = v.AllVulnMetadataTree.Origin
	retval.Collector = v.AllVulnMetadataTree.Collector
	return &retval, nil
}

// PathResponse is returned by Path on success.
type PathResponse struct {
	// path query returns a path between subject and target, of a maximum length.
	//
	// Since we want to uniquely identify endpoints, nodes must be specified by
	// valid IDs only (instead of using filters/input spec structs).
	//
	// Specifying any Edge value in `usingOnly` will make the path only contain the
	// corresponding GUAC evidence trees (GUAC verbs).
	Path []PathPathNode `json:"-"`
}

// GetPath returns PathResponse.Path, and is useful for accessing the field via an interface.
func (v *PathResponse) GetPath() []PathPathNode { return v.Path }

func (v *PathResponse) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*PathResponse
		Path []json.RawMessage `json:"path"`
		graphql.NoUnmarshalJSON
	}
	firstPass.PathResponse = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Path
		src := firstPass.Path
		*dst = make(
			[]PathPathNode,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				err = __unmarshalPathPathNode(
					src, dst)
				if err != nil {
					return fmt.Errorf(
						"unable to unmarshal PathResponse.Path: %w", err)
				}
			}
		}
	}
	return nil
}

type __premarshalPathResponse struct {
	Path []json.RawMessage `json:"path"`
}

func (v *PathResponse) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *PathResponse) __premarshalJSON() (*__premarshalPathResponse, error) {
	var retval __premarshalPathResponse

	{

		dst := &retval.Path
		src := v.Path
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			var err error
			*dst, err = __marshalPathPathNode(
				&src)
			if err != nil {
				return nil, fmt.Errorf(
					"unable to marshal PathResponse.Path: %w", err)
			}
		}
	}
	return &retval, nil
}

// PkgEqualInputSpec represents the input to certify that packages are similar.
type PkgEqualInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetJustification returns PkgEqualInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *PkgEqualInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns PkgEqualInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *PkgEqualInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns PkgEqualInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *PkgEqualInputSpec) GetCollector() string { return v.Collector }

// PkgInputSpec specifies a package for mutations.
//
// This is different than PkgSpec because we want to encode mandatory fields:
// type and name. All optional fields are given empty default values.
type PkgInputSpec struct {
	Type       string                      `json:"type"`
	Namespace  *string                     `json:"namespace"`
	Name       string                      `json:"name"`
	Version    *string                     `json:"version"`
	Qualifiers []PackageQualifierInputSpec `json:"qualifiers"`
	Subpath    *string                     `json:"subpath"`
}

// GetType returns PkgInputSpec.Type, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetType() string { return v.Type }

// GetNamespace returns PkgInputSpec.Namespace, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetNamespace() *string { return v.Namespace }

// GetName returns PkgInputSpec.Name, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetName() string { return v.Name }

// GetVersion returns PkgInputSpec.Version, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetVersion() *string { return v.Version }

// GetQualifiers returns PkgInputSpec.Qualifiers, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetQualifiers() []PackageQualifierInputSpec { return v.Qualifiers }

// GetSubpath returns PkgInputSpec.Subpath, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetSubpath() *string { return v.Subpath }

// PkgMatchType is an enum to determine if the attestation should be done at the
// specific version or package name.
type PkgMatchType string

const (
	PkgMatchTypeAllVersions     PkgMatchType = "ALL_VERSIONS"
	PkgMatchTypeSpecificVersion PkgMatchType = "SPECIFIC_VERSION"
)

// PkgSpec allows filtering the list of sources to return in a query.
//
// Each field matches a qualifier from pURL. Use null to match on all values at
// that level. For example, to get all packages in GUAC backend, use a PkgSpec
// where every field is null.
//
// Empty string at a field means matching with the empty string. If passing in
// qualifiers, all of the values in the list must match. Since we want to return
// nodes with any number of qualifiers if no qualifiers are passed in the input,
// we must also return the same set of nodes it the qualifiers list is empty. To
// match on nodes that don't contain any qualifier, set matchOnlyEmptyQualifiers
// to true. If this field is true, then the qualifiers argument is ignored.
type PkgSpec struct {
	Id                       *string                `json:"id"`
	Type                     *string                `json:"type"`
	Namespace                *string                `json:"namespace"`
	Name                     *string                `json:"name"`
	Version                  *string                `json:"version"`
	Qualifiers               []PackageQualifierSpec `json:"qualifiers"`
	MatchOnlyEmptyQualifiers *bool                  `json:"matchOnlyEmptyQualifiers"`
	Subpath                  *string                `json:"subpath"`
}

// GetId returns PkgSpec.Id, and is useful for accessing the field via an interface.
func (v *PkgSpec) GetId() *string { return v.Id }

// GetType returns PkgSpec.Type, and is useful for accessing the field via an interface.
func (v *PkgSpec) GetType() *string { return v.Type }

// GetNamespace returns PkgSpec.Namespace, and is useful for accessing the field via an interface.
func (v *PkgSpec) GetNamespace() *string { return v.Namespace }

// GetName returns PkgSpec.Name, and is useful for accessing the field via an interface.
func (v *PkgSpec) GetName() *string { return v.Name }

// GetVersion returns PkgSpec.Version, and is useful for accessing the field via an interface.
func (v *PkgSpec) GetVersion() *string { return v.Version }

// GetQualifiers returns PkgSpec.Qualifiers, and is useful for accessing the field via an interface.
func (v *PkgSpec) GetQualifiers() []PackageQualifierSpec { return v.Qualifiers }

// GetMatchOnlyEmptyQualifiers returns PkgSpec.MatchOnlyEmptyQualifiers, and is useful for accessing the field via an interface.
func (v *PkgSpec) GetMatchOnlyEmptyQualifiers() *bool { return v.MatchOnlyEmptyQualifiers }

// GetSubpath returns PkgSpec.Subpath, and is useful for accessing the field via an interface.
func (v *PkgSpec) GetSubpath() *string { return v.Subpath }

// PointOfContactArtifactResponse is returned by PointOfContactArtifact on success.
type PointOfContactArtifactResponse struct {
	// Adds a PointOfContact attestation to a package, source or artifact. The returned ID can be empty string.
	IngestPointOfContact string `json:"ingestPointOfContact"`
}

// GetIngestPointOfContact returns PointOfContactArtifactResponse.IngestPointOfContact, and is useful for accessing the field via an interface.
func (v *PointOfContactArtifactResponse) GetIngestPointOfContact() string {
	return v.IngestPointOfContact
}

// PointOfContactInputSpec represents the mutation input to ingest a PointOfContact evidence.
type PointOfContactInputSpec struct {
	Email         string    `json:"email"`
	Info          string    `json:"info"`
	Since         time.Time `json:"since"`
	Justification string    `json:"justification"`
	Origin        string    `json:"origin"`
	Collector     string    `json:"collector"`
}

// GetEmail returns PointOfContactInputSpec.Email, and is useful for accessing the field via an interface.
func (v *PointOfContactInputSpec) GetEmail() string { return v.Email }

// GetInfo returns PointOfContactInputSpec.Info, and is useful for accessing the field via an interface.
func (v *PointOfContactInputSpec) GetInfo() string { return v.Info }

// GetSince returns PointOfContactInputSpec.Since, and is useful for accessing the field via an interface.
func (v *PointOfContactInputSpec) GetSince() time.Time { return v.Since }

// GetJustification returns PointOfContactInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *PointOfContactInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns PointOfContactInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *PointOfContactInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns PointOfContactInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *PointOfContactInputSpec) GetCollector() string { return v.Collector }

// PointOfContactPkgResponse is returned by PointOfContactPkg on success.
type PointOfContactPkgResponse struct {
	// Adds a PointOfContact attestation to a package, source or artifact. The returned ID can be empty string.
	IngestPointOfContact string `json:"ingestPointOfContact"`
}

// GetIngestPointOfContact returns PointOfContactPkgResponse.IngestPointOfContact, and is useful for accessing the field via an interface.
func (v *PointOfContactPkgResponse) GetIngestPointOfContact() string { return v.IngestPointOfContact }

// PointOfContactSrcResponse is returned by PointOfContactSrc on success.
type PointOfContactSrcResponse struct {
	// Adds a PointOfContact attestation to a package, source or artifact. The returned ID can be empty string.
	IngestPointOfContact string `json:"ingestPointOfContact"`
}

// GetIngestPointOfContact returns PointOfContactSrcResponse.IngestPointOfContact, and is useful for accessing the field via an interface.
func (v *PointOfContactSrcResponse) GetIngestPointOfContact() string { return v.IngestPointOfContact }

// SLSAForArtifactResponse is returned by SLSAForArtifact on success.
type SLSAForArtifactResponse struct {
	// Ingests a SLSA attestation. The returned ID can be empty string.
	IngestSLSA string `json:"ingestSLSA"`
}

// GetIngestSLSA returns SLSAForArtifactResponse.IngestSLSA, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactResponse) GetIngestSLSA() string { return v.IngestSLSA }

// SLSAForArtifactsResponse is returned by SLSAForArtifacts on success.
type SLSAForArtifactsResponse struct {
	// Bulk Ingest SLSA attestations. The returned array of IDs can be a an array of empty string.
	IngestSLSAs []string `json:"ingestSLSAs"`
}

// GetIngestSLSAs returns SLSAForArtifactsResponse.IngestSLSAs, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactsResponse) GetIngestSLSAs() []string { return v.IngestSLSAs }

// SLSAInputSpec is the same as SLSA but for mutation input.
type SLSAInputSpec struct {
	BuildType     string                   `json:"buildType"`
	SlsaPredicate []SLSAPredicateInputSpec `json:"slsaPredicate"`
	SlsaVersion   string                   `json:"slsaVersion"`
	StartedOn     *time.Time               `json:"startedOn"`
	FinishedOn    *time.Time               `json:"finishedOn"`
	Origin        string                   `json:"origin"`
	Collector     string                   `json:"collector"`
}

// GetBuildType returns SLSAInputSpec.BuildType, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetBuildType() string { return v.BuildType }

// GetSlsaPredicate returns SLSAInputSpec.SlsaPredicate, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetSlsaPredicate() []SLSAPredicateInputSpec { return v.SlsaPredicate }

// GetSlsaVersion returns SLSAInputSpec.SlsaVersion, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetSlsaVersion() string { return v.SlsaVersion }

// GetStartedOn returns SLSAInputSpec.StartedOn, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetStartedOn() *time.Time { return v.StartedOn }

// GetFinishedOn returns SLSAInputSpec.FinishedOn, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetFinishedOn() *time.Time { return v.FinishedOn }

// GetOrigin returns SLSAInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns SLSAInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetCollector() string { return v.Collector }

// SLSAPredicateInputSpec allows ingesting SLSAPredicateSpec.
type SLSAPredicateInputSpec struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns SLSAPredicateInputSpec.Key, and is useful for accessing the field via an interface.
func (v *SLSAPredicateInputSpec) GetKey() string { return v.Key }

// GetValue returns SLSAPredicateInputSpec.Value, and is useful for accessing the field via an interface.
func (v *SLSAPredicateInputSpec) GetValue() string { return v.Value }

// ScanMetadataInput represents the input for certifying vulnerability
// scans in mutations.
type ScanMetadataInput struct {
	TimeScanned    time.Time `json:"timeScanned"`
	DbUri          string    `json:"dbUri"`
	DbVersion      string    `json:"dbVersion"`
	ScannerUri     string    `json:"scannerUri"`
	ScannerVersion string    `json:"scannerVersion"`
	Origin         string    `json:"origin"`
	Collector      string    `json:"collector"`
}

// GetTimeScanned returns ScanMetadataInput.TimeScanned, and is useful for accessing the field via an interface.
func (v *ScanMetadataInput) GetTimeScanned() time.Time { return v.TimeScanned }

// GetDbUri returns ScanMetadataInput.DbUri, and is useful for accessing the field via an interface.
func (v *ScanMetadataInput) GetDbUri() string { return v.DbUri }

// GetDbVersion returns ScanMetadataInput.DbVersion, and is useful for accessing the field via an interface.
func (v *ScanMetadataInput) GetDbVersion() string { return v.DbVersion }

// GetScannerUri returns ScanMetadataInput.ScannerUri, and is useful for accessing the field via an interface.
func (v *ScanMetadataInput) GetScannerUri() string { return v.ScannerUri }

// GetScannerVersion returns ScanMetadataInput.ScannerVersion, and is useful for accessing the field via an interface.
func (v *ScanMetadataInput) GetScannerVersion() string { return v.ScannerVersion }

// GetOrigin returns ScanMetadataInput.Origin, and is useful for accessing the field via an interface.
func (v *ScanMetadataInput) GetOrigin() string { return v.Origin }

// GetCollector returns ScanMetadataInput.Collector, and is useful for accessing the field via an interface.
func (v *ScanMetadataInput) GetCollector() string { return v.Collector }

// ScorecardCheckInputSpec represents the mutation input for a Scorecard check.
type ScorecardCheckInputSpec struct {
	Check string `json:"check"`
	Score int    `json:"score"`
}

// GetCheck returns ScorecardCheckInputSpec.Check, and is useful for accessing the field via an interface.
func (v *ScorecardCheckInputSpec) GetCheck() string { return v.Check }

// GetScore returns ScorecardCheckInputSpec.Score, and is useful for accessing the field via an interface.
func (v *ScorecardCheckInputSpec) GetScore() int { return v.Score }

// ScorecardInputSpec represents the mutation input to ingest a Scorecard.
type ScorecardInputSpec struct {
	Checks           []ScorecardCheckInputSpec `json:"checks"`
	AggregateScore   float64                   `json:"aggregateScore"`
	TimeScanned      time.Time                 `json:"timeScanned"`
	ScorecardVersion string                    `json:"scorecardVersion"`
	ScorecardCommit  string                    `json:"scorecardCommit"`
	Origin           string                    `json:"origin"`
	Collector        string                    `json:"collector"`
}

// GetChecks returns ScorecardInputSpec.Checks, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetChecks() []ScorecardCheckInputSpec { return v.Checks }

// GetAggregateScore returns ScorecardInputSpec.AggregateScore, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetAggregateScore() float64 { return v.AggregateScore }

// GetTimeScanned returns ScorecardInputSpec.TimeScanned, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetTimeScanned() time.Time { return v.TimeScanned }

// GetScorecardVersion returns ScorecardInputSpec.ScorecardVersion, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetScorecardVersion() string { return v.ScorecardVersion }

// GetScorecardCommit returns ScorecardInputSpec.ScorecardCommit, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetScorecardCommit() string { return v.ScorecardCommit }

// GetOrigin returns ScorecardInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns ScorecardInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetCollector() string { return v.Collector }

// SourceInputSpec specifies a source for mutations.
//
// This is different than SourceSpec because we want to encode that all fields
// except tag and commit are mandatory fields. All optional fields are given empty
// default values.
//
// It is an error to set both tag and commit fields to values different than the
// default.
type SourceInputSpec struct {
	Type      string  `json:"type"`
	Namespace string  `json:"namespace"`
	Name      string  `json:"name"`
	Tag       *string `json:"tag"`
	Commit    *string `json:"commit"`
}

// GetType returns SourceInputSpec.Type, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetType() string { return v.Type }

// GetNamespace returns SourceInputSpec.Namespace, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetNamespace() string { return v.Namespace }

// GetName returns SourceInputSpec.Name, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetName() string { return v.Name }

// GetTag returns SourceInputSpec.Tag, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetTag() *string { return v.Tag }

// GetCommit returns SourceInputSpec.Commit, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetCommit() *string { return v.Commit }

// SourceSpec allows filtering the list of sources to return in a query.
//
// Empty string at a field means matching with the empty string. Missing field
// means retrieving all possible matches.
//
// It is an error to specify both tag and commit fields, except it both are set as
// empty string (in which case the returned sources are only those for which there
// is no tag/commit information).
type SourceSpec struct {
	Id        *string `json:"id"`
	Type      *string `json:"type"`
	Namespace *string `json:"namespace"`
	Name      *string `json:"name"`
	Tag       *string `json:"tag"`
	Commit    *string `json:"commit"`
}

// GetId returns SourceSpec.Id, and is useful for accessing the field via an interface.
func (v *SourceSpec) GetId() *string { return v.Id }

// GetType returns SourceSpec.Type, and is useful for accessing the field via an interface.
func (v *SourceSpec) GetType() *string { return v.Type }

// GetNamespace returns SourceSpec.Namespace, and is useful for accessing the field via an interface.
func (v *SourceSpec) GetNamespace() *string { return v.Namespace }

// GetName returns SourceSpec.Name, and is useful for accessing the field via an interface.
func (v *SourceSpec) GetName() *string { return v.Name }

// GetTag returns SourceSpec.Tag, and is useful for accessing the field via an interface.
func (v *SourceSpec) GetTag() *string { return v.Tag }

// GetCommit returns SourceSpec.Commit, and is useful for accessing the field via an interface.
func (v *SourceSpec) GetCommit() *string { return v.Commit }

// SourcesResponse is returned by Sources on success.
type SourcesResponse struct {
	// Returns all sources matching a filter.
	Sources []SourcesSourcesSource `json:"sources"`
}

// GetSources returns SourcesResponse.Sources, and is useful for accessing the field via an interface.
func (v *SourcesResponse) GetSources() []SourcesSourcesSource { return v.Sources }

// SourcesSourcesSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents the root of the source trie/tree.
//
// We map source information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type, namespace, name and an optional
// qualifier that stands for tag/commit information.
//
// This node represents the type part of the trie path. It is used to represent
// the version control system that is being used.
//
// Since this node is at the root of the source trie, it is named Source, not
// SourceType.
type SourcesSourcesSource struct {
	AllSourceTree `json:"-"`
}

// GetId returns SourcesSourcesSource.Id, and is useful for accessing the field via an interface.
func (v *SourcesSourcesSource) GetId() string { return v.AllSourceTree.Id }

// GetType returns SourcesSourcesSource.Type, and is useful for accessing the field via an interface.
func (v *SourcesSourcesSource) GetType() string { return v.AllSourceTree.Type }

// GetNamespaces returns SourcesSourcesSource.Namespaces, and is useful for accessing the field via an interface.
func (v *SourcesSourcesSource) GetNamespaces() []AllSourceTreeNamespacesSourceNamespace {
	return v.AllSourceTree.Namespaces
}

func (v *SourcesSourcesSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SourcesSourcesSource
		graphql.NoUnmarshalJSON
	}
	firstPass.SourcesSourcesSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSourcesSourcesSource struct {
	Id string `json:"id"`

	Type string `json:"type"`

	Namespaces []AllSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *SourcesSourcesSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SourcesSourcesSource) __premarshalJSON() (*__premarshalSourcesSourcesSource, error) {
	var retval __premarshalSourcesSourcesSource

	retval.Id = v.AllSourceTree.Id
	retval.Type = v.AllSourceTree.Type
	retval.Namespaces = v.AllSourceTree.Namespaces
	return &retval, nil
}

// Records the justification included in the VEX statement.
type VexJustification string

const (
	VexJustificationComponentNotPresent                         VexJustification = "COMPONENT_NOT_PRESENT"
	VexJustificationVulnerableCodeNotPresent                    VexJustification = "VULNERABLE_CODE_NOT_PRESENT"
	VexJustificationVulnerableCodeNotInExecutePath              VexJustification = "VULNERABLE_CODE_NOT_IN_EXECUTE_PATH"
	VexJustificationVulnerableCodeCannotBeControlledByAdversary VexJustification = "VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY"
	VexJustificationInlineMitigationsAlreadyExist               VexJustification = "INLINE_MITIGATIONS_ALREADY_EXIST"
	VexJustificationNotProvided                                 VexJustification = "NOT_PROVIDED"
)

// VexStatementInputSpec represents the input to ingest VEX statements.
type VexStatementInputSpec struct {
	Status           VexStatus        `json:"status"`
	VexJustification VexJustification `json:"vexJustification"`
	Statement        string           `json:"statement"`
	StatusNotes      string           `json:"statusNotes"`
	KnownSince       time.Time        `json:"knownSince"`
	Origin           string           `json:"origin"`
	Collector        string           `json:"collector"`
}

// GetStatus returns VexStatementInputSpec.Status, and is useful for accessing the field via an interface.
func (v *VexStatementInputSpec) GetStatus() VexStatus { return v.Status }

// GetVexJustification returns VexStatementInputSpec.VexJustification, and is useful for accessing the field via an interface.
func (v *VexStatementInputSpec) GetVexJustification() VexJustification { return v.VexJustification }

// GetStatement returns VexStatementInputSpec.Statement, and is useful for accessing the field via an interface.
func (v *VexStatementInputSpec) GetStatement() string { return v.Statement }

// GetStatusNotes returns VexStatementInputSpec.StatusNotes, and is useful for accessing the field via an interface.
func (v *VexStatementInputSpec) GetStatusNotes() string { return v.StatusNotes }

// GetKnownSince returns VexStatementInputSpec.KnownSince, and is useful for accessing the field via an interface.
func (v *VexStatementInputSpec) GetKnownSince() time.Time { return v.KnownSince }

// GetOrigin returns VexStatementInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *VexStatementInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns VexStatementInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *VexStatementInputSpec) GetCollector() string { return v.Collector }

// Records the status of a VEX statement subject.
type VexStatus string

const (
	VexStatusNotAffected        VexStatus = "NOT_AFFECTED"
	VexStatusAffected           VexStatus = "AFFECTED"
	VexStatusFixed              VexStatus = "FIXED"
	VexStatusUnderInvestigation VexStatus = "UNDER_INVESTIGATION"
)

// VulnEqualInputSpec represents the input to link vulnerabilities to each other.
type VulnEqualInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetJustification returns VulnEqualInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *VulnEqualInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns VulnEqualInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *VulnEqualInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns VulnEqualInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *VulnEqualInputSpec) GetCollector() string { return v.Collector }

// VulnHasMetadataResponse is returned by VulnHasMetadata on success.
type VulnHasMetadataResponse struct {
	// Adds metadata about a vulnerability. The returned ID can be empty string.
	IngestVulnerabilityMetadata string `json:"ingestVulnerabilityMetadata"`
}

// GetIngestVulnerabilityMetadata returns VulnHasMetadataResponse.IngestVulnerabilityMetadata, and is useful for accessing the field via an interface.
func (v *VulnHasMetadataResponse) GetIngestVulnerabilityMetadata() string {
	return v.IngestVulnerabilityMetadata
}

// VulnerabilitiesResponse is returned by Vulnerabilities on success.
type VulnerabilitiesResponse struct {
	// Returns all vulnerabilities matching a filter.
	Vulnerabilities []VulnerabilitiesVulnerabilitiesVulnerability `json:"vulnerabilities"`
}

// GetVulnerabilities returns VulnerabilitiesResponse.Vulnerabilities, and is useful for accessing the field via an interface.
func (v *VulnerabilitiesResponse) GetVulnerabilities() []VulnerabilitiesVulnerabilitiesVulnerability {
	return v.Vulnerabilities
}

// VulnerabilitiesVulnerabilitiesVulnerability includes the requested fields of the GraphQL type Vulnerability.
// The GraphQL type's documentation follows.
//
// Vulnerability represents the root of the vulnerability trie/tree.
//
// We map vulnerability information to a trie, as a derivative of the pURL specification:
// each path in the trie represents a type and a vulnerability ID. This allows for generic
// representation of the various vulnerabilities and does not limit to just cve, ghsa or osv.
// This would be in the general format: vuln://<general-type>/<vuln-id>
//
// Examples:
//
// CVE, using path separator: vuln://cve/cve-2023-20753
// OSV, representing its knowledge of a GHSA: vuln://osv/ghsa-205hk
// Random vendor: vuln://snyk/sn-whatever
// NoVuln: vuln://novuln/
//
// This node represents the type part of the trie path. It is used to represent
// the specific type of the vulnerability: cve, ghsa, osv or some other vendor specific
//
// Since this node is at the root of the vulnerability trie, it is named Vulnerability, not
// VulnerabilityType.
//
// NoVuln is a special vulnerability node to attest that no vulnerability has been
// found during a vulnerability scan. It will have the type "novuln" and contain an empty string
// for vulnerabilityID
//
// The resolvers will enforce that both the type and vulnerability IDs are lower case.
type VulnerabilitiesVulnerabilitiesVulnerability struct {
	AllVulnerabilityTree `json:"-"`
}

// GetId returns VulnerabilitiesVulnerabilitiesVulnerability.Id, and is useful for accessing the field via an interface.
func (v *VulnerabilitiesVulnerabilitiesVulnerability) GetId() string {
	return v.AllVulnerabilityTree.Id
}

// GetType returns VulnerabilitiesVulnerabilitiesVulnerability.Type, and is useful for accessing the field via an interface.
func (v *VulnerabilitiesVulnerabilitiesVulnerability) GetType() string {
	return v.AllVulnerabilityTree.Type
}

// GetVulnerabilityIDs returns VulnerabilitiesVulnerabilitiesVulnerability.VulnerabilityIDs, and is useful for accessing the field via an interface.
func (v *VulnerabilitiesVulnerabilitiesVulnerability) GetVulnerabilityIDs() []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID {
	return v.AllVulnerabilityTree.VulnerabilityIDs
}

func (v *VulnerabilitiesVulnerabilitiesVulnerability) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*VulnerabilitiesVulnerabilitiesVulnerability
		graphql.NoUnmarshalJSON
	}
	firstPass.VulnerabilitiesVulnerabilitiesVulnerability = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.AllVulnerabilityTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalVulnerabilitiesVulnerabilitiesVulnerability struct {
	Id string `json:"id"`

	Type string `json:"type"`

	VulnerabilityIDs []AllVulnerabilityTreeVulnerabilityIDsVulnerabilityID `json:"vulnerabilityIDs"`
}

func (v *VulnerabilitiesVulnerabilitiesVulnerability) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *VulnerabilitiesVulnerabilitiesVulnerability) __premarshalJSON() (*__premarshalVulnerabilitiesVulnerabilitiesVulnerability, error) {
	var retval __premarshalVulnerabilitiesVulnerabilitiesVulnerability

	retval.Id = v.AllVulnerabilityTree.Id
	retval.Type = v.AllVulnerabilityTree.Type
	retval.VulnerabilityIDs = v.AllVulnerabilityTree.VulnerabilityIDs
	return &retval, nil
}

// VulnInputSpec specifies a vulnerability for mutations.
//
// This is different than VulnSpec because we want to encode mandatory fields:
// type and vulnerabilityID.
type VulnerabilityInputSpec struct {
	Type            string `json:"type"`
	VulnerabilityID string `json:"vulnerabilityID"`
}

// GetType returns VulnerabilityInputSpec.Type, and is useful for accessing the field via an interface.
func (v *VulnerabilityInputSpec) GetType() string { return v.Type }

// GetVulnerabilityID returns VulnerabilityInputSpec.VulnerabilityID, and is useful for accessing the field via an interface.
func (v *VulnerabilityInputSpec) GetVulnerabilityID() string { return v.VulnerabilityID }

// VulnerabilityMetadataInputSpec represents the mutation input to ingest a vulnerability metadata.
type VulnerabilityMetadataInputSpec struct {
	ScoreType  VulnerabilityScoreType `json:"scoreType"`
	ScoreValue float64                `json:"scoreValue"`
	Timestamp  time.Time              `json:"timestamp"`
	Origin     string                 `json:"origin"`
	Collector  string                 `json:"collector"`
}

// GetScoreType returns VulnerabilityMetadataInputSpec.ScoreType, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetadataInputSpec) GetScoreType() VulnerabilityScoreType { return v.ScoreType }

// GetScoreValue returns VulnerabilityMetadataInputSpec.ScoreValue, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetadataInputSpec) GetScoreValue() float64 { return v.ScoreValue }

// GetTimestamp returns VulnerabilityMetadataInputSpec.Timestamp, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetadataInputSpec) GetTimestamp() time.Time { return v.Timestamp }

// GetOrigin returns VulnerabilityMetadataInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetadataInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns VulnerabilityMetadataInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetadataInputSpec) GetCollector() string { return v.Collector }

// Records the type of the score being captured by the score node
type VulnerabilityScoreType string

const (
	VulnerabilityScoreTypeCvssv2  VulnerabilityScoreType = "CVSSv2"
	VulnerabilityScoreTypeCvssv3  VulnerabilityScoreType = "CVSSv3"
	VulnerabilityScoreTypeEpssv1  VulnerabilityScoreType = "EPSSv1"
	VulnerabilityScoreTypeEpssv2  VulnerabilityScoreType = "EPSSv2"
	VulnerabilityScoreTypeCvssv31 VulnerabilityScoreType = "CVSSv31"
	VulnerabilityScoreTypeCvssv4  VulnerabilityScoreType = "CVSSv4"
	VulnerabilityScoreTypeOwasp   VulnerabilityScoreType = "OWASP"
	VulnerabilityScoreTypeSsvc    VulnerabilityScoreType = "SSVC"
)

// VulnerabilitySpec allows filtering the list of vulnerabilities to return in a query.
//
// Use null to match on all values at that level.
// For example, to get all vulnerabilities in GUAC backend, use a VulnSpec
// where every field is null.
//
// Setting the noVuln boolean true will ignore the other inputs for type and vulnerabilityID.
// Setting noVuln to true means retrieving only nodes where the type of the vulnerability is "novuln"
// and the it has an empty string for vulnerabilityID. Setting it to false filters out all results that are "novuln".
// Setting one of the other fields and omitting the noVuln means retrieving vulnerabilities for the corresponding
// type and vulnerabilityID. Omission of noVuln field will return all vulnerabilities and novuln.
type VulnerabilitySpec struct {
	Id              *string `json:"id"`
	Type            *string `json:"type"`
	VulnerabilityID *string `json:"vulnerabilityID"`
	NoVuln          *bool   `json:"noVuln"`
}

// GetId returns VulnerabilitySpec.Id, and is useful for accessing the field via an interface.
func (v *VulnerabilitySpec) GetId() *string { return v.Id }

// GetType returns VulnerabilitySpec.Type, and is useful for accessing the field via an interface.
func (v *VulnerabilitySpec) GetType() *string { return v.Type }

// GetVulnerabilityID returns VulnerabilitySpec.VulnerabilityID, and is useful for accessing the field via an interface.
func (v *VulnerabilitySpec) GetVulnerabilityID() *string { return v.VulnerabilityID }

// GetNoVuln returns VulnerabilitySpec.NoVuln, and is useful for accessing the field via an interface.
func (v *VulnerabilitySpec) GetNoVuln() *bool { return v.NoVuln }

// __ArtifactsInput is used internally by genqlient
type __ArtifactsInput struct {
	Filter ArtifactSpec `json:"filter"`
}

// GetFilter returns __ArtifactsInput.Filter, and is useful for accessing the field via an interface.
func (v *__ArtifactsInput) GetFilter() ArtifactSpec { return v.Filter }

// __BulkVulnHasMetadataInput is used internally by genqlient
type __BulkVulnHasMetadataInput struct {
	Vulnerabilities           []VulnerabilityInputSpec         `json:"vulnerabilities"`
	VulnerabilityMetadataList []VulnerabilityMetadataInputSpec `json:"vulnerabilityMetadataList"`
}

// GetVulnerabilities returns __BulkVulnHasMetadataInput.Vulnerabilities, and is useful for accessing the field via an interface.
func (v *__BulkVulnHasMetadataInput) GetVulnerabilities() []VulnerabilityInputSpec {
	return v.Vulnerabilities
}

// GetVulnerabilityMetadataList returns __BulkVulnHasMetadataInput.VulnerabilityMetadataList, and is useful for accessing the field via an interface.
func (v *__BulkVulnHasMetadataInput) GetVulnerabilityMetadataList() []VulnerabilityMetadataInputSpec {
	return v.VulnerabilityMetadataList
}

// __CertifyBadArtifactInput is used internally by genqlient
type __CertifyBadArtifactInput struct {
	Artifact   ArtifactInputSpec   `json:"artifact"`
	CertifyBad CertifyBadInputSpec `json:"certifyBad"`
}

// GetArtifact returns __CertifyBadArtifactInput.Artifact, and is useful for accessing the field via an interface.
func (v *__CertifyBadArtifactInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetCertifyBad returns __CertifyBadArtifactInput.CertifyBad, and is useful for accessing the field via an interface.
func (v *__CertifyBadArtifactInput) GetCertifyBad() CertifyBadInputSpec { return v.CertifyBad }

// __CertifyBadArtifactsInput is used internally by genqlient
type __CertifyBadArtifactsInput struct {
	Artifacts   []ArtifactInputSpec   `json:"artifacts"`
	CertifyBads []CertifyBadInputSpec `json:"certifyBads"`
}

// GetArtifacts returns __CertifyBadArtifactsInput.Artifacts, and is useful for accessing the field via an interface.
func (v *__CertifyBadArtifactsInput) GetArtifacts() []ArtifactInputSpec { return v.Artifacts }

// GetCertifyBads returns __CertifyBadArtifactsInput.CertifyBads, and is useful for accessing the field via an interface.
func (v *__CertifyBadArtifactsInput) GetCertifyBads() []CertifyBadInputSpec { return v.CertifyBads }

// __CertifyBadPkgInput is used internally by genqlient
type __CertifyBadPkgInput struct {
	Pkg          PkgInputSpec        `json:"pkg"`
	PkgMatchType MatchFlags          `json:"pkgMatchType"`
	CertifyBad   CertifyBadInputSpec `json:"certifyBad"`
}

// GetPkg returns __CertifyBadPkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyBadPkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetPkgMatchType returns __CertifyBadPkgInput.PkgMatchType, and is useful for accessing the field via an interface.
func (v *__CertifyBadPkgInput) GetPkgMatchType() MatchFlags { return v.PkgMatchType }

// GetCertifyBad returns __CertifyBadPkgInput.CertifyBad, and is useful for accessing the field via an interface.
func (v *__CertifyBadPkgInput) GetCertifyBad() CertifyBadInputSpec { return v.CertifyBad }

// __CertifyBadPkgsInput is used internally by genqlient
type __CertifyBadPkgsInput struct {
	Pkgs         []PkgInputSpec        `json:"pkgs"`
	PkgMatchType MatchFlags            `json:"pkgMatchType"`
	CertifyBads  []CertifyBadInputSpec `json:"certifyBads"`
}

// GetPkgs returns __CertifyBadPkgsInput.Pkgs, and is useful for accessing the field via an interface.
func (v *__CertifyBadPkgsInput) GetPkgs() []PkgInputSpec { return v.Pkgs }

// GetPkgMatchType returns __CertifyBadPkgsInput.PkgMatchType, and is useful for accessing the field via an interface.
func (v *__CertifyBadPkgsInput) GetPkgMatchType() MatchFlags { return v.PkgMatchType }

// GetCertifyBads returns __CertifyBadPkgsInput.CertifyBads, and is useful for accessing the field via an interface.
func (v *__CertifyBadPkgsInput) GetCertifyBads() []CertifyBadInputSpec { return v.CertifyBads }

// __CertifyBadSrcInput is used internally by genqlient
type __CertifyBadSrcInput struct {
	Source     SourceInputSpec     `json:"source"`
	CertifyBad CertifyBadInputSpec `json:"certifyBad"`
}

// GetSource returns __CertifyBadSrcInput.Source, and is useful for accessing the field via an interface.
func (v *__CertifyBadSrcInput) GetSource() SourceInputSpec { return v.Source }

// GetCertifyBad returns __CertifyBadSrcInput.CertifyBad, and is useful for accessing the field via an interface.
func (v *__CertifyBadSrcInput) GetCertifyBad() CertifyBadInputSpec { return v.CertifyBad }

// __CertifyBadSrcsInput is used internally by genqlient
type __CertifyBadSrcsInput struct {
	Sources     []SourceInputSpec     `json:"sources"`
	CertifyBads []CertifyBadInputSpec `json:"certifyBads"`
}

// GetSources returns __CertifyBadSrcsInput.Sources, and is useful for accessing the field via an interface.
func (v *__CertifyBadSrcsInput) GetSources() []SourceInputSpec { return v.Sources }

// GetCertifyBads returns __CertifyBadSrcsInput.CertifyBads, and is useful for accessing the field via an interface.
func (v *__CertifyBadSrcsInput) GetCertifyBads() []CertifyBadInputSpec { return v.CertifyBads }

// __CertifyBadsInput is used internally by genqlient
type __CertifyBadsInput struct {
	Filter CertifyBadSpec `json:"filter"`
}

// GetFilter returns __CertifyBadsInput.Filter, and is useful for accessing the field via an interface.
func (v *__CertifyBadsInput) GetFilter() CertifyBadSpec { return v.Filter }

// __CertifyGoodArtifactInput is used internally by genqlient
type __CertifyGoodArtifactInput struct {
	Artifact    ArtifactInputSpec    `json:"artifact"`
	CertifyGood CertifyGoodInputSpec `json:"certifyGood"`
}

// GetArtifact returns __CertifyGoodArtifactInput.Artifact, and is useful for accessing the field via an interface.
func (v *__CertifyGoodArtifactInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetCertifyGood returns __CertifyGoodArtifactInput.CertifyGood, and is useful for accessing the field via an interface.
func (v *__CertifyGoodArtifactInput) GetCertifyGood() CertifyGoodInputSpec { return v.CertifyGood }

// __CertifyGoodArtifactsInput is used internally by genqlient
type __CertifyGoodArtifactsInput struct {
	Artifacts    []ArtifactInputSpec    `json:"artifacts"`
	CertifyGoods []CertifyGoodInputSpec `json:"certifyGoods"`
}

// GetArtifacts returns __CertifyGoodArtifactsInput.Artifacts, and is useful for accessing the field via an interface.
func (v *__CertifyGoodArtifactsInput) GetArtifacts() []ArtifactInputSpec { return v.Artifacts }

// GetCertifyGoods returns __CertifyGoodArtifactsInput.CertifyGoods, and is useful for accessing the field via an interface.
func (v *__CertifyGoodArtifactsInput) GetCertifyGoods() []CertifyGoodInputSpec { return v.CertifyGoods }

// __CertifyGoodPkgInput is used internally by genqlient
type __CertifyGoodPkgInput struct {
	Pkg          PkgInputSpec         `json:"pkg"`
	PkgMatchType MatchFlags           `json:"pkgMatchType"`
	CertifyGood  CertifyGoodInputSpec `json:"certifyGood"`
}

// GetPkg returns __CertifyGoodPkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyGoodPkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetPkgMatchType returns __CertifyGoodPkgInput.PkgMatchType, and is useful for accessing the field via an interface.
func (v *__CertifyGoodPkgInput) GetPkgMatchType() MatchFlags { return v.PkgMatchType }

// GetCertifyGood returns __CertifyGoodPkgInput.CertifyGood, and is useful for accessing the field via an interface.
func (v *__CertifyGoodPkgInput) GetCertifyGood() CertifyGoodInputSpec { return v.CertifyGood }

// __CertifyGoodPkgsInput is used internally by genqlient
type __CertifyGoodPkgsInput struct {
	Pkgs         []PkgInputSpec         `json:"pkgs"`
	PkgMatchType MatchFlags             `json:"pkgMatchType"`
	CertifyGoods []CertifyGoodInputSpec `json:"certifyGoods"`
}

// GetPkgs returns __CertifyGoodPkgsInput.Pkgs, and is useful for accessing the field via an interface.
func (v *__CertifyGoodPkgsInput) GetPkgs() []PkgInputSpec { return v.Pkgs }

// GetPkgMatchType returns __CertifyGoodPkgsInput.PkgMatchType, and is useful for accessing the field via an interface.
func (v *__CertifyGoodPkgsInput) GetPkgMatchType() MatchFlags { return v.PkgMatchType }

// GetCertifyGoods returns __CertifyGoodPkgsInput.CertifyGoods, and is useful for accessing the field via an interface.
func (v *__CertifyGoodPkgsInput) GetCertifyGoods() []CertifyGoodInputSpec { return v.CertifyGoods }

// __CertifyGoodSrcInput is used internally by genqlient
type __CertifyGoodSrcInput struct {
	Source      SourceInputSpec      `json:"source"`
	CertifyGood CertifyGoodInputSpec `json:"certifyGood"`
}

// GetSource returns __CertifyGoodSrcInput.Source, and is useful for accessing the field via an interface.
func (v *__CertifyGoodSrcInput) GetSource() SourceInputSpec { return v.Source }

// GetCertifyGood returns __CertifyGoodSrcInput.CertifyGood, and is useful for accessing the field via an interface.
func (v *__CertifyGoodSrcInput) GetCertifyGood() CertifyGoodInputSpec { return v.CertifyGood }

// __CertifyGoodSrcsInput is used internally by genqlient
type __CertifyGoodSrcsInput struct {
	Sources      []SourceInputSpec      `json:"sources"`
	CertifyGoods []CertifyGoodInputSpec `json:"certifyGoods"`
}

// GetSources returns __CertifyGoodSrcsInput.Sources, and is useful for accessing the field via an interface.
func (v *__CertifyGoodSrcsInput) GetSources() []SourceInputSpec { return v.Sources }

// GetCertifyGoods returns __CertifyGoodSrcsInput.CertifyGoods, and is useful for accessing the field via an interface.
func (v *__CertifyGoodSrcsInput) GetCertifyGoods() []CertifyGoodInputSpec { return v.CertifyGoods }

// __CertifyLegalPkgInput is used internally by genqlient
type __CertifyLegalPkgInput struct {
	Pkg                PkgInputSpec          `json:"pkg"`
	DeclaredLicenses   []LicenseInputSpec    `json:"declaredLicenses"`
	DiscoveredLicenses []LicenseInputSpec    `json:"discoveredLicenses"`
	Legal              CertifyLegalInputSpec `json:"legal"`
}

// GetPkg returns __CertifyLegalPkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyLegalPkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetDeclaredLicenses returns __CertifyLegalPkgInput.DeclaredLicenses, and is useful for accessing the field via an interface.
func (v *__CertifyLegalPkgInput) GetDeclaredLicenses() []LicenseInputSpec { return v.DeclaredLicenses }

// GetDiscoveredLicenses returns __CertifyLegalPkgInput.DiscoveredLicenses, and is useful for accessing the field via an interface.
func (v *__CertifyLegalPkgInput) GetDiscoveredLicenses() []LicenseInputSpec {
	return v.DiscoveredLicenses
}

// GetLegal returns __CertifyLegalPkgInput.Legal, and is useful for accessing the field via an interface.
func (v *__CertifyLegalPkgInput) GetLegal() CertifyLegalInputSpec { return v.Legal }

// __CertifyLegalPkgsInput is used internally by genqlient
type __CertifyLegalPkgsInput struct {
	Pkgs                   []PkgInputSpec          `json:"pkgs"`
	DeclaredLicensesList   [][]LicenseInputSpec    `json:"declaredLicensesList"`
	DiscoveredLicensesList [][]LicenseInputSpec    `json:"discoveredLicensesList"`
	Legals                 []CertifyLegalInputSpec `json:"legals"`
}

// GetPkgs returns __CertifyLegalPkgsInput.Pkgs, and is useful for accessing the field via an interface.
func (v *__CertifyLegalPkgsInput) GetPkgs() []PkgInputSpec { return v.Pkgs }

// GetDeclaredLicensesList returns __CertifyLegalPkgsInput.DeclaredLicensesList, and is useful for accessing the field via an interface.
func (v *__CertifyLegalPkgsInput) GetDeclaredLicensesList() [][]LicenseInputSpec {
	return v.DeclaredLicensesList
}

// GetDiscoveredLicensesList returns __CertifyLegalPkgsInput.DiscoveredLicensesList, and is useful for accessing the field via an interface.
func (v *__CertifyLegalPkgsInput) GetDiscoveredLicensesList() [][]LicenseInputSpec {
	return v.DiscoveredLicensesList
}

// GetLegals returns __CertifyLegalPkgsInput.Legals, and is useful for accessing the field via an interface.
func (v *__CertifyLegalPkgsInput) GetLegals() []CertifyLegalInputSpec { return v.Legals }

// __CertifyLegalSrcInput is used internally by genqlient
type __CertifyLegalSrcInput struct {
	Src                SourceInputSpec       `json:"src"`
	DeclaredLicenses   []LicenseInputSpec    `json:"declaredLicenses"`
	DiscoveredLicenses []LicenseInputSpec    `json:"discoveredLicenses"`
	Legal              CertifyLegalInputSpec `json:"legal"`
}

// GetSrc returns __CertifyLegalSrcInput.Src, and is useful for accessing the field via an interface.
func (v *__CertifyLegalSrcInput) GetSrc() SourceInputSpec { return v.Src }

// GetDeclaredLicenses returns __CertifyLegalSrcInput.DeclaredLicenses, and is useful for accessing the field via an interface.
func (v *__CertifyLegalSrcInput) GetDeclaredLicenses() []LicenseInputSpec { return v.DeclaredLicenses }

// GetDiscoveredLicenses returns __CertifyLegalSrcInput.DiscoveredLicenses, and is useful for accessing the field via an interface.
func (v *__CertifyLegalSrcInput) GetDiscoveredLicenses() []LicenseInputSpec {
	return v.DiscoveredLicenses
}

// GetLegal returns __CertifyLegalSrcInput.Legal, and is useful for accessing the field via an interface.
func (v *__CertifyLegalSrcInput) GetLegal() CertifyLegalInputSpec { return v.Legal }

// __CertifyLegalSrcsInput is used internally by genqlient
type __CertifyLegalSrcsInput struct {
	Srcs                   []SourceInputSpec       `json:"srcs"`
	DeclaredLicensesList   [][]LicenseInputSpec    `json:"declaredLicensesList"`
	DiscoveredLicensesList [][]LicenseInputSpec    `json:"discoveredLicensesList"`
	Legals                 []CertifyLegalInputSpec `json:"legals"`
}

// GetSrcs returns __CertifyLegalSrcsInput.Srcs, and is useful for accessing the field via an interface.
func (v *__CertifyLegalSrcsInput) GetSrcs() []SourceInputSpec { return v.Srcs }

// GetDeclaredLicensesList returns __CertifyLegalSrcsInput.DeclaredLicensesList, and is useful for accessing the field via an interface.
func (v *__CertifyLegalSrcsInput) GetDeclaredLicensesList() [][]LicenseInputSpec {
	return v.DeclaredLicensesList
}

// GetDiscoveredLicensesList returns __CertifyLegalSrcsInput.DiscoveredLicensesList, and is useful for accessing the field via an interface.
func (v *__CertifyLegalSrcsInput) GetDiscoveredLicensesList() [][]LicenseInputSpec {
	return v.DiscoveredLicensesList
}

// GetLegals returns __CertifyLegalSrcsInput.Legals, and is useful for accessing the field via an interface.
func (v *__CertifyLegalSrcsInput) GetLegals() []CertifyLegalInputSpec { return v.Legals }

// __CertifyLegalsInput is used internally by genqlient
type __CertifyLegalsInput struct {
	Filter CertifyLegalSpec `json:"filter"`
}

// GetFilter returns __CertifyLegalsInput.Filter, and is useful for accessing the field via an interface.
func (v *__CertifyLegalsInput) GetFilter() CertifyLegalSpec { return v.Filter }

// __CertifyScorecardInput is used internally by genqlient
type __CertifyScorecardInput struct {
	Source    SourceInputSpec    `json:"source"`
	Scorecard ScorecardInputSpec `json:"scorecard"`
}

// GetSource returns __CertifyScorecardInput.Source, and is useful for accessing the field via an interface.
func (v *__CertifyScorecardInput) GetSource() SourceInputSpec { return v.Source }

// GetScorecard returns __CertifyScorecardInput.Scorecard, and is useful for accessing the field via an interface.
func (v *__CertifyScorecardInput) GetScorecard() ScorecardInputSpec { return v.Scorecard }

// __CertifyScorecardsInput is used internally by genqlient
type __CertifyScorecardsInput struct {
	Sources    []SourceInputSpec    `json:"sources"`
	Scorecards []ScorecardInputSpec `json:"scorecards"`
}

// GetSources returns __CertifyScorecardsInput.Sources, and is useful for accessing the field via an interface.
func (v *__CertifyScorecardsInput) GetSources() []SourceInputSpec { return v.Sources }

// GetScorecards returns __CertifyScorecardsInput.Scorecards, and is useful for accessing the field via an interface.
func (v *__CertifyScorecardsInput) GetScorecards() []ScorecardInputSpec { return v.Scorecards }

// __CertifyVexArtifactInput is used internally by genqlient
type __CertifyVexArtifactInput struct {
	Artifact      ArtifactInputSpec      `json:"artifact"`
	Vulnerability VulnerabilityInputSpec `json:"vulnerability"`
	VexStatement  VexStatementInputSpec  `json:"vexStatement"`
}

// GetArtifact returns __CertifyVexArtifactInput.Artifact, and is useful for accessing the field via an interface.
func (v *__CertifyVexArtifactInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetVulnerability returns __CertifyVexArtifactInput.Vulnerability, and is useful for accessing the field via an interface.
func (v *__CertifyVexArtifactInput) GetVulnerability() VulnerabilityInputSpec { return v.Vulnerability }

// GetVexStatement returns __CertifyVexArtifactInput.VexStatement, and is useful for accessing the field via an interface.
func (v *__CertifyVexArtifactInput) GetVexStatement() VexStatementInputSpec { return v.VexStatement }

// __CertifyVexArtifactsInput is used internally by genqlient
type __CertifyVexArtifactsInput struct {
	Artifacts       []ArtifactInputSpec      `json:"artifacts"`
	Vulnerabilities []VulnerabilityInputSpec `json:"vulnerabilities"`
	VexStatements   []VexStatementInputSpec  `json:"vexStatements"`
}

// GetArtifacts returns __CertifyVexArtifactsInput.Artifacts, and is useful for accessing the field via an interface.
func (v *__CertifyVexArtifactsInput) GetArtifacts() []ArtifactInputSpec { return v.Artifacts }

// GetVulnerabilities returns __CertifyVexArtifactsInput.Vulnerabilities, and is useful for accessing the field via an interface.
func (v *__CertifyVexArtifactsInput) GetVulnerabilities() []VulnerabilityInputSpec {
	return v.Vulnerabilities
}

// GetVexStatements returns __CertifyVexArtifactsInput.VexStatements, and is useful for accessing the field via an interface.
func (v *__CertifyVexArtifactsInput) GetVexStatements() []VexStatementInputSpec {
	return v.VexStatements
}

// __CertifyVexPkgInput is used internally by genqlient
type __CertifyVexPkgInput struct {
	Pkg           PkgInputSpec           `json:"pkg"`
	Vulnerability VulnerabilityInputSpec `json:"vulnerability"`
	VexStatement  VexStatementInputSpec  `json:"vexStatement"`
}

// GetPkg returns __CertifyVexPkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyVexPkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetVulnerability returns __CertifyVexPkgInput.Vulnerability, and is useful for accessing the field via an interface.
func (v *__CertifyVexPkgInput) GetVulnerability() VulnerabilityInputSpec { return v.Vulnerability }

// GetVexStatement returns __CertifyVexPkgInput.VexStatement, and is useful for accessing the field via an interface.
func (v *__CertifyVexPkgInput) GetVexStatement() VexStatementInputSpec { return v.VexStatement }

// __CertifyVexPkgsInput is used internally by genqlient
type __CertifyVexPkgsInput struct {
	Pkgs            []PkgInputSpec           `json:"pkgs"`
	Vulnerabilities []VulnerabilityInputSpec `json:"vulnerabilities"`
	VexStatements   []VexStatementInputSpec  `json:"vexStatements"`
}

// GetPkgs returns __CertifyVexPkgsInput.Pkgs, and is useful for accessing the field via an interface.
func (v *__CertifyVexPkgsInput) GetPkgs() []PkgInputSpec { return v.Pkgs }

// GetVulnerabilities returns __CertifyVexPkgsInput.Vulnerabilities, and is useful for accessing the field via an interface.
func (v *__CertifyVexPkgsInput) GetVulnerabilities() []VulnerabilityInputSpec {
	return v.Vulnerabilities
}

// GetVexStatements returns __CertifyVexPkgsInput.VexStatements, and is useful for accessing the field via an interface.
func (v *__CertifyVexPkgsInput) GetVexStatements() []VexStatementInputSpec { return v.VexStatements }

// __CertifyVulnPkgInput is used internally by genqlient
type __CertifyVulnPkgInput struct {
	Pkg           PkgInputSpec           `json:"pkg"`
	Vulnerability VulnerabilityInputSpec `json:"vulnerability"`
	CertifyVuln   ScanMetadataInput      `json:"certifyVuln"`
}

// GetPkg returns __CertifyVulnPkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyVulnPkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetVulnerability returns __CertifyVulnPkgInput.Vulnerability, and is useful for accessing the field via an interface.
func (v *__CertifyVulnPkgInput) GetVulnerability() VulnerabilityInputSpec { return v.Vulnerability }

// GetCertifyVuln returns __CertifyVulnPkgInput.CertifyVuln, and is useful for accessing the field via an interface.
func (v *__CertifyVulnPkgInput) GetCertifyVuln() ScanMetadataInput { return v.CertifyVuln }

// __CertifyVulnPkgsInput is used internally by genqlient
type __CertifyVulnPkgsInput struct {
	Pkgs            []PkgInputSpec           `json:"pkgs"`
	Vulnerabilities []VulnerabilityInputSpec `json:"vulnerabilities"`
	CertifyVulns    []ScanMetadataInput      `json:"certifyVulns"`
}

// GetPkgs returns __CertifyVulnPkgsInput.Pkgs, and is useful for accessing the field via an interface.
func (v *__CertifyVulnPkgsInput) GetPkgs() []PkgInputSpec { return v.Pkgs }

// GetVulnerabilities returns __CertifyVulnPkgsInput.Vulnerabilities, and is useful for accessing the field via an interface.
func (v *__CertifyVulnPkgsInput) GetVulnerabilities() []VulnerabilityInputSpec {
	return v.Vulnerabilities
}

// GetCertifyVulns returns __CertifyVulnPkgsInput.CertifyVulns, and is useful for accessing the field via an interface.
func (v *__CertifyVulnPkgsInput) GetCertifyVulns() []ScanMetadataInput { return v.CertifyVulns }

// __FindSoftwareInput is used internally by genqlient
type __FindSoftwareInput struct {
	SearchText string `json:"searchText"`
}

// GetSearchText returns __FindSoftwareInput.SearchText, and is useful for accessing the field via an interface.
func (v *__FindSoftwareInput) GetSearchText() string { return v.SearchText }

// __HasMetadataArtifactInput is used internally by genqlient
type __HasMetadataArtifactInput struct {
	Artifact    ArtifactInputSpec    `json:"artifact"`
	HasMetadata HasMetadataInputSpec `json:"hasMetadata"`
}

// GetArtifact returns __HasMetadataArtifactInput.Artifact, and is useful for accessing the field via an interface.
func (v *__HasMetadataArtifactInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetHasMetadata returns __HasMetadataArtifactInput.HasMetadata, and is useful for accessing the field via an interface.
func (v *__HasMetadataArtifactInput) GetHasMetadata() HasMetadataInputSpec { return v.HasMetadata }

// __HasMetadataArtifactsInput is used internally by genqlient
type __HasMetadataArtifactsInput struct {
	Artifacts       []ArtifactInputSpec    `json:"artifacts"`
	HasMetadataList []HasMetadataInputSpec `json:"hasMetadataList"`
}

// GetArtifacts returns __HasMetadataArtifactsInput.Artifacts, and is useful for accessing the field via an interface.
func (v *__HasMetadataArtifactsInput) GetArtifacts() []ArtifactInputSpec { return v.Artifacts }

// GetHasMetadataList returns __HasMetadataArtifactsInput.HasMetadataList, and is useful for accessing the field via an interface.
func (v *__HasMetadataArtifactsInput) GetHasMetadataList() []HasMetadataInputSpec {
	return v.HasMetadataList
}

// __HasMetadataPkgInput is used internally by genqlient
type __HasMetadataPkgInput struct {
	Pkg          PkgInputSpec         `json:"pkg"`
	PkgMatchType MatchFlags           `json:"pkgMatchType"`
	HasMetadata  HasMetadataInputSpec `json:"hasMetadata"`
}

// GetPkg returns __HasMetadataPkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__HasMetadataPkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetPkgMatchType returns __HasMetadataPkgInput.PkgMatchType, and is useful for accessing the field via an interface.
func (v *__HasMetadataPkgInput) GetPkgMatchType() MatchFlags { return v.PkgMatchType }

// GetHasMetadata returns __HasMetadataPkgInput.HasMetadata, and is useful for accessing the field via an interface.
func (v *__HasMetadataPkgInput) GetHasMetadata() HasMetadataInputSpec { return v.HasMetadata }

// __HasMetadataPkgsInput is used internally by genqlient
type __HasMetadataPkgsInput struct {
	Pkgs            []PkgInputSpec         `json:"pkgs"`
	PkgMatchType    MatchFlags             `json:"pkgMatchType"`
	HasMetadataList []HasMetadataInputSpec `json:"hasMetadataList"`
}

// GetPkgs returns __HasMetadataPkgsInput.Pkgs, and is useful for accessing the field via an interface.
func (v *__HasMetadataPkgsInput) GetPkgs() []PkgInputSpec { return v.Pkgs }

// GetPkgMatchType returns __HasMetadataPkgsInput.PkgMatchType, and is useful for accessing the field via an interface.
func (v *__HasMetadataPkgsInput) GetPkgMatchType() MatchFlags { return v.PkgMatchType }

// GetHasMetadataList returns __HasMetadataPkgsInput.HasMetadataList, and is useful for accessing the field via an interface.
func (v *__HasMetadataPkgsInput) GetHasMetadataList() []HasMetadataInputSpec {
	return v.HasMetadataList
}

// __HasMetadataSrcInput is used internally by genqlient
type __HasMetadataSrcInput struct {
	Source      SourceInputSpec      `json:"source"`
	HasMetadata HasMetadataInputSpec `json:"hasMetadata"`
}

// GetSource returns __HasMetadataSrcInput.Source, and is useful for accessing the field via an interface.
func (v *__HasMetadataSrcInput) GetSource() SourceInputSpec { return v.Source }

// GetHasMetadata returns __HasMetadataSrcInput.HasMetadata, and is useful for accessing the field via an interface.
func (v *__HasMetadataSrcInput) GetHasMetadata() HasMetadataInputSpec { return v.HasMetadata }

// __HasMetadataSrcsInput is used internally by genqlient
type __HasMetadataSrcsInput struct {
	Sources         []SourceInputSpec      `json:"sources"`
	HasMetadataList []HasMetadataInputSpec `json:"hasMetadataList"`
}

// GetSources returns __HasMetadataSrcsInput.Sources, and is useful for accessing the field via an interface.
func (v *__HasMetadataSrcsInput) GetSources() []SourceInputSpec { return v.Sources }

// GetHasMetadataList returns __HasMetadataSrcsInput.HasMetadataList, and is useful for accessing the field via an interface.
func (v *__HasMetadataSrcsInput) GetHasMetadataList() []HasMetadataInputSpec {
	return v.HasMetadataList
}

// __HasSBOMArtifactInput is used internally by genqlient
type __HasSBOMArtifactInput struct {
	Artifact ArtifactInputSpec `json:"artifact"`
	HasSBOM  HasSBOMInputSpec  `json:"hasSBOM"`
}

// GetArtifact returns __HasSBOMArtifactInput.Artifact, and is useful for accessing the field via an interface.
func (v *__HasSBOMArtifactInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetHasSBOM returns __HasSBOMArtifactInput.HasSBOM, and is useful for accessing the field via an interface.
func (v *__HasSBOMArtifactInput) GetHasSBOM() HasSBOMInputSpec { return v.HasSBOM }

// __HasSBOMArtifactsInput is used internally by genqlient
type __HasSBOMArtifactsInput struct {
	Artifacts []ArtifactInputSpec `json:"artifacts"`
	HasSBOMs  []HasSBOMInputSpec  `json:"hasSBOMs"`
}

// GetArtifacts returns __HasSBOMArtifactsInput.Artifacts, and is useful for accessing the field via an interface.
func (v *__HasSBOMArtifactsInput) GetArtifacts() []ArtifactInputSpec { return v.Artifacts }

// GetHasSBOMs returns __HasSBOMArtifactsInput.HasSBOMs, and is useful for accessing the field via an interface.
func (v *__HasSBOMArtifactsInput) GetHasSBOMs() []HasSBOMInputSpec { return v.HasSBOMs }

// __HasSBOMPkgInput is used internally by genqlient
type __HasSBOMPkgInput struct {
	Pkg     PkgInputSpec     `json:"pkg"`
	HasSBOM HasSBOMInputSpec `json:"hasSBOM"`
}

// GetPkg returns __HasSBOMPkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__HasSBOMPkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetHasSBOM returns __HasSBOMPkgInput.HasSBOM, and is useful for accessing the field via an interface.
func (v *__HasSBOMPkgInput) GetHasSBOM() HasSBOMInputSpec { return v.HasSBOM }

// __HasSBOMPkgsInput is used internally by genqlient
type __HasSBOMPkgsInput struct {
	Pkgs     []PkgInputSpec     `json:"pkgs"`
	HasSBOMs []HasSBOMInputSpec `json:"hasSBOMs"`
}

// GetPkgs returns __HasSBOMPkgsInput.Pkgs, and is useful for accessing the field via an interface.
func (v *__HasSBOMPkgsInput) GetPkgs() []PkgInputSpec { return v.Pkgs }

// GetHasSBOMs returns __HasSBOMPkgsInput.HasSBOMs, and is useful for accessing the field via an interface.
func (v *__HasSBOMPkgsInput) GetHasSBOMs() []HasSBOMInputSpec { return v.HasSBOMs }

// __HasSourceAtInput is used internally by genqlient
type __HasSourceAtInput struct {
	Pkg          PkgInputSpec         `json:"pkg"`
	PkgMatchType MatchFlags           `json:"pkgMatchType"`
	Source       SourceInputSpec      `json:"source"`
	HasSourceAt  HasSourceAtInputSpec `json:"hasSourceAt"`
}

// GetPkg returns __HasSourceAtInput.Pkg, and is useful for accessing the field via an interface.
func (v *__HasSourceAtInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetPkgMatchType returns __HasSourceAtInput.PkgMatchType, and is useful for accessing the field via an interface.
func (v *__HasSourceAtInput) GetPkgMatchType() MatchFlags { return v.PkgMatchType }

// GetSource returns __HasSourceAtInput.Source, and is useful for accessing the field via an interface.
func (v *__HasSourceAtInput) GetSource() SourceInputSpec { return v.Source }

// GetHasSourceAt returns __HasSourceAtInput.HasSourceAt, and is useful for accessing the field via an interface.
func (v *__HasSourceAtInput) GetHasSourceAt() HasSourceAtInputSpec { return v.HasSourceAt }

// __IngestArtifactInput is used internally by genqlient
type __IngestArtifactInput struct {
	Artifact ArtifactInputSpec `json:"artifact"`
}

// GetArtifact returns __IngestArtifactInput.Artifact, and is useful for accessing the field via an interface.
func (v *__IngestArtifactInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// __IngestArtifactsInput is used internally by genqlient
type __IngestArtifactsInput struct {
	Artifacts []ArtifactInputSpec `json:"artifacts"`
}

// GetArtifacts returns __IngestArtifactsInput.Artifacts, and is useful for accessing the field via an interface.
func (v *__IngestArtifactsInput) GetArtifacts() []ArtifactInputSpec { return v.Artifacts }

// __IngestBuilderInput is used internally by genqlient
type __IngestBuilderInput struct {
	Builder BuilderInputSpec `json:"builder"`
}

// GetBuilder returns __IngestBuilderInput.Builder, and is useful for accessing the field via an interface.
func (v *__IngestBuilderInput) GetBuilder() BuilderInputSpec { return v.Builder }

// __IngestBuildersInput is used internally by genqlient
type __IngestBuildersInput struct {
	Builders []BuilderInputSpec `json:"builders"`
}

// GetBuilders returns __IngestBuildersInput.Builders, and is useful for accessing the field via an interface.
func (v *__IngestBuildersInput) GetBuilders() []BuilderInputSpec { return v.Builders }

// __IngestHashEqualInput is used internally by genqlient
type __IngestHashEqualInput struct {
	Artifact      ArtifactInputSpec  `json:"artifact"`
	OtherArtifact ArtifactInputSpec  `json:"otherArtifact"`
	HashEqual     HashEqualInputSpec `json:"hashEqual"`
}

// GetArtifact returns __IngestHashEqualInput.Artifact, and is useful for accessing the field via an interface.
func (v *__IngestHashEqualInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetOtherArtifact returns __IngestHashEqualInput.OtherArtifact, and is useful for accessing the field via an interface.
func (v *__IngestHashEqualInput) GetOtherArtifact() ArtifactInputSpec { return v.OtherArtifact }

// GetHashEqual returns __IngestHashEqualInput.HashEqual, and is useful for accessing the field via an interface.
func (v *__IngestHashEqualInput) GetHashEqual() HashEqualInputSpec { return v.HashEqual }

// __IngestHashEqualsInput is used internally by genqlient
type __IngestHashEqualsInput struct {
	Artifacts      []ArtifactInputSpec  `json:"artifacts"`
	OtherArtifacts []ArtifactInputSpec  `json:"otherArtifacts"`
	HashEquals     []HashEqualInputSpec `json:"hashEquals"`
}

// GetArtifacts returns __IngestHashEqualsInput.Artifacts, and is useful for accessing the field via an interface.
func (v *__IngestHashEqualsInput) GetArtifacts() []ArtifactInputSpec { return v.Artifacts }

// GetOtherArtifacts returns __IngestHashEqualsInput.OtherArtifacts, and is useful for accessing the field via an interface.
func (v *__IngestHashEqualsInput) GetOtherArtifacts() []ArtifactInputSpec { return v.OtherArtifacts }

// GetHashEquals returns __IngestHashEqualsInput.HashEquals, and is useful for accessing the field via an interface.
func (v *__IngestHashEqualsInput) GetHashEquals() []HashEqualInputSpec { return v.HashEquals }

// __IngestLicenseInput is used internally by genqlient
type __IngestLicenseInput struct {
	License LicenseInputSpec `json:"license"`
}

// GetLicense returns __IngestLicenseInput.License, and is useful for accessing the field via an interface.
func (v *__IngestLicenseInput) GetLicense() LicenseInputSpec { return v.License }

// __IngestLicensesInput is used internally by genqlient
type __IngestLicensesInput struct {
	Licenses []LicenseInputSpec `json:"licenses"`
}

// GetLicenses returns __IngestLicensesInput.Licenses, and is useful for accessing the field via an interface.
func (v *__IngestLicensesInput) GetLicenses() []LicenseInputSpec { return v.Licenses }

// __IngestPackageInput is used internally by genqlient
type __IngestPackageInput struct {
	Pkg PkgInputSpec `json:"pkg"`
}

// GetPkg returns __IngestPackageInput.Pkg, and is useful for accessing the field via an interface.
func (v *__IngestPackageInput) GetPkg() PkgInputSpec { return v.Pkg }

// __IngestPackagesInput is used internally by genqlient
type __IngestPackagesInput struct {
	Pkgs []PkgInputSpec `json:"pkgs"`
}

// GetPkgs returns __IngestPackagesInput.Pkgs, and is useful for accessing the field via an interface.
func (v *__IngestPackagesInput) GetPkgs() []PkgInputSpec { return v.Pkgs }

// __IngestPkgEqualInput is used internally by genqlient
type __IngestPkgEqualInput struct {
	Pkg          PkgInputSpec      `json:"pkg"`
	OtherPackage PkgInputSpec      `json:"otherPackage"`
	PkgEqual     PkgEqualInputSpec `json:"pkgEqual"`
}

// GetPkg returns __IngestPkgEqualInput.Pkg, and is useful for accessing the field via an interface.
func (v *__IngestPkgEqualInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetOtherPackage returns __IngestPkgEqualInput.OtherPackage, and is useful for accessing the field via an interface.
func (v *__IngestPkgEqualInput) GetOtherPackage() PkgInputSpec { return v.OtherPackage }

// GetPkgEqual returns __IngestPkgEqualInput.PkgEqual, and is useful for accessing the field via an interface.
func (v *__IngestPkgEqualInput) GetPkgEqual() PkgEqualInputSpec { return v.PkgEqual }

// __IngestPkgEqualsInput is used internally by genqlient
type __IngestPkgEqualsInput struct {
	Pkgs          []PkgInputSpec      `json:"pkgs"`
	OtherPackages []PkgInputSpec      `json:"otherPackages"`
	PkgEquals     []PkgEqualInputSpec `json:"pkgEquals"`
}

// GetPkgs returns __IngestPkgEqualsInput.Pkgs, and is useful for accessing the field via an interface.
func (v *__IngestPkgEqualsInput) GetPkgs() []PkgInputSpec { return v.Pkgs }

// GetOtherPackages returns __IngestPkgEqualsInput.OtherPackages, and is useful for accessing the field via an interface.
func (v *__IngestPkgEqualsInput) GetOtherPackages() []PkgInputSpec { return v.OtherPackages }

// GetPkgEquals returns __IngestPkgEqualsInput.PkgEquals, and is useful for accessing the field via an interface.
func (v *__IngestPkgEqualsInput) GetPkgEquals() []PkgEqualInputSpec { return v.PkgEquals }

// __IngestSourceInput is used internally by genqlient
type __IngestSourceInput struct {
	Source SourceInputSpec `json:"source"`
}

// GetSource returns __IngestSourceInput.Source, and is useful for accessing the field via an interface.
func (v *__IngestSourceInput) GetSource() SourceInputSpec { return v.Source }

// __IngestSourcesInput is used internally by genqlient
type __IngestSourcesInput struct {
	Sources []SourceInputSpec `json:"sources"`
}

// GetSources returns __IngestSourcesInput.Sources, and is useful for accessing the field via an interface.
func (v *__IngestSourcesInput) GetSources() []SourceInputSpec { return v.Sources }

// __IngestVulnEqualInput is used internally by genqlient
type __IngestVulnEqualInput struct {
	Vulnerability      VulnerabilityInputSpec `json:"vulnerability"`
	OtherVulnerability VulnerabilityInputSpec `json:"otherVulnerability"`
	VulnEqual          VulnEqualInputSpec     `json:"vulnEqual"`
}

// GetVulnerability returns __IngestVulnEqualInput.Vulnerability, and is useful for accessing the field via an interface.
func (v *__IngestVulnEqualInput) GetVulnerability() VulnerabilityInputSpec { return v.Vulnerability }

// GetOtherVulnerability returns __IngestVulnEqualInput.OtherVulnerability, and is useful for accessing the field via an interface.
func (v *__IngestVulnEqualInput) GetOtherVulnerability() VulnerabilityInputSpec {
	return v.OtherVulnerability
}

// GetVulnEqual returns __IngestVulnEqualInput.VulnEqual, and is useful for accessing the field via an interface.
func (v *__IngestVulnEqualInput) GetVulnEqual() VulnEqualInputSpec { return v.VulnEqual }

// __IngestVulnEqualsInput is used internally by genqlient
type __IngestVulnEqualsInput struct {
	Vulnerabilities      []VulnerabilityInputSpec `json:"vulnerabilities"`
	OtherVulnerabilities []VulnerabilityInputSpec `json:"otherVulnerabilities"`
	VulnEquals           []VulnEqualInputSpec     `json:"vulnEquals"`
}

// GetVulnerabilities returns __IngestVulnEqualsInput.Vulnerabilities, and is useful for accessing the field via an interface.
func (v *__IngestVulnEqualsInput) GetVulnerabilities() []VulnerabilityInputSpec {
	return v.Vulnerabilities
}

// GetOtherVulnerabilities returns __IngestVulnEqualsInput.OtherVulnerabilities, and is useful for accessing the field via an interface.
func (v *__IngestVulnEqualsInput) GetOtherVulnerabilities() []VulnerabilityInputSpec {
	return v.OtherVulnerabilities
}

// GetVulnEquals returns __IngestVulnEqualsInput.VulnEquals, and is useful for accessing the field via an interface.
func (v *__IngestVulnEqualsInput) GetVulnEquals() []VulnEqualInputSpec { return v.VulnEquals }

// __IngestVulnerabilitiesInput is used internally by genqlient
type __IngestVulnerabilitiesInput struct {
	Vulns []VulnerabilityInputSpec `json:"vulns"`
}

// GetVulns returns __IngestVulnerabilitiesInput.Vulns, and is useful for accessing the field via an interface.
func (v *__IngestVulnerabilitiesInput) GetVulns() []VulnerabilityInputSpec { return v.Vulns }

// __IngestVulnerabilityInput is used internally by genqlient
type __IngestVulnerabilityInput struct {
	Vuln VulnerabilityInputSpec `json:"vuln"`
}

// GetVuln returns __IngestVulnerabilityInput.Vuln, and is useful for accessing the field via an interface.
func (v *__IngestVulnerabilityInput) GetVuln() VulnerabilityInputSpec { return v.Vuln }

// __IsDependenciesInput is used internally by genqlient
type __IsDependenciesInput struct {
	Pkgs            []PkgInputSpec          `json:"pkgs"`
	DepPkgs         []PkgInputSpec          `json:"depPkgs"`
	DepPkgMatchType MatchFlags              `json:"depPkgMatchType"`
	Dependencies    []IsDependencyInputSpec `json:"dependencies"`
}

// GetPkgs returns __IsDependenciesInput.Pkgs, and is useful for accessing the field via an interface.
func (v *__IsDependenciesInput) GetPkgs() []PkgInputSpec { return v.Pkgs }

// GetDepPkgs returns __IsDependenciesInput.DepPkgs, and is useful for accessing the field via an interface.
func (v *__IsDependenciesInput) GetDepPkgs() []PkgInputSpec { return v.DepPkgs }

// GetDepPkgMatchType returns __IsDependenciesInput.DepPkgMatchType, and is useful for accessing the field via an interface.
func (v *__IsDependenciesInput) GetDepPkgMatchType() MatchFlags { return v.DepPkgMatchType }

// GetDependencies returns __IsDependenciesInput.Dependencies, and is useful for accessing the field via an interface.
func (v *__IsDependenciesInput) GetDependencies() []IsDependencyInputSpec { return v.Dependencies }

// __IsDependencyInput is used internally by genqlient
type __IsDependencyInput struct {
	Pkg             PkgInputSpec          `json:"pkg"`
	DepPkg          PkgInputSpec          `json:"depPkg"`
	DepPkgMatchType MatchFlags            `json:"depPkgMatchType"`
	Dependency      IsDependencyInputSpec `json:"dependency"`
}

// GetPkg returns __IsDependencyInput.Pkg, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetDepPkg returns __IsDependencyInput.DepPkg, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetDepPkg() PkgInputSpec { return v.DepPkg }

// GetDepPkgMatchType returns __IsDependencyInput.DepPkgMatchType, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetDepPkgMatchType() MatchFlags { return v.DepPkgMatchType }

// GetDependency returns __IsDependencyInput.Dependency, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetDependency() IsDependencyInputSpec { return v.Dependency }

// __IsOccurrencePkgInput is used internally by genqlient
type __IsOccurrencePkgInput struct {
	Pkg        PkgInputSpec          `json:"pkg"`
	Artifact   ArtifactInputSpec     `json:"artifact"`
	Occurrence IsOccurrenceInputSpec `json:"occurrence"`
}

// GetPkg returns __IsOccurrencePkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__IsOccurrencePkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetArtifact returns __IsOccurrencePkgInput.Artifact, and is useful for accessing the field via an interface.
func (v *__IsOccurrencePkgInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetOccurrence returns __IsOccurrencePkgInput.Occurrence, and is useful for accessing the field via an interface.
func (v *__IsOccurrencePkgInput) GetOccurrence() IsOccurrenceInputSpec { return v.Occurrence }

// __IsOccurrenceSrcInput is used internally by genqlient
type __IsOccurrenceSrcInput struct {
	Source     SourceInputSpec       `json:"source"`
	Artifact   ArtifactInputSpec     `json:"artifact"`
	Occurrence IsOccurrenceInputSpec `json:"occurrence"`
}

// GetSource returns __IsOccurrenceSrcInput.Source, and is useful for accessing the field via an interface.
func (v *__IsOccurrenceSrcInput) GetSource() SourceInputSpec { return v.Source }

// GetArtifact returns __IsOccurrenceSrcInput.Artifact, and is useful for accessing the field via an interface.
func (v *__IsOccurrenceSrcInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetOccurrence returns __IsOccurrenceSrcInput.Occurrence, and is useful for accessing the field via an interface.
func (v *__IsOccurrenceSrcInput) GetOccurrence() IsOccurrenceInputSpec { return v.Occurrence }

// __IsOccurrencesPkgInput is used internally by genqlient
type __IsOccurrencesPkgInput struct {
	Pkgs        []PkgInputSpec          `json:"pkgs"`
	Artifacts   []ArtifactInputSpec     `json:"artifacts"`
	Occurrences []IsOccurrenceInputSpec `json:"occurrences"`
}

// GetPkgs returns __IsOccurrencesPkgInput.Pkgs, and is useful for accessing the field via an interface.
func (v *__IsOccurrencesPkgInput) GetPkgs() []PkgInputSpec { return v.Pkgs }

// GetArtifacts returns __IsOccurrencesPkgInput.Artifacts, and is useful for accessing the field via an interface.
func (v *__IsOccurrencesPkgInput) GetArtifacts() []ArtifactInputSpec { return v.Artifacts }

// GetOccurrences returns __IsOccurrencesPkgInput.Occurrences, and is useful for accessing the field via an interface.
func (v *__IsOccurrencesPkgInput) GetOccurrences() []IsOccurrenceInputSpec { return v.Occurrences }

// __IsOccurrencesSrcInput is used internally by genqlient
type __IsOccurrencesSrcInput struct {
	Sources     []SourceInputSpec       `json:"sources"`
	Artifacts   []ArtifactInputSpec     `json:"artifacts"`
	Occurrences []IsOccurrenceInputSpec `json:"occurrences"`
}

// GetSources returns __IsOccurrencesSrcInput.Sources, and is useful for accessing the field via an interface.
func (v *__IsOccurrencesSrcInput) GetSources() []SourceInputSpec { return v.Sources }

// GetArtifacts returns __IsOccurrencesSrcInput.Artifacts, and is useful for accessing the field via an interface.
func (v *__IsOccurrencesSrcInput) GetArtifacts() []ArtifactInputSpec { return v.Artifacts }

// GetOccurrences returns __IsOccurrencesSrcInput.Occurrences, and is useful for accessing the field via an interface.
func (v *__IsOccurrencesSrcInput) GetOccurrences() []IsOccurrenceInputSpec { return v.Occurrences }

// __LicensesInput is used internally by genqlient
type __LicensesInput struct {
	Filter LicenseSpec `json:"filter"`
}

// GetFilter returns __LicensesInput.Filter, and is useful for accessing the field via an interface.
func (v *__LicensesInput) GetFilter() LicenseSpec { return v.Filter }

// __NeighborsInput is used internally by genqlient
type __NeighborsInput struct {
	Node      string `json:"node"`
	UsingOnly []Edge `json:"usingOnly"`
}

// GetNode returns __NeighborsInput.Node, and is useful for accessing the field via an interface.
func (v *__NeighborsInput) GetNode() string { return v.Node }

// GetUsingOnly returns __NeighborsInput.UsingOnly, and is useful for accessing the field via an interface.
func (v *__NeighborsInput) GetUsingOnly() []Edge { return v.UsingOnly }

// __NodeInput is used internally by genqlient
type __NodeInput struct {
	Node string `json:"node"`
}

// GetNode returns __NodeInput.Node, and is useful for accessing the field via an interface.
func (v *__NodeInput) GetNode() string { return v.Node }

// __NodesInput is used internally by genqlient
type __NodesInput struct {
	Nodes []string `json:"nodes"`
}

// GetNodes returns __NodesInput.Nodes, and is useful for accessing the field via an interface.
func (v *__NodesInput) GetNodes() []string { return v.Nodes }

// __PackageNamesInput is used internally by genqlient
type __PackageNamesInput struct {
	Filter PkgSpec `json:"filter"`
}

// GetFilter returns __PackageNamesInput.Filter, and is useful for accessing the field via an interface.
func (v *__PackageNamesInput) GetFilter() PkgSpec { return v.Filter }

// __PackageNamespacesInput is used internally by genqlient
type __PackageNamespacesInput struct {
	Filter PkgSpec `json:"filter"`
}

// GetFilter returns __PackageNamespacesInput.Filter, and is useful for accessing the field via an interface.
func (v *__PackageNamespacesInput) GetFilter() PkgSpec { return v.Filter }

// __PackageTypesInput is used internally by genqlient
type __PackageTypesInput struct {
	Filter PkgSpec `json:"filter"`
}

// GetFilter returns __PackageTypesInput.Filter, and is useful for accessing the field via an interface.
func (v *__PackageTypesInput) GetFilter() PkgSpec { return v.Filter }

// __PackageVersionsInput is used internally by genqlient
type __PackageVersionsInput struct {
	Filter PkgSpec `json:"filter"`
}

// GetFilter returns __PackageVersionsInput.Filter, and is useful for accessing the field via an interface.
func (v *__PackageVersionsInput) GetFilter() PkgSpec { return v.Filter }

// __PackagesInput is used internally by genqlient
type __PackagesInput struct {
	Filter PkgSpec `json:"filter"`
}

// GetFilter returns __PackagesInput.Filter, and is useful for accessing the field via an interface.
func (v *__PackagesInput) GetFilter() PkgSpec { return v.Filter }

// __PathInput is used internally by genqlient
type __PathInput struct {
	Subject       string `json:"subject"`
	Target        string `json:"target"`
	MaxPathLength int    `json:"maxPathLength"`
	UsingOnly     []Edge `json:"usingOnly"`
}

// GetSubject returns __PathInput.Subject, and is useful for accessing the field via an interface.
func (v *__PathInput) GetSubject() string { return v.Subject }

// GetTarget returns __PathInput.Target, and is useful for accessing the field via an interface.
func (v *__PathInput) GetTarget() string { return v.Target }

// GetMaxPathLength returns __PathInput.MaxPathLength, and is useful for accessing the field via an interface.
func (v *__PathInput) GetMaxPathLength() int { return v.MaxPathLength }

// GetUsingOnly returns __PathInput.UsingOnly, and is useful for accessing the field via an interface.
func (v *__PathInput) GetUsingOnly() []Edge { return v.UsingOnly }

// __PointOfContactArtifactInput is used internally by genqlient
type __PointOfContactArtifactInput struct {
	Artifact       ArtifactInputSpec       `json:"artifact"`
	PointOfContact PointOfContactInputSpec `json:"pointOfContact"`
}

// GetArtifact returns __PointOfContactArtifactInput.Artifact, and is useful for accessing the field via an interface.
func (v *__PointOfContactArtifactInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetPointOfContact returns __PointOfContactArtifactInput.PointOfContact, and is useful for accessing the field via an interface.
func (v *__PointOfContactArtifactInput) GetPointOfContact() PointOfContactInputSpec {
	return v.PointOfContact
}

// __PointOfContactPkgInput is used internally by genqlient
type __PointOfContactPkgInput struct {
	Pkg            PkgInputSpec            `json:"pkg"`
	PkgMatchType   MatchFlags              `json:"pkgMatchType"`
	PointOfContact PointOfContactInputSpec `json:"pointOfContact"`
}

// GetPkg returns __PointOfContactPkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__PointOfContactPkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetPkgMatchType returns __PointOfContactPkgInput.PkgMatchType, and is useful for accessing the field via an interface.
func (v *__PointOfContactPkgInput) GetPkgMatchType() MatchFlags { return v.PkgMatchType }

// GetPointOfContact returns __PointOfContactPkgInput.PointOfContact, and is useful for accessing the field via an interface.
func (v *__PointOfContactPkgInput) GetPointOfContact() PointOfContactInputSpec {
	return v.PointOfContact
}

// __PointOfContactSrcInput is used internally by genqlient
type __PointOfContactSrcInput struct {
	Source         SourceInputSpec         `json:"source"`
	PointOfContact PointOfContactInputSpec `json:"pointOfContact"`
}

// GetSource returns __PointOfContactSrcInput.Source, and is useful for accessing the field via an interface.
func (v *__PointOfContactSrcInput) GetSource() SourceInputSpec { return v.Source }

// GetPointOfContact returns __PointOfContactSrcInput.PointOfContact, and is useful for accessing the field via an interface.
func (v *__PointOfContactSrcInput) GetPointOfContact() PointOfContactInputSpec {
	return v.PointOfContact
}

// __SLSAForArtifactInput is used internally by genqlient
type __SLSAForArtifactInput struct {
	Artifact  ArtifactInputSpec   `json:"artifact"`
	Materials []ArtifactInputSpec `json:"materials"`
	Builder   BuilderInputSpec    `json:"builder"`
	Slsa      SLSAInputSpec       `json:"slsa"`
}

// GetArtifact returns __SLSAForArtifactInput.Artifact, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetMaterials returns __SLSAForArtifactInput.Materials, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactInput) GetMaterials() []ArtifactInputSpec { return v.Materials }

// GetBuilder returns __SLSAForArtifactInput.Builder, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactInput) GetBuilder() BuilderInputSpec { return v.Builder }

// GetSlsa returns __SLSAForArtifactInput.Slsa, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactInput) GetSlsa() SLSAInputSpec { return v.Slsa }

// __SLSAForArtifactsInput is used internally by genqlient
type __SLSAForArtifactsInput struct {
	Artifacts     []ArtifactInputSpec   `json:"artifacts"`
	MaterialsList [][]ArtifactInputSpec `json:"materialsList"`
	Builders      []BuilderInputSpec    `json:"builders"`
	SlsaList      []SLSAInputSpec       `json:"slsaList"`
}

// GetArtifacts returns __SLSAForArtifactsInput.Artifacts, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactsInput) GetArtifacts() []ArtifactInputSpec { return v.Artifacts }

// GetMaterialsList returns __SLSAForArtifactsInput.MaterialsList, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactsInput) GetMaterialsList() [][]ArtifactInputSpec { return v.MaterialsList }

// GetBuilders returns __SLSAForArtifactsInput.Builders, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactsInput) GetBuilders() []BuilderInputSpec { return v.Builders }

// GetSlsaList returns __SLSAForArtifactsInput.SlsaList, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactsInput) GetSlsaList() []SLSAInputSpec { return v.SlsaList }

// __SourcesInput is used internally by genqlient
type __SourcesInput struct {
	Filter SourceSpec `json:"filter"`
}

// GetFilter returns __SourcesInput.Filter, and is useful for accessing the field via an interface.
func (v *__SourcesInput) GetFilter() SourceSpec { return v.Filter }

// __VulnHasMetadataInput is used internally by genqlient
type __VulnHasMetadataInput struct {
	Vulnerability VulnerabilityInputSpec         `json:"vulnerability"`
	VulnMetadata  VulnerabilityMetadataInputSpec `json:"vulnMetadata"`
}

// GetVulnerability returns __VulnHasMetadataInput.Vulnerability, and is useful for accessing the field via an interface.
func (v *__VulnHasMetadataInput) GetVulnerability() VulnerabilityInputSpec { return v.Vulnerability }

// GetVulnMetadata returns __VulnHasMetadataInput.VulnMetadata, and is useful for accessing the field via an interface.
func (v *__VulnHasMetadataInput) GetVulnMetadata() VulnerabilityMetadataInputSpec {
	return v.VulnMetadata
}

// __VulnerabilitiesInput is used internally by genqlient
type __VulnerabilitiesInput struct {
	Filter VulnerabilitySpec `json:"filter"`
}

// GetFilter returns __VulnerabilitiesInput.Filter, and is useful for accessing the field via an interface.
func (v *__VulnerabilitiesInput) GetFilter() VulnerabilitySpec { return v.Filter }

// The query or mutation executed by Artifacts.
const Artifacts_Operation = `
query Artifacts ($filter: ArtifactSpec!) {
	artifacts(artifactSpec: $filter) {
		... AllArtifactTree
	}
}
fragment AllArtifactTree on Artifact {
	id
	algorithm
	digest
}
`

func Artifacts(
	ctx context.Context,
	client graphql.Client,
	filter ArtifactSpec,
) (*ArtifactsResponse, error) {
	req := &graphql.Request{
		OpName: "Artifacts",
		Query:  Artifacts_Operation,
		Variables: &__ArtifactsInput{
			Filter: filter,
		},
	}
	var err error

	var data ArtifactsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by BulkVulnHasMetadata.
const BulkVulnHasMetadata_Operation = `
mutation BulkVulnHasMetadata ($vulnerabilities: [VulnerabilityInputSpec!]!, $vulnerabilityMetadataList: [VulnerabilityMetadataInputSpec!]!) {
	ingestBulkVulnerabilityMetadata(vulnerabilities: $vulnerabilities, vulnerabilityMetadataList: $vulnerabilityMetadataList)
}
`

func BulkVulnHasMetadata(
	ctx context.Context,
	client graphql.Client,
	vulnerabilities []VulnerabilityInputSpec,
	vulnerabilityMetadataList []VulnerabilityMetadataInputSpec,
) (*BulkVulnHasMetadataResponse, error) {
	req := &graphql.Request{
		OpName: "BulkVulnHasMetadata",
		Query:  BulkVulnHasMetadata_Operation,
		Variables: &__BulkVulnHasMetadataInput{
			Vulnerabilities:           vulnerabilities,
			VulnerabilityMetadataList: vulnerabilityMetadataList,
		},
	}
	var err error

	var data BulkVulnHasMetadataResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyBadArtifact.
const CertifyBadArtifact_Operation = `
mutation CertifyBadArtifact ($artifact: ArtifactInputSpec!, $certifyBad: CertifyBadInputSpec!) {
	ingestCertifyBad(subject: {artifact:$artifact}, pkgMatchType: {pkg:ALL_VERSIONS}, certifyBad: $certifyBad)
}
`

func CertifyBadArtifact(
	ctx context.Context,
	client graphql.Client,
	artifact ArtifactInputSpec,
	certifyBad CertifyBadInputSpec,
) (*CertifyBadArtifactResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyBadArtifact",
		Query:  CertifyBadArtifact_Operation,
		Variables: &__CertifyBadArtifactInput{
			Artifact:   artifact,
			CertifyBad: certifyBad,
		},
	}
	var err error

	var data CertifyBadArtifactResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyBadArtifacts.
const CertifyBadArtifacts_Operation = `
mutation CertifyBadArtifacts ($artifacts: [ArtifactInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {
	ingestCertifyBads(subjects: {artifacts:$artifacts}, pkgMatchType: {pkg:ALL_VERSIONS}, certifyBads: $certifyBads)
}
`

func CertifyBadArtifacts(
	ctx context.Context,
	client graphql.Client,
	artifacts []ArtifactInputSpec,
	certifyBads []CertifyBadInputSpec,
) (*CertifyBadArtifactsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyBadArtifacts",
		Query:  CertifyBadArtifacts_Operation,
		Variables: &__CertifyBadArtifactsInput{
			Artifacts:   artifacts,
			CertifyBads: certifyBads,
		},
	}
	var err error

	var data CertifyBadArtifactsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyBadPkg.
const CertifyBadPkg_Operation = `
mutation CertifyBadPkg ($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyBad: CertifyBadInputSpec!) {
	ingestCertifyBad(subject: {package:$pkg}, pkgMatchType: $pkgMatchType, certifyBad: $certifyBad)
}
`

func CertifyBadPkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	pkgMatchType MatchFlags,
	certifyBad CertifyBadInputSpec,
) (*CertifyBadPkgResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyBadPkg",
		Query:  CertifyBadPkg_Operation,
		Variables: &__CertifyBadPkgInput{
			Pkg:          pkg,
			PkgMatchType: pkgMatchType,
			CertifyBad:   certifyBad,
		},
	}
	var err error

	var data CertifyBadPkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyBadPkgs.
const CertifyBadPkgs_Operation = `
mutation CertifyBadPkgs ($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyBads: [CertifyBadInputSpec!]!) {
	ingestCertifyBads(subjects: {packages:$pkgs}, pkgMatchType: $pkgMatchType, certifyBads: $certifyBads)
}
`

func CertifyBadPkgs(
	ctx context.Context,
	client graphql.Client,
	pkgs []PkgInputSpec,
	pkgMatchType MatchFlags,
	certifyBads []CertifyBadInputSpec,
) (*CertifyBadPkgsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyBadPkgs",
		Query:  CertifyBadPkgs_Operation,
		Variables: &__CertifyBadPkgsInput{
			Pkgs:         pkgs,
			PkgMatchType: pkgMatchType,
			CertifyBads:  certifyBads,
		},
	}
	var err error

	var data CertifyBadPkgsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyBadSrc.
const CertifyBadSrc_Operation = `
mutation CertifyBadSrc ($source: SourceInputSpec!, $certifyBad: CertifyBadInputSpec!) {
	ingestCertifyBad(subject: {source:$source}, pkgMatchType: {pkg:ALL_VERSIONS}, certifyBad: $certifyBad)
}
`

func CertifyBadSrc(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	certifyBad CertifyBadInputSpec,
) (*CertifyBadSrcResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyBadSrc",
		Query:  CertifyBadSrc_Operation,
		Variables: &__CertifyBadSrcInput{
			Source:     source,
			CertifyBad: certifyBad,
		},
	}
	var err error

	var data CertifyBadSrcResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyBadSrcs.
const CertifyBadSrcs_Operation = `
mutation CertifyBadSrcs ($sources: [SourceInputSpec!]!, $certifyBads: [CertifyBadInputSpec!]!) {
	ingestCertifyBads(subjects: {sources:$sources}, pkgMatchType: {pkg:ALL_VERSIONS}, certifyBads: $certifyBads)
}
`

func CertifyBadSrcs(
	ctx context.Context,
	client graphql.Client,
	sources []SourceInputSpec,
	certifyBads []CertifyBadInputSpec,
) (*CertifyBadSrcsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyBadSrcs",
		Query:  CertifyBadSrcs_Operation,
		Variables: &__CertifyBadSrcsInput{
			Sources:     sources,
			CertifyBads: certifyBads,
		},
	}
	var err error

	var data CertifyBadSrcsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyBads.
const CertifyBads_Operation = `
query CertifyBads ($filter: CertifyBadSpec!) {
	CertifyBad(certifyBadSpec: $filter) {
		... AllCertifyBad
	}
}
fragment AllCertifyBad on CertifyBad {
	id
	justification
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	origin
	collector
}
fragment AllPkgTree on Package {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			versions {
				id
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment AllSourceTree on Source {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			tag
			commit
		}
	}
}
fragment AllArtifactTree on Artifact {
	id
	algorithm
	digest
}
`

func CertifyBads(
	ctx context.Context,
	client graphql.Client,
	filter CertifyBadSpec,
) (*CertifyBadsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyBads",
		Query:  CertifyBads_Operation,
		Variables: &__CertifyBadsInput{
			Filter: filter,
		},
	}
	var err error

	var data CertifyBadsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyGoodArtifact.
const CertifyGoodArtifact_Operation = `
mutation CertifyGoodArtifact ($artifact: ArtifactInputSpec!, $certifyGood: CertifyGoodInputSpec!) {
	ingestCertifyGood(subject: {artifact:$artifact}, pkgMatchType: {pkg:ALL_VERSIONS}, certifyGood: $certifyGood)
}
`

func CertifyGoodArtifact(
	ctx context.Context,
	client graphql.Client,
	artifact ArtifactInputSpec,
	certifyGood CertifyGoodInputSpec,
) (*CertifyGoodArtifactResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyGoodArtifact",
		Query:  CertifyGoodArtifact_Operation,
		Variables: &__CertifyGoodArtifactInput{
			Artifact:    artifact,
			CertifyGood: certifyGood,
		},
	}
	var err error

	var data CertifyGoodArtifactResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyGoodArtifacts.
const CertifyGoodArtifacts_Operation = `
mutation CertifyGoodArtifacts ($artifacts: [ArtifactInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {
	ingestCertifyGoods(subjects: {artifacts:$artifacts}, pkgMatchType: {pkg:ALL_VERSIONS}, certifyGoods: $certifyGoods)
}
`

func CertifyGoodArtifacts(
	ctx context.Context,
	client graphql.Client,
	artifacts []ArtifactInputSpec,
	certifyGoods []CertifyGoodInputSpec,
) (*CertifyGoodArtifactsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyGoodArtifacts",
		Query:  CertifyGoodArtifacts_Operation,
		Variables: &__CertifyGoodArtifactsInput{
			Artifacts:    artifacts,
			CertifyGoods: certifyGoods,
		},
	}
	var err error

	var data CertifyGoodArtifactsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyGoodPkg.
const CertifyGoodPkg_Operation = `
mutation CertifyGoodPkg ($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $certifyGood: CertifyGoodInputSpec!) {
	ingestCertifyGood(subject: {package:$pkg}, pkgMatchType: $pkgMatchType, certifyGood: $certifyGood)
}
`

func CertifyGoodPkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	pkgMatchType MatchFlags,
	certifyGood CertifyGoodInputSpec,
) (*CertifyGoodPkgResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyGoodPkg",
		Query:  CertifyGoodPkg_Operation,
		Variables: &__CertifyGoodPkgInput{
			Pkg:          pkg,
			PkgMatchType: pkgMatchType,
			CertifyGood:  certifyGood,
		},
	}
	var err error

	var data CertifyGoodPkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyGoodPkgs.
const CertifyGoodPkgs_Operation = `
mutation CertifyGoodPkgs ($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $certifyGoods: [CertifyGoodInputSpec!]!) {
	ingestCertifyGoods(subjects: {packages:$pkgs}, pkgMatchType: $pkgMatchType, certifyGoods: $certifyGoods)
}
`

func CertifyGoodPkgs(
	ctx context.Context,
	client graphql.Client,
	pkgs []PkgInputSpec,
	pkgMatchType MatchFlags,
	certifyGoods []CertifyGoodInputSpec,
) (*CertifyGoodPkgsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyGoodPkgs",
		Query:  CertifyGoodPkgs_Operation,
		Variables: &__CertifyGoodPkgsInput{
			Pkgs:         pkgs,
			PkgMatchType: pkgMatchType,
			CertifyGoods: certifyGoods,
		},
	}
	var err error

	var data CertifyGoodPkgsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyGoodSrc.
const CertifyGoodSrc_Operation = `
mutation CertifyGoodSrc ($source: SourceInputSpec!, $certifyGood: CertifyGoodInputSpec!) {
	ingestCertifyGood(subject: {source:$source}, pkgMatchType: {pkg:ALL_VERSIONS}, certifyGood: $certifyGood)
}
`

func CertifyGoodSrc(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	certifyGood CertifyGoodInputSpec,
) (*CertifyGoodSrcResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyGoodSrc",
		Query:  CertifyGoodSrc_Operation,
		Variables: &__CertifyGoodSrcInput{
			Source:      source,
			CertifyGood: certifyGood,
		},
	}
	var err error

	var data CertifyGoodSrcResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyGoodSrcs.
const CertifyGoodSrcs_Operation = `
mutation CertifyGoodSrcs ($sources: [SourceInputSpec!]!, $certifyGoods: [CertifyGoodInputSpec!]!) {
	ingestCertifyGoods(subjects: {sources:$sources}, pkgMatchType: {pkg:ALL_VERSIONS}, certifyGoods: $certifyGoods)
}
`

func CertifyGoodSrcs(
	ctx context.Context,
	client graphql.Client,
	sources []SourceInputSpec,
	certifyGoods []CertifyGoodInputSpec,
) (*CertifyGoodSrcsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyGoodSrcs",
		Query:  CertifyGoodSrcs_Operation,
		Variables: &__CertifyGoodSrcsInput{
			Sources:      sources,
			CertifyGoods: certifyGoods,
		},
	}
	var err error

	var data CertifyGoodSrcsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyLegalPkg.
const CertifyLegalPkg_Operation = `
mutation CertifyLegalPkg ($pkg: PkgInputSpec!, $declaredLicenses: [LicenseInputSpec!]!, $discoveredLicenses: [LicenseInputSpec!]!, $legal: CertifyLegalInputSpec!) {
	ingestCertifyLegal(subject: {package:$pkg}, declaredLicenses: $declaredLicenses, discoveredLicenses: $discoveredLicenses, certifyLegal: $legal)
}
`

func CertifyLegalPkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	declaredLicenses []LicenseInputSpec,
	discoveredLicenses []LicenseInputSpec,
	legal CertifyLegalInputSpec,
) (*CertifyLegalPkgResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyLegalPkg",
		Query:  CertifyLegalPkg_Operation,
		Variables: &__CertifyLegalPkgInput{
			Pkg:                pkg,
			DeclaredLicenses:   declaredLicenses,
			DiscoveredLicenses: discoveredLicenses,
			Legal:              legal,
		},
	}
	var err error

	var data CertifyLegalPkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyLegalPkgs.
const CertifyLegalPkgs_Operation = `
mutation CertifyLegalPkgs ($pkgs: [PkgInputSpec!]!, $declaredLicensesList: [[LicenseInputSpec!]!]!, $discoveredLicensesList: [[LicenseInputSpec!]!]!, $legals: [CertifyLegalInputSpec!]!) {
	ingestCertifyLegals(subjects: {packages:$pkgs}, declaredLicensesList: $declaredLicensesList, discoveredLicensesList: $discoveredLicensesList, certifyLegals: $legals)
}
`

func CertifyLegalPkgs(
	ctx context.Context,
	client graphql.Client,
	pkgs []PkgInputSpec,
	declaredLicensesList [][]LicenseInputSpec,
	discoveredLicensesList [][]LicenseInputSpec,
	legals []CertifyLegalInputSpec,
) (*CertifyLegalPkgsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyLegalPkgs",
		Query:  CertifyLegalPkgs_Operation,
		Variables: &__CertifyLegalPkgsInput{
			Pkgs:                   pkgs,
			DeclaredLicensesList:   declaredLicensesList,
			DiscoveredLicensesList: discoveredLicensesList,
			Legals:                 legals,
		},
	}
	var err error

	var data CertifyLegalPkgsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyLegalSrc.
const CertifyLegalSrc_Operation = `
mutation CertifyLegalSrc ($src: SourceInputSpec!, $declaredLicenses: [LicenseInputSpec!]!, $discoveredLicenses: [LicenseInputSpec!]!, $legal: CertifyLegalInputSpec!) {
	ingestCertifyLegal(subject: {source:$src}, declaredLicenses: $declaredLicenses, discoveredLicenses: $discoveredLicenses, certifyLegal: $legal)
}
`

func CertifyLegalSrc(
	ctx context.Context,
	client graphql.Client,
	src SourceInputSpec,
	declaredLicenses []LicenseInputSpec,
	discoveredLicenses []LicenseInputSpec,
	legal CertifyLegalInputSpec,
) (*CertifyLegalSrcResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyLegalSrc",
		Query:  CertifyLegalSrc_Operation,
		Variables: &__CertifyLegalSrcInput{
			Src:                src,
			DeclaredLicenses:   declaredLicenses,
			DiscoveredLicenses: discoveredLicenses,
			Legal:              legal,
		},
	}
	var err error

	var data CertifyLegalSrcResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyLegalSrcs.
const CertifyLegalSrcs_Operation = `
mutation CertifyLegalSrcs ($srcs: [SourceInputSpec!]!, $declaredLicensesList: [[LicenseInputSpec!]!]!, $discoveredLicensesList: [[LicenseInputSpec!]!]!, $legals: [CertifyLegalInputSpec!]!) {
	ingestCertifyLegals(subjects: {sources:$srcs}, declaredLicensesList: $declaredLicensesList, discoveredLicensesList: $discoveredLicensesList, certifyLegals: $legals)
}
`

func CertifyLegalSrcs(
	ctx context.Context,
	client graphql.Client,
	srcs []SourceInputSpec,
	declaredLicensesList [][]LicenseInputSpec,
	discoveredLicensesList [][]LicenseInputSpec,
	legals []CertifyLegalInputSpec,
) (*CertifyLegalSrcsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyLegalSrcs",
		Query:  CertifyLegalSrcs_Operation,
		Variables: &__CertifyLegalSrcsInput{
			Srcs:                   srcs,
			DeclaredLicensesList:   declaredLicensesList,
			DiscoveredLicensesList: discoveredLicensesList,
			Legals:                 legals,
		},
	}
	var err error

	var data CertifyLegalSrcsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyLegals.
const CertifyLegals_Operation = `
query CertifyLegals ($filter: CertifyLegalSpec!) {
	CertifyLegal(certifyLegalSpec: $filter) {
		... AllCertifyLegalTree
	}
}
fragment AllCertifyLegalTree on CertifyLegal {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
	}
	declaredLicense
	declaredLicenses {
		... AllLicenseTree
	}
	discoveredLicense
	discoveredLicenses {
		... AllLicenseTree
	}
	attribution
	justification
	timeScanned
	origin
	collector
}
fragment AllPkgTree on Package {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			versions {
				id
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment AllSourceTree on Source {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			tag
			commit
		}
	}
}
fragment AllLicenseTree on License {
	id
	name
	inline
	listVersion
}
`

func CertifyLegals(
	ctx context.Context,
	client graphql.Client,
	filter CertifyLegalSpec,
) (*CertifyLegalsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyLegals",
		Query:  CertifyLegals_Operation,
		Variables: &__CertifyLegalsInput{
			Filter: filter,
		},
	}
	var err error

	var data CertifyLegalsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyScorecard.
const CertifyScorecard_Operation = `
mutation CertifyScorecard ($source: SourceInputSpec!, $scorecard: ScorecardInputSpec!) {
	ingestScorecard(source: $source, scorecard: $scorecard)
}
`

func CertifyScorecard(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	scorecard ScorecardInputSpec,
) (*CertifyScorecardResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyScorecard",
		Query:  CertifyScorecard_Operation,
		Variables: &__CertifyScorecardInput{
			Source:    source,
			Scorecard: scorecard,
		},
	}
	var err error

	var data CertifyScorecardResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyScorecards.
const CertifyScorecards_Operation = `
mutation CertifyScorecards ($sources: [SourceInputSpec!]!, $scorecards: [ScorecardInputSpec!]!) {
	ingestScorecards(sources: $sources, scorecards: $scorecards)
}
`

func CertifyScorecards(
	ctx context.Context,
	client graphql.Client,
	sources []SourceInputSpec,
	scorecards []ScorecardInputSpec,
) (*CertifyScorecardsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyScorecards",
		Query:  CertifyScorecards_Operation,
		Variables: &__CertifyScorecardsInput{
			Sources:    sources,
			Scorecards: scorecards,
		},
	}
	var err error

	var data CertifyScorecardsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyVexArtifact.
const CertifyVexArtifact_Operation = `
mutation CertifyVexArtifact ($artifact: ArtifactInputSpec!, $vulnerability: VulnerabilityInputSpec!, $vexStatement: VexStatementInputSpec!) {
	ingestVEXStatement(subject: {artifact:$artifact}, vulnerability: $vulnerability, vexStatement: $vexStatement)
}
`

func CertifyVexArtifact(
	ctx context.Context,
	client graphql.Client,
	artifact ArtifactInputSpec,
	vulnerability VulnerabilityInputSpec,
	vexStatement VexStatementInputSpec,
) (*CertifyVexArtifactResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyVexArtifact",
		Query:  CertifyVexArtifact_Operation,
		Variables: &__CertifyVexArtifactInput{
			Artifact:      artifact,
			Vulnerability: vulnerability,
			VexStatement:  vexStatement,
		},
	}
	var err error

	var data CertifyVexArtifactResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyVexArtifacts.
const CertifyVexArtifacts_Operation = `
mutation CertifyVexArtifacts ($artifacts: [ArtifactInputSpec!]!, $vulnerabilities: [VulnerabilityInputSpec!]!, $vexStatements: [VexStatementInputSpec!]!) {
	ingestVEXStatements(subjects: {artifacts:$artifacts}, vulnerabilities: $vulnerabilities, vexStatements: $vexStatements)
}
`

func CertifyVexArtifacts(
	ctx context.Context,
	client graphql.Client,
	artifacts []ArtifactInputSpec,
	vulnerabilities []VulnerabilityInputSpec,
	vexStatements []VexStatementInputSpec,
) (*CertifyVexArtifactsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyVexArtifacts",
		Query:  CertifyVexArtifacts_Operation,
		Variables: &__CertifyVexArtifactsInput{
			Artifacts:       artifacts,
			Vulnerabilities: vulnerabilities,
			VexStatements:   vexStatements,
		},
	}
	var err error

	var data CertifyVexArtifactsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyVexPkg.
const CertifyVexPkg_Operation = `
mutation CertifyVexPkg ($pkg: PkgInputSpec!, $vulnerability: VulnerabilityInputSpec!, $vexStatement: VexStatementInputSpec!) {
	ingestVEXStatement(subject: {package:$pkg}, vulnerability: $vulnerability, vexStatement: $vexStatement)
}
`

func CertifyVexPkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	vulnerability VulnerabilityInputSpec,
	vexStatement VexStatementInputSpec,
) (*CertifyVexPkgResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyVexPkg",
		Query:  CertifyVexPkg_Operation,
		Variables: &__CertifyVexPkgInput{
			Pkg:           pkg,
			Vulnerability: vulnerability,
			VexStatement:  vexStatement,
		},
	}
	var err error

	var data CertifyVexPkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyVexPkgs.
const CertifyVexPkgs_Operation = `
mutation CertifyVexPkgs ($pkgs: [PkgInputSpec!]!, $vulnerabilities: [VulnerabilityInputSpec!]!, $vexStatements: [VexStatementInputSpec!]!) {
	ingestVEXStatements(subjects: {packages:$pkgs}, vulnerabilities: $vulnerabilities, vexStatements: $vexStatements)
}
`

func CertifyVexPkgs(
	ctx context.Context,
	client graphql.Client,
	pkgs []PkgInputSpec,
	vulnerabilities []VulnerabilityInputSpec,
	vexStatements []VexStatementInputSpec,
) (*CertifyVexPkgsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyVexPkgs",
		Query:  CertifyVexPkgs_Operation,
		Variables: &__CertifyVexPkgsInput{
			Pkgs:            pkgs,
			Vulnerabilities: vulnerabilities,
			VexStatements:   vexStatements,
		},
	}
	var err error

	var data CertifyVexPkgsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyVulnPkg.
const CertifyVulnPkg_Operation = `
mutation CertifyVulnPkg ($pkg: PkgInputSpec!, $vulnerability: VulnerabilityInputSpec!, $certifyVuln: ScanMetadataInput!) {
	ingestCertifyVuln(pkg: $pkg, vulnerability: $vulnerability, certifyVuln: $certifyVuln)
}
`

func CertifyVulnPkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	vulnerability VulnerabilityInputSpec,
	certifyVuln ScanMetadataInput,
) (*CertifyVulnPkgResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyVulnPkg",
		Query:  CertifyVulnPkg_Operation,
		Variables: &__CertifyVulnPkgInput{
			Pkg:           pkg,
			Vulnerability: vulnerability,
			CertifyVuln:   certifyVuln,
		},
	}
	var err error

	var data CertifyVulnPkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by CertifyVulnPkgs.
const CertifyVulnPkgs_Operation = `
mutation CertifyVulnPkgs ($pkgs: [PkgInputSpec!]!, $vulnerabilities: [VulnerabilityInputSpec!]!, $certifyVulns: [ScanMetadataInput!]!) {
	ingestCertifyVulns(pkgs: $pkgs, vulnerabilities: $vulnerabilities, certifyVulns: $certifyVulns)
}
`

func CertifyVulnPkgs(
	ctx context.Context,
	client graphql.Client,
	pkgs []PkgInputSpec,
	vulnerabilities []VulnerabilityInputSpec,
	certifyVulns []ScanMetadataInput,
) (*CertifyVulnPkgsResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyVulnPkgs",
		Query:  CertifyVulnPkgs_Operation,
		Variables: &__CertifyVulnPkgsInput{
			Pkgs:            pkgs,
			Vulnerabilities: vulnerabilities,
			CertifyVulns:    certifyVulns,
		},
	}
	var err error

	var data CertifyVulnPkgsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by FindSoftware.
const FindSoftware_Operation = `
query FindSoftware ($searchText: String!) {
	findSoftware(searchText: $searchText) {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
}
fragment AllPkgTree on Package {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			versions {
				id
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment AllSourceTree on Source {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			tag
			commit
		}
	}
}
fragment AllArtifactTree on Artifact {
	id
	algorithm
	digest
}
`

func FindSoftware(
	ctx context.Context,
	client graphql.Client,
	searchText string,
) (*FindSoftwareResponse, error) {
	req := &graphql.Request{
		OpName: "FindSoftware",
		Query:  FindSoftware_Operation,
		Variables: &__FindSoftwareInput{
			SearchText: searchText,
		},
	}
	var err error

	var data FindSoftwareResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by HasMetadataArtifact.
const HasMetadataArtifact_Operation = `
mutation HasMetadataArtifact ($artifact: ArtifactInputSpec!, $hasMetadata: HasMetadataInputSpec!) {
	ingestHasMetadata(subject: {artifact:$artifact}, pkgMatchType: {pkg:ALL_VERSIONS}, hasMetadata: $hasMetadata)
}
`

func HasMetadataArtifact(
	ctx context.Context,
	client graphql.Client,
	artifact ArtifactInputSpec,
	hasMetadata HasMetadataInputSpec,
) (*HasMetadataArtifactResponse, error) {
	req := &graphql.Request{
		OpName: "HasMetadataArtifact",
		Query:  HasMetadataArtifact_Operation,
		Variables: &__HasMetadataArtifactInput{
			Artifact:    artifact,
			HasMetadata: hasMetadata,
		},
	}
	var err error

	var data HasMetadataArtifactResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by HasMetadataArtifacts.
const HasMetadataArtifacts_Operation = `
mutation HasMetadataArtifacts ($artifacts: [ArtifactInputSpec!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {
	ingestBulkHasMetadata(subjects: {artifacts:$artifacts}, pkgMatchType: {pkg:ALL_VERSIONS}, hasMetadataList: $hasMetadataList)
}
`

func HasMetadataArtifacts(
	ctx context.Context,
	client graphql.Client,
	artifacts []ArtifactInputSpec,
	hasMetadataList []HasMetadataInputSpec,
) (*HasMetadataArtifactsResponse, error) {
	req := &graphql.Request{
		OpName: "HasMetadataArtifacts",
		Query:  HasMetadataArtifacts_Operation,
		Variables: &__HasMetadataArtifactsInput{
			Artifacts:       artifacts,
			HasMetadataList: hasMetadataList,
		},
	}
	var err error

	var data HasMetadataArtifactsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by HasMetadataPkg.
const HasMetadataPkg_Operation = `
mutation HasMetadataPkg ($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $hasMetadata: HasMetadataInputSpec!) {
	ingestHasMetadata(subject: {package:$pkg}, pkgMatchType: $pkgMatchType, hasMetadata: $hasMetadata)
}
`

func HasMetadataPkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	pkgMatchType MatchFlags,
	hasMetadata HasMetadataInputSpec,
) (*HasMetadataPkgResponse, error) {
	req := &graphql.Request{
		OpName: "HasMetadataPkg",
		Query:  HasMetadataPkg_Operation,
		Variables: &__HasMetadataPkgInput{
			Pkg:          pkg,
			PkgMatchType: pkgMatchType,
			HasMetadata:  hasMetadata,
		},
	}
	var err error

	var data HasMetadataPkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by HasMetadataPkgs.
const HasMetadataPkgs_Operation = `
mutation HasMetadataPkgs ($pkgs: [PkgInputSpec!]!, $pkgMatchType: MatchFlags!, $hasMetadataList: [HasMetadataInputSpec!]!) {
	ingestBulkHasMetadata(subjects: {packages:$pkgs}, pkgMatchType: $pkgMatchType, hasMetadataList: $hasMetadataList)
}
`

func HasMetadataPkgs(
	ctx context.Context,
	client graphql.Client,
	pkgs []PkgInputSpec,
	pkgMatchType MatchFlags,
	hasMetadataList []HasMetadataInputSpec,
) (*HasMetadataPkgsResponse, error) {
	req := &graphql.Request{
		OpName: "HasMetadataPkgs",
		Query:  HasMetadataPkgs_Operation,
		Variables: &__HasMetadataPkgsInput{
			Pkgs:            pkgs,
			PkgMatchType:    pkgMatchType,
			HasMetadataList: hasMetadataList,
		},
	}
	var err error

	var data HasMetadataPkgsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by HasMetadataSrc.
const HasMetadataSrc_Operation = `
mutation HasMetadataSrc ($source: SourceInputSpec!, $hasMetadata: HasMetadataInputSpec!) {
	ingestHasMetadata(subject: {source:$source}, pkgMatchType: {pkg:ALL_VERSIONS}, hasMetadata: $hasMetadata)
}
`

func HasMetadataSrc(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	hasMetadata HasMetadataInputSpec,
) (*HasMetadataSrcResponse, error) {
	req := &graphql.Request{
		OpName: "HasMetadataSrc",
		Query:  HasMetadataSrc_Operation,
		Variables: &__HasMetadataSrcInput{
			Source:      source,
			HasMetadata: hasMetadata,
		},
	}
	var err error

	var data HasMetadataSrcResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by HasMetadataSrcs.
const HasMetadataSrcs_Operation = `
mutation HasMetadataSrcs ($sources: [SourceInputSpec!]!, $hasMetadataList: [HasMetadataInputSpec!]!) {
	ingestBulkHasMetadata(subjects: {sources:$sources}, pkgMatchType: {pkg:ALL_VERSIONS}, hasMetadataList: $hasMetadataList)
}
`

func HasMetadataSrcs(
	ctx context.Context,
	client graphql.Client,
	sources []SourceInputSpec,
	hasMetadataList []HasMetadataInputSpec,
) (*HasMetadataSrcsResponse, error) {
	req := &graphql.Request{
		OpName: "HasMetadataSrcs",
		Query:  HasMetadataSrcs_Operation,
		Variables: &__HasMetadataSrcsInput{
			Sources:         sources,
			HasMetadataList: hasMetadataList,
		},
	}
	var err error

	var data HasMetadataSrcsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by HasSBOMArtifact.
const HasSBOMArtifact_Operation = `
mutation HasSBOMArtifact ($artifact: ArtifactInputSpec!, $hasSBOM: HasSBOMInputSpec!) {
	ingestHasSBOM(subject: {artifact:$artifact}, hasSBOM: $hasSBOM)
}
`

func HasSBOMArtifact(
	ctx context.Context,
	client graphql.Client,
	artifact ArtifactInputSpec,
	hasSBOM HasSBOMInputSpec,
) (*HasSBOMArtifactResponse, error) {
	req := &graphql.Request{
		OpName: "HasSBOMArtifact",
		Query:  HasSBOMArtifact_Operation,
		Variables: &__HasSBOMArtifactInput{
			Artifact: artifact,
			HasSBOM:  hasSBOM,
		},
	}
	var err error

	var data HasSBOMArtifactResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by HasSBOMArtifacts.
const HasSBOMArtifacts_Operation = `
mutation HasSBOMArtifacts ($artifacts: [ArtifactInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {
	ingestHasSBOMs(subjects: {artifacts:$artifacts}, hasSBOMs: $hasSBOMs)
}
`

func HasSBOMArtifacts(
	ctx context.Context,
	client graphql.Client,
	artifacts []ArtifactInputSpec,
	hasSBOMs []HasSBOMInputSpec,
) (*HasSBOMArtifactsResponse, error) {
	req := &graphql.Request{
		OpName: "HasSBOMArtifacts",
		Query:  HasSBOMArtifacts_Operation,
		Variables: &__HasSBOMArtifactsInput{
			Artifacts: artifacts,
			HasSBOMs:  hasSBOMs,
		},
	}
	var err error

	var data HasSBOMArtifactsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by HasSBOMPkg.
const HasSBOMPkg_Operation = `
mutation HasSBOMPkg ($pkg: PkgInputSpec!, $hasSBOM: HasSBOMInputSpec!) {
	ingestHasSBOM(subject: {package:$pkg}, hasSBOM: $hasSBOM)
}
`

func HasSBOMPkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	hasSBOM HasSBOMInputSpec,
) (*HasSBOMPkgResponse, error) {
	req := &graphql.Request{
		OpName: "HasSBOMPkg",
		Query:  HasSBOMPkg_Operation,
		Variables: &__HasSBOMPkgInput{
			Pkg:     pkg,
			HasSBOM: hasSBOM,
		},
	}
	var err error

	var data HasSBOMPkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by HasSBOMPkgs.
const HasSBOMPkgs_Operation = `
mutation HasSBOMPkgs ($pkgs: [PkgInputSpec!]!, $hasSBOMs: [HasSBOMInputSpec!]!) {
	ingestHasSBOMs(subjects: {packages:$pkgs}, hasSBOMs: $hasSBOMs)
}
`

func HasSBOMPkgs(
	ctx context.Context,
	client graphql.Client,
	pkgs []PkgInputSpec,
	hasSBOMs []HasSBOMInputSpec,
) (*HasSBOMPkgsResponse, error) {
	req := &graphql.Request{
		OpName: "HasSBOMPkgs",
		Query:  HasSBOMPkgs_Operation,
		Variables: &__HasSBOMPkgsInput{
			Pkgs:     pkgs,
			HasSBOMs: hasSBOMs,
		},
	}
	var err error

	var data HasSBOMPkgsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by HasSourceAt.
const HasSourceAt_Operation = `
mutation HasSourceAt ($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $source: SourceInputSpec!, $hasSourceAt: HasSourceAtInputSpec!) {
	ingestHasSourceAt(pkg: $pkg, pkgMatchType: $pkgMatchType, source: $source, hasSourceAt: $hasSourceAt)
}
`

func HasSourceAt(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	pkgMatchType MatchFlags,
	source SourceInputSpec,
	hasSourceAt HasSourceAtInputSpec,
) (*HasSourceAtResponse, error) {
	req := &graphql.Request{
		OpName: "HasSourceAt",
		Query:  HasSourceAt_Operation,
		Variables: &__HasSourceAtInput{
			Pkg:          pkg,
			PkgMatchType: pkgMatchType,
			Source:       source,
			HasSourceAt:  hasSourceAt,
		},
	}
	var err error

	var data HasSourceAtResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestArtifact.
const IngestArtifact_Operation = `
mutation IngestArtifact ($artifact: ArtifactInputSpec!) {
	ingestArtifact(artifact: $artifact)
}
`

func IngestArtifact(
	ctx context.Context,
	client graphql.Client,
	artifact ArtifactInputSpec,
) (*IngestArtifactResponse, error) {
	req := &graphql.Request{
		OpName: "IngestArtifact",
		Query:  IngestArtifact_Operation,
		Variables: &__IngestArtifactInput{
			Artifact: artifact,
		},
	}
	var err error

	var data IngestArtifactResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestArtifacts.
const IngestArtifacts_Operation = `
mutation IngestArtifacts ($artifacts: [ArtifactInputSpec!]!) {
	ingestArtifacts(artifacts: $artifacts)
}
`

func IngestArtifacts(
	ctx context.Context,
	client graphql.Client,
	artifacts []ArtifactInputSpec,
) (*IngestArtifactsResponse, error) {
	req := &graphql.Request{
		OpName: "IngestArtifacts",
		Query:  IngestArtifacts_Operation,
		Variables: &__IngestArtifactsInput{
			Artifacts: artifacts,
		},
	}
	var err error

	var data IngestArtifactsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestBuilder.
const IngestBuilder_Operation = `
mutation IngestBuilder ($builder: BuilderInputSpec!) {
	ingestBuilder(builder: $builder)
}
`

func IngestBuilder(
	ctx context.Context,
	client graphql.Client,
	builder BuilderInputSpec,
) (*IngestBuilderResponse, error) {
	req := &graphql.Request{
		OpName: "IngestBuilder",
		Query:  IngestBuilder_Operation,
		Variables: &__IngestBuilderInput{
			Builder: builder,
		},
	}
	var err error

	var data IngestBuilderResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestBuilders.
const IngestBuilders_Operation = `
mutation IngestBuilders ($builders: [BuilderInputSpec!]!) {
	ingestBuilders(builders: $builders)
}
`

func IngestBuilders(
	ctx context.Context,
	client graphql.Client,
	builders []BuilderInputSpec,
) (*IngestBuildersResponse, error) {
	req := &graphql.Request{
		OpName: "IngestBuilders",
		Query:  IngestBuilders_Operation,
		Variables: &__IngestBuildersInput{
			Builders: builders,
		},
	}
	var err error

	var data IngestBuildersResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestHashEqual.
const IngestHashEqual_Operation = `
mutation IngestHashEqual ($artifact: ArtifactInputSpec!, $otherArtifact: ArtifactInputSpec!, $hashEqual: HashEqualInputSpec!) {
	ingestHashEqual(artifact: $artifact, otherArtifact: $otherArtifact, hashEqual: $hashEqual)
}
`

func IngestHashEqual(
	ctx context.Context,
	client graphql.Client,
	artifact ArtifactInputSpec,
	otherArtifact ArtifactInputSpec,
	hashEqual HashEqualInputSpec,
) (*IngestHashEqualResponse, error) {
	req := &graphql.Request{
		OpName: "IngestHashEqual",
		Query:  IngestHashEqual_Operation,
		Variables: &__IngestHashEqualInput{
			Artifact:      artifact,
			OtherArtifact: otherArtifact,
			HashEqual:     hashEqual,
		},
	}
	var err error

	var data IngestHashEqualResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestHashEquals.
const IngestHashEquals_Operation = `
mutation IngestHashEquals ($artifacts: [ArtifactInputSpec!]!, $otherArtifacts: [ArtifactInputSpec!]!, $hashEquals: [HashEqualInputSpec!]!) {
	ingestHashEquals(artifacts: $artifacts, otherArtifacts: $otherArtifacts, hashEquals: $hashEquals)
}
`

func IngestHashEquals(
	ctx context.Context,
	client graphql.Client,
	artifacts []ArtifactInputSpec,
	otherArtifacts []ArtifactInputSpec,
	hashEquals []HashEqualInputSpec,
) (*IngestHashEqualsResponse, error) {
	req := &graphql.Request{
		OpName: "IngestHashEquals",
		Query:  IngestHashEquals_Operation,
		Variables: &__IngestHashEqualsInput{
			Artifacts:      artifacts,
			OtherArtifacts: otherArtifacts,
			HashEquals:     hashEquals,
		},
	}
	var err error

	var data IngestHashEqualsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestLicense.
const IngestLicense_Operation = `
mutation IngestLicense ($license: LicenseInputSpec!) {
	ingestLicense(license: $license)
}
`

func IngestLicense(
	ctx context.Context,
	client graphql.Client,
	license LicenseInputSpec,
) (*IngestLicenseResponse, error) {
	req := &graphql.Request{
		OpName: "IngestLicense",
		Query:  IngestLicense_Operation,
		Variables: &__IngestLicenseInput{
			License: license,
		},
	}
	var err error

	var data IngestLicenseResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestLicenses.
const IngestLicenses_Operation = `
mutation IngestLicenses ($licenses: [LicenseInputSpec!]!) {
	ingestLicenses(licenses: $licenses)
}
`

func IngestLicenses(
	ctx context.Context,
	client graphql.Client,
	licenses []LicenseInputSpec,
) (*IngestLicensesResponse, error) {
	req := &graphql.Request{
		OpName: "IngestLicenses",
		Query:  IngestLicenses_Operation,
		Variables: &__IngestLicensesInput{
			Licenses: licenses,
		},
	}
	var err error

	var data IngestLicensesResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestPackage.
const IngestPackage_Operation = `
mutation IngestPackage ($pkg: PkgInputSpec!) {
	ingestPackage(pkg: $pkg)
}
`

func IngestPackage(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
) (*IngestPackageResponse, error) {
	req := &graphql.Request{
		OpName: "IngestPackage",
		Query:  IngestPackage_Operation,
		Variables: &__IngestPackageInput{
			Pkg: pkg,
		},
	}
	var err error

	var data IngestPackageResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestPackages.
const IngestPackages_Operation = `
mutation IngestPackages ($pkgs: [PkgInputSpec!]!) {
	ingestPackages(pkgs: $pkgs)
}
`

func IngestPackages(
	ctx context.Context,
	client graphql.Client,
	pkgs []PkgInputSpec,
) (*IngestPackagesResponse, error) {
	req := &graphql.Request{
		OpName: "IngestPackages",
		Query:  IngestPackages_Operation,
		Variables: &__IngestPackagesInput{
			Pkgs: pkgs,
		},
	}
	var err error

	var data IngestPackagesResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestPkgEqual.
const IngestPkgEqual_Operation = `
mutation IngestPkgEqual ($pkg: PkgInputSpec!, $otherPackage: PkgInputSpec!, $pkgEqual: PkgEqualInputSpec!) {
	ingestPkgEqual(pkg: $pkg, otherPackage: $otherPackage, pkgEqual: $pkgEqual)
}
`

func IngestPkgEqual(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	otherPackage PkgInputSpec,
	pkgEqual PkgEqualInputSpec,
) (*IngestPkgEqualResponse, error) {
	req := &graphql.Request{
		OpName: "IngestPkgEqual",
		Query:  IngestPkgEqual_Operation,
		Variables: &__IngestPkgEqualInput{
			Pkg:          pkg,
			OtherPackage: otherPackage,
			PkgEqual:     pkgEqual,
		},
	}
	var err error

	var data IngestPkgEqualResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestPkgEquals.
const IngestPkgEquals_Operation = `
mutation IngestPkgEquals ($pkgs: [PkgInputSpec!]!, $otherPackages: [PkgInputSpec!]!, $pkgEquals: [PkgEqualInputSpec!]!) {
	ingestPkgEquals(pkgs: $pkgs, otherPackages: $otherPackages, pkgEquals: $pkgEquals)
}
`

func IngestPkgEquals(
	ctx context.Context,
	client graphql.Client,
	pkgs []PkgInputSpec,
	otherPackages []PkgInputSpec,
	pkgEquals []PkgEqualInputSpec,
) (*IngestPkgEqualsResponse, error) {
	req := &graphql.Request{
		OpName: "IngestPkgEquals",
		Query:  IngestPkgEquals_Operation,
		Variables: &__IngestPkgEqualsInput{
			Pkgs:          pkgs,
			OtherPackages: otherPackages,
			PkgEquals:     pkgEquals,
		},
	}
	var err error

	var data IngestPkgEqualsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestSource.
const IngestSource_Operation = `
mutation IngestSource ($source: SourceInputSpec!) {
	ingestSource(source: $source)
}
`

func IngestSource(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
) (*IngestSourceResponse, error) {
	req := &graphql.Request{
		OpName: "IngestSource",
		Query:  IngestSource_Operation,
		Variables: &__IngestSourceInput{
			Source: source,
		},
	}
	var err error

	var data IngestSourceResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestSources.
const IngestSources_Operation = `
mutation IngestSources ($sources: [SourceInputSpec!]!) {
	ingestSources(sources: $sources)
}
`

func IngestSources(
	ctx context.Context,
	client graphql.Client,
	sources []SourceInputSpec,
) (*IngestSourcesResponse, error) {
	req := &graphql.Request{
		OpName: "IngestSources",
		Query:  IngestSources_Operation,
		Variables: &__IngestSourcesInput{
			Sources: sources,
		},
	}
	var err error

	var data IngestSourcesResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestVulnEqual.
const IngestVulnEqual_Operation = `
mutation IngestVulnEqual ($vulnerability: VulnerabilityInputSpec!, $otherVulnerability: VulnerabilityInputSpec!, $vulnEqual: VulnEqualInputSpec!) {
	ingestVulnEqual(vulnerability: $vulnerability, otherVulnerability: $otherVulnerability, vulnEqual: $vulnEqual)
}
`

func IngestVulnEqual(
	ctx context.Context,
	client graphql.Client,
	vulnerability VulnerabilityInputSpec,
	otherVulnerability VulnerabilityInputSpec,
	vulnEqual VulnEqualInputSpec,
) (*IngestVulnEqualResponse, error) {
	req := &graphql.Request{
		OpName: "IngestVulnEqual",
		Query:  IngestVulnEqual_Operation,
		Variables: &__IngestVulnEqualInput{
			Vulnerability:      vulnerability,
			OtherVulnerability: otherVulnerability,
			VulnEqual:          vulnEqual,
		},
	}
	var err error

	var data IngestVulnEqualResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestVulnEquals.
const IngestVulnEquals_Operation = `
mutation IngestVulnEquals ($vulnerabilities: [VulnerabilityInputSpec!]!, $otherVulnerabilities: [VulnerabilityInputSpec!]!, $vulnEquals: [VulnEqualInputSpec!]!) {
	ingestVulnEquals(vulnerabilities: $vulnerabilities, otherVulnerabilities: $otherVulnerabilities, vulnEquals: $vulnEquals)
}
`

func IngestVulnEquals(
	ctx context.Context,
	client graphql.Client,
	vulnerabilities []VulnerabilityInputSpec,
	otherVulnerabilities []VulnerabilityInputSpec,
	vulnEquals []VulnEqualInputSpec,
) (*IngestVulnEqualsResponse, error) {
	req := &graphql.Request{
		OpName: "IngestVulnEquals",
		Query:  IngestVulnEquals_Operation,
		Variables: &__IngestVulnEqualsInput{
			Vulnerabilities:      vulnerabilities,
			OtherVulnerabilities: otherVulnerabilities,
			VulnEquals:           vulnEquals,
		},
	}
	var err error

	var data IngestVulnEqualsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestVulnerabilities.
const IngestVulnerabilities_Operation = `
mutation IngestVulnerabilities ($vulns: [VulnerabilityInputSpec!]!) {
	ingestVulnerabilities(vulns: $vulns)
}
`

func IngestVulnerabilities(
	ctx context.Context,
	client graphql.Client,
	vulns []VulnerabilityInputSpec,
) (*IngestVulnerabilitiesResponse, error) {
	req := &graphql.Request{
		OpName: "IngestVulnerabilities",
		Query:  IngestVulnerabilities_Operation,
		Variables: &__IngestVulnerabilitiesInput{
			Vulns: vulns,
		},
	}
	var err error

	var data IngestVulnerabilitiesResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IngestVulnerability.
const IngestVulnerability_Operation = `
mutation IngestVulnerability ($vuln: VulnerabilityInputSpec!) {
	ingestVulnerability(vuln: $vuln)
}
`

func IngestVulnerability(
	ctx context.Context,
	client graphql.Client,
	vuln VulnerabilityInputSpec,
) (*IngestVulnerabilityResponse, error) {
	req := &graphql.Request{
		OpName: "IngestVulnerability",
		Query:  IngestVulnerability_Operation,
		Variables: &__IngestVulnerabilityInput{
			Vuln: vuln,
		},
	}
	var err error

	var data IngestVulnerabilityResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IsDependencies.
const IsDependencies_Operation = `
mutation IsDependencies ($pkgs: [PkgInputSpec!]!, $depPkgs: [PkgInputSpec!]!, $depPkgMatchType: MatchFlags!, $dependencies: [IsDependencyInputSpec!]!) {
	ingestDependencies(pkgs: $pkgs, depPkgs: $depPkgs, depPkgMatchType: $depPkgMatchType, dependencies: $dependencies)
}
`

func IsDependencies(
	ctx context.Context,
	client graphql.Client,
	pkgs []PkgInputSpec,
	depPkgs []PkgInputSpec,
	depPkgMatchType MatchFlags,
	dependencies []IsDependencyInputSpec,
) (*IsDependenciesResponse, error) {
	req := &graphql.Request{
		OpName: "IsDependencies",
		Query:  IsDependencies_Operation,
		Variables: &__IsDependenciesInput{
			Pkgs:            pkgs,
			DepPkgs:         depPkgs,
			DepPkgMatchType: depPkgMatchType,
			Dependencies:    dependencies,
		},
	}
	var err error

	var data IsDependenciesResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IsDependency.
const IsDependency_Operation = `
mutation IsDependency ($pkg: PkgInputSpec!, $depPkg: PkgInputSpec!, $depPkgMatchType: MatchFlags!, $dependency: IsDependencyInputSpec!) {
	ingestDependency(pkg: $pkg, depPkg: $depPkg, depPkgMatchType: $depPkgMatchType, dependency: $dependency)
}
`

func IsDependency(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	depPkg PkgInputSpec,
	depPkgMatchType MatchFlags,
	dependency IsDependencyInputSpec,
) (*IsDependencyResponse, error) {
	req := &graphql.Request{
		OpName: "IsDependency",
		Query:  IsDependency_Operation,
		Variables: &__IsDependencyInput{
			Pkg:             pkg,
			DepPkg:          depPkg,
			DepPkgMatchType: depPkgMatchType,
			Dependency:      dependency,
		},
	}
	var err error

	var data IsDependencyResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IsOccurrencePkg.
const IsOccurrencePkg_Operation = `
mutation IsOccurrencePkg ($pkg: PkgInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {
	ingestOccurrence(subject: {package:$pkg}, artifact: $artifact, occurrence: $occurrence)
}
`

func IsOccurrencePkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	artifact ArtifactInputSpec,
	occurrence IsOccurrenceInputSpec,
) (*IsOccurrencePkgResponse, error) {
	req := &graphql.Request{
		OpName: "IsOccurrencePkg",
		Query:  IsOccurrencePkg_Operation,
		Variables: &__IsOccurrencePkgInput{
			Pkg:        pkg,
			Artifact:   artifact,
			Occurrence: occurrence,
		},
	}
	var err error

	var data IsOccurrencePkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IsOccurrenceSrc.
const IsOccurrenceSrc_Operation = `
mutation IsOccurrenceSrc ($source: SourceInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {
	ingestOccurrence(subject: {source:$source}, artifact: $artifact, occurrence: $occurrence)
}
`

func IsOccurrenceSrc(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	artifact ArtifactInputSpec,
	occurrence IsOccurrenceInputSpec,
) (*IsOccurrenceSrcResponse, error) {
	req := &graphql.Request{
		OpName: "IsOccurrenceSrc",
		Query:  IsOccurrenceSrc_Operation,
		Variables: &__IsOccurrenceSrcInput{
			Source:     source,
			Artifact:   artifact,
			Occurrence: occurrence,
		},
	}
	var err error

	var data IsOccurrenceSrcResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IsOccurrencesPkg.
const IsOccurrencesPkg_Operation = `
mutation IsOccurrencesPkg ($pkgs: [PkgInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {
	ingestOccurrences(subjects: {packages:$pkgs}, artifacts: $artifacts, occurrences: $occurrences)
}
`

func IsOccurrencesPkg(
	ctx context.Context,
	client graphql.Client,
	pkgs []PkgInputSpec,
	artifacts []ArtifactInputSpec,
	occurrences []IsOccurrenceInputSpec,
) (*IsOccurrencesPkgResponse, error) {
	req := &graphql.Request{
		OpName: "IsOccurrencesPkg",
		Query:  IsOccurrencesPkg_Operation,
		Variables: &__IsOccurrencesPkgInput{
			Pkgs:        pkgs,
			Artifacts:   artifacts,
			Occurrences: occurrences,
		},
	}
	var err error

	var data IsOccurrencesPkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by IsOccurrencesSrc.
const IsOccurrencesSrc_Operation = `
mutation IsOccurrencesSrc ($sources: [SourceInputSpec!]!, $artifacts: [ArtifactInputSpec!]!, $occurrences: [IsOccurrenceInputSpec!]!) {
	ingestOccurrences(subjects: {sources:$sources}, artifacts: $artifacts, occurrences: $occurrences)
}
`

func IsOccurrencesSrc(
	ctx context.Context,
	client graphql.Client,
	sources []SourceInputSpec,
	artifacts []ArtifactInputSpec,
	occurrences []IsOccurrenceInputSpec,
) (*IsOccurrencesSrcResponse, error) {
	req := &graphql.Request{
		OpName: "IsOccurrencesSrc",
		Query:  IsOccurrencesSrc_Operation,
		Variables: &__IsOccurrencesSrcInput{
			Sources:     sources,
			Artifacts:   artifacts,
			Occurrences: occurrences,
		},
	}
	var err error

	var data IsOccurrencesSrcResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by Licenses.
const Licenses_Operation = `
query Licenses ($filter: LicenseSpec!) {
	licenses(licenseSpec: $filter) {
		... AllLicenseTree
	}
}
fragment AllLicenseTree on License {
	id
	name
	inline
	listVersion
}
`

func Licenses(
	ctx context.Context,
	client graphql.Client,
	filter LicenseSpec,
) (*LicensesResponse, error) {
	req := &graphql.Request{
		OpName: "Licenses",
		Query:  Licenses_Operation,
		Variables: &__LicensesInput{
			Filter: filter,
		},
	}
	var err error

	var data LicensesResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by Neighbors.
const Neighbors_Operation = `
query Neighbors ($node: ID!, $usingOnly: [Edge!]!) {
	neighbors(node: $node, usingOnly: $usingOnly) {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
		... on Builder {
			... AllBuilderTree
		}
		... on Vulnerability {
			... AllVulnerabilityTree
		}
		... on License {
			... AllLicenseTree
		}
		... on CertifyScorecard {
			... AllCertifyScorecard
		}
		... on PkgEqual {
			... AllPkgEqual
		}
		... on IsOccurrence {
			... AllIsOccurrencesTree
		}
		... on IsDependency {
			... AllIsDependencyTree
		}
		... on HasSLSA {
			... AllSLSATree
		}
		... on CertifyBad {
			... AllCertifyBad
		}
		... on CertifyGood {
			... AllCertifyGood
		}
		... on HashEqual {
			... AllHashEqualTree
		}
		... on HasSBOM {
			... AllHasSBOMTree
		}
		... on HasSourceAt {
			... AllHasSourceAt
		}
		... on PointOfContact {
			... AllPointOfContact
		}
		... on CertifyVuln {
			... AllCertifyVuln
		}
		... on VulnEqual {
			... AllVulnEqual
		}
		... on CertifyVEXStatement {
			... AllCertifyVEXStatement
		}
		... on Builder {
			... AllBuilderTree
		}
		... on VulnerabilityMetadata {
			... AllVulnMetadataTree
		}
		... on HasMetadata {
			... AllHasMetadata
		}
		... on CertifyLegal {
			... AllCertifyLegalTree
		}
	}
}
fragment AllPkgTree on Package {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			versions {
				id
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment AllSourceTree on Source {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			tag
			commit
		}
	}
}
fragment AllArtifactTree on Artifact {
	id
	algorithm
	digest
}
fragment AllBuilderTree on Builder {
	id
	uri
}
fragment AllVulnerabilityTree on Vulnerability {
	id
	type
	vulnerabilityIDs {
		id
		vulnerabilityID
	}
}
fragment AllLicenseTree on License {
	id
	name
	inline
	listVersion
}
fragment AllCertifyScorecard on CertifyScorecard {
	id
	source {
		... AllSourceTree
	}
	scorecard {
		timeScanned
		aggregateScore
		checks {
			check
			score
		}
		scorecardVersion
		scorecardCommit
		origin
		collector
	}
}
fragment AllPkgEqual on PkgEqual {
	id
	justification
	packages {
		... AllPkgTree
	}
	origin
	collector
}
fragment AllIsOccurrencesTree on IsOccurrence {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
	}
	artifact {
		... AllArtifactTree
	}
	justification
	origin
	collector
}
fragment AllIsDependencyTree on IsDependency {
	id
	justification
	package {
		... AllPkgTree
	}
	dependentPackage {
		... AllPkgTree
	}
	dependencyType
	versionRange
	origin
	collector
}
fragment AllSLSATree on HasSLSA {
	id
	subject {
		... AllArtifactTree
	}
	slsa {
		builtFrom {
			... AllArtifactTree
		}
		builtBy {
			id
			uri
		}
		buildType
		slsaPredicate {
			key
			value
		}
		slsaVersion
		startedOn
		finishedOn
		origin
		collector
	}
}
fragment AllCertifyBad on CertifyBad {
	id
	justification
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	origin
	collector
}
fragment AllCertifyGood on CertifyGood {
	id
	justification
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	origin
	collector
}
fragment AllHashEqualTree on HashEqual {
	id
	justification
	artifacts {
		... AllArtifactTree
	}
	origin
	collector
}
fragment AllHasSBOMTree on HasSBOM {
	id
	subject {
		__typename
		... on Artifact {
			... AllArtifactTree
		}
		... on Package {
			... AllPkgTree
		}
	}
	uri
	algorithm
	digest
	downloadLocation
	origin
	collector
}
fragment AllHasSourceAt on HasSourceAt {
	id
	justification
	knownSince
	package {
		... AllPkgTree
	}
	source {
		... AllSourceTree
	}
	origin
	collector
}
fragment AllPointOfContact on PointOfContact {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	email
	info
	since
	justification
	origin
	collector
}
fragment AllCertifyVuln on CertifyVuln {
	id
	package {
		... AllPkgTree
	}
	vulnerability {
		... AllVulnerabilityTree
	}
	metadata {
		dbUri
		dbVersion
		scannerUri
		scannerVersion
		timeScanned
		origin
		collector
	}
}
fragment AllVulnEqual on VulnEqual {
	id
	vulnerabilities {
		... AllVulnerabilityTree
	}
	justification
	origin
	collector
}
fragment AllCertifyVEXStatement on CertifyVEXStatement {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	vulnerability {
		... AllVulnerabilityTree
	}
	status
	vexJustification
	statement
	statusNotes
	knownSince
	origin
	collector
}
fragment AllVulnMetadataTree on VulnerabilityMetadata {
	id
	vulnerability {
		id
		type
		vulnerabilityIDs {
			id
			vulnerabilityID
		}
	}
	scoreType
	scoreValue
	timestamp
	origin
	collector
}
fragment AllHasMetadata on HasMetadata {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	key
	value
	timestamp
	justification
	origin
	collector
}
fragment AllCertifyLegalTree on CertifyLegal {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
	}
	declaredLicense
	declaredLicenses {
		... AllLicenseTree
	}
	discoveredLicense
	discoveredLicenses {
		... AllLicenseTree
	}
	attribution
	justification
	timeScanned
	origin
	collector
}
`

func Neighbors(
	ctx context.Context,
	client graphql.Client,
	node string,
	usingOnly []Edge,
) (*NeighborsResponse, error) {
	req := &graphql.Request{
		OpName: "Neighbors",
		Query:  Neighbors_Operation,
		Variables: &__NeighborsInput{
			Node:      node,
			UsingOnly: usingOnly,
		},
	}
	var err error

	var data NeighborsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by Node.
const Node_Operation = `
query Node ($node: ID!) {
	node(node: $node) {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
		... on Builder {
			... AllBuilderTree
		}
		... on Vulnerability {
			... AllVulnerabilityTree
		}
		... on License {
			... AllLicenseTree
		}
		... on CertifyScorecard {
			... AllCertifyScorecard
		}
		... on PkgEqual {
			... AllPkgEqual
		}
		... on IsOccurrence {
			... AllIsOccurrencesTree
		}
		... on IsDependency {
			... AllIsDependencyTree
		}
		... on HasSLSA {
			... AllSLSATree
		}
		... on CertifyBad {
			... AllCertifyBad
		}
		... on CertifyGood {
			... AllCertifyGood
		}
		... on HashEqual {
			... AllHashEqualTree
		}
		... on HasSBOM {
			... AllHasSBOMTree
		}
		... on HasSourceAt {
			... AllHasSourceAt
		}
		... on PointOfContact {
			... AllPointOfContact
		}
		... on CertifyVuln {
			... AllCertifyVuln
		}
		... on VulnEqual {
			... AllVulnEqual
		}
		... on CertifyVEXStatement {
			... AllCertifyVEXStatement
		}
		... on Builder {
			... AllBuilderTree
		}
		... on VulnerabilityMetadata {
			... AllVulnMetadataTree
		}
		... on HasMetadata {
			... AllHasMetadata
		}
		... on CertifyLegal {
			... AllCertifyLegalTree
		}
	}
}
fragment AllPkgTree on Package {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			versions {
				id
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment AllSourceTree on Source {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			tag
			commit
		}
	}
}
fragment AllArtifactTree on Artifact {
	id
	algorithm
	digest
}
fragment AllBuilderTree on Builder {
	id
	uri
}
fragment AllVulnerabilityTree on Vulnerability {
	id
	type
	vulnerabilityIDs {
		id
		vulnerabilityID
	}
}
fragment AllLicenseTree on License {
	id
	name
	inline
	listVersion
}
fragment AllCertifyScorecard on CertifyScorecard {
	id
	source {
		... AllSourceTree
	}
	scorecard {
		timeScanned
		aggregateScore
		checks {
			check
			score
		}
		scorecardVersion
		scorecardCommit
		origin
		collector
	}
}
fragment AllPkgEqual on PkgEqual {
	id
	justification
	packages {
		... AllPkgTree
	}
	origin
	collector
}
fragment AllIsOccurrencesTree on IsOccurrence {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
	}
	artifact {
		... AllArtifactTree
	}
	justification
	origin
	collector
}
fragment AllIsDependencyTree on IsDependency {
	id
	justification
	package {
		... AllPkgTree
	}
	dependentPackage {
		... AllPkgTree
	}
	dependencyType
	versionRange
	origin
	collector
}
fragment AllSLSATree on HasSLSA {
	id
	subject {
		... AllArtifactTree
	}
	slsa {
		builtFrom {
			... AllArtifactTree
		}
		builtBy {
			id
			uri
		}
		buildType
		slsaPredicate {
			key
			value
		}
		slsaVersion
		startedOn
		finishedOn
		origin
		collector
	}
}
fragment AllCertifyBad on CertifyBad {
	id
	justification
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	origin
	collector
}
fragment AllCertifyGood on CertifyGood {
	id
	justification
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	origin
	collector
}
fragment AllHashEqualTree on HashEqual {
	id
	justification
	artifacts {
		... AllArtifactTree
	}
	origin
	collector
}
fragment AllHasSBOMTree on HasSBOM {
	id
	subject {
		__typename
		... on Artifact {
			... AllArtifactTree
		}
		... on Package {
			... AllPkgTree
		}
	}
	uri
	algorithm
	digest
	downloadLocation
	origin
	collector
}
fragment AllHasSourceAt on HasSourceAt {
	id
	justification
	knownSince
	package {
		... AllPkgTree
	}
	source {
		... AllSourceTree
	}
	origin
	collector
}
fragment AllPointOfContact on PointOfContact {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	email
	info
	since
	justification
	origin
	collector
}
fragment AllCertifyVuln on CertifyVuln {
	id
	package {
		... AllPkgTree
	}
	vulnerability {
		... AllVulnerabilityTree
	}
	metadata {
		dbUri
		dbVersion
		scannerUri
		scannerVersion
		timeScanned
		origin
		collector
	}
}
fragment AllVulnEqual on VulnEqual {
	id
	vulnerabilities {
		... AllVulnerabilityTree
	}
	justification
	origin
	collector
}
fragment AllCertifyVEXStatement on CertifyVEXStatement {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	vulnerability {
		... AllVulnerabilityTree
	}
	status
	vexJustification
	statement
	statusNotes
	knownSince
	origin
	collector
}
fragment AllVulnMetadataTree on VulnerabilityMetadata {
	id
	vulnerability {
		id
		type
		vulnerabilityIDs {
			id
			vulnerabilityID
		}
	}
	scoreType
	scoreValue
	timestamp
	origin
	collector
}
fragment AllHasMetadata on HasMetadata {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	key
	value
	timestamp
	justification
	origin
	collector
}
fragment AllCertifyLegalTree on CertifyLegal {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
	}
	declaredLicense
	declaredLicenses {
		... AllLicenseTree
	}
	discoveredLicense
	discoveredLicenses {
		... AllLicenseTree
	}
	attribution
	justification
	timeScanned
	origin
	collector
}
`

func Node(
	ctx context.Context,
	client graphql.Client,
	node string,
) (*NodeResponse, error) {
	req := &graphql.Request{
		OpName: "Node",
		Query:  Node_Operation,
		Variables: &__NodeInput{
			Node: node,
		},
	}
	var err error

	var data NodeResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by Nodes.
const Nodes_Operation = `
query Nodes ($nodes: [ID!]!) {
	nodes(nodes: $nodes) {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
		... on Builder {
			... AllBuilderTree
		}
		... on Vulnerability {
			... AllVulnerabilityTree
		}
		... on License {
			... AllLicenseTree
		}
		... on CertifyScorecard {
			... AllCertifyScorecard
		}
		... on PkgEqual {
			... AllPkgEqual
		}
		... on IsOccurrence {
			... AllIsOccurrencesTree
		}
		... on IsDependency {
			... AllIsDependencyTree
		}
		... on HasSLSA {
			... AllSLSATree
		}
		... on CertifyBad {
			... AllCertifyBad
		}
		... on CertifyGood {
			... AllCertifyGood
		}
		... on HashEqual {
			... AllHashEqualTree
		}
		... on HasSBOM {
			... AllHasSBOMTree
		}
		... on HasSourceAt {
			... AllHasSourceAt
		}
		... on PointOfContact {
			... AllPointOfContact
		}
		... on CertifyVuln {
			... AllCertifyVuln
		}
		... on VulnEqual {
			... AllVulnEqual
		}
		... on CertifyVEXStatement {
			... AllCertifyVEXStatement
		}
		... on Builder {
			... AllBuilderTree
		}
		... on VulnerabilityMetadata {
			... AllVulnMetadataTree
		}
		... on HasMetadata {
			... AllHasMetadata
		}
		... on CertifyLegal {
			... AllCertifyLegalTree
		}
	}
}
fragment AllPkgTree on Package {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			versions {
				id
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment AllSourceTree on Source {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			tag
			commit
		}
	}
}
fragment AllArtifactTree on Artifact {
	id
	algorithm
	digest
}
fragment AllBuilderTree on Builder {
	id
	uri
}
fragment AllVulnerabilityTree on Vulnerability {
	id
	type
	vulnerabilityIDs {
		id
		vulnerabilityID
	}
}
fragment AllLicenseTree on License {
	id
	name
	inline
	listVersion
}
fragment AllCertifyScorecard on CertifyScorecard {
	id
	source {
		... AllSourceTree
	}
	scorecard {
		timeScanned
		aggregateScore
		checks {
			check
			score
		}
		scorecardVersion
		scorecardCommit
		origin
		collector
	}
}
fragment AllPkgEqual on PkgEqual {
	id
	justification
	packages {
		... AllPkgTree
	}
	origin
	collector
}
fragment AllIsOccurrencesTree on IsOccurrence {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
	}
	artifact {
		... AllArtifactTree
	}
	justification
	origin
	collector
}
fragment AllIsDependencyTree on IsDependency {
	id
	justification
	package {
		... AllPkgTree
	}
	dependentPackage {
		... AllPkgTree
	}
	dependencyType
	versionRange
	origin
	collector
}
fragment AllSLSATree on HasSLSA {
	id
	subject {
		... AllArtifactTree
	}
	slsa {
		builtFrom {
			... AllArtifactTree
		}
		builtBy {
			id
			uri
		}
		buildType
		slsaPredicate {
			key
			value
		}
		slsaVersion
		startedOn
		finishedOn
		origin
		collector
	}
}
fragment AllCertifyBad on CertifyBad {
	id
	justification
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	origin
	collector
}
fragment AllCertifyGood on CertifyGood {
	id
	justification
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	origin
	collector
}
fragment AllHashEqualTree on HashEqual {
	id
	justification
	artifacts {
		... AllArtifactTree
	}
	origin
	collector
}
fragment AllHasSBOMTree on HasSBOM {
	id
	subject {
		__typename
		... on Artifact {
			... AllArtifactTree
		}
		... on Package {
			... AllPkgTree
		}
	}
	uri
	algorithm
	digest
	downloadLocation
	origin
	collector
}
fragment AllHasSourceAt on HasSourceAt {
	id
	justification
	knownSince
	package {
		... AllPkgTree
	}
	source {
		... AllSourceTree
	}
	origin
	collector
}
fragment AllPointOfContact on PointOfContact {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	email
	info
	since
	justification
	origin
	collector
}
fragment AllCertifyVuln on CertifyVuln {
	id
	package {
		... AllPkgTree
	}
	vulnerability {
		... AllVulnerabilityTree
	}
	metadata {
		dbUri
		dbVersion
		scannerUri
		scannerVersion
		timeScanned
		origin
		collector
	}
}
fragment AllVulnEqual on VulnEqual {
	id
	vulnerabilities {
		... AllVulnerabilityTree
	}
	justification
	origin
	collector
}
fragment AllCertifyVEXStatement on CertifyVEXStatement {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	vulnerability {
		... AllVulnerabilityTree
	}
	status
	vexJustification
	statement
	statusNotes
	knownSince
	origin
	collector
}
fragment AllVulnMetadataTree on VulnerabilityMetadata {
	id
	vulnerability {
		id
		type
		vulnerabilityIDs {
			id
			vulnerabilityID
		}
	}
	scoreType
	scoreValue
	timestamp
	origin
	collector
}
fragment AllHasMetadata on HasMetadata {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	key
	value
	timestamp
	justification
	origin
	collector
}
fragment AllCertifyLegalTree on CertifyLegal {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
	}
	declaredLicense
	declaredLicenses {
		... AllLicenseTree
	}
	discoveredLicense
	discoveredLicenses {
		... AllLicenseTree
	}
	attribution
	justification
	timeScanned
	origin
	collector
}
`

func Nodes(
	ctx context.Context,
	client graphql.Client,
	nodes []string,
) (*NodesResponse, error) {
	req := &graphql.Request{
		OpName: "Nodes",
		Query:  Nodes_Operation,
		Variables: &__NodesInput{
			Nodes: nodes,
		},
	}
	var err error

	var data NodesResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by PackageNames.
const PackageNames_Operation = `
query PackageNames ($filter: PkgSpec!) {
	packages(pkgSpec: $filter) {
		id
		type
		namespaces {
			id
			namespace
			names {
				id
				name
			}
		}
	}
}
`

func PackageNames(
	ctx context.Context,
	client graphql.Client,
	filter PkgSpec,
) (*PackageNamesResponse, error) {
	req := &graphql.Request{
		OpName: "PackageNames",
		Query:  PackageNames_Operation,
		Variables: &__PackageNamesInput{
			Filter: filter,
		},
	}
	var err error

	var data PackageNamesResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by PackageNamespaces.
const PackageNamespaces_Operation = `
query PackageNamespaces ($filter: PkgSpec!) {
	packages(pkgSpec: $filter) {
		id
		type
		namespaces {
			id
			namespace
		}
	}
}
`

func PackageNamespaces(
	ctx context.Context,
	client graphql.Client,
	filter PkgSpec,
) (*PackageNamespacesResponse, error) {
	req := &graphql.Request{
		OpName: "PackageNamespaces",
		Query:  PackageNamespaces_Operation,
		Variables: &__PackageNamespacesInput{
			Filter: filter,
		},
	}
	var err error

	var data PackageNamespacesResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by PackageTypes.
const PackageTypes_Operation = `
query PackageTypes ($filter: PkgSpec!) {
	packages(pkgSpec: $filter) {
		id
		type
	}
}
`

func PackageTypes(
	ctx context.Context,
	client graphql.Client,
	filter PkgSpec,
) (*PackageTypesResponse, error) {
	req := &graphql.Request{
		OpName: "PackageTypes",
		Query:  PackageTypes_Operation,
		Variables: &__PackageTypesInput{
			Filter: filter,
		},
	}
	var err error

	var data PackageTypesResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by PackageVersions.
const PackageVersions_Operation = `
query PackageVersions ($filter: PkgSpec!) {
	packages(pkgSpec: $filter) {
		id
		type
		namespaces {
			id
			namespace
			names {
				id
				name
				versions {
					id
					version
					qualifiers {
						key
						value
					}
					subpath
				}
			}
		}
	}
}
`

func PackageVersions(
	ctx context.Context,
	client graphql.Client,
	filter PkgSpec,
) (*PackageVersionsResponse, error) {
	req := &graphql.Request{
		OpName: "PackageVersions",
		Query:  PackageVersions_Operation,
		Variables: &__PackageVersionsInput{
			Filter: filter,
		},
	}
	var err error

	var data PackageVersionsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by Packages.
const Packages_Operation = `
query Packages ($filter: PkgSpec!) {
	packages(pkgSpec: $filter) {
		... AllPkgTree
	}
}
fragment AllPkgTree on Package {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			versions {
				id
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
`

func Packages(
	ctx context.Context,
	client graphql.Client,
	filter PkgSpec,
) (*PackagesResponse, error) {
	req := &graphql.Request{
		OpName: "Packages",
		Query:  Packages_Operation,
		Variables: &__PackagesInput{
			Filter: filter,
		},
	}
	var err error

	var data PackagesResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by Path.
const Path_Operation = `
query Path ($subject: ID!, $target: ID!, $maxPathLength: Int!, $usingOnly: [Edge!]!) {
	path(subject: $subject, target: $target, maxPathLength: $maxPathLength, usingOnly: $usingOnly) {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
		... on Builder {
			... AllBuilderTree
		}
		... on Vulnerability {
			... AllVulnerabilityTree
		}
		... on License {
			... AllLicenseTree
		}
		... on CertifyScorecard {
			... AllCertifyScorecard
		}
		... on PkgEqual {
			... AllPkgEqual
		}
		... on IsOccurrence {
			... AllIsOccurrencesTree
		}
		... on IsDependency {
			... AllIsDependencyTree
		}
		... on HasSLSA {
			... AllSLSATree
		}
		... on CertifyBad {
			... AllCertifyBad
		}
		... on CertifyGood {
			... AllCertifyGood
		}
		... on HashEqual {
			... AllHashEqualTree
		}
		... on HasSBOM {
			... AllHasSBOMTree
		}
		... on HasSourceAt {
			... AllHasSourceAt
		}
		... on PointOfContact {
			... AllPointOfContact
		}
		... on CertifyVuln {
			... AllCertifyVuln
		}
		... on VulnEqual {
			... AllVulnEqual
		}
		... on CertifyVEXStatement {
			... AllCertifyVEXStatement
		}
		... on Builder {
			... AllBuilderTree
		}
		... on VulnerabilityMetadata {
			... AllVulnMetadataTree
		}
		... on HasMetadata {
			... AllHasMetadata
		}
		... on CertifyLegal {
			... AllCertifyLegalTree
		}
	}
}
fragment AllPkgTree on Package {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			versions {
				id
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment AllSourceTree on Source {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			tag
			commit
		}
	}
}
fragment AllArtifactTree on Artifact {
	id
	algorithm
	digest
}
fragment AllBuilderTree on Builder {
	id
	uri
}
fragment AllVulnerabilityTree on Vulnerability {
	id
	type
	vulnerabilityIDs {
		id
		vulnerabilityID
	}
}
fragment AllLicenseTree on License {
	id
	name
	inline
	listVersion
}
fragment AllCertifyScorecard on CertifyScorecard {
	id
	source {
		... AllSourceTree
	}
	scorecard {
		timeScanned
		aggregateScore
		checks {
			check
			score
		}
		scorecardVersion
		scorecardCommit
		origin
		collector
	}
}
fragment AllPkgEqual on PkgEqual {
	id
	justification
	packages {
		... AllPkgTree
	}
	origin
	collector
}
fragment AllIsOccurrencesTree on IsOccurrence {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
	}
	artifact {
		... AllArtifactTree
	}
	justification
	origin
	collector
}
fragment AllIsDependencyTree on IsDependency {
	id
	justification
	package {
		... AllPkgTree
	}
	dependentPackage {
		... AllPkgTree
	}
	dependencyType
	versionRange
	origin
	collector
}
fragment AllSLSATree on HasSLSA {
	id
	subject {
		... AllArtifactTree
	}
	slsa {
		builtFrom {
			... AllArtifactTree
		}
		builtBy {
			id
			uri
		}
		buildType
		slsaPredicate {
			key
			value
		}
		slsaVersion
		startedOn
		finishedOn
		origin
		collector
	}
}
fragment AllCertifyBad on CertifyBad {
	id
	justification
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	origin
	collector
}
fragment AllCertifyGood on CertifyGood {
	id
	justification
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	origin
	collector
}
fragment AllHashEqualTree on HashEqual {
	id
	justification
	artifacts {
		... AllArtifactTree
	}
	origin
	collector
}
fragment AllHasSBOMTree on HasSBOM {
	id
	subject {
		__typename
		... on Artifact {
			... AllArtifactTree
		}
		... on Package {
			... AllPkgTree
		}
	}
	uri
	algorithm
	digest
	downloadLocation
	origin
	collector
}
fragment AllHasSourceAt on HasSourceAt {
	id
	justification
	knownSince
	package {
		... AllPkgTree
	}
	source {
		... AllSourceTree
	}
	origin
	collector
}
fragment AllPointOfContact on PointOfContact {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	email
	info
	since
	justification
	origin
	collector
}
fragment AllCertifyVuln on CertifyVuln {
	id
	package {
		... AllPkgTree
	}
	vulnerability {
		... AllVulnerabilityTree
	}
	metadata {
		dbUri
		dbVersion
		scannerUri
		scannerVersion
		timeScanned
		origin
		collector
	}
}
fragment AllVulnEqual on VulnEqual {
	id
	vulnerabilities {
		... AllVulnerabilityTree
	}
	justification
	origin
	collector
}
fragment AllCertifyVEXStatement on CertifyVEXStatement {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	vulnerability {
		... AllVulnerabilityTree
	}
	status
	vexJustification
	statement
	statusNotes
	knownSince
	origin
	collector
}
fragment AllVulnMetadataTree on VulnerabilityMetadata {
	id
	vulnerability {
		id
		type
		vulnerabilityIDs {
			id
			vulnerabilityID
		}
	}
	scoreType
	scoreValue
	timestamp
	origin
	collector
}
fragment AllHasMetadata on HasMetadata {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
		... on Artifact {
			... AllArtifactTree
		}
	}
	key
	value
	timestamp
	justification
	origin
	collector
}
fragment AllCertifyLegalTree on CertifyLegal {
	id
	subject {
		__typename
		... on Package {
			... AllPkgTree
		}
		... on Source {
			... AllSourceTree
		}
	}
	declaredLicense
	declaredLicenses {
		... AllLicenseTree
	}
	discoveredLicense
	discoveredLicenses {
		... AllLicenseTree
	}
	attribution
	justification
	timeScanned
	origin
	collector
}
`

func Path(
	ctx context.Context,
	client graphql.Client,
	subject string,
	target string,
	maxPathLength int,
	usingOnly []Edge,
) (*PathResponse, error) {
	req := &graphql.Request{
		OpName: "Path",
		Query:  Path_Operation,
		Variables: &__PathInput{
			Subject:       subject,
			Target:        target,
			MaxPathLength: maxPathLength,
			UsingOnly:     usingOnly,
		},
	}
	var err error

	var data PathResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by PointOfContactArtifact.
const PointOfContactArtifact_Operation = `
mutation PointOfContactArtifact ($artifact: ArtifactInputSpec!, $pointOfContact: PointOfContactInputSpec!) {
	ingestPointOfContact(subject: {artifact:$artifact}, pkgMatchType: {pkg:ALL_VERSIONS}, pointOfContact: $pointOfContact)
}
`

func PointOfContactArtifact(
	ctx context.Context,
	client graphql.Client,
	artifact ArtifactInputSpec,
	pointOfContact PointOfContactInputSpec,
) (*PointOfContactArtifactResponse, error) {
	req := &graphql.Request{
		OpName: "PointOfContactArtifact",
		Query:  PointOfContactArtifact_Operation,
		Variables: &__PointOfContactArtifactInput{
			Artifact:       artifact,
			PointOfContact: pointOfContact,
		},
	}
	var err error

	var data PointOfContactArtifactResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by PointOfContactPkg.
const PointOfContactPkg_Operation = `
mutation PointOfContactPkg ($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $pointOfContact: PointOfContactInputSpec!) {
	ingestPointOfContact(subject: {package:$pkg}, pkgMatchType: $pkgMatchType, pointOfContact: $pointOfContact)
}
`

func PointOfContactPkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	pkgMatchType MatchFlags,
	pointOfContact PointOfContactInputSpec,
) (*PointOfContactPkgResponse, error) {
	req := &graphql.Request{
		OpName: "PointOfContactPkg",
		Query:  PointOfContactPkg_Operation,
		Variables: &__PointOfContactPkgInput{
			Pkg:            pkg,
			PkgMatchType:   pkgMatchType,
			PointOfContact: pointOfContact,
		},
	}
	var err error

	var data PointOfContactPkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by PointOfContactSrc.
const PointOfContactSrc_Operation = `
mutation PointOfContactSrc ($source: SourceInputSpec!, $pointOfContact: PointOfContactInputSpec!) {
	ingestPointOfContact(subject: {source:$source}, pkgMatchType: {pkg:ALL_VERSIONS}, pointOfContact: $pointOfContact)
}
`

func PointOfContactSrc(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	pointOfContact PointOfContactInputSpec,
) (*PointOfContactSrcResponse, error) {
	req := &graphql.Request{
		OpName: "PointOfContactSrc",
		Query:  PointOfContactSrc_Operation,
		Variables: &__PointOfContactSrcInput{
			Source:         source,
			PointOfContact: pointOfContact,
		},
	}
	var err error

	var data PointOfContactSrcResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by SLSAForArtifact.
const SLSAForArtifact_Operation = `
mutation SLSAForArtifact ($artifact: ArtifactInputSpec!, $materials: [ArtifactInputSpec!]!, $builder: BuilderInputSpec!, $slsa: SLSAInputSpec!) {
	ingestSLSA(subject: $artifact, builtFrom: $materials, builtBy: $builder, slsa: $slsa)
}
`

func SLSAForArtifact(
	ctx context.Context,
	client graphql.Client,
	artifact ArtifactInputSpec,
	materials []ArtifactInputSpec,
	builder BuilderInputSpec,
	slsa SLSAInputSpec,
) (*SLSAForArtifactResponse, error) {
	req := &graphql.Request{
		OpName: "SLSAForArtifact",
		Query:  SLSAForArtifact_Operation,
		Variables: &__SLSAForArtifactInput{
			Artifact:  artifact,
			Materials: materials,
			Builder:   builder,
			Slsa:      slsa,
		},
	}
	var err error

	var data SLSAForArtifactResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by SLSAForArtifacts.
const SLSAForArtifacts_Operation = `
mutation SLSAForArtifacts ($artifacts: [ArtifactInputSpec!]!, $materialsList: [[ArtifactInputSpec!]!]!, $builders: [BuilderInputSpec!]!, $slsaList: [SLSAInputSpec!]!) {
	ingestSLSAs(subjects: $artifacts, builtFromList: $materialsList, builtByList: $builders, slsaList: $slsaList)
}
`

func SLSAForArtifacts(
	ctx context.Context,
	client graphql.Client,
	artifacts []ArtifactInputSpec,
	materialsList [][]ArtifactInputSpec,
	builders []BuilderInputSpec,
	slsaList []SLSAInputSpec,
) (*SLSAForArtifactsResponse, error) {
	req := &graphql.Request{
		OpName: "SLSAForArtifacts",
		Query:  SLSAForArtifacts_Operation,
		Variables: &__SLSAForArtifactsInput{
			Artifacts:     artifacts,
			MaterialsList: materialsList,
			Builders:      builders,
			SlsaList:      slsaList,
		},
	}
	var err error

	var data SLSAForArtifactsResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by Sources.
const Sources_Operation = `
query Sources ($filter: SourceSpec!) {
	sources(sourceSpec: $filter) {
		... AllSourceTree
	}
}
fragment AllSourceTree on Source {
	id
	type
	namespaces {
		id
		namespace
		names {
			id
			name
			tag
			commit
		}
	}
}
`

func Sources(
	ctx context.Context,
	client graphql.Client,
	filter SourceSpec,
) (*SourcesResponse, error) {
	req := &graphql.Request{
		OpName: "Sources",
		Query:  Sources_Operation,
		Variables: &__SourcesInput{
			Filter: filter,
		},
	}
	var err error

	var data SourcesResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by VulnHasMetadata.
const VulnHasMetadata_Operation = `
mutation VulnHasMetadata ($vulnerability: VulnerabilityInputSpec!, $vulnMetadata: VulnerabilityMetadataInputSpec!) {
	ingestVulnerabilityMetadata(vulnerability: $vulnerability, vulnerabilityMetadata: $vulnMetadata)
}
`

func VulnHasMetadata(
	ctx context.Context,
	client graphql.Client,
	vulnerability VulnerabilityInputSpec,
	vulnMetadata VulnerabilityMetadataInputSpec,
) (*VulnHasMetadataResponse, error) {
	req := &graphql.Request{
		OpName: "VulnHasMetadata",
		Query:  VulnHasMetadata_Operation,
		Variables: &__VulnHasMetadataInput{
			Vulnerability: vulnerability,
			VulnMetadata:  vulnMetadata,
		},
	}
	var err error

	var data VulnHasMetadataResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

// The query or mutation executed by Vulnerabilities.
const Vulnerabilities_Operation = `
query Vulnerabilities ($filter: VulnerabilitySpec!) {
	vulnerabilities(vulnSpec: $filter) {
		... AllVulnerabilityTree
	}
}
fragment AllVulnerabilityTree on Vulnerability {
	id
	type
	vulnerabilityIDs {
		id
		vulnerabilityID
	}
}
`

func Vulnerabilities(
	ctx context.Context,
	client graphql.Client,
	filter VulnerabilitySpec,
) (*VulnerabilitiesResponse, error) {
	req := &graphql.Request{
		OpName: "Vulnerabilities",
		Query:  Vulnerabilities_Operation,
		Variables: &__VulnerabilitiesInput{
			Filter: filter,
		},
	}
	var err error

	var data VulnerabilitiesResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}
