// Code generated by github.com/Khan/genqlient, DO NOT EDIT.

package generated

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Khan/genqlient/graphql"
)

// ArtifactInputSpec is the same as Artifact, but used as mutation input.
//
// Both arguments will be canonicalized to lowercase.
type ArtifactInputSpec struct {
	Algorithm string `json:"algorithm"`
	Digest    string `json:"digest"`
}

// GetAlgorithm returns ArtifactInputSpec.Algorithm, and is useful for accessing the field via an interface.
func (v *ArtifactInputSpec) GetAlgorithm() string { return v.Algorithm }

// GetDigest returns ArtifactInputSpec.Digest, and is useful for accessing the field via an interface.
func (v *ArtifactInputSpec) GetDigest() string { return v.Digest }

// CVEInputSpec is the same as CVESpec, but used for mutation ingestion.
type CVEInputSpec struct {
	Year  string `json:"year"`
	CveId string `json:"cveId"`
}

// GetYear returns CVEInputSpec.Year, and is useful for accessing the field via an interface.
func (v *CVEInputSpec) GetYear() string { return v.Year }

// GetCveId returns CVEInputSpec.CveId, and is useful for accessing the field via an interface.
func (v *CVEInputSpec) GetCveId() string { return v.CveId }

// CertifyCVEIngestCVE includes the requested fields of the GraphQL type CVE.
// The GraphQL type's documentation follows.
//
// CVE represents common vulnerabilities and exposures. It contains the year along
// with the CVE ID.
//
// The year is mandatory.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `year` value.
type CertifyCVEIngestCVE struct {
	allCveTree `json:"-"`
}

// GetYear returns CertifyCVEIngestCVE.Year, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestCVE) GetYear() string { return v.allCveTree.Year }

// GetCveId returns CertifyCVEIngestCVE.CveId, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestCVE) GetCveId() []allCveTreeCveIdCVEId { return v.allCveTree.CveId }

func (v *CertifyCVEIngestCVE) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyCVEIngestCVE
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyCVEIngestCVE = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCveTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyCVEIngestCVE struct {
	Year string `json:"year"`

	CveId []allCveTreeCveIdCVEId `json:"cveId"`
}

func (v *CertifyCVEIngestCVE) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyCVEIngestCVE) __premarshalJSON() (*__premarshalCertifyCVEIngestCVE, error) {
	var retval __premarshalCertifyCVEIngestCVE

	retval.Year = v.allCveTree.Year
	retval.CveId = v.allCveTree.CveId
	return &retval, nil
}

// CertifyCVEIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type CertifyCVEIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns CertifyCVEIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns CertifyCVEIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *CertifyCVEIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyCVEIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyCVEIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyCVEIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *CertifyCVEIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyCVEIngestPackage) __premarshalJSON() (*__premarshalCertifyCVEIngestPackage, error) {
	var retval __premarshalCertifyCVEIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// CertifyCVEIngestVulnerabilityCertifyVuln includes the requested fields of the GraphQL type CertifyVuln.
// The GraphQL type's documentation follows.
//
// CertifyVuln is an attestation that represents when a package has a vulnerability
type CertifyCVEIngestVulnerabilityCertifyVuln struct {
	allCertifyVuln `json:"-"`
}

// GetPackage returns CertifyCVEIngestVulnerabilityCertifyVuln.Package, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestVulnerabilityCertifyVuln) GetPackage() allCertifyVulnPackage {
	return v.allCertifyVuln.Package
}

// GetVulnerability returns CertifyCVEIngestVulnerabilityCertifyVuln.Vulnerability, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestVulnerabilityCertifyVuln) GetVulnerability() allCertifyVulnVulnerabilityOsvCveOrGhsa {
	return v.allCertifyVuln.Vulnerability
}

// GetMetadata returns CertifyCVEIngestVulnerabilityCertifyVuln.Metadata, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestVulnerabilityCertifyVuln) GetMetadata() allCertifyVulnMetadataVulnerabilityMetaData {
	return v.allCertifyVuln.Metadata
}

func (v *CertifyCVEIngestVulnerabilityCertifyVuln) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyCVEIngestVulnerabilityCertifyVuln
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyCVEIngestVulnerabilityCertifyVuln = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyVuln)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyCVEIngestVulnerabilityCertifyVuln struct {
	Package allCertifyVulnPackage `json:"package"`

	Vulnerability json.RawMessage `json:"vulnerability"`

	Metadata allCertifyVulnMetadataVulnerabilityMetaData `json:"metadata"`
}

func (v *CertifyCVEIngestVulnerabilityCertifyVuln) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyCVEIngestVulnerabilityCertifyVuln) __premarshalJSON() (*__premarshalCertifyCVEIngestVulnerabilityCertifyVuln, error) {
	var retval __premarshalCertifyCVEIngestVulnerabilityCertifyVuln

	retval.Package = v.allCertifyVuln.Package
	{

		dst := &retval.Vulnerability
		src := v.allCertifyVuln.Vulnerability
		var err error
		*dst, err = __marshalallCertifyVulnVulnerabilityOsvCveOrGhsa(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal CertifyCVEIngestVulnerabilityCertifyVuln.allCertifyVuln.Vulnerability: %w", err)
		}
	}
	retval.Metadata = v.allCertifyVuln.Metadata
	return &retval, nil
}

// CertifyCVEResponse is returned by CertifyCVE on success.
type CertifyCVEResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage CertifyCVEIngestPackage `json:"ingestPackage"`
	// Ingest a new CVE. Returns the ingested object
	IngestCVE CertifyCVEIngestCVE `json:"ingestCVE"`
	// certify that a package is vulnerable to a vulnerability (OSV, CVE or GHSA)
	IngestVulnerability CertifyCVEIngestVulnerabilityCertifyVuln `json:"ingestVulnerability"`
}

// GetIngestPackage returns CertifyCVEResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *CertifyCVEResponse) GetIngestPackage() CertifyCVEIngestPackage { return v.IngestPackage }

// GetIngestCVE returns CertifyCVEResponse.IngestCVE, and is useful for accessing the field via an interface.
func (v *CertifyCVEResponse) GetIngestCVE() CertifyCVEIngestCVE { return v.IngestCVE }

// GetIngestVulnerability returns CertifyCVEResponse.IngestVulnerability, and is useful for accessing the field via an interface.
func (v *CertifyCVEResponse) GetIngestVulnerability() CertifyCVEIngestVulnerabilityCertifyVuln {
	return v.IngestVulnerability
}

// CertifyGHSAIngestGHSA includes the requested fields of the GraphQL type GHSA.
// The GraphQL type's documentation follows.
//
// GHSA represents GitHub security advisories.
//
// We create a separate node to allow retrieving all GHSAs.
type CertifyGHSAIngestGHSA struct {
	allGHSATree `json:"-"`
}

// GetGhsaId returns CertifyGHSAIngestGHSA.GhsaId, and is useful for accessing the field via an interface.
func (v *CertifyGHSAIngestGHSA) GetGhsaId() []allGHSATreeGhsaIdGHSAId { return v.allGHSATree.GhsaId }

func (v *CertifyGHSAIngestGHSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyGHSAIngestGHSA
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyGHSAIngestGHSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allGHSATree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyGHSAIngestGHSA struct {
	GhsaId []allGHSATreeGhsaIdGHSAId `json:"ghsaId"`
}

func (v *CertifyGHSAIngestGHSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyGHSAIngestGHSA) __premarshalJSON() (*__premarshalCertifyGHSAIngestGHSA, error) {
	var retval __premarshalCertifyGHSAIngestGHSA

	retval.GhsaId = v.allGHSATree.GhsaId
	return &retval, nil
}

// CertifyGHSAIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type CertifyGHSAIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns CertifyGHSAIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *CertifyGHSAIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns CertifyGHSAIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *CertifyGHSAIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *CertifyGHSAIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyGHSAIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyGHSAIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyGHSAIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *CertifyGHSAIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyGHSAIngestPackage) __premarshalJSON() (*__premarshalCertifyGHSAIngestPackage, error) {
	var retval __premarshalCertifyGHSAIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// CertifyGHSAIngestVulnerabilityCertifyVuln includes the requested fields of the GraphQL type CertifyVuln.
// The GraphQL type's documentation follows.
//
// CertifyVuln is an attestation that represents when a package has a vulnerability
type CertifyGHSAIngestVulnerabilityCertifyVuln struct {
	allCertifyVuln `json:"-"`
}

// GetPackage returns CertifyGHSAIngestVulnerabilityCertifyVuln.Package, and is useful for accessing the field via an interface.
func (v *CertifyGHSAIngestVulnerabilityCertifyVuln) GetPackage() allCertifyVulnPackage {
	return v.allCertifyVuln.Package
}

// GetVulnerability returns CertifyGHSAIngestVulnerabilityCertifyVuln.Vulnerability, and is useful for accessing the field via an interface.
func (v *CertifyGHSAIngestVulnerabilityCertifyVuln) GetVulnerability() allCertifyVulnVulnerabilityOsvCveOrGhsa {
	return v.allCertifyVuln.Vulnerability
}

// GetMetadata returns CertifyGHSAIngestVulnerabilityCertifyVuln.Metadata, and is useful for accessing the field via an interface.
func (v *CertifyGHSAIngestVulnerabilityCertifyVuln) GetMetadata() allCertifyVulnMetadataVulnerabilityMetaData {
	return v.allCertifyVuln.Metadata
}

func (v *CertifyGHSAIngestVulnerabilityCertifyVuln) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyGHSAIngestVulnerabilityCertifyVuln
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyGHSAIngestVulnerabilityCertifyVuln = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyVuln)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyGHSAIngestVulnerabilityCertifyVuln struct {
	Package allCertifyVulnPackage `json:"package"`

	Vulnerability json.RawMessage `json:"vulnerability"`

	Metadata allCertifyVulnMetadataVulnerabilityMetaData `json:"metadata"`
}

func (v *CertifyGHSAIngestVulnerabilityCertifyVuln) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyGHSAIngestVulnerabilityCertifyVuln) __premarshalJSON() (*__premarshalCertifyGHSAIngestVulnerabilityCertifyVuln, error) {
	var retval __premarshalCertifyGHSAIngestVulnerabilityCertifyVuln

	retval.Package = v.allCertifyVuln.Package
	{

		dst := &retval.Vulnerability
		src := v.allCertifyVuln.Vulnerability
		var err error
		*dst, err = __marshalallCertifyVulnVulnerabilityOsvCveOrGhsa(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal CertifyGHSAIngestVulnerabilityCertifyVuln.allCertifyVuln.Vulnerability: %w", err)
		}
	}
	retval.Metadata = v.allCertifyVuln.Metadata
	return &retval, nil
}

// CertifyGHSAResponse is returned by CertifyGHSA on success.
type CertifyGHSAResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage CertifyGHSAIngestPackage `json:"ingestPackage"`
	// Ingest a new GHSA. Returns the ingested object
	IngestGHSA CertifyGHSAIngestGHSA `json:"ingestGHSA"`
	// certify that a package is vulnerable to a vulnerability (OSV, CVE or GHSA)
	IngestVulnerability CertifyGHSAIngestVulnerabilityCertifyVuln `json:"ingestVulnerability"`
}

// GetIngestPackage returns CertifyGHSAResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *CertifyGHSAResponse) GetIngestPackage() CertifyGHSAIngestPackage { return v.IngestPackage }

// GetIngestGHSA returns CertifyGHSAResponse.IngestGHSA, and is useful for accessing the field via an interface.
func (v *CertifyGHSAResponse) GetIngestGHSA() CertifyGHSAIngestGHSA { return v.IngestGHSA }

// GetIngestVulnerability returns CertifyGHSAResponse.IngestVulnerability, and is useful for accessing the field via an interface.
func (v *CertifyGHSAResponse) GetIngestVulnerability() CertifyGHSAIngestVulnerabilityCertifyVuln {
	return v.IngestVulnerability
}

// CertifyOSVIngestOSV includes the requested fields of the GraphQL type OSV.
// The GraphQL type's documentation follows.
//
// OSV represents an Open Source Vulnerability.
//
// We create a separate node to allow retrieving all OSVs.
type CertifyOSVIngestOSV struct {
	allOSVTree `json:"-"`
}

// GetOsvId returns CertifyOSVIngestOSV.OsvId, and is useful for accessing the field via an interface.
func (v *CertifyOSVIngestOSV) GetOsvId() []allOSVTreeOsvIdOSVId { return v.allOSVTree.OsvId }

func (v *CertifyOSVIngestOSV) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyOSVIngestOSV
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyOSVIngestOSV = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allOSVTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyOSVIngestOSV struct {
	OsvId []allOSVTreeOsvIdOSVId `json:"osvId"`
}

func (v *CertifyOSVIngestOSV) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyOSVIngestOSV) __premarshalJSON() (*__premarshalCertifyOSVIngestOSV, error) {
	var retval __premarshalCertifyOSVIngestOSV

	retval.OsvId = v.allOSVTree.OsvId
	return &retval, nil
}

// CertifyOSVIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type CertifyOSVIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns CertifyOSVIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *CertifyOSVIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns CertifyOSVIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *CertifyOSVIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *CertifyOSVIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyOSVIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyOSVIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyOSVIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *CertifyOSVIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyOSVIngestPackage) __premarshalJSON() (*__premarshalCertifyOSVIngestPackage, error) {
	var retval __premarshalCertifyOSVIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// CertifyOSVIngestVulnerabilityCertifyVuln includes the requested fields of the GraphQL type CertifyVuln.
// The GraphQL type's documentation follows.
//
// CertifyVuln is an attestation that represents when a package has a vulnerability
type CertifyOSVIngestVulnerabilityCertifyVuln struct {
	allCertifyVuln `json:"-"`
}

// GetPackage returns CertifyOSVIngestVulnerabilityCertifyVuln.Package, and is useful for accessing the field via an interface.
func (v *CertifyOSVIngestVulnerabilityCertifyVuln) GetPackage() allCertifyVulnPackage {
	return v.allCertifyVuln.Package
}

// GetVulnerability returns CertifyOSVIngestVulnerabilityCertifyVuln.Vulnerability, and is useful for accessing the field via an interface.
func (v *CertifyOSVIngestVulnerabilityCertifyVuln) GetVulnerability() allCertifyVulnVulnerabilityOsvCveOrGhsa {
	return v.allCertifyVuln.Vulnerability
}

// GetMetadata returns CertifyOSVIngestVulnerabilityCertifyVuln.Metadata, and is useful for accessing the field via an interface.
func (v *CertifyOSVIngestVulnerabilityCertifyVuln) GetMetadata() allCertifyVulnMetadataVulnerabilityMetaData {
	return v.allCertifyVuln.Metadata
}

func (v *CertifyOSVIngestVulnerabilityCertifyVuln) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyOSVIngestVulnerabilityCertifyVuln
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyOSVIngestVulnerabilityCertifyVuln = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyVuln)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyOSVIngestVulnerabilityCertifyVuln struct {
	Package allCertifyVulnPackage `json:"package"`

	Vulnerability json.RawMessage `json:"vulnerability"`

	Metadata allCertifyVulnMetadataVulnerabilityMetaData `json:"metadata"`
}

func (v *CertifyOSVIngestVulnerabilityCertifyVuln) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyOSVIngestVulnerabilityCertifyVuln) __premarshalJSON() (*__premarshalCertifyOSVIngestVulnerabilityCertifyVuln, error) {
	var retval __premarshalCertifyOSVIngestVulnerabilityCertifyVuln

	retval.Package = v.allCertifyVuln.Package
	{

		dst := &retval.Vulnerability
		src := v.allCertifyVuln.Vulnerability
		var err error
		*dst, err = __marshalallCertifyVulnVulnerabilityOsvCveOrGhsa(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal CertifyOSVIngestVulnerabilityCertifyVuln.allCertifyVuln.Vulnerability: %w", err)
		}
	}
	retval.Metadata = v.allCertifyVuln.Metadata
	return &retval, nil
}

// CertifyOSVResponse is returned by CertifyOSV on success.
type CertifyOSVResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage CertifyOSVIngestPackage `json:"ingestPackage"`
	// Ingest a new OSV. Returns the ingested object
	IngestOSV CertifyOSVIngestOSV `json:"ingestOSV"`
	// certify that a package is vulnerable to a vulnerability (OSV, CVE or GHSA)
	IngestVulnerability CertifyOSVIngestVulnerabilityCertifyVuln `json:"ingestVulnerability"`
}

// GetIngestPackage returns CertifyOSVResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *CertifyOSVResponse) GetIngestPackage() CertifyOSVIngestPackage { return v.IngestPackage }

// GetIngestOSV returns CertifyOSVResponse.IngestOSV, and is useful for accessing the field via an interface.
func (v *CertifyOSVResponse) GetIngestOSV() CertifyOSVIngestOSV { return v.IngestOSV }

// GetIngestVulnerability returns CertifyOSVResponse.IngestVulnerability, and is useful for accessing the field via an interface.
func (v *CertifyOSVResponse) GetIngestVulnerability() CertifyOSVIngestVulnerabilityCertifyVuln {
	return v.IngestVulnerability
}

// CertifyPkgDependentPkgPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type CertifyPkgDependentPkgPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns CertifyPkgDependentPkgPackage.Type, and is useful for accessing the field via an interface.
func (v *CertifyPkgDependentPkgPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns CertifyPkgDependentPkgPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *CertifyPkgDependentPkgPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *CertifyPkgDependentPkgPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyPkgDependentPkgPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyPkgDependentPkgPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyPkgDependentPkgPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *CertifyPkgDependentPkgPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyPkgDependentPkgPackage) __premarshalJSON() (*__premarshalCertifyPkgDependentPkgPackage, error) {
	var retval __premarshalCertifyPkgDependentPkgPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// CertifyPkgIngestCertifyPkg includes the requested fields of the GraphQL type CertifyPkg.
// The GraphQL type's documentation follows.
//
// # CertifyPkg is an attestation that represents when a package objects are similar
//
// packages (subject) - list of package objects
// justification (property) - string value representing why the packages are similar
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type CertifyPkgIngestCertifyPkg struct {
	allCertifyPkg `json:"-"`
}

// GetJustification returns CertifyPkgIngestCertifyPkg.Justification, and is useful for accessing the field via an interface.
func (v *CertifyPkgIngestCertifyPkg) GetJustification() string { return v.allCertifyPkg.Justification }

// GetPackages returns CertifyPkgIngestCertifyPkg.Packages, and is useful for accessing the field via an interface.
func (v *CertifyPkgIngestCertifyPkg) GetPackages() []allCertifyPkgPackagesPackage {
	return v.allCertifyPkg.Packages
}

// GetOrigin returns CertifyPkgIngestCertifyPkg.Origin, and is useful for accessing the field via an interface.
func (v *CertifyPkgIngestCertifyPkg) GetOrigin() string { return v.allCertifyPkg.Origin }

// GetCollector returns CertifyPkgIngestCertifyPkg.Collector, and is useful for accessing the field via an interface.
func (v *CertifyPkgIngestCertifyPkg) GetCollector() string { return v.allCertifyPkg.Collector }

func (v *CertifyPkgIngestCertifyPkg) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyPkgIngestCertifyPkg
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyPkgIngestCertifyPkg = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyPkg)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyPkgIngestCertifyPkg struct {
	Justification string `json:"justification"`

	Packages []allCertifyPkgPackagesPackage `json:"packages"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *CertifyPkgIngestCertifyPkg) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyPkgIngestCertifyPkg) __premarshalJSON() (*__premarshalCertifyPkgIngestCertifyPkg, error) {
	var retval __premarshalCertifyPkgIngestCertifyPkg

	retval.Justification = v.allCertifyPkg.Justification
	retval.Packages = v.allCertifyPkg.Packages
	retval.Origin = v.allCertifyPkg.Origin
	retval.Collector = v.allCertifyPkg.Collector
	return &retval, nil
}

// CertifyPkgInputSpec is the same as CertifyPkg but for mutation input.
//
// All fields are required.
type CertifyPkgInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetJustification returns CertifyPkgInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *CertifyPkgInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns CertifyPkgInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *CertifyPkgInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns CertifyPkgInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *CertifyPkgInputSpec) GetCollector() string { return v.Collector }

// CertifyPkgPkgPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type CertifyPkgPkgPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns CertifyPkgPkgPackage.Type, and is useful for accessing the field via an interface.
func (v *CertifyPkgPkgPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns CertifyPkgPkgPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *CertifyPkgPkgPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *CertifyPkgPkgPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyPkgPkgPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyPkgPkgPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyPkgPkgPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *CertifyPkgPkgPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyPkgPkgPackage) __premarshalJSON() (*__premarshalCertifyPkgPkgPackage, error) {
	var retval __premarshalCertifyPkgPkgPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// CertifyPkgResponse is returned by CertifyPkg on success.
type CertifyPkgResponse struct {
	// Ingest a new package. Returns the ingested package trie
	Pkg CertifyPkgPkgPackage `json:"pkg"`
	// Ingest a new package. Returns the ingested package trie
	DependentPkg CertifyPkgDependentPkgPackage `json:"dependentPkg"`
	// Adds a certification that two packages are similar
	IngestCertifyPkg CertifyPkgIngestCertifyPkg `json:"ingestCertifyPkg"`
}

// GetPkg returns CertifyPkgResponse.Pkg, and is useful for accessing the field via an interface.
func (v *CertifyPkgResponse) GetPkg() CertifyPkgPkgPackage { return v.Pkg }

// GetDependentPkg returns CertifyPkgResponse.DependentPkg, and is useful for accessing the field via an interface.
func (v *CertifyPkgResponse) GetDependentPkg() CertifyPkgDependentPkgPackage { return v.DependentPkg }

// GetIngestCertifyPkg returns CertifyPkgResponse.IngestCertifyPkg, and is useful for accessing the field via an interface.
func (v *CertifyPkgResponse) GetIngestCertifyPkg() CertifyPkgIngestCertifyPkg {
	return v.IngestCertifyPkg
}

// GHSAInputSpec is the same as GHSASpec, but used for mutation ingestion.
type GHSAInputSpec struct {
	GhsaId string `json:"ghsaId"`
}

// GetGhsaId returns GHSAInputSpec.GhsaId, and is useful for accessing the field via an interface.
func (v *GHSAInputSpec) GetGhsaId() string { return v.GhsaId }

// IsDependencyDependentPkgPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type IsDependencyDependentPkgPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns IsDependencyDependentPkgPackage.Type, and is useful for accessing the field via an interface.
func (v *IsDependencyDependentPkgPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns IsDependencyDependentPkgPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *IsDependencyDependentPkgPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *IsDependencyDependentPkgPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsDependencyDependentPkgPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.IsDependencyDependentPkgPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsDependencyDependentPkgPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *IsDependencyDependentPkgPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsDependencyDependentPkgPackage) __premarshalJSON() (*__premarshalIsDependencyDependentPkgPackage, error) {
	var retval __premarshalIsDependencyDependentPkgPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// IsDependencyIngestDependencyIsDependency includes the requested fields of the GraphQL type IsDependency.
// The GraphQL type's documentation follows.
//
// # IsDependency is an attestation that represents when a package is dependent on another package
//
// package (subject) - the package object type that represents the package
// dependentPackage (object) - the package object type that represents the packageName (cannot be to the packageVersion)
// versionRange (property) - string value for version range that applies to the dependent package
// justification (property) - string value representing why the artifacts are the equal
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type IsDependencyIngestDependencyIsDependency struct {
	allIsDependencyTree `json:"-"`
}

// GetJustification returns IsDependencyIngestDependencyIsDependency.Justification, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetJustification() string {
	return v.allIsDependencyTree.Justification
}

// GetPackage returns IsDependencyIngestDependencyIsDependency.Package, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetPackage() allIsDependencyTreePackage {
	return v.allIsDependencyTree.Package
}

// GetDependentPackage returns IsDependencyIngestDependencyIsDependency.DependentPackage, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetDependentPackage() allIsDependencyTreeDependentPackage {
	return v.allIsDependencyTree.DependentPackage
}

// GetVersionRange returns IsDependencyIngestDependencyIsDependency.VersionRange, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetVersionRange() string {
	return v.allIsDependencyTree.VersionRange
}

// GetOrigin returns IsDependencyIngestDependencyIsDependency.Origin, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetOrigin() string {
	return v.allIsDependencyTree.Origin
}

// GetCollector returns IsDependencyIngestDependencyIsDependency.Collector, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetCollector() string {
	return v.allIsDependencyTree.Collector
}

func (v *IsDependencyIngestDependencyIsDependency) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsDependencyIngestDependencyIsDependency
		graphql.NoUnmarshalJSON
	}
	firstPass.IsDependencyIngestDependencyIsDependency = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allIsDependencyTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsDependencyIngestDependencyIsDependency struct {
	Justification string `json:"justification"`

	Package allIsDependencyTreePackage `json:"package"`

	DependentPackage allIsDependencyTreeDependentPackage `json:"dependentPackage"`

	VersionRange string `json:"versionRange"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *IsDependencyIngestDependencyIsDependency) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsDependencyIngestDependencyIsDependency) __premarshalJSON() (*__premarshalIsDependencyIngestDependencyIsDependency, error) {
	var retval __premarshalIsDependencyIngestDependencyIsDependency

	retval.Justification = v.allIsDependencyTree.Justification
	retval.Package = v.allIsDependencyTree.Package
	retval.DependentPackage = v.allIsDependencyTree.DependentPackage
	retval.VersionRange = v.allIsDependencyTree.VersionRange
	retval.Origin = v.allIsDependencyTree.Origin
	retval.Collector = v.allIsDependencyTree.Collector
	return &retval, nil
}

// IsDependencyInputSpec is the same as IsDependency but for mutation input.
//
// All fields are required.
type IsDependencyInputSpec struct {
	VersionRange  string `json:"versionRange"`
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetVersionRange returns IsDependencyInputSpec.VersionRange, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetVersionRange() string { return v.VersionRange }

// GetJustification returns IsDependencyInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns IsDependencyInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns IsDependencyInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetCollector() string { return v.Collector }

// IsDependencyPkgPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type IsDependencyPkgPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns IsDependencyPkgPackage.Type, and is useful for accessing the field via an interface.
func (v *IsDependencyPkgPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns IsDependencyPkgPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *IsDependencyPkgPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *IsDependencyPkgPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsDependencyPkgPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.IsDependencyPkgPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsDependencyPkgPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *IsDependencyPkgPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsDependencyPkgPackage) __premarshalJSON() (*__premarshalIsDependencyPkgPackage, error) {
	var retval __premarshalIsDependencyPkgPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// IsDependencyResponse is returned by IsDependency on success.
type IsDependencyResponse struct {
	// Ingest a new package. Returns the ingested package trie
	Pkg IsDependencyPkgPackage `json:"pkg"`
	// Ingest a new package. Returns the ingested package trie
	DependentPkg IsDependencyDependentPkgPackage `json:"dependentPkg"`
	// Adds dependency between two packages
	IngestDependency IsDependencyIngestDependencyIsDependency `json:"ingestDependency"`
}

// GetPkg returns IsDependencyResponse.Pkg, and is useful for accessing the field via an interface.
func (v *IsDependencyResponse) GetPkg() IsDependencyPkgPackage { return v.Pkg }

// GetDependentPkg returns IsDependencyResponse.DependentPkg, and is useful for accessing the field via an interface.
func (v *IsDependencyResponse) GetDependentPkg() IsDependencyDependentPkgPackage {
	return v.DependentPkg
}

// GetIngestDependency returns IsDependencyResponse.IngestDependency, and is useful for accessing the field via an interface.
func (v *IsDependencyResponse) GetIngestDependency() IsDependencyIngestDependencyIsDependency {
	return v.IngestDependency
}

// IsOccurrenceInputSpec is the same as IsOccurrence but for mutation input.
//
// All fields are required.
type IsOccurrenceInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetJustification returns IsOccurrenceInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *IsOccurrenceInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns IsOccurrenceInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *IsOccurrenceInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns IsOccurrenceInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *IsOccurrenceInputSpec) GetCollector() string { return v.Collector }

// IsOccurrencePkgIngestArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type IsOccurrencePkgIngestArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns IsOccurrencePkgIngestArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns IsOccurrencePkgIngestArtifact.Digest, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *IsOccurrencePkgIngestArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrencePkgIngestArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrencePkgIngestArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrencePkgIngestArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *IsOccurrencePkgIngestArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrencePkgIngestArtifact) __premarshalJSON() (*__premarshalIsOccurrencePkgIngestArtifact, error) {
	var retval __premarshalIsOccurrencePkgIngestArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// IsOccurrencePkgIngestOccurrenceIsOccurrence includes the requested fields of the GraphQL type IsOccurrence.
// The GraphQL type's documentation follows.
//
// # IsOccurrence is an attestation represents when either a package or source is represented by an artifact
//
// Note: Package or Source must be specified but not both at the same time.
// Attestation must occur at the PackageVersion or at the SourceName.
type IsOccurrencePkgIngestOccurrenceIsOccurrence struct {
	allIsOccurrencesTree `json:"-"`
}

// GetSubject returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Subject, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetSubject() allIsOccurrencesTreeSubjectPackageOrSource {
	return v.allIsOccurrencesTree.Subject
}

// GetArtifact returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Artifact, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetArtifact() allIsOccurrencesTreeArtifact {
	return v.allIsOccurrencesTree.Artifact
}

// GetJustification returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Justification, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetJustification() string {
	return v.allIsOccurrencesTree.Justification
}

// GetOrigin returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Origin, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetOrigin() string {
	return v.allIsOccurrencesTree.Origin
}

// GetCollector returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Collector, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetCollector() string {
	return v.allIsOccurrencesTree.Collector
}

func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrencePkgIngestOccurrenceIsOccurrence
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrencePkgIngestOccurrenceIsOccurrence = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allIsOccurrencesTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrencePkgIngestOccurrenceIsOccurrence struct {
	Subject json.RawMessage `json:"subject"`

	Artifact allIsOccurrencesTreeArtifact `json:"artifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) __premarshalJSON() (*__premarshalIsOccurrencePkgIngestOccurrenceIsOccurrence, error) {
	var retval __premarshalIsOccurrencePkgIngestOccurrenceIsOccurrence

	{

		dst := &retval.Subject
		src := v.allIsOccurrencesTree.Subject
		var err error
		*dst, err = __marshalallIsOccurrencesTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal IsOccurrencePkgIngestOccurrenceIsOccurrence.allIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.Artifact = v.allIsOccurrencesTree.Artifact
	retval.Justification = v.allIsOccurrencesTree.Justification
	retval.Origin = v.allIsOccurrencesTree.Origin
	retval.Collector = v.allIsOccurrencesTree.Collector
	return &retval, nil
}

// IsOccurrencePkgIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type IsOccurrencePkgIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns IsOccurrencePkgIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns IsOccurrencePkgIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *IsOccurrencePkgIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrencePkgIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrencePkgIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrencePkgIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *IsOccurrencePkgIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrencePkgIngestPackage) __premarshalJSON() (*__premarshalIsOccurrencePkgIngestPackage, error) {
	var retval __premarshalIsOccurrencePkgIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// IsOccurrencePkgResponse is returned by IsOccurrencePkg on success.
type IsOccurrencePkgResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage IsOccurrencePkgIngestPackage `json:"ingestPackage"`
	// Ingest a new artifact. Returns the ingested artifact
	IngestArtifact IsOccurrencePkgIngestArtifact `json:"ingestArtifact"`
	// Adds an artifact as an occurrence for either a package or a source
	IngestOccurrence IsOccurrencePkgIngestOccurrenceIsOccurrence `json:"ingestOccurrence"`
}

// GetIngestPackage returns IsOccurrencePkgResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgResponse) GetIngestPackage() IsOccurrencePkgIngestPackage {
	return v.IngestPackage
}

// GetIngestArtifact returns IsOccurrencePkgResponse.IngestArtifact, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgResponse) GetIngestArtifact() IsOccurrencePkgIngestArtifact {
	return v.IngestArtifact
}

// GetIngestOccurrence returns IsOccurrencePkgResponse.IngestOccurrence, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgResponse) GetIngestOccurrence() IsOccurrencePkgIngestOccurrenceIsOccurrence {
	return v.IngestOccurrence
}

// IsOccurrenceSrcIngestArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type IsOccurrenceSrcIngestArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns IsOccurrenceSrcIngestArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns IsOccurrenceSrcIngestArtifact.Digest, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *IsOccurrenceSrcIngestArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrenceSrcIngestArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrenceSrcIngestArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrenceSrcIngestArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *IsOccurrenceSrcIngestArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrenceSrcIngestArtifact) __premarshalJSON() (*__premarshalIsOccurrenceSrcIngestArtifact, error) {
	var retval __premarshalIsOccurrenceSrcIngestArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// IsOccurrenceSrcIngestOccurrenceIsOccurrence includes the requested fields of the GraphQL type IsOccurrence.
// The GraphQL type's documentation follows.
//
// # IsOccurrence is an attestation represents when either a package or source is represented by an artifact
//
// Note: Package or Source must be specified but not both at the same time.
// Attestation must occur at the PackageVersion or at the SourceName.
type IsOccurrenceSrcIngestOccurrenceIsOccurrence struct {
	allIsOccurrencesTree `json:"-"`
}

// GetSubject returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Subject, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetSubject() allIsOccurrencesTreeSubjectPackageOrSource {
	return v.allIsOccurrencesTree.Subject
}

// GetArtifact returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Artifact, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetArtifact() allIsOccurrencesTreeArtifact {
	return v.allIsOccurrencesTree.Artifact
}

// GetJustification returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Justification, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetJustification() string {
	return v.allIsOccurrencesTree.Justification
}

// GetOrigin returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Origin, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetOrigin() string {
	return v.allIsOccurrencesTree.Origin
}

// GetCollector returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Collector, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetCollector() string {
	return v.allIsOccurrencesTree.Collector
}

func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrenceSrcIngestOccurrenceIsOccurrence
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrenceSrcIngestOccurrenceIsOccurrence = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allIsOccurrencesTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrenceSrcIngestOccurrenceIsOccurrence struct {
	Subject json.RawMessage `json:"subject"`

	Artifact allIsOccurrencesTreeArtifact `json:"artifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) __premarshalJSON() (*__premarshalIsOccurrenceSrcIngestOccurrenceIsOccurrence, error) {
	var retval __premarshalIsOccurrenceSrcIngestOccurrenceIsOccurrence

	{

		dst := &retval.Subject
		src := v.allIsOccurrencesTree.Subject
		var err error
		*dst, err = __marshalallIsOccurrencesTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal IsOccurrenceSrcIngestOccurrenceIsOccurrence.allIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.Artifact = v.allIsOccurrencesTree.Artifact
	retval.Justification = v.allIsOccurrencesTree.Justification
	retval.Origin = v.allIsOccurrencesTree.Origin
	retval.Collector = v.allIsOccurrencesTree.Collector
	return &retval, nil
}

// IsOccurrenceSrcIngestSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type IsOccurrenceSrcIngestSource struct {
	allSrcTree `json:"-"`
}

// GetType returns IsOccurrenceSrcIngestSource.Type, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestSource) GetType() string { return v.allSrcTree.Type }

// GetNamespaces returns IsOccurrenceSrcIngestSource.Namespaces, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestSource) GetNamespaces() []allSrcTreeNamespacesSourceNamespace {
	return v.allSrcTree.Namespaces
}

func (v *IsOccurrenceSrcIngestSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrenceSrcIngestSource
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrenceSrcIngestSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSrcTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrenceSrcIngestSource struct {
	Type string `json:"type"`

	Namespaces []allSrcTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *IsOccurrenceSrcIngestSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrenceSrcIngestSource) __premarshalJSON() (*__premarshalIsOccurrenceSrcIngestSource, error) {
	var retval __premarshalIsOccurrenceSrcIngestSource

	retval.Type = v.allSrcTree.Type
	retval.Namespaces = v.allSrcTree.Namespaces
	return &retval, nil
}

// IsOccurrenceSrcResponse is returned by IsOccurrenceSrc on success.
type IsOccurrenceSrcResponse struct {
	// Ingest a new source. Returns the ingested source trie
	IngestSource IsOccurrenceSrcIngestSource `json:"ingestSource"`
	// Ingest a new artifact. Returns the ingested artifact
	IngestArtifact IsOccurrenceSrcIngestArtifact `json:"ingestArtifact"`
	// Adds an artifact as an occurrence for either a package or a source
	IngestOccurrence IsOccurrenceSrcIngestOccurrenceIsOccurrence `json:"ingestOccurrence"`
}

// GetIngestSource returns IsOccurrenceSrcResponse.IngestSource, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcResponse) GetIngestSource() IsOccurrenceSrcIngestSource {
	return v.IngestSource
}

// GetIngestArtifact returns IsOccurrenceSrcResponse.IngestArtifact, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcResponse) GetIngestArtifact() IsOccurrenceSrcIngestArtifact {
	return v.IngestArtifact
}

// GetIngestOccurrence returns IsOccurrenceSrcResponse.IngestOccurrence, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcResponse) GetIngestOccurrence() IsOccurrenceSrcIngestOccurrenceIsOccurrence {
	return v.IngestOccurrence
}

// OSVInputSpec is the same as OSVSpec, but used for mutation ingestion.
type OSVInputSpec struct {
	OsvId string `json:"osvId"`
}

// GetOsvId returns OSVInputSpec.OsvId, and is useful for accessing the field via an interface.
func (v *OSVInputSpec) GetOsvId() string { return v.OsvId }

// PackageQualifierInputSpec is the same as PackageQualifier, but usable as
// mutation input.
//
// GraphQL does not allow input types to contain composite types and does not allow
// composite types to contain input types. So, although in this case these two
// types are semantically the same, we have to duplicate the definition.
//
// Both fields are mandatory.
type PackageQualifierInputSpec struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns PackageQualifierInputSpec.Key, and is useful for accessing the field via an interface.
func (v *PackageQualifierInputSpec) GetKey() string { return v.Key }

// GetValue returns PackageQualifierInputSpec.Value, and is useful for accessing the field via an interface.
func (v *PackageQualifierInputSpec) GetValue() string { return v.Value }

// PkgInputSpec specifies a package for a mutation.
//
// This is different than PkgSpec because we want to encode mandatory fields:
// `type` and `name`. All optional fields are given empty default values.
type PkgInputSpec struct {
	Type       string                      `json:"type"`
	Namespace  *string                     `json:"namespace"`
	Name       string                      `json:"name"`
	Version    *string                     `json:"version"`
	Qualifiers []PackageQualifierInputSpec `json:"qualifiers"`
	Subpath    *string                     `json:"subpath"`
}

// GetType returns PkgInputSpec.Type, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetType() string { return v.Type }

// GetNamespace returns PkgInputSpec.Namespace, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetNamespace() *string { return v.Namespace }

// GetName returns PkgInputSpec.Name, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetName() string { return v.Name }

// GetVersion returns PkgInputSpec.Version, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetVersion() *string { return v.Version }

// GetQualifiers returns PkgInputSpec.Qualifiers, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetQualifiers() []PackageQualifierInputSpec { return v.Qualifiers }

// GetSubpath returns PkgInputSpec.Subpath, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetSubpath() *string { return v.Subpath }

// ScorecardCertifyScorecard includes the requested fields of the GraphQL type CertifyScorecard.
// The GraphQL type's documentation follows.
//
// CertifyScorecard is an attestation which represents the scorecard of a
// particular source repository.
type ScorecardCertifyScorecard struct {
	allCertifyScorecard `json:"-"`
}

// GetSource returns ScorecardCertifyScorecard.Source, and is useful for accessing the field via an interface.
func (v *ScorecardCertifyScorecard) GetSource() allCertifyScorecardSource {
	return v.allCertifyScorecard.Source
}

// GetScorecard returns ScorecardCertifyScorecard.Scorecard, and is useful for accessing the field via an interface.
func (v *ScorecardCertifyScorecard) GetScorecard() allCertifyScorecardScorecard {
	return v.allCertifyScorecard.Scorecard
}

func (v *ScorecardCertifyScorecard) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*ScorecardCertifyScorecard
		graphql.NoUnmarshalJSON
	}
	firstPass.ScorecardCertifyScorecard = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyScorecard)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalScorecardCertifyScorecard struct {
	Source allCertifyScorecardSource `json:"source"`

	Scorecard allCertifyScorecardScorecard `json:"scorecard"`
}

func (v *ScorecardCertifyScorecard) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *ScorecardCertifyScorecard) __premarshalJSON() (*__premarshalScorecardCertifyScorecard, error) {
	var retval __premarshalScorecardCertifyScorecard

	retval.Source = v.allCertifyScorecard.Source
	retval.Scorecard = v.allCertifyScorecard.Scorecard
	return &retval, nil
}

// ScorecardCheckInputSpec is the same as ScorecardCheck, but for mutation input.
type ScorecardCheckInputSpec struct {
	Check string `json:"check"`
	Score int    `json:"score"`
}

// GetCheck returns ScorecardCheckInputSpec.Check, and is useful for accessing the field via an interface.
func (v *ScorecardCheckInputSpec) GetCheck() string { return v.Check }

// GetScore returns ScorecardCheckInputSpec.Score, and is useful for accessing the field via an interface.
func (v *ScorecardCheckInputSpec) GetScore() int { return v.Score }

// ScorecardIngestSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type ScorecardIngestSource struct {
	allSrcTree `json:"-"`
}

// GetType returns ScorecardIngestSource.Type, and is useful for accessing the field via an interface.
func (v *ScorecardIngestSource) GetType() string { return v.allSrcTree.Type }

// GetNamespaces returns ScorecardIngestSource.Namespaces, and is useful for accessing the field via an interface.
func (v *ScorecardIngestSource) GetNamespaces() []allSrcTreeNamespacesSourceNamespace {
	return v.allSrcTree.Namespaces
}

func (v *ScorecardIngestSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*ScorecardIngestSource
		graphql.NoUnmarshalJSON
	}
	firstPass.ScorecardIngestSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSrcTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalScorecardIngestSource struct {
	Type string `json:"type"`

	Namespaces []allSrcTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *ScorecardIngestSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *ScorecardIngestSource) __premarshalJSON() (*__premarshalScorecardIngestSource, error) {
	var retval __premarshalScorecardIngestSource

	retval.Type = v.allSrcTree.Type
	retval.Namespaces = v.allSrcTree.Namespaces
	return &retval, nil
}

// ScorecardInputSpec is the same as Scorecard but for mutation input.
//
// All fields are required.
type ScorecardInputSpec struct {
	Checks           []ScorecardCheckInputSpec `json:"checks"`
	AggregateScore   float64                   `json:"aggregateScore"`
	TimeScanned      time.Time                 `json:"timeScanned"`
	ScorecardVersion string                    `json:"scorecardVersion"`
	ScorecardCommit  string                    `json:"scorecardCommit"`
	Origin           string                    `json:"origin"`
	Collector        string                    `json:"collector"`
}

// GetChecks returns ScorecardInputSpec.Checks, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetChecks() []ScorecardCheckInputSpec { return v.Checks }

// GetAggregateScore returns ScorecardInputSpec.AggregateScore, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetAggregateScore() float64 { return v.AggregateScore }

// GetTimeScanned returns ScorecardInputSpec.TimeScanned, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetTimeScanned() time.Time { return v.TimeScanned }

// GetScorecardVersion returns ScorecardInputSpec.ScorecardVersion, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetScorecardVersion() string { return v.ScorecardVersion }

// GetScorecardCommit returns ScorecardInputSpec.ScorecardCommit, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetScorecardCommit() string { return v.ScorecardCommit }

// GetOrigin returns ScorecardInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns ScorecardInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetCollector() string { return v.Collector }

// ScorecardResponse is returned by Scorecard on success.
type ScorecardResponse struct {
	// Ingest a new source. Returns the ingested source trie
	IngestSource ScorecardIngestSource `json:"ingestSource"`
	// Certifies the Scorecard scanning of a source repository
	CertifyScorecard ScorecardCertifyScorecard `json:"certifyScorecard"`
}

// GetIngestSource returns ScorecardResponse.IngestSource, and is useful for accessing the field via an interface.
func (v *ScorecardResponse) GetIngestSource() ScorecardIngestSource { return v.IngestSource }

// GetCertifyScorecard returns ScorecardResponse.CertifyScorecard, and is useful for accessing the field via an interface.
func (v *ScorecardResponse) GetCertifyScorecard() ScorecardCertifyScorecard {
	return v.CertifyScorecard
}

// SourceInputSpec specifies a source for a mutation.
//
// This is different than SourceSpec because we want to encode that all fields
// except tag and commit are mandatory fields. All optional fields are given
// empty default values.
//
// It is an error to set both `tag` and `commit` fields to values different than
// the default.
type SourceInputSpec struct {
	Type      string  `json:"type"`
	Namespace string  `json:"namespace"`
	Name      string  `json:"name"`
	Tag       *string `json:"tag"`
	Commit    *string `json:"commit"`
}

// GetType returns SourceInputSpec.Type, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetType() string { return v.Type }

// GetNamespace returns SourceInputSpec.Namespace, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetNamespace() string { return v.Namespace }

// GetName returns SourceInputSpec.Name, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetName() string { return v.Name }

// GetTag returns SourceInputSpec.Tag, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetTag() *string { return v.Tag }

// GetCommit returns SourceInputSpec.Commit, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetCommit() *string { return v.Commit }

// VulnerabilityInputSpec is the same as VulnerabilityMetaData but for mutation input.
//
// All fields are required.
type VulnerabilityMetaDataInput struct {
	TimeScanned    time.Time `json:"timeScanned"`
	DbUri          string    `json:"dbUri"`
	DbVersion      string    `json:"dbVersion"`
	ScannerUri     string    `json:"scannerUri"`
	ScannerVersion string    `json:"scannerVersion"`
	Origin         string    `json:"origin"`
	Collector      string    `json:"collector"`
}

// GetTimeScanned returns VulnerabilityMetaDataInput.TimeScanned, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetTimeScanned() time.Time { return v.TimeScanned }

// GetDbUri returns VulnerabilityMetaDataInput.DbUri, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetDbUri() string { return v.DbUri }

// GetDbVersion returns VulnerabilityMetaDataInput.DbVersion, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetDbVersion() string { return v.DbVersion }

// GetScannerUri returns VulnerabilityMetaDataInput.ScannerUri, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetScannerUri() string { return v.ScannerUri }

// GetScannerVersion returns VulnerabilityMetaDataInput.ScannerVersion, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetScannerVersion() string { return v.ScannerVersion }

// GetOrigin returns VulnerabilityMetaDataInput.Origin, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetOrigin() string { return v.Origin }

// GetCollector returns VulnerabilityMetaDataInput.Collector, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetCollector() string { return v.Collector }

// __CertifyCVEInput is used internally by genqlient
type __CertifyCVEInput struct {
	Pkg         PkgInputSpec               `json:"pkg"`
	Cve         CVEInputSpec               `json:"cve"`
	CertifyVuln VulnerabilityMetaDataInput `json:"certifyVuln"`
}

// GetPkg returns __CertifyCVEInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyCVEInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetCve returns __CertifyCVEInput.Cve, and is useful for accessing the field via an interface.
func (v *__CertifyCVEInput) GetCve() CVEInputSpec { return v.Cve }

// GetCertifyVuln returns __CertifyCVEInput.CertifyVuln, and is useful for accessing the field via an interface.
func (v *__CertifyCVEInput) GetCertifyVuln() VulnerabilityMetaDataInput { return v.CertifyVuln }

// __CertifyGHSAInput is used internally by genqlient
type __CertifyGHSAInput struct {
	Pkg         PkgInputSpec               `json:"pkg"`
	Ghsa        GHSAInputSpec              `json:"ghsa"`
	CertifyVuln VulnerabilityMetaDataInput `json:"certifyVuln"`
}

// GetPkg returns __CertifyGHSAInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyGHSAInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetGhsa returns __CertifyGHSAInput.Ghsa, and is useful for accessing the field via an interface.
func (v *__CertifyGHSAInput) GetGhsa() GHSAInputSpec { return v.Ghsa }

// GetCertifyVuln returns __CertifyGHSAInput.CertifyVuln, and is useful for accessing the field via an interface.
func (v *__CertifyGHSAInput) GetCertifyVuln() VulnerabilityMetaDataInput { return v.CertifyVuln }

// __CertifyOSVInput is used internally by genqlient
type __CertifyOSVInput struct {
	Pkg         PkgInputSpec               `json:"pkg"`
	Osv         OSVInputSpec               `json:"osv"`
	CertifyVuln VulnerabilityMetaDataInput `json:"certifyVuln"`
}

// GetPkg returns __CertifyOSVInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyOSVInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetOsv returns __CertifyOSVInput.Osv, and is useful for accessing the field via an interface.
func (v *__CertifyOSVInput) GetOsv() OSVInputSpec { return v.Osv }

// GetCertifyVuln returns __CertifyOSVInput.CertifyVuln, and is useful for accessing the field via an interface.
func (v *__CertifyOSVInput) GetCertifyVuln() VulnerabilityMetaDataInput { return v.CertifyVuln }

// __CertifyPkgInput is used internally by genqlient
type __CertifyPkgInput struct {
	Pkg        PkgInputSpec        `json:"pkg"`
	DepPkg     PkgInputSpec        `json:"depPkg"`
	CertifyPkg CertifyPkgInputSpec `json:"certifyPkg"`
}

// GetPkg returns __CertifyPkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyPkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetDepPkg returns __CertifyPkgInput.DepPkg, and is useful for accessing the field via an interface.
func (v *__CertifyPkgInput) GetDepPkg() PkgInputSpec { return v.DepPkg }

// GetCertifyPkg returns __CertifyPkgInput.CertifyPkg, and is useful for accessing the field via an interface.
func (v *__CertifyPkgInput) GetCertifyPkg() CertifyPkgInputSpec { return v.CertifyPkg }

// __IsDependencyInput is used internally by genqlient
type __IsDependencyInput struct {
	Pkg        PkgInputSpec          `json:"pkg"`
	DepPkg     PkgInputSpec          `json:"depPkg"`
	Dependency IsDependencyInputSpec `json:"dependency"`
}

// GetPkg returns __IsDependencyInput.Pkg, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetDepPkg returns __IsDependencyInput.DepPkg, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetDepPkg() PkgInputSpec { return v.DepPkg }

// GetDependency returns __IsDependencyInput.Dependency, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetDependency() IsDependencyInputSpec { return v.Dependency }

// __IsOccurrencePkgInput is used internally by genqlient
type __IsOccurrencePkgInput struct {
	Pkg        PkgInputSpec          `json:"pkg"`
	Artifact   ArtifactInputSpec     `json:"artifact"`
	Occurrence IsOccurrenceInputSpec `json:"occurrence"`
}

// GetPkg returns __IsOccurrencePkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__IsOccurrencePkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetArtifact returns __IsOccurrencePkgInput.Artifact, and is useful for accessing the field via an interface.
func (v *__IsOccurrencePkgInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetOccurrence returns __IsOccurrencePkgInput.Occurrence, and is useful for accessing the field via an interface.
func (v *__IsOccurrencePkgInput) GetOccurrence() IsOccurrenceInputSpec { return v.Occurrence }

// __IsOccurrenceSrcInput is used internally by genqlient
type __IsOccurrenceSrcInput struct {
	Source     SourceInputSpec       `json:"source"`
	Artifact   ArtifactInputSpec     `json:"artifact"`
	Occurrence IsOccurrenceInputSpec `json:"occurrence"`
}

// GetSource returns __IsOccurrenceSrcInput.Source, and is useful for accessing the field via an interface.
func (v *__IsOccurrenceSrcInput) GetSource() SourceInputSpec { return v.Source }

// GetArtifact returns __IsOccurrenceSrcInput.Artifact, and is useful for accessing the field via an interface.
func (v *__IsOccurrenceSrcInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetOccurrence returns __IsOccurrenceSrcInput.Occurrence, and is useful for accessing the field via an interface.
func (v *__IsOccurrenceSrcInput) GetOccurrence() IsOccurrenceInputSpec { return v.Occurrence }

// __ScorecardInput is used internally by genqlient
type __ScorecardInput struct {
	Source    SourceInputSpec    `json:"source"`
	Scorecard ScorecardInputSpec `json:"scorecard"`
}

// GetSource returns __ScorecardInput.Source, and is useful for accessing the field via an interface.
func (v *__ScorecardInput) GetSource() SourceInputSpec { return v.Source }

// GetScorecard returns __ScorecardInput.Scorecard, and is useful for accessing the field via an interface.
func (v *__ScorecardInput) GetScorecard() ScorecardInputSpec { return v.Scorecard }

// allArtifactTree includes the GraphQL fields of Artifact requested by the fragment allArtifactTree.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type allArtifactTree struct {
	Algorithm string `json:"algorithm"`
	Digest    string `json:"digest"`
}

// GetAlgorithm returns allArtifactTree.Algorithm, and is useful for accessing the field via an interface.
func (v *allArtifactTree) GetAlgorithm() string { return v.Algorithm }

// GetDigest returns allArtifactTree.Digest, and is useful for accessing the field via an interface.
func (v *allArtifactTree) GetDigest() string { return v.Digest }

// allCertifyPkg includes the GraphQL fields of CertifyPkg requested by the fragment allCertifyPkg.
// The GraphQL type's documentation follows.
//
// # CertifyPkg is an attestation that represents when a package objects are similar
//
// packages (subject) - list of package objects
// justification (property) - string value representing why the packages are similar
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type allCertifyPkg struct {
	Justification string                         `json:"justification"`
	Packages      []allCertifyPkgPackagesPackage `json:"packages"`
	Origin        string                         `json:"origin"`
	Collector     string                         `json:"collector"`
}

// GetJustification returns allCertifyPkg.Justification, and is useful for accessing the field via an interface.
func (v *allCertifyPkg) GetJustification() string { return v.Justification }

// GetPackages returns allCertifyPkg.Packages, and is useful for accessing the field via an interface.
func (v *allCertifyPkg) GetPackages() []allCertifyPkgPackagesPackage { return v.Packages }

// GetOrigin returns allCertifyPkg.Origin, and is useful for accessing the field via an interface.
func (v *allCertifyPkg) GetOrigin() string { return v.Origin }

// GetCollector returns allCertifyPkg.Collector, and is useful for accessing the field via an interface.
func (v *allCertifyPkg) GetCollector() string { return v.Collector }

// allCertifyPkgPackagesPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allCertifyPkgPackagesPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns allCertifyPkgPackagesPackage.Type, and is useful for accessing the field via an interface.
func (v *allCertifyPkgPackagesPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allCertifyPkgPackagesPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allCertifyPkgPackagesPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allCertifyPkgPackagesPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allCertifyPkgPackagesPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allCertifyPkgPackagesPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallCertifyPkgPackagesPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allCertifyPkgPackagesPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allCertifyPkgPackagesPackage) __premarshalJSON() (*__premarshalallCertifyPkgPackagesPackage, error) {
	var retval __premarshalallCertifyPkgPackagesPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allCertifyScorecard includes the GraphQL fields of CertifyScorecard requested by the fragment allCertifyScorecard.
// The GraphQL type's documentation follows.
//
// CertifyScorecard is an attestation which represents the scorecard of a
// particular source repository.
type allCertifyScorecard struct {
	// The source repository that is being scanned (attestation subject)
	Source allCertifyScorecardSource `json:"source"`
	// The Scorecard attached to the repository (attestation object)
	Scorecard allCertifyScorecardScorecard `json:"scorecard"`
}

// GetSource returns allCertifyScorecard.Source, and is useful for accessing the field via an interface.
func (v *allCertifyScorecard) GetSource() allCertifyScorecardSource { return v.Source }

// GetScorecard returns allCertifyScorecard.Scorecard, and is useful for accessing the field via an interface.
func (v *allCertifyScorecard) GetScorecard() allCertifyScorecardScorecard { return v.Scorecard }

// allCertifyScorecardScorecard includes the requested fields of the GraphQL type Scorecard.
// The GraphQL type's documentation follows.
//
// Scorecard contains all of the fields present in a Scorecard attestation.
//
// We also include fields to specify under what conditions the check was performed
// (time of scan, version of scanners, etc.) as well as how this information got
// included into GUAC (origin document and the collector for that document).
type allCertifyScorecardScorecard struct {
	// Exact timestamp when the source was last scanned (in RFC 3339 format)
	TimeScanned time.Time `json:"timeScanned"`
	// Overall Scorecard score for the source
	AggregateScore float64 `json:"aggregateScore"`
	// Individual Scorecard check scores (Branch-Protection, Code-Review, ...)
	Checks []allCertifyScorecardScorecardChecksScorecardCheck `json:"checks"`
	// Version of the Scorecard scanner used to analyze the source
	ScorecardVersion string `json:"scorecardVersion"`
	// Commit of the Scorecards repository at the time of scanning the source
	ScorecardCommit string `json:"scorecardCommit"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetTimeScanned returns allCertifyScorecardScorecard.TimeScanned, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetTimeScanned() time.Time { return v.TimeScanned }

// GetAggregateScore returns allCertifyScorecardScorecard.AggregateScore, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetAggregateScore() float64 { return v.AggregateScore }

// GetChecks returns allCertifyScorecardScorecard.Checks, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetChecks() []allCertifyScorecardScorecardChecksScorecardCheck {
	return v.Checks
}

// GetScorecardVersion returns allCertifyScorecardScorecard.ScorecardVersion, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetScorecardVersion() string { return v.ScorecardVersion }

// GetScorecardCommit returns allCertifyScorecardScorecard.ScorecardCommit, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetScorecardCommit() string { return v.ScorecardCommit }

// GetOrigin returns allCertifyScorecardScorecard.Origin, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetOrigin() string { return v.Origin }

// GetCollector returns allCertifyScorecardScorecard.Collector, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetCollector() string { return v.Collector }

// allCertifyScorecardScorecardChecksScorecardCheck includes the requested fields of the GraphQL type ScorecardCheck.
// The GraphQL type's documentation follows.
//
// ScorecardCheck are the individual checks from scorecard and their values as a
// key-value pair.
//
// For example:  Branch-Protection, Code-Review...etc
//
// Based off scorecard's:
// type jsonCheckResultV2 struct {
// Details []string                 `json:"details"`
// Score   int                      `json:"score"`
// Reason  string                   `json:"reason"`
// Name    string                   `json:"name"`
// Doc     jsonCheckDocumentationV2 `json:"documentation"`
// }
// This node cannot be directly referred by other parts of GUAC.
type allCertifyScorecardScorecardChecksScorecardCheck struct {
	Check string `json:"check"`
	Score int    `json:"score"`
}

// GetCheck returns allCertifyScorecardScorecardChecksScorecardCheck.Check, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecardChecksScorecardCheck) GetCheck() string { return v.Check }

// GetScore returns allCertifyScorecardScorecardChecksScorecardCheck.Score, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecardChecksScorecardCheck) GetScore() int { return v.Score }

// allCertifyScorecardSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allCertifyScorecardSource struct {
	allSrcTree `json:"-"`
}

// GetType returns allCertifyScorecardSource.Type, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardSource) GetType() string { return v.allSrcTree.Type }

// GetNamespaces returns allCertifyScorecardSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardSource) GetNamespaces() []allSrcTreeNamespacesSourceNamespace {
	return v.allSrcTree.Namespaces
}

func (v *allCertifyScorecardSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allCertifyScorecardSource
		graphql.NoUnmarshalJSON
	}
	firstPass.allCertifyScorecardSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSrcTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallCertifyScorecardSource struct {
	Type string `json:"type"`

	Namespaces []allSrcTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *allCertifyScorecardSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allCertifyScorecardSource) __premarshalJSON() (*__premarshalallCertifyScorecardSource, error) {
	var retval __premarshalallCertifyScorecardSource

	retval.Type = v.allSrcTree.Type
	retval.Namespaces = v.allSrcTree.Namespaces
	return &retval, nil
}

// allCertifyVuln includes the GraphQL fields of CertifyVuln requested by the fragment allCertifyVuln.
// The GraphQL type's documentation follows.
//
// CertifyVuln is an attestation that represents when a package has a vulnerability
type allCertifyVuln struct {
	// package (subject) - the package object type that represents the package
	Package allCertifyVulnPackage `json:"package"`
	// vulnerability (object) - union type that consists of osv, cve or ghsa
	Vulnerability allCertifyVulnVulnerabilityOsvCveOrGhsa `json:"-"`
	// metadata (property) - contains all the vulnerability metadata
	Metadata allCertifyVulnMetadataVulnerabilityMetaData `json:"metadata"`
}

// GetPackage returns allCertifyVuln.Package, and is useful for accessing the field via an interface.
func (v *allCertifyVuln) GetPackage() allCertifyVulnPackage { return v.Package }

// GetVulnerability returns allCertifyVuln.Vulnerability, and is useful for accessing the field via an interface.
func (v *allCertifyVuln) GetVulnerability() allCertifyVulnVulnerabilityOsvCveOrGhsa {
	return v.Vulnerability
}

// GetMetadata returns allCertifyVuln.Metadata, and is useful for accessing the field via an interface.
func (v *allCertifyVuln) GetMetadata() allCertifyVulnMetadataVulnerabilityMetaData { return v.Metadata }

func (v *allCertifyVuln) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allCertifyVuln
		Vulnerability json.RawMessage `json:"vulnerability"`
		graphql.NoUnmarshalJSON
	}
	firstPass.allCertifyVuln = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Vulnerability
		src := firstPass.Vulnerability
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalallCertifyVulnVulnerabilityOsvCveOrGhsa(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"Unable to unmarshal allCertifyVuln.Vulnerability: %w", err)
			}
		}
	}
	return nil
}

type __premarshalallCertifyVuln struct {
	Package allCertifyVulnPackage `json:"package"`

	Vulnerability json.RawMessage `json:"vulnerability"`

	Metadata allCertifyVulnMetadataVulnerabilityMetaData `json:"metadata"`
}

func (v *allCertifyVuln) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allCertifyVuln) __premarshalJSON() (*__premarshalallCertifyVuln, error) {
	var retval __premarshalallCertifyVuln

	retval.Package = v.Package
	{

		dst := &retval.Vulnerability
		src := v.Vulnerability
		var err error
		*dst, err = __marshalallCertifyVulnVulnerabilityOsvCveOrGhsa(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal allCertifyVuln.Vulnerability: %w", err)
		}
	}
	retval.Metadata = v.Metadata
	return &retval, nil
}

// allCertifyVulnMetadataVulnerabilityMetaData includes the requested fields of the GraphQL type VulnerabilityMetaData.
type allCertifyVulnMetadataVulnerabilityMetaData struct {
	// dbUri (property) - scanner vulnerability database uri
	DbUri string `json:"dbUri"`
	// dbVersion (property) - scanner vulnerability database version
	DbVersion string `json:"dbVersion"`
	// scannerUri (property) - vulnerability scanner's uri
	ScannerUri string `json:"scannerUri"`
	// scannerVersion (property) - vulnerability scanner version
	ScannerVersion string `json:"scannerVersion"`
	// timeScanned (property) - timestamp of when the package was last scanned
	TimeScanned time.Time `json:"timeScanned"`
	// origin (property) - where this attestation was generated from (based on which document)
	Origin string `json:"origin"`
	// collector (property) - the GUAC collector that collected the document that generated this attestation
	Collector string `json:"collector"`
}

// GetDbUri returns allCertifyVulnMetadataVulnerabilityMetaData.DbUri, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetDbUri() string { return v.DbUri }

// GetDbVersion returns allCertifyVulnMetadataVulnerabilityMetaData.DbVersion, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetDbVersion() string { return v.DbVersion }

// GetScannerUri returns allCertifyVulnMetadataVulnerabilityMetaData.ScannerUri, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetScannerUri() string { return v.ScannerUri }

// GetScannerVersion returns allCertifyVulnMetadataVulnerabilityMetaData.ScannerVersion, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetScannerVersion() string {
	return v.ScannerVersion
}

// GetTimeScanned returns allCertifyVulnMetadataVulnerabilityMetaData.TimeScanned, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetTimeScanned() time.Time {
	return v.TimeScanned
}

// GetOrigin returns allCertifyVulnMetadataVulnerabilityMetaData.Origin, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetOrigin() string { return v.Origin }

// GetCollector returns allCertifyVulnMetadataVulnerabilityMetaData.Collector, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetCollector() string { return v.Collector }

// allCertifyVulnPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allCertifyVulnPackage struct {
	Type       string                                            `json:"type"`
	Namespaces []allCertifyVulnPackageNamespacesPackageNamespace `json:"namespaces"`
}

// GetType returns allCertifyVulnPackage.Type, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackage) GetType() string { return v.Type }

// GetNamespaces returns allCertifyVulnPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackage) GetNamespaces() []allCertifyVulnPackageNamespacesPackageNamespace {
	return v.Namespaces
}

// allCertifyVulnPackageNamespacesPackageNamespace includes the requested fields of the GraphQL type PackageNamespace.
// The GraphQL type's documentation follows.
//
// PackageNamespace is a namespace for packages.
//
// In the pURL representation, each PackageNamespace matches the
// `pkg:<type>/<namespace>/` partial pURL.
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type allCertifyVulnPackageNamespacesPackageNamespace struct {
	Namespace string                                                            `json:"namespace"`
	Names     []allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName `json:"names"`
}

// GetNamespace returns allCertifyVulnPackageNamespacesPackageNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns allCertifyVulnPackageNamespacesPackageNamespace.Names, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespace) GetNames() []allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName {
	return v.Names
}

// allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName includes the requested fields of the GraphQL type PackageName.
// The GraphQL type's documentation follows.
//
// PackageName is a name for packages.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>` pURL.
//
// Names are always mandatory.
//
// This is the first node in the trie that can be referred to by other parts of
// GUAC.
type allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName struct {
	Name     string                                                                                  `json:"name"`
	Versions []allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion `json:"versions"`
}

// GetName returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName.Name, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName) GetName() string {
	return v.Name
}

// GetVersions returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName.Versions, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName) GetVersions() []allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion {
	return v.Versions
}

// allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion includes the requested fields of the GraphQL type PackageVersion.
// The GraphQL type's documentation follows.
//
// PackageVersion is a package version.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>@<version>` pURL.
//
// Versions are optional and each Package type defines own rules for handling them.
// For this level of GUAC, these are just opaque strings.
//
// This node can be referred to by other parts of GUAC.
//
// Subpath and qualifiers are optional. Lack of qualifiers is represented by an
// empty list and lack of subpath by empty string (to be consistent with
// optionality of namespace and version). Two nodes that have different qualifiers
// and/or subpath but the same version mean two different packages in the trie
// (they are different). Two nodes that have same version but qualifiers of one are
// a subset of the qualifier of the other also mean two different packages in the
// trie.
type allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion struct {
	Version    string                                                                                                            `json:"version"`
	Qualifiers []allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier `json:"qualifiers"`
	Subpath    string                                                                                                            `json:"subpath"`
}

// GetVersion returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Version, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetVersion() string {
	return v.Version
}

// GetQualifiers returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Qualifiers, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetQualifiers() []allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier {
	return v.Qualifiers
}

// GetSubpath returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Subpath, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetSubpath() string {
	return v.Subpath
}

// allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier includes the requested fields of the GraphQL type PackageQualifier.
// The GraphQL type's documentation follows.
//
// PackageQualifier is a qualifier for a package, a key-value pair.
//
// In the pURL representation, it is a part of the `<qualifiers>` part of the
// `pkg:<type>/<namespace>/<name>@<version>?<qualifiers>` pURL.
//
// Qualifiers are optional, each Package type defines own rules for handling them,
// and multiple qualifiers could be attached to the same package.
//
// This node cannot be directly referred by other parts of GUAC.
type allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Key, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetKey() string {
	return v.Key
}

// GetValue returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Value, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetValue() string {
	return v.Value
}

// allCertifyVulnVulnerabilityCVE includes the requested fields of the GraphQL type CVE.
// The GraphQL type's documentation follows.
//
// CVE represents common vulnerabilities and exposures. It contains the year along
// with the CVE ID.
//
// The year is mandatory.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `year` value.
type allCertifyVulnVulnerabilityCVE struct {
	Typename *string                                    `json:"__typename"`
	Year     string                                     `json:"year"`
	CveId    []allCertifyVulnVulnerabilityCVECveIdCVEId `json:"cveId"`
}

// GetTypename returns allCertifyVulnVulnerabilityCVE.Typename, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityCVE) GetTypename() *string { return v.Typename }

// GetYear returns allCertifyVulnVulnerabilityCVE.Year, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityCVE) GetYear() string { return v.Year }

// GetCveId returns allCertifyVulnVulnerabilityCVE.CveId, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityCVE) GetCveId() []allCertifyVulnVulnerabilityCVECveIdCVEId {
	return v.CveId
}

// allCertifyVulnVulnerabilityCVECveIdCVEId includes the requested fields of the GraphQL type CVEId.
// The GraphQL type's documentation follows.
//
// # CVEId is the actual ID that is given to a specific vulnerability
//
// The `id` field is mandatory and canonicalized to be lowercase.
//
// This node can be referred to by other parts of GUAC.
type allCertifyVulnVulnerabilityCVECveIdCVEId struct {
	Id string `json:"id"`
}

// GetId returns allCertifyVulnVulnerabilityCVECveIdCVEId.Id, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityCVECveIdCVEId) GetId() string { return v.Id }

// allCertifyVulnVulnerabilityGHSA includes the requested fields of the GraphQL type GHSA.
// The GraphQL type's documentation follows.
//
// GHSA represents GitHub security advisories.
//
// We create a separate node to allow retrieving all GHSAs.
type allCertifyVulnVulnerabilityGHSA struct {
	Typename *string                                       `json:"__typename"`
	GhsaId   []allCertifyVulnVulnerabilityGHSAGhsaIdGHSAId `json:"ghsaId"`
}

// GetTypename returns allCertifyVulnVulnerabilityGHSA.Typename, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityGHSA) GetTypename() *string { return v.Typename }

// GetGhsaId returns allCertifyVulnVulnerabilityGHSA.GhsaId, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityGHSA) GetGhsaId() []allCertifyVulnVulnerabilityGHSAGhsaIdGHSAId {
	return v.GhsaId
}

// allCertifyVulnVulnerabilityGHSAGhsaIdGHSAId includes the requested fields of the GraphQL type GHSAId.
// The GraphQL type's documentation follows.
//
// # GHSAId is the actual ID that is given to a specific vulnerability on GitHub
//
// The `id` field is mandatory and canonicalized to be lowercase.
//
// This node can be referred to by other parts of GUAC.
type allCertifyVulnVulnerabilityGHSAGhsaIdGHSAId struct {
	Id string `json:"id"`
}

// GetId returns allCertifyVulnVulnerabilityGHSAGhsaIdGHSAId.Id, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityGHSAGhsaIdGHSAId) GetId() string { return v.Id }

// allCertifyVulnVulnerabilityOSV includes the requested fields of the GraphQL type OSV.
// The GraphQL type's documentation follows.
//
// OSV represents an Open Source Vulnerability.
//
// We create a separate node to allow retrieving all OSVs.
type allCertifyVulnVulnerabilityOSV struct {
	Typename *string                                    `json:"__typename"`
	OsvId    []allCertifyVulnVulnerabilityOSVOsvIdOSVId `json:"osvId"`
}

// GetTypename returns allCertifyVulnVulnerabilityOSV.Typename, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityOSV) GetTypename() *string { return v.Typename }

// GetOsvId returns allCertifyVulnVulnerabilityOSV.OsvId, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityOSV) GetOsvId() []allCertifyVulnVulnerabilityOSVOsvIdOSVId {
	return v.OsvId
}

// allCertifyVulnVulnerabilityOSVOsvIdOSVId includes the requested fields of the GraphQL type OSVId.
// The GraphQL type's documentation follows.
//
// OSVId is the actual ID that is given to a specific vulnerability.
//
// The `id` field is mandatory and canonicalized to be lowercase.
//
// This maps to a vulnerability ID specific to the environment (e.g., GHSA ID or
// CVE ID).
//
// This node can be referred to by other parts of GUAC.
type allCertifyVulnVulnerabilityOSVOsvIdOSVId struct {
	Id string `json:"id"`
}

// GetId returns allCertifyVulnVulnerabilityOSVOsvIdOSVId.Id, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityOSVOsvIdOSVId) GetId() string { return v.Id }

// allCertifyVulnVulnerabilityOsvCveOrGhsa includes the requested fields of the GraphQL interface OsvCveOrGhsa.
//
// allCertifyVulnVulnerabilityOsvCveOrGhsa is implemented by the following types:
// allCertifyVulnVulnerabilityOSV
// allCertifyVulnVulnerabilityCVE
// allCertifyVulnVulnerabilityGHSA
// The GraphQL type's documentation follows.
//
// OsvCveGhsaObject is a union of OSV, CVE and GHSA. Any of these objects can be specified for vulnerability
type allCertifyVulnVulnerabilityOsvCveOrGhsa interface {
	implementsGraphQLInterfaceallCertifyVulnVulnerabilityOsvCveOrGhsa()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *allCertifyVulnVulnerabilityOSV) implementsGraphQLInterfaceallCertifyVulnVulnerabilityOsvCveOrGhsa() {
}
func (v *allCertifyVulnVulnerabilityCVE) implementsGraphQLInterfaceallCertifyVulnVulnerabilityOsvCveOrGhsa() {
}
func (v *allCertifyVulnVulnerabilityGHSA) implementsGraphQLInterfaceallCertifyVulnVulnerabilityOsvCveOrGhsa() {
}

func __unmarshalallCertifyVulnVulnerabilityOsvCveOrGhsa(b []byte, v *allCertifyVulnVulnerabilityOsvCveOrGhsa) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "OSV":
		*v = new(allCertifyVulnVulnerabilityOSV)
		return json.Unmarshal(b, *v)
	case "CVE":
		*v = new(allCertifyVulnVulnerabilityCVE)
		return json.Unmarshal(b, *v)
	case "GHSA":
		*v = new(allCertifyVulnVulnerabilityGHSA)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing OsvCveOrGhsa.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for allCertifyVulnVulnerabilityOsvCveOrGhsa: "%v"`, tn.TypeName)
	}
}

func __marshalallCertifyVulnVulnerabilityOsvCveOrGhsa(v *allCertifyVulnVulnerabilityOsvCveOrGhsa) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *allCertifyVulnVulnerabilityOSV:
		typename = "OSV"

		result := struct {
			TypeName string `json:"__typename"`
			*allCertifyVulnVulnerabilityOSV
		}{typename, v}
		return json.Marshal(result)
	case *allCertifyVulnVulnerabilityCVE:
		typename = "CVE"

		result := struct {
			TypeName string `json:"__typename"`
			*allCertifyVulnVulnerabilityCVE
		}{typename, v}
		return json.Marshal(result)
	case *allCertifyVulnVulnerabilityGHSA:
		typename = "GHSA"

		result := struct {
			TypeName string `json:"__typename"`
			*allCertifyVulnVulnerabilityGHSA
		}{typename, v}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for allCertifyVulnVulnerabilityOsvCveOrGhsa: "%T"`, v)
	}
}

// allCveTree includes the GraphQL fields of CVE requested by the fragment allCveTree.
// The GraphQL type's documentation follows.
//
// CVE represents common vulnerabilities and exposures. It contains the year along
// with the CVE ID.
//
// The year is mandatory.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `year` value.
type allCveTree struct {
	Year  string                 `json:"year"`
	CveId []allCveTreeCveIdCVEId `json:"cveId"`
}

// GetYear returns allCveTree.Year, and is useful for accessing the field via an interface.
func (v *allCveTree) GetYear() string { return v.Year }

// GetCveId returns allCveTree.CveId, and is useful for accessing the field via an interface.
func (v *allCveTree) GetCveId() []allCveTreeCveIdCVEId { return v.CveId }

// allCveTreeCveIdCVEId includes the requested fields of the GraphQL type CVEId.
// The GraphQL type's documentation follows.
//
// # CVEId is the actual ID that is given to a specific vulnerability
//
// The `id` field is mandatory and canonicalized to be lowercase.
//
// This node can be referred to by other parts of GUAC.
type allCveTreeCveIdCVEId struct {
	Id string `json:"id"`
}

// GetId returns allCveTreeCveIdCVEId.Id, and is useful for accessing the field via an interface.
func (v *allCveTreeCveIdCVEId) GetId() string { return v.Id }

// allGHSATree includes the GraphQL fields of GHSA requested by the fragment allGHSATree.
// The GraphQL type's documentation follows.
//
// GHSA represents GitHub security advisories.
//
// We create a separate node to allow retrieving all GHSAs.
type allGHSATree struct {
	GhsaId []allGHSATreeGhsaIdGHSAId `json:"ghsaId"`
}

// GetGhsaId returns allGHSATree.GhsaId, and is useful for accessing the field via an interface.
func (v *allGHSATree) GetGhsaId() []allGHSATreeGhsaIdGHSAId { return v.GhsaId }

// allGHSATreeGhsaIdGHSAId includes the requested fields of the GraphQL type GHSAId.
// The GraphQL type's documentation follows.
//
// # GHSAId is the actual ID that is given to a specific vulnerability on GitHub
//
// The `id` field is mandatory and canonicalized to be lowercase.
//
// This node can be referred to by other parts of GUAC.
type allGHSATreeGhsaIdGHSAId struct {
	Id string `json:"id"`
}

// GetId returns allGHSATreeGhsaIdGHSAId.Id, and is useful for accessing the field via an interface.
func (v *allGHSATreeGhsaIdGHSAId) GetId() string { return v.Id }

// allIsDependencyTree includes the GraphQL fields of IsDependency requested by the fragment allIsDependencyTree.
// The GraphQL type's documentation follows.
//
// # IsDependency is an attestation that represents when a package is dependent on another package
//
// package (subject) - the package object type that represents the package
// dependentPackage (object) - the package object type that represents the packageName (cannot be to the packageVersion)
// versionRange (property) - string value for version range that applies to the dependent package
// justification (property) - string value representing why the artifacts are the equal
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type allIsDependencyTree struct {
	Justification    string                              `json:"justification"`
	Package          allIsDependencyTreePackage          `json:"package"`
	DependentPackage allIsDependencyTreeDependentPackage `json:"dependentPackage"`
	VersionRange     string                              `json:"versionRange"`
	Origin           string                              `json:"origin"`
	Collector        string                              `json:"collector"`
}

// GetJustification returns allIsDependencyTree.Justification, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetJustification() string { return v.Justification }

// GetPackage returns allIsDependencyTree.Package, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetPackage() allIsDependencyTreePackage { return v.Package }

// GetDependentPackage returns allIsDependencyTree.DependentPackage, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetDependentPackage() allIsDependencyTreeDependentPackage {
	return v.DependentPackage
}

// GetVersionRange returns allIsDependencyTree.VersionRange, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetVersionRange() string { return v.VersionRange }

// GetOrigin returns allIsDependencyTree.Origin, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetOrigin() string { return v.Origin }

// GetCollector returns allIsDependencyTree.Collector, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetCollector() string { return v.Collector }

// allIsDependencyTreeDependentPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allIsDependencyTreeDependentPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns allIsDependencyTreeDependentPackage.Type, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreeDependentPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allIsDependencyTreeDependentPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreeDependentPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allIsDependencyTreeDependentPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsDependencyTreeDependentPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsDependencyTreeDependentPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsDependencyTreeDependentPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allIsDependencyTreeDependentPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsDependencyTreeDependentPackage) __premarshalJSON() (*__premarshalallIsDependencyTreeDependentPackage, error) {
	var retval __premarshalallIsDependencyTreeDependentPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allIsDependencyTreePackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allIsDependencyTreePackage struct {
	allPkgTree `json:"-"`
}

// GetType returns allIsDependencyTreePackage.Type, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreePackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allIsDependencyTreePackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreePackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allIsDependencyTreePackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsDependencyTreePackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsDependencyTreePackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsDependencyTreePackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allIsDependencyTreePackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsDependencyTreePackage) __premarshalJSON() (*__premarshalallIsDependencyTreePackage, error) {
	var retval __premarshalallIsDependencyTreePackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allIsOccurrencesTree includes the GraphQL fields of IsOccurrence requested by the fragment allIsOccurrencesTree.
// The GraphQL type's documentation follows.
//
// # IsOccurrence is an attestation represents when either a package or source is represented by an artifact
//
// Note: Package or Source must be specified but not both at the same time.
// Attestation must occur at the PackageVersion or at the SourceName.
type allIsOccurrencesTree struct {
	// subject - union type that can be either a package or source object type
	Subject allIsOccurrencesTreeSubjectPackageOrSource `json:"-"`
	// artifact (object) - artifact that represent the the package or source
	Artifact allIsOccurrencesTreeArtifact `json:"artifact"`
	// justification (property) - string value representing why the package or source is represented by the specified artifact
	Justification string `json:"justification"`
	// origin (property) - where this attestation was generated from (based on which document)
	Origin string `json:"origin"`
	// collector (property) - the GUAC collector that collected the document that generated this attestation
	Collector string `json:"collector"`
}

// GetSubject returns allIsOccurrencesTree.Subject, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetSubject() allIsOccurrencesTreeSubjectPackageOrSource {
	return v.Subject
}

// GetArtifact returns allIsOccurrencesTree.Artifact, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetArtifact() allIsOccurrencesTreeArtifact { return v.Artifact }

// GetJustification returns allIsOccurrencesTree.Justification, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetJustification() string { return v.Justification }

// GetOrigin returns allIsOccurrencesTree.Origin, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetOrigin() string { return v.Origin }

// GetCollector returns allIsOccurrencesTree.Collector, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetCollector() string { return v.Collector }

func (v *allIsOccurrencesTree) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsOccurrencesTree
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsOccurrencesTree = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalallIsOccurrencesTreeSubjectPackageOrSource(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"Unable to unmarshal allIsOccurrencesTree.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalallIsOccurrencesTree struct {
	Subject json.RawMessage `json:"subject"`

	Artifact allIsOccurrencesTreeArtifact `json:"artifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *allIsOccurrencesTree) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsOccurrencesTree) __premarshalJSON() (*__premarshalallIsOccurrencesTree, error) {
	var retval __premarshalallIsOccurrencesTree

	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalallIsOccurrencesTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal allIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.Artifact = v.Artifact
	retval.Justification = v.Justification
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// allIsOccurrencesTreeArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type allIsOccurrencesTreeArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns allIsOccurrencesTreeArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns allIsOccurrencesTreeArtifact.Digest, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *allIsOccurrencesTreeArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsOccurrencesTreeArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsOccurrencesTreeArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsOccurrencesTreeArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *allIsOccurrencesTreeArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsOccurrencesTreeArtifact) __premarshalJSON() (*__premarshalallIsOccurrencesTreeArtifact, error) {
	var retval __premarshalallIsOccurrencesTreeArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// allIsOccurrencesTreeSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allIsOccurrencesTreeSubjectPackage struct {
	Typename   *string `json:"__typename"`
	allPkgTree `json:"-"`
}

// GetTypename returns allIsOccurrencesTreeSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectPackage) GetTypename() *string { return v.Typename }

// GetType returns allIsOccurrencesTreeSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allIsOccurrencesTreeSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allIsOccurrencesTreeSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsOccurrencesTreeSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsOccurrencesTreeSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsOccurrencesTreeSubjectPackage struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allIsOccurrencesTreeSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsOccurrencesTreeSubjectPackage) __premarshalJSON() (*__premarshalallIsOccurrencesTreeSubjectPackage, error) {
	var retval __premarshalallIsOccurrencesTreeSubjectPackage

	retval.Typename = v.Typename
	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allIsOccurrencesTreeSubjectPackageOrSource includes the requested fields of the GraphQL interface PackageOrSource.
//
// allIsOccurrencesTreeSubjectPackageOrSource is implemented by the following types:
// allIsOccurrencesTreeSubjectPackage
// allIsOccurrencesTreeSubjectSource
// The GraphQL type's documentation follows.
//
// PackageOrSource is a union of Package and Source. Any of these objects can be specified
type allIsOccurrencesTreeSubjectPackageOrSource interface {
	implementsGraphQLInterfaceallIsOccurrencesTreeSubjectPackageOrSource()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *allIsOccurrencesTreeSubjectPackage) implementsGraphQLInterfaceallIsOccurrencesTreeSubjectPackageOrSource() {
}
func (v *allIsOccurrencesTreeSubjectSource) implementsGraphQLInterfaceallIsOccurrencesTreeSubjectPackageOrSource() {
}

func __unmarshalallIsOccurrencesTreeSubjectPackageOrSource(b []byte, v *allIsOccurrencesTreeSubjectPackageOrSource) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(allIsOccurrencesTreeSubjectPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(allIsOccurrencesTreeSubjectSource)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageOrSource.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for allIsOccurrencesTreeSubjectPackageOrSource: "%v"`, tn.TypeName)
	}
}

func __marshalallIsOccurrencesTreeSubjectPackageOrSource(v *allIsOccurrencesTreeSubjectPackageOrSource) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *allIsOccurrencesTreeSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallIsOccurrencesTreeSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allIsOccurrencesTreeSubjectSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallIsOccurrencesTreeSubjectSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for allIsOccurrencesTreeSubjectPackageOrSource: "%T"`, v)
	}
}

// allIsOccurrencesTreeSubjectSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allIsOccurrencesTreeSubjectSource struct {
	Typename   *string `json:"__typename"`
	allSrcTree `json:"-"`
}

// GetTypename returns allIsOccurrencesTreeSubjectSource.Typename, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectSource) GetTypename() *string { return v.Typename }

// GetType returns allIsOccurrencesTreeSubjectSource.Type, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectSource) GetType() string { return v.allSrcTree.Type }

// GetNamespaces returns allIsOccurrencesTreeSubjectSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectSource) GetNamespaces() []allSrcTreeNamespacesSourceNamespace {
	return v.allSrcTree.Namespaces
}

func (v *allIsOccurrencesTreeSubjectSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsOccurrencesTreeSubjectSource
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsOccurrencesTreeSubjectSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSrcTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsOccurrencesTreeSubjectSource struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allSrcTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *allIsOccurrencesTreeSubjectSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsOccurrencesTreeSubjectSource) __premarshalJSON() (*__premarshalallIsOccurrencesTreeSubjectSource, error) {
	var retval __premarshalallIsOccurrencesTreeSubjectSource

	retval.Typename = v.Typename
	retval.Type = v.allSrcTree.Type
	retval.Namespaces = v.allSrcTree.Namespaces
	return &retval, nil
}

// allOSVTree includes the GraphQL fields of OSV requested by the fragment allOSVTree.
// The GraphQL type's documentation follows.
//
// OSV represents an Open Source Vulnerability.
//
// We create a separate node to allow retrieving all OSVs.
type allOSVTree struct {
	OsvId []allOSVTreeOsvIdOSVId `json:"osvId"`
}

// GetOsvId returns allOSVTree.OsvId, and is useful for accessing the field via an interface.
func (v *allOSVTree) GetOsvId() []allOSVTreeOsvIdOSVId { return v.OsvId }

// allOSVTreeOsvIdOSVId includes the requested fields of the GraphQL type OSVId.
// The GraphQL type's documentation follows.
//
// OSVId is the actual ID that is given to a specific vulnerability.
//
// The `id` field is mandatory and canonicalized to be lowercase.
//
// This maps to a vulnerability ID specific to the environment (e.g., GHSA ID or
// CVE ID).
//
// This node can be referred to by other parts of GUAC.
type allOSVTreeOsvIdOSVId struct {
	Id string `json:"id"`
}

// GetId returns allOSVTreeOsvIdOSVId.Id, and is useful for accessing the field via an interface.
func (v *allOSVTreeOsvIdOSVId) GetId() string { return v.Id }

// allPkgTree includes the GraphQL fields of Package requested by the fragment allPkgTree.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allPkgTree struct {
	Type       string                                 `json:"type"`
	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

// GetType returns allPkgTree.Type, and is useful for accessing the field via an interface.
func (v *allPkgTree) GetType() string { return v.Type }

// GetNamespaces returns allPkgTree.Namespaces, and is useful for accessing the field via an interface.
func (v *allPkgTree) GetNamespaces() []allPkgTreeNamespacesPackageNamespace { return v.Namespaces }

// allPkgTreeNamespacesPackageNamespace includes the requested fields of the GraphQL type PackageNamespace.
// The GraphQL type's documentation follows.
//
// PackageNamespace is a namespace for packages.
//
// In the pURL representation, each PackageNamespace matches the
// `pkg:<type>/<namespace>/` partial pURL.
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type allPkgTreeNamespacesPackageNamespace struct {
	Namespace string                                                 `json:"namespace"`
	Names     []allPkgTreeNamespacesPackageNamespaceNamesPackageName `json:"names"`
}

// GetNamespace returns allPkgTreeNamespacesPackageNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns allPkgTreeNamespacesPackageNamespace.Names, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespace) GetNames() []allPkgTreeNamespacesPackageNamespaceNamesPackageName {
	return v.Names
}

// allPkgTreeNamespacesPackageNamespaceNamesPackageName includes the requested fields of the GraphQL type PackageName.
// The GraphQL type's documentation follows.
//
// PackageName is a name for packages.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>` pURL.
//
// Names are always mandatory.
//
// This is the first node in the trie that can be referred to by other parts of
// GUAC.
type allPkgTreeNamespacesPackageNamespaceNamesPackageName struct {
	Name     string                                                                       `json:"name"`
	Versions []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion `json:"versions"`
}

// GetName returns allPkgTreeNamespacesPackageNamespaceNamesPackageName.Name, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageName) GetName() string { return v.Name }

// GetVersions returns allPkgTreeNamespacesPackageNamespaceNamesPackageName.Versions, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageName) GetVersions() []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion {
	return v.Versions
}

// allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion includes the requested fields of the GraphQL type PackageVersion.
// The GraphQL type's documentation follows.
//
// PackageVersion is a package version.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>@<version>` pURL.
//
// Versions are optional and each Package type defines own rules for handling them.
// For this level of GUAC, these are just opaque strings.
//
// This node can be referred to by other parts of GUAC.
//
// Subpath and qualifiers are optional. Lack of qualifiers is represented by an
// empty list and lack of subpath by empty string (to be consistent with
// optionality of namespace and version). Two nodes that have different qualifiers
// and/or subpath but the same version mean two different packages in the trie
// (they are different). Two nodes that have same version but qualifiers of one are
// a subset of the qualifier of the other also mean two different packages in the
// trie.
type allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion struct {
	Version    string                                                                                                 `json:"version"`
	Qualifiers []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier `json:"qualifiers"`
	Subpath    string                                                                                                 `json:"subpath"`
}

// GetVersion returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Version, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetVersion() string {
	return v.Version
}

// GetQualifiers returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Qualifiers, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetQualifiers() []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier {
	return v.Qualifiers
}

// GetSubpath returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Subpath, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetSubpath() string {
	return v.Subpath
}

// allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier includes the requested fields of the GraphQL type PackageQualifier.
// The GraphQL type's documentation follows.
//
// PackageQualifier is a qualifier for a package, a key-value pair.
//
// In the pURL representation, it is a part of the `<qualifiers>` part of the
// `pkg:<type>/<namespace>/<name>@<version>?<qualifiers>` pURL.
//
// Qualifiers are optional, each Package type defines own rules for handling them,
// and multiple qualifiers could be attached to the same package.
//
// This node cannot be directly referred by other parts of GUAC.
type allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Key, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetKey() string {
	return v.Key
}

// GetValue returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Value, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetValue() string {
	return v.Value
}

// allSrcTree includes the GraphQL fields of Source requested by the fragment allSrcTree.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allSrcTree struct {
	Type       string                                `json:"type"`
	Namespaces []allSrcTreeNamespacesSourceNamespace `json:"namespaces"`
}

// GetType returns allSrcTree.Type, and is useful for accessing the field via an interface.
func (v *allSrcTree) GetType() string { return v.Type }

// GetNamespaces returns allSrcTree.Namespaces, and is useful for accessing the field via an interface.
func (v *allSrcTree) GetNamespaces() []allSrcTreeNamespacesSourceNamespace { return v.Namespaces }

// allSrcTreeNamespacesSourceNamespace includes the requested fields of the GraphQL type SourceNamespace.
// The GraphQL type's documentation follows.
//
// SourceNamespace is a namespace for sources.
//
// This is the location of the repository (such as github/gitlab/bitbucket).
//
// The `namespace` field is mandatory.
type allSrcTreeNamespacesSourceNamespace struct {
	Namespace string                                               `json:"namespace"`
	Names     []allSrcTreeNamespacesSourceNamespaceNamesSourceName `json:"names"`
}

// GetNamespace returns allSrcTreeNamespacesSourceNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *allSrcTreeNamespacesSourceNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns allSrcTreeNamespacesSourceNamespace.Names, and is useful for accessing the field via an interface.
func (v *allSrcTreeNamespacesSourceNamespace) GetNames() []allSrcTreeNamespacesSourceNamespaceNamesSourceName {
	return v.Names
}

// allSrcTreeNamespacesSourceNamespaceNamesSourceName includes the requested fields of the GraphQL type SourceName.
// The GraphQL type's documentation follows.
//
// SourceName is a url of the repository and its tag or commit.
//
// The `name` field is mandatory. The `tag` and `commit` fields are optional, but
// it is an error to specify both.
//
// This is the only source trie node that can be referenced by other parts of
// GUAC.
type allSrcTreeNamespacesSourceNamespaceNamesSourceName struct {
	Name   string  `json:"name"`
	Tag    *string `json:"tag"`
	Commit *string `json:"commit"`
}

// GetName returns allSrcTreeNamespacesSourceNamespaceNamesSourceName.Name, and is useful for accessing the field via an interface.
func (v *allSrcTreeNamespacesSourceNamespaceNamesSourceName) GetName() string { return v.Name }

// GetTag returns allSrcTreeNamespacesSourceNamespaceNamesSourceName.Tag, and is useful for accessing the field via an interface.
func (v *allSrcTreeNamespacesSourceNamespaceNamesSourceName) GetTag() *string { return v.Tag }

// GetCommit returns allSrcTreeNamespacesSourceNamespaceNamesSourceName.Commit, and is useful for accessing the field via an interface.
func (v *allSrcTreeNamespacesSourceNamespaceNamesSourceName) GetCommit() *string { return v.Commit }

func CertifyCVE(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	cve CVEInputSpec,
	certifyVuln VulnerabilityMetaDataInput,
) (*CertifyCVEResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyCVE",
		Query: `
mutation CertifyCVE ($pkg: PkgInputSpec!, $cve: CVEInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestCVE(cve: $cve) {
		... allCveTree
	}
	ingestVulnerability(pkg: $pkg, vulnerability: {cve:$cve}, certifyVuln: $certifyVuln) {
		... allCertifyVuln
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allCveTree on CVE {
	year
	cveId {
		id
	}
}
fragment allCertifyVuln on CertifyVuln {
	package {
		type
		namespaces {
			namespace
			names {
				name
				versions {
					version
					qualifiers {
						key
						value
					}
					subpath
				}
			}
		}
	}
	vulnerability {
		__typename
		... on CVE {
			year
			cveId {
				id
			}
		}
		... on OSV {
			osvId {
				id
			}
		}
		... on GHSA {
			ghsaId {
				id
			}
		}
	}
	metadata {
		dbUri
		dbVersion
		scannerUri
		scannerVersion
		timeScanned
		origin
		collector
	}
}
`,
		Variables: &__CertifyCVEInput{
			Pkg:         pkg,
			Cve:         cve,
			CertifyVuln: certifyVuln,
		},
	}
	var err error

	var data CertifyCVEResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func CertifyGHSA(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	ghsa GHSAInputSpec,
	certifyVuln VulnerabilityMetaDataInput,
) (*CertifyGHSAResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyGHSA",
		Query: `
mutation CertifyGHSA ($pkg: PkgInputSpec!, $ghsa: GHSAInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestGHSA(ghsa: $ghsa) {
		... allGHSATree
	}
	ingestVulnerability(pkg: $pkg, vulnerability: {ghsa:$ghsa}, certifyVuln: $certifyVuln) {
		... allCertifyVuln
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allGHSATree on GHSA {
	ghsaId {
		id
	}
}
fragment allCertifyVuln on CertifyVuln {
	package {
		type
		namespaces {
			namespace
			names {
				name
				versions {
					version
					qualifiers {
						key
						value
					}
					subpath
				}
			}
		}
	}
	vulnerability {
		__typename
		... on CVE {
			year
			cveId {
				id
			}
		}
		... on OSV {
			osvId {
				id
			}
		}
		... on GHSA {
			ghsaId {
				id
			}
		}
	}
	metadata {
		dbUri
		dbVersion
		scannerUri
		scannerVersion
		timeScanned
		origin
		collector
	}
}
`,
		Variables: &__CertifyGHSAInput{
			Pkg:         pkg,
			Ghsa:        ghsa,
			CertifyVuln: certifyVuln,
		},
	}
	var err error

	var data CertifyGHSAResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func CertifyOSV(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	osv OSVInputSpec,
	certifyVuln VulnerabilityMetaDataInput,
) (*CertifyOSVResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyOSV",
		Query: `
mutation CertifyOSV ($pkg: PkgInputSpec!, $osv: OSVInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestOSV(osv: $osv) {
		... allOSVTree
	}
	ingestVulnerability(pkg: $pkg, vulnerability: {osv:$osv}, certifyVuln: $certifyVuln) {
		... allCertifyVuln
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allOSVTree on OSV {
	osvId {
		id
	}
}
fragment allCertifyVuln on CertifyVuln {
	package {
		type
		namespaces {
			namespace
			names {
				name
				versions {
					version
					qualifiers {
						key
						value
					}
					subpath
				}
			}
		}
	}
	vulnerability {
		__typename
		... on CVE {
			year
			cveId {
				id
			}
		}
		... on OSV {
			osvId {
				id
			}
		}
		... on GHSA {
			ghsaId {
				id
			}
		}
	}
	metadata {
		dbUri
		dbVersion
		scannerUri
		scannerVersion
		timeScanned
		origin
		collector
	}
}
`,
		Variables: &__CertifyOSVInput{
			Pkg:         pkg,
			Osv:         osv,
			CertifyVuln: certifyVuln,
		},
	}
	var err error

	var data CertifyOSVResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func CertifyPkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	depPkg PkgInputSpec,
	certifyPkg CertifyPkgInputSpec,
) (*CertifyPkgResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyPkg",
		Query: `
mutation CertifyPkg ($pkg: PkgInputSpec!, $depPkg: PkgInputSpec!, $certifyPkg: CertifyPkgInputSpec!) {
	pkg: ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	dependentPkg: ingestPackage(pkg: $depPkg) {
		... allPkgTree
	}
	ingestCertifyPkg(pkg: $pkg, depPkg: $depPkg, certifyPkg: $certifyPkg) {
		... allCertifyPkg
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allCertifyPkg on CertifyPkg {
	justification
	packages {
		... allPkgTree
	}
	origin
	collector
}
`,
		Variables: &__CertifyPkgInput{
			Pkg:        pkg,
			DepPkg:     depPkg,
			CertifyPkg: certifyPkg,
		},
	}
	var err error

	var data CertifyPkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func IsDependency(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	depPkg PkgInputSpec,
	dependency IsDependencyInputSpec,
) (*IsDependencyResponse, error) {
	req := &graphql.Request{
		OpName: "IsDependency",
		Query: `
mutation IsDependency ($pkg: PkgInputSpec!, $depPkg: PkgInputSpec!, $dependency: IsDependencyInputSpec!) {
	pkg: ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	dependentPkg: ingestPackage(pkg: $depPkg) {
		... allPkgTree
	}
	ingestDependency(pkg: $pkg, depPkg: $depPkg, dependency: $dependency) {
		... allIsDependencyTree
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allIsDependencyTree on IsDependency {
	justification
	package {
		... allPkgTree
	}
	dependentPackage {
		... allPkgTree
	}
	versionRange
	origin
	collector
}
`,
		Variables: &__IsDependencyInput{
			Pkg:        pkg,
			DepPkg:     depPkg,
			Dependency: dependency,
		},
	}
	var err error

	var data IsDependencyResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func IsOccurrencePkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	artifact ArtifactInputSpec,
	occurrence IsOccurrenceInputSpec,
) (*IsOccurrencePkgResponse, error) {
	req := &graphql.Request{
		OpName: "IsOccurrencePkg",
		Query: `
mutation IsOccurrencePkg ($pkg: PkgInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestArtifact(artifact: $artifact) {
		... allArtifactTree
	}
	ingestOccurrence(subject: {package:$pkg}, artifact: $artifact, occurrence: $occurrence) {
		... allIsOccurrencesTree
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
fragment allIsOccurrencesTree on IsOccurrence {
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSrcTree
		}
	}
	artifact {
		... allArtifactTree
	}
	justification
	origin
	collector
}
fragment allSrcTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
`,
		Variables: &__IsOccurrencePkgInput{
			Pkg:        pkg,
			Artifact:   artifact,
			Occurrence: occurrence,
		},
	}
	var err error

	var data IsOccurrencePkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func IsOccurrenceSrc(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	artifact ArtifactInputSpec,
	occurrence IsOccurrenceInputSpec,
) (*IsOccurrenceSrcResponse, error) {
	req := &graphql.Request{
		OpName: "IsOccurrenceSrc",
		Query: `
mutation IsOccurrenceSrc ($source: SourceInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {
	ingestSource(source: $source) {
		... allSrcTree
	}
	ingestArtifact(artifact: $artifact) {
		... allArtifactTree
	}
	ingestOccurrence(subject: {source:$source}, artifact: $artifact, occurrence: $occurrence) {
		... allIsOccurrencesTree
	}
}
fragment allSrcTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
fragment allIsOccurrencesTree on IsOccurrence {
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSrcTree
		}
	}
	artifact {
		... allArtifactTree
	}
	justification
	origin
	collector
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
`,
		Variables: &__IsOccurrenceSrcInput{
			Source:     source,
			Artifact:   artifact,
			Occurrence: occurrence,
		},
	}
	var err error

	var data IsOccurrenceSrcResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func Scorecard(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	scorecard ScorecardInputSpec,
) (*ScorecardResponse, error) {
	req := &graphql.Request{
		OpName: "Scorecard",
		Query: `
mutation Scorecard ($source: SourceInputSpec!, $scorecard: ScorecardInputSpec!) {
	ingestSource(source: $source) {
		... allSrcTree
	}
	certifyScorecard(source: $source, scorecard: $scorecard) {
		... allCertifyScorecard
	}
}
fragment allSrcTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allCertifyScorecard on CertifyScorecard {
	source {
		... allSrcTree
	}
	scorecard {
		timeScanned
		aggregateScore
		checks {
			check
			score
		}
		scorecardVersion
		scorecardCommit
		origin
		collector
	}
}
`,
		Variables: &__ScorecardInput{
			Source:    source,
			Scorecard: scorecard,
		},
	}
	var err error

	var data ScorecardResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}
