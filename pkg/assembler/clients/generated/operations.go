// Code generated by github.com/Khan/genqlient, DO NOT EDIT.

package generated

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Khan/genqlient/graphql"
)

// ArtifactInputSpec is the same as Artifact, but used as mutation input.
//
// Both arguments will be canonicalized to lowercase.
type ArtifactInputSpec struct {
	Algorithm string `json:"algorithm"`
	Digest    string `json:"digest"`
}

// GetAlgorithm returns ArtifactInputSpec.Algorithm, and is useful for accessing the field via an interface.
func (v *ArtifactInputSpec) GetAlgorithm() string { return v.Algorithm }

// GetDigest returns ArtifactInputSpec.Digest, and is useful for accessing the field via an interface.
func (v *ArtifactInputSpec) GetDigest() string { return v.Digest }

// BuilderInputSpec is the same as Builder, but used for mutation ingestion.
type BuilderInputSpec struct {
	Uri string `json:"uri"`
}

// GetUri returns BuilderInputSpec.Uri, and is useful for accessing the field via an interface.
func (v *BuilderInputSpec) GetUri() string { return v.Uri }

// CVEInputSpec is the same as CVESpec, but used for mutation ingestion.
type CVEInputSpec struct {
	Year  string `json:"year"`
	CveId string `json:"cveId"`
}

// GetYear returns CVEInputSpec.Year, and is useful for accessing the field via an interface.
func (v *CVEInputSpec) GetYear() string { return v.Year }

// GetCveId returns CVEInputSpec.CveId, and is useful for accessing the field via an interface.
func (v *CVEInputSpec) GetCveId() string { return v.CveId }

// CertifyBadArtifactIngestArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type CertifyBadArtifactIngestArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns CertifyBadArtifactIngestArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *CertifyBadArtifactIngestArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns CertifyBadArtifactIngestArtifact.Digest, and is useful for accessing the field via an interface.
func (v *CertifyBadArtifactIngestArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *CertifyBadArtifactIngestArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyBadArtifactIngestArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyBadArtifactIngestArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyBadArtifactIngestArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *CertifyBadArtifactIngestArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyBadArtifactIngestArtifact) __premarshalJSON() (*__premarshalCertifyBadArtifactIngestArtifact, error) {
	var retval __premarshalCertifyBadArtifactIngestArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// CertifyBadArtifactIngestCertifyBad includes the requested fields of the GraphQL type CertifyBad.
// The GraphQL type's documentation follows.
//
// # CertifyBad is an attestation represents when a package, source or artifact is considered bad
//
// subject - union type that can be either a package, source or artifact object type
// justification (property) - string value representing why the subject is considered bad
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
//
// Note: Attestation must occur at the PackageName or the PackageVersion or at the SourceName.
type CertifyBadArtifactIngestCertifyBad struct {
	allCertifyBad `json:"-"`
}

// GetJustification returns CertifyBadArtifactIngestCertifyBad.Justification, and is useful for accessing the field via an interface.
func (v *CertifyBadArtifactIngestCertifyBad) GetJustification() string {
	return v.allCertifyBad.Justification
}

// GetSubject returns CertifyBadArtifactIngestCertifyBad.Subject, and is useful for accessing the field via an interface.
func (v *CertifyBadArtifactIngestCertifyBad) GetSubject() allCertifyBadSubjectPackageSourceOrArtifact {
	return v.allCertifyBad.Subject
}

func (v *CertifyBadArtifactIngestCertifyBad) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyBadArtifactIngestCertifyBad
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyBadArtifactIngestCertifyBad = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyBad)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyBadArtifactIngestCertifyBad struct {
	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`
}

func (v *CertifyBadArtifactIngestCertifyBad) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyBadArtifactIngestCertifyBad) __premarshalJSON() (*__premarshalCertifyBadArtifactIngestCertifyBad, error) {
	var retval __premarshalCertifyBadArtifactIngestCertifyBad

	retval.Justification = v.allCertifyBad.Justification
	{

		dst := &retval.Subject
		src := v.allCertifyBad.Subject
		var err error
		*dst, err = __marshalallCertifyBadSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal CertifyBadArtifactIngestCertifyBad.allCertifyBad.Subject: %w", err)
		}
	}
	return &retval, nil
}

// CertifyBadArtifactResponse is returned by CertifyBadArtifact on success.
type CertifyBadArtifactResponse struct {
	// Ingest a new artifact. Returns the ingested artifact
	IngestArtifact CertifyBadArtifactIngestArtifact `json:"ingestArtifact"`
	// Adds a certification that two packages are similar
	IngestCertifyBad CertifyBadArtifactIngestCertifyBad `json:"ingestCertifyBad"`
}

// GetIngestArtifact returns CertifyBadArtifactResponse.IngestArtifact, and is useful for accessing the field via an interface.
func (v *CertifyBadArtifactResponse) GetIngestArtifact() CertifyBadArtifactIngestArtifact {
	return v.IngestArtifact
}

// GetIngestCertifyBad returns CertifyBadArtifactResponse.IngestCertifyBad, and is useful for accessing the field via an interface.
func (v *CertifyBadArtifactResponse) GetIngestCertifyBad() CertifyBadArtifactIngestCertifyBad {
	return v.IngestCertifyBad
}

// CertifyBadInputSpec is the same as CertifyBad but for mutation input.
//
// All fields are required.
type CertifyBadInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetJustification returns CertifyBadInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *CertifyBadInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns CertifyBadInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *CertifyBadInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns CertifyBadInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *CertifyBadInputSpec) GetCollector() string { return v.Collector }

// CertifyBadPkgIngestCertifyBad includes the requested fields of the GraphQL type CertifyBad.
// The GraphQL type's documentation follows.
//
// # CertifyBad is an attestation represents when a package, source or artifact is considered bad
//
// subject - union type that can be either a package, source or artifact object type
// justification (property) - string value representing why the subject is considered bad
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
//
// Note: Attestation must occur at the PackageName or the PackageVersion or at the SourceName.
type CertifyBadPkgIngestCertifyBad struct {
	allCertifyBad `json:"-"`
}

// GetJustification returns CertifyBadPkgIngestCertifyBad.Justification, and is useful for accessing the field via an interface.
func (v *CertifyBadPkgIngestCertifyBad) GetJustification() string {
	return v.allCertifyBad.Justification
}

// GetSubject returns CertifyBadPkgIngestCertifyBad.Subject, and is useful for accessing the field via an interface.
func (v *CertifyBadPkgIngestCertifyBad) GetSubject() allCertifyBadSubjectPackageSourceOrArtifact {
	return v.allCertifyBad.Subject
}

func (v *CertifyBadPkgIngestCertifyBad) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyBadPkgIngestCertifyBad
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyBadPkgIngestCertifyBad = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyBad)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyBadPkgIngestCertifyBad struct {
	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`
}

func (v *CertifyBadPkgIngestCertifyBad) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyBadPkgIngestCertifyBad) __premarshalJSON() (*__premarshalCertifyBadPkgIngestCertifyBad, error) {
	var retval __premarshalCertifyBadPkgIngestCertifyBad

	retval.Justification = v.allCertifyBad.Justification
	{

		dst := &retval.Subject
		src := v.allCertifyBad.Subject
		var err error
		*dst, err = __marshalallCertifyBadSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal CertifyBadPkgIngestCertifyBad.allCertifyBad.Subject: %w", err)
		}
	}
	return &retval, nil
}

// CertifyBadPkgIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type CertifyBadPkgIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns CertifyBadPkgIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *CertifyBadPkgIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns CertifyBadPkgIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *CertifyBadPkgIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *CertifyBadPkgIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyBadPkgIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyBadPkgIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyBadPkgIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *CertifyBadPkgIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyBadPkgIngestPackage) __premarshalJSON() (*__premarshalCertifyBadPkgIngestPackage, error) {
	var retval __premarshalCertifyBadPkgIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// CertifyBadPkgResponse is returned by CertifyBadPkg on success.
type CertifyBadPkgResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage CertifyBadPkgIngestPackage `json:"ingestPackage"`
	// Adds a certification that two packages are similar
	IngestCertifyBad CertifyBadPkgIngestCertifyBad `json:"ingestCertifyBad"`
}

// GetIngestPackage returns CertifyBadPkgResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *CertifyBadPkgResponse) GetIngestPackage() CertifyBadPkgIngestPackage { return v.IngestPackage }

// GetIngestCertifyBad returns CertifyBadPkgResponse.IngestCertifyBad, and is useful for accessing the field via an interface.
func (v *CertifyBadPkgResponse) GetIngestCertifyBad() CertifyBadPkgIngestCertifyBad {
	return v.IngestCertifyBad
}

// CertifyBadSrcIngestCertifyBad includes the requested fields of the GraphQL type CertifyBad.
// The GraphQL type's documentation follows.
//
// # CertifyBad is an attestation represents when a package, source or artifact is considered bad
//
// subject - union type that can be either a package, source or artifact object type
// justification (property) - string value representing why the subject is considered bad
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
//
// Note: Attestation must occur at the PackageName or the PackageVersion or at the SourceName.
type CertifyBadSrcIngestCertifyBad struct {
	allCertifyBad `json:"-"`
}

// GetJustification returns CertifyBadSrcIngestCertifyBad.Justification, and is useful for accessing the field via an interface.
func (v *CertifyBadSrcIngestCertifyBad) GetJustification() string {
	return v.allCertifyBad.Justification
}

// GetSubject returns CertifyBadSrcIngestCertifyBad.Subject, and is useful for accessing the field via an interface.
func (v *CertifyBadSrcIngestCertifyBad) GetSubject() allCertifyBadSubjectPackageSourceOrArtifact {
	return v.allCertifyBad.Subject
}

func (v *CertifyBadSrcIngestCertifyBad) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyBadSrcIngestCertifyBad
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyBadSrcIngestCertifyBad = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyBad)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyBadSrcIngestCertifyBad struct {
	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`
}

func (v *CertifyBadSrcIngestCertifyBad) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyBadSrcIngestCertifyBad) __premarshalJSON() (*__premarshalCertifyBadSrcIngestCertifyBad, error) {
	var retval __premarshalCertifyBadSrcIngestCertifyBad

	retval.Justification = v.allCertifyBad.Justification
	{

		dst := &retval.Subject
		src := v.allCertifyBad.Subject
		var err error
		*dst, err = __marshalallCertifyBadSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal CertifyBadSrcIngestCertifyBad.allCertifyBad.Subject: %w", err)
		}
	}
	return &retval, nil
}

// CertifyBadSrcIngestSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type CertifyBadSrcIngestSource struct {
	allSourceTree `json:"-"`
}

// GetType returns CertifyBadSrcIngestSource.Type, and is useful for accessing the field via an interface.
func (v *CertifyBadSrcIngestSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns CertifyBadSrcIngestSource.Namespaces, and is useful for accessing the field via an interface.
func (v *CertifyBadSrcIngestSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *CertifyBadSrcIngestSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyBadSrcIngestSource
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyBadSrcIngestSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyBadSrcIngestSource struct {
	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *CertifyBadSrcIngestSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyBadSrcIngestSource) __premarshalJSON() (*__premarshalCertifyBadSrcIngestSource, error) {
	var retval __premarshalCertifyBadSrcIngestSource

	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// CertifyBadSrcResponse is returned by CertifyBadSrc on success.
type CertifyBadSrcResponse struct {
	// Ingest a new source. Returns the ingested source trie
	IngestSource CertifyBadSrcIngestSource `json:"ingestSource"`
	// Adds a certification that two packages are similar
	IngestCertifyBad CertifyBadSrcIngestCertifyBad `json:"ingestCertifyBad"`
}

// GetIngestSource returns CertifyBadSrcResponse.IngestSource, and is useful for accessing the field via an interface.
func (v *CertifyBadSrcResponse) GetIngestSource() CertifyBadSrcIngestSource { return v.IngestSource }

// GetIngestCertifyBad returns CertifyBadSrcResponse.IngestCertifyBad, and is useful for accessing the field via an interface.
func (v *CertifyBadSrcResponse) GetIngestCertifyBad() CertifyBadSrcIngestCertifyBad {
	return v.IngestCertifyBad
}

// CertifyCVEIngestCVE includes the requested fields of the GraphQL type CVE.
// The GraphQL type's documentation follows.
//
// CVE represents common vulnerabilities and exposures. It contains the year along
// with the CVE ID.
//
// The year is mandatory.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `year` value.
type CertifyCVEIngestCVE struct {
	allCveTree `json:"-"`
}

// GetYear returns CertifyCVEIngestCVE.Year, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestCVE) GetYear() string { return v.allCveTree.Year }

// GetCveId returns CertifyCVEIngestCVE.CveId, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestCVE) GetCveId() []allCveTreeCveIdCVEId { return v.allCveTree.CveId }

func (v *CertifyCVEIngestCVE) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyCVEIngestCVE
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyCVEIngestCVE = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCveTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyCVEIngestCVE struct {
	Year string `json:"year"`

	CveId []allCveTreeCveIdCVEId `json:"cveId"`
}

func (v *CertifyCVEIngestCVE) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyCVEIngestCVE) __premarshalJSON() (*__premarshalCertifyCVEIngestCVE, error) {
	var retval __premarshalCertifyCVEIngestCVE

	retval.Year = v.allCveTree.Year
	retval.CveId = v.allCveTree.CveId
	return &retval, nil
}

// CertifyCVEIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type CertifyCVEIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns CertifyCVEIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns CertifyCVEIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *CertifyCVEIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyCVEIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyCVEIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyCVEIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *CertifyCVEIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyCVEIngestPackage) __premarshalJSON() (*__premarshalCertifyCVEIngestPackage, error) {
	var retval __premarshalCertifyCVEIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// CertifyCVEIngestVulnerabilityCertifyVuln includes the requested fields of the GraphQL type CertifyVuln.
// The GraphQL type's documentation follows.
//
// CertifyVuln is an attestation that represents when a package has a vulnerability
type CertifyCVEIngestVulnerabilityCertifyVuln struct {
	allCertifyVuln `json:"-"`
}

// GetPackage returns CertifyCVEIngestVulnerabilityCertifyVuln.Package, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestVulnerabilityCertifyVuln) GetPackage() allCertifyVulnPackage {
	return v.allCertifyVuln.Package
}

// GetVulnerability returns CertifyCVEIngestVulnerabilityCertifyVuln.Vulnerability, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestVulnerabilityCertifyVuln) GetVulnerability() allCertifyVulnVulnerabilityOsvCveOrGhsa {
	return v.allCertifyVuln.Vulnerability
}

// GetMetadata returns CertifyCVEIngestVulnerabilityCertifyVuln.Metadata, and is useful for accessing the field via an interface.
func (v *CertifyCVEIngestVulnerabilityCertifyVuln) GetMetadata() allCertifyVulnMetadataVulnerabilityMetaData {
	return v.allCertifyVuln.Metadata
}

func (v *CertifyCVEIngestVulnerabilityCertifyVuln) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyCVEIngestVulnerabilityCertifyVuln
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyCVEIngestVulnerabilityCertifyVuln = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyVuln)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyCVEIngestVulnerabilityCertifyVuln struct {
	Package allCertifyVulnPackage `json:"package"`

	Vulnerability json.RawMessage `json:"vulnerability"`

	Metadata allCertifyVulnMetadataVulnerabilityMetaData `json:"metadata"`
}

func (v *CertifyCVEIngestVulnerabilityCertifyVuln) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyCVEIngestVulnerabilityCertifyVuln) __premarshalJSON() (*__premarshalCertifyCVEIngestVulnerabilityCertifyVuln, error) {
	var retval __premarshalCertifyCVEIngestVulnerabilityCertifyVuln

	retval.Package = v.allCertifyVuln.Package
	{

		dst := &retval.Vulnerability
		src := v.allCertifyVuln.Vulnerability
		var err error
		*dst, err = __marshalallCertifyVulnVulnerabilityOsvCveOrGhsa(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal CertifyCVEIngestVulnerabilityCertifyVuln.allCertifyVuln.Vulnerability: %w", err)
		}
	}
	retval.Metadata = v.allCertifyVuln.Metadata
	return &retval, nil
}

// CertifyCVEResponse is returned by CertifyCVE on success.
type CertifyCVEResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage CertifyCVEIngestPackage `json:"ingestPackage"`
	// Ingest a new CVE. Returns the ingested object
	IngestCVE CertifyCVEIngestCVE `json:"ingestCVE"`
	// certify that a package is vulnerable to a vulnerability (OSV, CVE or GHSA)
	IngestVulnerability CertifyCVEIngestVulnerabilityCertifyVuln `json:"ingestVulnerability"`
}

// GetIngestPackage returns CertifyCVEResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *CertifyCVEResponse) GetIngestPackage() CertifyCVEIngestPackage { return v.IngestPackage }

// GetIngestCVE returns CertifyCVEResponse.IngestCVE, and is useful for accessing the field via an interface.
func (v *CertifyCVEResponse) GetIngestCVE() CertifyCVEIngestCVE { return v.IngestCVE }

// GetIngestVulnerability returns CertifyCVEResponse.IngestVulnerability, and is useful for accessing the field via an interface.
func (v *CertifyCVEResponse) GetIngestVulnerability() CertifyCVEIngestVulnerabilityCertifyVuln {
	return v.IngestVulnerability
}

// CertifyGHSAIngestGHSA includes the requested fields of the GraphQL type GHSA.
// The GraphQL type's documentation follows.
//
// GHSA represents GitHub security advisories.
//
// We create a separate node to allow retrieving all GHSAs.
type CertifyGHSAIngestGHSA struct {
	allGHSATree `json:"-"`
}

// GetGhsaId returns CertifyGHSAIngestGHSA.GhsaId, and is useful for accessing the field via an interface.
func (v *CertifyGHSAIngestGHSA) GetGhsaId() []allGHSATreeGhsaIdGHSAId { return v.allGHSATree.GhsaId }

func (v *CertifyGHSAIngestGHSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyGHSAIngestGHSA
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyGHSAIngestGHSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allGHSATree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyGHSAIngestGHSA struct {
	GhsaId []allGHSATreeGhsaIdGHSAId `json:"ghsaId"`
}

func (v *CertifyGHSAIngestGHSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyGHSAIngestGHSA) __premarshalJSON() (*__premarshalCertifyGHSAIngestGHSA, error) {
	var retval __premarshalCertifyGHSAIngestGHSA

	retval.GhsaId = v.allGHSATree.GhsaId
	return &retval, nil
}

// CertifyGHSAIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type CertifyGHSAIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns CertifyGHSAIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *CertifyGHSAIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns CertifyGHSAIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *CertifyGHSAIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *CertifyGHSAIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyGHSAIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyGHSAIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyGHSAIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *CertifyGHSAIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyGHSAIngestPackage) __premarshalJSON() (*__premarshalCertifyGHSAIngestPackage, error) {
	var retval __premarshalCertifyGHSAIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// CertifyGHSAIngestVulnerabilityCertifyVuln includes the requested fields of the GraphQL type CertifyVuln.
// The GraphQL type's documentation follows.
//
// CertifyVuln is an attestation that represents when a package has a vulnerability
type CertifyGHSAIngestVulnerabilityCertifyVuln struct {
	allCertifyVuln `json:"-"`
}

// GetPackage returns CertifyGHSAIngestVulnerabilityCertifyVuln.Package, and is useful for accessing the field via an interface.
func (v *CertifyGHSAIngestVulnerabilityCertifyVuln) GetPackage() allCertifyVulnPackage {
	return v.allCertifyVuln.Package
}

// GetVulnerability returns CertifyGHSAIngestVulnerabilityCertifyVuln.Vulnerability, and is useful for accessing the field via an interface.
func (v *CertifyGHSAIngestVulnerabilityCertifyVuln) GetVulnerability() allCertifyVulnVulnerabilityOsvCveOrGhsa {
	return v.allCertifyVuln.Vulnerability
}

// GetMetadata returns CertifyGHSAIngestVulnerabilityCertifyVuln.Metadata, and is useful for accessing the field via an interface.
func (v *CertifyGHSAIngestVulnerabilityCertifyVuln) GetMetadata() allCertifyVulnMetadataVulnerabilityMetaData {
	return v.allCertifyVuln.Metadata
}

func (v *CertifyGHSAIngestVulnerabilityCertifyVuln) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyGHSAIngestVulnerabilityCertifyVuln
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyGHSAIngestVulnerabilityCertifyVuln = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyVuln)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyGHSAIngestVulnerabilityCertifyVuln struct {
	Package allCertifyVulnPackage `json:"package"`

	Vulnerability json.RawMessage `json:"vulnerability"`

	Metadata allCertifyVulnMetadataVulnerabilityMetaData `json:"metadata"`
}

func (v *CertifyGHSAIngestVulnerabilityCertifyVuln) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyGHSAIngestVulnerabilityCertifyVuln) __premarshalJSON() (*__premarshalCertifyGHSAIngestVulnerabilityCertifyVuln, error) {
	var retval __premarshalCertifyGHSAIngestVulnerabilityCertifyVuln

	retval.Package = v.allCertifyVuln.Package
	{

		dst := &retval.Vulnerability
		src := v.allCertifyVuln.Vulnerability
		var err error
		*dst, err = __marshalallCertifyVulnVulnerabilityOsvCveOrGhsa(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal CertifyGHSAIngestVulnerabilityCertifyVuln.allCertifyVuln.Vulnerability: %w", err)
		}
	}
	retval.Metadata = v.allCertifyVuln.Metadata
	return &retval, nil
}

// CertifyGHSAResponse is returned by CertifyGHSA on success.
type CertifyGHSAResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage CertifyGHSAIngestPackage `json:"ingestPackage"`
	// Ingest a new GHSA. Returns the ingested object
	IngestGHSA CertifyGHSAIngestGHSA `json:"ingestGHSA"`
	// certify that a package is vulnerable to a vulnerability (OSV, CVE or GHSA)
	IngestVulnerability CertifyGHSAIngestVulnerabilityCertifyVuln `json:"ingestVulnerability"`
}

// GetIngestPackage returns CertifyGHSAResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *CertifyGHSAResponse) GetIngestPackage() CertifyGHSAIngestPackage { return v.IngestPackage }

// GetIngestGHSA returns CertifyGHSAResponse.IngestGHSA, and is useful for accessing the field via an interface.
func (v *CertifyGHSAResponse) GetIngestGHSA() CertifyGHSAIngestGHSA { return v.IngestGHSA }

// GetIngestVulnerability returns CertifyGHSAResponse.IngestVulnerability, and is useful for accessing the field via an interface.
func (v *CertifyGHSAResponse) GetIngestVulnerability() CertifyGHSAIngestVulnerabilityCertifyVuln {
	return v.IngestVulnerability
}

// CertifyOSVIngestOSV includes the requested fields of the GraphQL type OSV.
// The GraphQL type's documentation follows.
//
// OSV represents an Open Source Vulnerability.
//
// We create a separate node to allow retrieving all OSVs.
type CertifyOSVIngestOSV struct {
	allOSVTree `json:"-"`
}

// GetOsvId returns CertifyOSVIngestOSV.OsvId, and is useful for accessing the field via an interface.
func (v *CertifyOSVIngestOSV) GetOsvId() []allOSVTreeOsvIdOSVId { return v.allOSVTree.OsvId }

func (v *CertifyOSVIngestOSV) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyOSVIngestOSV
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyOSVIngestOSV = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allOSVTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyOSVIngestOSV struct {
	OsvId []allOSVTreeOsvIdOSVId `json:"osvId"`
}

func (v *CertifyOSVIngestOSV) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyOSVIngestOSV) __premarshalJSON() (*__premarshalCertifyOSVIngestOSV, error) {
	var retval __premarshalCertifyOSVIngestOSV

	retval.OsvId = v.allOSVTree.OsvId
	return &retval, nil
}

// CertifyOSVIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type CertifyOSVIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns CertifyOSVIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *CertifyOSVIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns CertifyOSVIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *CertifyOSVIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *CertifyOSVIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyOSVIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyOSVIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyOSVIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *CertifyOSVIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyOSVIngestPackage) __premarshalJSON() (*__premarshalCertifyOSVIngestPackage, error) {
	var retval __premarshalCertifyOSVIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// CertifyOSVIngestVulnerabilityCertifyVuln includes the requested fields of the GraphQL type CertifyVuln.
// The GraphQL type's documentation follows.
//
// CertifyVuln is an attestation that represents when a package has a vulnerability
type CertifyOSVIngestVulnerabilityCertifyVuln struct {
	allCertifyVuln `json:"-"`
}

// GetPackage returns CertifyOSVIngestVulnerabilityCertifyVuln.Package, and is useful for accessing the field via an interface.
func (v *CertifyOSVIngestVulnerabilityCertifyVuln) GetPackage() allCertifyVulnPackage {
	return v.allCertifyVuln.Package
}

// GetVulnerability returns CertifyOSVIngestVulnerabilityCertifyVuln.Vulnerability, and is useful for accessing the field via an interface.
func (v *CertifyOSVIngestVulnerabilityCertifyVuln) GetVulnerability() allCertifyVulnVulnerabilityOsvCveOrGhsa {
	return v.allCertifyVuln.Vulnerability
}

// GetMetadata returns CertifyOSVIngestVulnerabilityCertifyVuln.Metadata, and is useful for accessing the field via an interface.
func (v *CertifyOSVIngestVulnerabilityCertifyVuln) GetMetadata() allCertifyVulnMetadataVulnerabilityMetaData {
	return v.allCertifyVuln.Metadata
}

func (v *CertifyOSVIngestVulnerabilityCertifyVuln) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyOSVIngestVulnerabilityCertifyVuln
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyOSVIngestVulnerabilityCertifyVuln = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyVuln)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyOSVIngestVulnerabilityCertifyVuln struct {
	Package allCertifyVulnPackage `json:"package"`

	Vulnerability json.RawMessage `json:"vulnerability"`

	Metadata allCertifyVulnMetadataVulnerabilityMetaData `json:"metadata"`
}

func (v *CertifyOSVIngestVulnerabilityCertifyVuln) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyOSVIngestVulnerabilityCertifyVuln) __premarshalJSON() (*__premarshalCertifyOSVIngestVulnerabilityCertifyVuln, error) {
	var retval __premarshalCertifyOSVIngestVulnerabilityCertifyVuln

	retval.Package = v.allCertifyVuln.Package
	{

		dst := &retval.Vulnerability
		src := v.allCertifyVuln.Vulnerability
		var err error
		*dst, err = __marshalallCertifyVulnVulnerabilityOsvCveOrGhsa(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal CertifyOSVIngestVulnerabilityCertifyVuln.allCertifyVuln.Vulnerability: %w", err)
		}
	}
	retval.Metadata = v.allCertifyVuln.Metadata
	return &retval, nil
}

// CertifyOSVResponse is returned by CertifyOSV on success.
type CertifyOSVResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage CertifyOSVIngestPackage `json:"ingestPackage"`
	// Ingest a new OSV. Returns the ingested object
	IngestOSV CertifyOSVIngestOSV `json:"ingestOSV"`
	// certify that a package is vulnerable to a vulnerability (OSV, CVE or GHSA)
	IngestVulnerability CertifyOSVIngestVulnerabilityCertifyVuln `json:"ingestVulnerability"`
}

// GetIngestPackage returns CertifyOSVResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *CertifyOSVResponse) GetIngestPackage() CertifyOSVIngestPackage { return v.IngestPackage }

// GetIngestOSV returns CertifyOSVResponse.IngestOSV, and is useful for accessing the field via an interface.
func (v *CertifyOSVResponse) GetIngestOSV() CertifyOSVIngestOSV { return v.IngestOSV }

// GetIngestVulnerability returns CertifyOSVResponse.IngestVulnerability, and is useful for accessing the field via an interface.
func (v *CertifyOSVResponse) GetIngestVulnerability() CertifyOSVIngestVulnerabilityCertifyVuln {
	return v.IngestVulnerability
}

// CertifyPkgDependentPkgPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type CertifyPkgDependentPkgPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns CertifyPkgDependentPkgPackage.Type, and is useful for accessing the field via an interface.
func (v *CertifyPkgDependentPkgPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns CertifyPkgDependentPkgPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *CertifyPkgDependentPkgPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *CertifyPkgDependentPkgPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyPkgDependentPkgPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyPkgDependentPkgPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyPkgDependentPkgPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *CertifyPkgDependentPkgPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyPkgDependentPkgPackage) __premarshalJSON() (*__premarshalCertifyPkgDependentPkgPackage, error) {
	var retval __premarshalCertifyPkgDependentPkgPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// CertifyPkgIngestCertifyPkg includes the requested fields of the GraphQL type CertifyPkg.
// The GraphQL type's documentation follows.
//
// # CertifyPkg is an attestation that represents when a package objects are similar
//
// packages (subject) - list of package objects
// justification (property) - string value representing why the packages are similar
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type CertifyPkgIngestCertifyPkg struct {
	allCertifyPkg `json:"-"`
}

// GetJustification returns CertifyPkgIngestCertifyPkg.Justification, and is useful for accessing the field via an interface.
func (v *CertifyPkgIngestCertifyPkg) GetJustification() string { return v.allCertifyPkg.Justification }

// GetPackages returns CertifyPkgIngestCertifyPkg.Packages, and is useful for accessing the field via an interface.
func (v *CertifyPkgIngestCertifyPkg) GetPackages() []allCertifyPkgPackagesPackage {
	return v.allCertifyPkg.Packages
}

// GetOrigin returns CertifyPkgIngestCertifyPkg.Origin, and is useful for accessing the field via an interface.
func (v *CertifyPkgIngestCertifyPkg) GetOrigin() string { return v.allCertifyPkg.Origin }

// GetCollector returns CertifyPkgIngestCertifyPkg.Collector, and is useful for accessing the field via an interface.
func (v *CertifyPkgIngestCertifyPkg) GetCollector() string { return v.allCertifyPkg.Collector }

func (v *CertifyPkgIngestCertifyPkg) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyPkgIngestCertifyPkg
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyPkgIngestCertifyPkg = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyPkg)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyPkgIngestCertifyPkg struct {
	Justification string `json:"justification"`

	Packages []allCertifyPkgPackagesPackage `json:"packages"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *CertifyPkgIngestCertifyPkg) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyPkgIngestCertifyPkg) __premarshalJSON() (*__premarshalCertifyPkgIngestCertifyPkg, error) {
	var retval __premarshalCertifyPkgIngestCertifyPkg

	retval.Justification = v.allCertifyPkg.Justification
	retval.Packages = v.allCertifyPkg.Packages
	retval.Origin = v.allCertifyPkg.Origin
	retval.Collector = v.allCertifyPkg.Collector
	return &retval, nil
}

// CertifyPkgInputSpec is the same as CertifyPkg but for mutation input.
//
// All fields are required.
type CertifyPkgInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetJustification returns CertifyPkgInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *CertifyPkgInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns CertifyPkgInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *CertifyPkgInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns CertifyPkgInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *CertifyPkgInputSpec) GetCollector() string { return v.Collector }

// CertifyPkgPkgPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type CertifyPkgPkgPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns CertifyPkgPkgPackage.Type, and is useful for accessing the field via an interface.
func (v *CertifyPkgPkgPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns CertifyPkgPkgPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *CertifyPkgPkgPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *CertifyPkgPkgPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*CertifyPkgPkgPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.CertifyPkgPkgPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalCertifyPkgPkgPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *CertifyPkgPkgPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *CertifyPkgPkgPackage) __premarshalJSON() (*__premarshalCertifyPkgPkgPackage, error) {
	var retval __premarshalCertifyPkgPkgPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// CertifyPkgResponse is returned by CertifyPkg on success.
type CertifyPkgResponse struct {
	// Ingest a new package. Returns the ingested package trie
	Pkg CertifyPkgPkgPackage `json:"pkg"`
	// Ingest a new package. Returns the ingested package trie
	DependentPkg CertifyPkgDependentPkgPackage `json:"dependentPkg"`
	// Adds a certification that two packages are similar
	IngestCertifyPkg CertifyPkgIngestCertifyPkg `json:"ingestCertifyPkg"`
}

// GetPkg returns CertifyPkgResponse.Pkg, and is useful for accessing the field via an interface.
func (v *CertifyPkgResponse) GetPkg() CertifyPkgPkgPackage { return v.Pkg }

// GetDependentPkg returns CertifyPkgResponse.DependentPkg, and is useful for accessing the field via an interface.
func (v *CertifyPkgResponse) GetDependentPkg() CertifyPkgDependentPkgPackage { return v.DependentPkg }

// GetIngestCertifyPkg returns CertifyPkgResponse.IngestCertifyPkg, and is useful for accessing the field via an interface.
func (v *CertifyPkgResponse) GetIngestCertifyPkg() CertifyPkgIngestCertifyPkg {
	return v.IngestCertifyPkg
}

// GHSAInputSpec is the same as GHSASpec, but used for mutation ingestion.
type GHSAInputSpec struct {
	GhsaId string `json:"ghsaId"`
}

// GetGhsaId returns GHSAInputSpec.GhsaId, and is useful for accessing the field via an interface.
func (v *GHSAInputSpec) GetGhsaId() string { return v.GhsaId }

// HasSBOMInputSpec is the same as HasSBOM but for mutation input.
//
// All fields are required.
type HasSBOMInputSpec struct {
	Uri       string `json:"uri"`
	Origin    string `json:"origin"`
	Collector string `json:"collector"`
}

// GetUri returns HasSBOMInputSpec.Uri, and is useful for accessing the field via an interface.
func (v *HasSBOMInputSpec) GetUri() string { return v.Uri }

// GetOrigin returns HasSBOMInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *HasSBOMInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns HasSBOMInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *HasSBOMInputSpec) GetCollector() string { return v.Collector }

// HasSBOMPkgIngestHasSBOM includes the requested fields of the GraphQL type HasSBOM.
// The GraphQL type's documentation follows.
//
// # HasSBOM is an attestation represents that a package object or source object has an SBOM associated with a uri
//
// subject - union type that can be either a package or source object type
// uri (property) - identifier string for the SBOM
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
//
// Note: Only package object or source object can be defined. Not both.
type HasSBOMPkgIngestHasSBOM struct {
	allHasSBOMTree `json:"-"`
}

// GetUri returns HasSBOMPkgIngestHasSBOM.Uri, and is useful for accessing the field via an interface.
func (v *HasSBOMPkgIngestHasSBOM) GetUri() string { return v.allHasSBOMTree.Uri }

// GetSubject returns HasSBOMPkgIngestHasSBOM.Subject, and is useful for accessing the field via an interface.
func (v *HasSBOMPkgIngestHasSBOM) GetSubject() allHasSBOMTreeSubjectPackageOrSource {
	return v.allHasSBOMTree.Subject
}

// GetOrigin returns HasSBOMPkgIngestHasSBOM.Origin, and is useful for accessing the field via an interface.
func (v *HasSBOMPkgIngestHasSBOM) GetOrigin() string { return v.allHasSBOMTree.Origin }

// GetCollector returns HasSBOMPkgIngestHasSBOM.Collector, and is useful for accessing the field via an interface.
func (v *HasSBOMPkgIngestHasSBOM) GetCollector() string { return v.allHasSBOMTree.Collector }

func (v *HasSBOMPkgIngestHasSBOM) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*HasSBOMPkgIngestHasSBOM
		graphql.NoUnmarshalJSON
	}
	firstPass.HasSBOMPkgIngestHasSBOM = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allHasSBOMTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalHasSBOMPkgIngestHasSBOM struct {
	Uri string `json:"uri"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *HasSBOMPkgIngestHasSBOM) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *HasSBOMPkgIngestHasSBOM) __premarshalJSON() (*__premarshalHasSBOMPkgIngestHasSBOM, error) {
	var retval __premarshalHasSBOMPkgIngestHasSBOM

	retval.Uri = v.allHasSBOMTree.Uri
	{

		dst := &retval.Subject
		src := v.allHasSBOMTree.Subject
		var err error
		*dst, err = __marshalallHasSBOMTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal HasSBOMPkgIngestHasSBOM.allHasSBOMTree.Subject: %w", err)
		}
	}
	retval.Origin = v.allHasSBOMTree.Origin
	retval.Collector = v.allHasSBOMTree.Collector
	return &retval, nil
}

// HasSBOMPkgIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type HasSBOMPkgIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns HasSBOMPkgIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *HasSBOMPkgIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns HasSBOMPkgIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *HasSBOMPkgIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *HasSBOMPkgIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*HasSBOMPkgIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.HasSBOMPkgIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalHasSBOMPkgIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *HasSBOMPkgIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *HasSBOMPkgIngestPackage) __premarshalJSON() (*__premarshalHasSBOMPkgIngestPackage, error) {
	var retval __premarshalHasSBOMPkgIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// HasSBOMPkgResponse is returned by HasSBOMPkg on success.
type HasSBOMPkgResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage HasSBOMPkgIngestPackage `json:"ingestPackage"`
	// Certifies that a package or a source has SBOM at the URI
	IngestHasSBOM HasSBOMPkgIngestHasSBOM `json:"ingestHasSBOM"`
}

// GetIngestPackage returns HasSBOMPkgResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *HasSBOMPkgResponse) GetIngestPackage() HasSBOMPkgIngestPackage { return v.IngestPackage }

// GetIngestHasSBOM returns HasSBOMPkgResponse.IngestHasSBOM, and is useful for accessing the field via an interface.
func (v *HasSBOMPkgResponse) GetIngestHasSBOM() HasSBOMPkgIngestHasSBOM { return v.IngestHasSBOM }

// HasSBOMSrcIngestHasSBOM includes the requested fields of the GraphQL type HasSBOM.
// The GraphQL type's documentation follows.
//
// # HasSBOM is an attestation represents that a package object or source object has an SBOM associated with a uri
//
// subject - union type that can be either a package or source object type
// uri (property) - identifier string for the SBOM
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
//
// Note: Only package object or source object can be defined. Not both.
type HasSBOMSrcIngestHasSBOM struct {
	allHasSBOMTree `json:"-"`
}

// GetUri returns HasSBOMSrcIngestHasSBOM.Uri, and is useful for accessing the field via an interface.
func (v *HasSBOMSrcIngestHasSBOM) GetUri() string { return v.allHasSBOMTree.Uri }

// GetSubject returns HasSBOMSrcIngestHasSBOM.Subject, and is useful for accessing the field via an interface.
func (v *HasSBOMSrcIngestHasSBOM) GetSubject() allHasSBOMTreeSubjectPackageOrSource {
	return v.allHasSBOMTree.Subject
}

// GetOrigin returns HasSBOMSrcIngestHasSBOM.Origin, and is useful for accessing the field via an interface.
func (v *HasSBOMSrcIngestHasSBOM) GetOrigin() string { return v.allHasSBOMTree.Origin }

// GetCollector returns HasSBOMSrcIngestHasSBOM.Collector, and is useful for accessing the field via an interface.
func (v *HasSBOMSrcIngestHasSBOM) GetCollector() string { return v.allHasSBOMTree.Collector }

func (v *HasSBOMSrcIngestHasSBOM) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*HasSBOMSrcIngestHasSBOM
		graphql.NoUnmarshalJSON
	}
	firstPass.HasSBOMSrcIngestHasSBOM = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allHasSBOMTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalHasSBOMSrcIngestHasSBOM struct {
	Uri string `json:"uri"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *HasSBOMSrcIngestHasSBOM) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *HasSBOMSrcIngestHasSBOM) __premarshalJSON() (*__premarshalHasSBOMSrcIngestHasSBOM, error) {
	var retval __premarshalHasSBOMSrcIngestHasSBOM

	retval.Uri = v.allHasSBOMTree.Uri
	{

		dst := &retval.Subject
		src := v.allHasSBOMTree.Subject
		var err error
		*dst, err = __marshalallHasSBOMTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal HasSBOMSrcIngestHasSBOM.allHasSBOMTree.Subject: %w", err)
		}
	}
	retval.Origin = v.allHasSBOMTree.Origin
	retval.Collector = v.allHasSBOMTree.Collector
	return &retval, nil
}

// HasSBOMSrcIngestSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type HasSBOMSrcIngestSource struct {
	allSourceTree `json:"-"`
}

// GetType returns HasSBOMSrcIngestSource.Type, and is useful for accessing the field via an interface.
func (v *HasSBOMSrcIngestSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns HasSBOMSrcIngestSource.Namespaces, and is useful for accessing the field via an interface.
func (v *HasSBOMSrcIngestSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *HasSBOMSrcIngestSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*HasSBOMSrcIngestSource
		graphql.NoUnmarshalJSON
	}
	firstPass.HasSBOMSrcIngestSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalHasSBOMSrcIngestSource struct {
	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *HasSBOMSrcIngestSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *HasSBOMSrcIngestSource) __premarshalJSON() (*__premarshalHasSBOMSrcIngestSource, error) {
	var retval __premarshalHasSBOMSrcIngestSource

	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// HasSBOMSrcResponse is returned by HasSBOMSrc on success.
type HasSBOMSrcResponse struct {
	// Ingest a new source. Returns the ingested source trie
	IngestSource HasSBOMSrcIngestSource `json:"ingestSource"`
	// Certifies that a package or a source has SBOM at the URI
	IngestHasSBOM HasSBOMSrcIngestHasSBOM `json:"ingestHasSBOM"`
}

// GetIngestSource returns HasSBOMSrcResponse.IngestSource, and is useful for accessing the field via an interface.
func (v *HasSBOMSrcResponse) GetIngestSource() HasSBOMSrcIngestSource { return v.IngestSource }

// GetIngestHasSBOM returns HasSBOMSrcResponse.IngestHasSBOM, and is useful for accessing the field via an interface.
func (v *HasSBOMSrcResponse) GetIngestHasSBOM() HasSBOMSrcIngestHasSBOM { return v.IngestHasSBOM }

// HasSourceAtIngestHasSourceAt includes the requested fields of the GraphQL type HasSourceAt.
// The GraphQL type's documentation follows.
//
// # HasSourceAt is an attestation represents that a package object has a source object since a timestamp
//
// package (subject) - the package object type that represents the package
// source (object) - the source object type that represents the source
// knownSince (property) - timestamp when this was last checked (exact time)
// justification (property) - string value representing why the package has a source specified
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type HasSourceAtIngestHasSourceAt struct {
	allHasSourceAt `json:"-"`
}

// GetJustification returns HasSourceAtIngestHasSourceAt.Justification, and is useful for accessing the field via an interface.
func (v *HasSourceAtIngestHasSourceAt) GetJustification() string {
	return v.allHasSourceAt.Justification
}

// GetKnownSince returns HasSourceAtIngestHasSourceAt.KnownSince, and is useful for accessing the field via an interface.
func (v *HasSourceAtIngestHasSourceAt) GetKnownSince() time.Time { return v.allHasSourceAt.KnownSince }

// GetPackage returns HasSourceAtIngestHasSourceAt.Package, and is useful for accessing the field via an interface.
func (v *HasSourceAtIngestHasSourceAt) GetPackage() allHasSourceAtPackage {
	return v.allHasSourceAt.Package
}

// GetSource returns HasSourceAtIngestHasSourceAt.Source, and is useful for accessing the field via an interface.
func (v *HasSourceAtIngestHasSourceAt) GetSource() allHasSourceAtSource {
	return v.allHasSourceAt.Source
}

// GetOrigin returns HasSourceAtIngestHasSourceAt.Origin, and is useful for accessing the field via an interface.
func (v *HasSourceAtIngestHasSourceAt) GetOrigin() string { return v.allHasSourceAt.Origin }

// GetCollector returns HasSourceAtIngestHasSourceAt.Collector, and is useful for accessing the field via an interface.
func (v *HasSourceAtIngestHasSourceAt) GetCollector() string { return v.allHasSourceAt.Collector }

func (v *HasSourceAtIngestHasSourceAt) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*HasSourceAtIngestHasSourceAt
		graphql.NoUnmarshalJSON
	}
	firstPass.HasSourceAtIngestHasSourceAt = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allHasSourceAt)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalHasSourceAtIngestHasSourceAt struct {
	Justification string `json:"justification"`

	KnownSince time.Time `json:"knownSince"`

	Package allHasSourceAtPackage `json:"package"`

	Source allHasSourceAtSource `json:"source"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *HasSourceAtIngestHasSourceAt) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *HasSourceAtIngestHasSourceAt) __premarshalJSON() (*__premarshalHasSourceAtIngestHasSourceAt, error) {
	var retval __premarshalHasSourceAtIngestHasSourceAt

	retval.Justification = v.allHasSourceAt.Justification
	retval.KnownSince = v.allHasSourceAt.KnownSince
	retval.Package = v.allHasSourceAt.Package
	retval.Source = v.allHasSourceAt.Source
	retval.Origin = v.allHasSourceAt.Origin
	retval.Collector = v.allHasSourceAt.Collector
	return &retval, nil
}

// HasSourceAtIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type HasSourceAtIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns HasSourceAtIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *HasSourceAtIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns HasSourceAtIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *HasSourceAtIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *HasSourceAtIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*HasSourceAtIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.HasSourceAtIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalHasSourceAtIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *HasSourceAtIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *HasSourceAtIngestPackage) __premarshalJSON() (*__premarshalHasSourceAtIngestPackage, error) {
	var retval __premarshalHasSourceAtIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// HasSourceAtIngestSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type HasSourceAtIngestSource struct {
	allSourceTree `json:"-"`
}

// GetType returns HasSourceAtIngestSource.Type, and is useful for accessing the field via an interface.
func (v *HasSourceAtIngestSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns HasSourceAtIngestSource.Namespaces, and is useful for accessing the field via an interface.
func (v *HasSourceAtIngestSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *HasSourceAtIngestSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*HasSourceAtIngestSource
		graphql.NoUnmarshalJSON
	}
	firstPass.HasSourceAtIngestSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalHasSourceAtIngestSource struct {
	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *HasSourceAtIngestSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *HasSourceAtIngestSource) __premarshalJSON() (*__premarshalHasSourceAtIngestSource, error) {
	var retval __premarshalHasSourceAtIngestSource

	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// HasSourceAtInputSpec is the same as HasSourceAt but for mutation input.
//
// All fields are required.
type HasSourceAtInputSpec struct {
	KnownSince    time.Time `json:"knownSince"`
	Justification string    `json:"justification"`
	Origin        string    `json:"origin"`
	Collector     string    `json:"collector"`
}

// GetKnownSince returns HasSourceAtInputSpec.KnownSince, and is useful for accessing the field via an interface.
func (v *HasSourceAtInputSpec) GetKnownSince() time.Time { return v.KnownSince }

// GetJustification returns HasSourceAtInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *HasSourceAtInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns HasSourceAtInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *HasSourceAtInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns HasSourceAtInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *HasSourceAtInputSpec) GetCollector() string { return v.Collector }

// HasSourceAtResponse is returned by HasSourceAt on success.
type HasSourceAtResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage HasSourceAtIngestPackage `json:"ingestPackage"`
	// Ingest a new source. Returns the ingested source trie
	IngestSource HasSourceAtIngestSource `json:"ingestSource"`
	// Adds a certification that a package (either at the version level or package name level) is associated with the source
	IngestHasSourceAt HasSourceAtIngestHasSourceAt `json:"ingestHasSourceAt"`
}

// GetIngestPackage returns HasSourceAtResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *HasSourceAtResponse) GetIngestPackage() HasSourceAtIngestPackage { return v.IngestPackage }

// GetIngestSource returns HasSourceAtResponse.IngestSource, and is useful for accessing the field via an interface.
func (v *HasSourceAtResponse) GetIngestSource() HasSourceAtIngestSource { return v.IngestSource }

// GetIngestHasSourceAt returns HasSourceAtResponse.IngestHasSourceAt, and is useful for accessing the field via an interface.
func (v *HasSourceAtResponse) GetIngestHasSourceAt() HasSourceAtIngestHasSourceAt {
	return v.IngestHasSourceAt
}

// HashEqualArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type HashEqualArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns HashEqualArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *HashEqualArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns HashEqualArtifact.Digest, and is useful for accessing the field via an interface.
func (v *HashEqualArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *HashEqualArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*HashEqualArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.HashEqualArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalHashEqualArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *HashEqualArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *HashEqualArtifact) __premarshalJSON() (*__premarshalHashEqualArtifact, error) {
	var retval __premarshalHashEqualArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// HashEqualEqualArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type HashEqualEqualArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns HashEqualEqualArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *HashEqualEqualArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns HashEqualEqualArtifact.Digest, and is useful for accessing the field via an interface.
func (v *HashEqualEqualArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *HashEqualEqualArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*HashEqualEqualArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.HashEqualEqualArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalHashEqualEqualArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *HashEqualEqualArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *HashEqualEqualArtifact) __premarshalJSON() (*__premarshalHashEqualEqualArtifact, error) {
	var retval __premarshalHashEqualEqualArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// HashEqualIngestHashEqual includes the requested fields of the GraphQL type HashEqual.
// The GraphQL type's documentation follows.
//
// HashEqual is an attestation that represents when two artifact hash are similar based on a justification.
//
// artifacts (subject) - the artifacts (represented by algorithm and digest) that are equal
// justification (property) - string value representing why the artifacts are the equal
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type HashEqualIngestHashEqual struct {
	allHashEqualTree `json:"-"`
}

// GetJustification returns HashEqualIngestHashEqual.Justification, and is useful for accessing the field via an interface.
func (v *HashEqualIngestHashEqual) GetJustification() string { return v.allHashEqualTree.Justification }

// GetArtifacts returns HashEqualIngestHashEqual.Artifacts, and is useful for accessing the field via an interface.
func (v *HashEqualIngestHashEqual) GetArtifacts() []allHashEqualTreeArtifactsArtifact {
	return v.allHashEqualTree.Artifacts
}

// GetOrigin returns HashEqualIngestHashEqual.Origin, and is useful for accessing the field via an interface.
func (v *HashEqualIngestHashEqual) GetOrigin() string { return v.allHashEqualTree.Origin }

// GetCollector returns HashEqualIngestHashEqual.Collector, and is useful for accessing the field via an interface.
func (v *HashEqualIngestHashEqual) GetCollector() string { return v.allHashEqualTree.Collector }

func (v *HashEqualIngestHashEqual) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*HashEqualIngestHashEqual
		graphql.NoUnmarshalJSON
	}
	firstPass.HashEqualIngestHashEqual = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allHashEqualTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalHashEqualIngestHashEqual struct {
	Justification string `json:"justification"`

	Artifacts []allHashEqualTreeArtifactsArtifact `json:"artifacts"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *HashEqualIngestHashEqual) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *HashEqualIngestHashEqual) __premarshalJSON() (*__premarshalHashEqualIngestHashEqual, error) {
	var retval __premarshalHashEqualIngestHashEqual

	retval.Justification = v.allHashEqualTree.Justification
	retval.Artifacts = v.allHashEqualTree.Artifacts
	retval.Origin = v.allHashEqualTree.Origin
	retval.Collector = v.allHashEqualTree.Collector
	return &retval, nil
}

// HashEqualInputSpec is the same as HashEqual but for mutation input.
//
// All fields are required.
type HashEqualInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetJustification returns HashEqualInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *HashEqualInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns HashEqualInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *HashEqualInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns HashEqualInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *HashEqualInputSpec) GetCollector() string { return v.Collector }

// HashEqualResponse is returned by HashEqual on success.
type HashEqualResponse struct {
	// Ingest a new artifact. Returns the ingested artifact
	Artifact HashEqualArtifact `json:"artifact"`
	// Ingest a new artifact. Returns the ingested artifact
	EqualArtifact HashEqualEqualArtifact `json:"equalArtifact"`
	// certify that two artifacts are the same (hashes are equal)
	IngestHashEqual HashEqualIngestHashEqual `json:"ingestHashEqual"`
}

// GetArtifact returns HashEqualResponse.Artifact, and is useful for accessing the field via an interface.
func (v *HashEqualResponse) GetArtifact() HashEqualArtifact { return v.Artifact }

// GetEqualArtifact returns HashEqualResponse.EqualArtifact, and is useful for accessing the field via an interface.
func (v *HashEqualResponse) GetEqualArtifact() HashEqualEqualArtifact { return v.EqualArtifact }

// GetIngestHashEqual returns HashEqualResponse.IngestHashEqual, and is useful for accessing the field via an interface.
func (v *HashEqualResponse) GetIngestHashEqual() HashEqualIngestHashEqual { return v.IngestHashEqual }

// IsDependencyDependentPkgPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type IsDependencyDependentPkgPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns IsDependencyDependentPkgPackage.Type, and is useful for accessing the field via an interface.
func (v *IsDependencyDependentPkgPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns IsDependencyDependentPkgPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *IsDependencyDependentPkgPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *IsDependencyDependentPkgPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsDependencyDependentPkgPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.IsDependencyDependentPkgPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsDependencyDependentPkgPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *IsDependencyDependentPkgPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsDependencyDependentPkgPackage) __premarshalJSON() (*__premarshalIsDependencyDependentPkgPackage, error) {
	var retval __premarshalIsDependencyDependentPkgPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// IsDependencyIngestDependencyIsDependency includes the requested fields of the GraphQL type IsDependency.
// The GraphQL type's documentation follows.
//
// # IsDependency is an attestation that represents when a package is dependent on another package
//
// package (subject) - the package object type that represents the package
// dependentPackage (object) - the package object type that represents the packageName (cannot be to the packageVersion)
// versionRange (property) - string value for version range that applies to the dependent package
// justification (property) - string value representing why the artifacts are the equal
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type IsDependencyIngestDependencyIsDependency struct {
	allIsDependencyTree `json:"-"`
}

// GetJustification returns IsDependencyIngestDependencyIsDependency.Justification, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetJustification() string {
	return v.allIsDependencyTree.Justification
}

// GetPackage returns IsDependencyIngestDependencyIsDependency.Package, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetPackage() allIsDependencyTreePackage {
	return v.allIsDependencyTree.Package
}

// GetDependentPackage returns IsDependencyIngestDependencyIsDependency.DependentPackage, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetDependentPackage() allIsDependencyTreeDependentPackage {
	return v.allIsDependencyTree.DependentPackage
}

// GetVersionRange returns IsDependencyIngestDependencyIsDependency.VersionRange, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetVersionRange() string {
	return v.allIsDependencyTree.VersionRange
}

// GetOrigin returns IsDependencyIngestDependencyIsDependency.Origin, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetOrigin() string {
	return v.allIsDependencyTree.Origin
}

// GetCollector returns IsDependencyIngestDependencyIsDependency.Collector, and is useful for accessing the field via an interface.
func (v *IsDependencyIngestDependencyIsDependency) GetCollector() string {
	return v.allIsDependencyTree.Collector
}

func (v *IsDependencyIngestDependencyIsDependency) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsDependencyIngestDependencyIsDependency
		graphql.NoUnmarshalJSON
	}
	firstPass.IsDependencyIngestDependencyIsDependency = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allIsDependencyTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsDependencyIngestDependencyIsDependency struct {
	Justification string `json:"justification"`

	Package allIsDependencyTreePackage `json:"package"`

	DependentPackage allIsDependencyTreeDependentPackage `json:"dependentPackage"`

	VersionRange string `json:"versionRange"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *IsDependencyIngestDependencyIsDependency) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsDependencyIngestDependencyIsDependency) __premarshalJSON() (*__premarshalIsDependencyIngestDependencyIsDependency, error) {
	var retval __premarshalIsDependencyIngestDependencyIsDependency

	retval.Justification = v.allIsDependencyTree.Justification
	retval.Package = v.allIsDependencyTree.Package
	retval.DependentPackage = v.allIsDependencyTree.DependentPackage
	retval.VersionRange = v.allIsDependencyTree.VersionRange
	retval.Origin = v.allIsDependencyTree.Origin
	retval.Collector = v.allIsDependencyTree.Collector
	return &retval, nil
}

// IsDependencyInputSpec is the same as IsDependency but for mutation input.
//
// All fields are required.
type IsDependencyInputSpec struct {
	VersionRange  string `json:"versionRange"`
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetVersionRange returns IsDependencyInputSpec.VersionRange, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetVersionRange() string { return v.VersionRange }

// GetJustification returns IsDependencyInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns IsDependencyInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns IsDependencyInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *IsDependencyInputSpec) GetCollector() string { return v.Collector }

// IsDependencyPkgPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type IsDependencyPkgPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns IsDependencyPkgPackage.Type, and is useful for accessing the field via an interface.
func (v *IsDependencyPkgPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns IsDependencyPkgPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *IsDependencyPkgPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *IsDependencyPkgPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsDependencyPkgPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.IsDependencyPkgPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsDependencyPkgPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *IsDependencyPkgPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsDependencyPkgPackage) __premarshalJSON() (*__premarshalIsDependencyPkgPackage, error) {
	var retval __premarshalIsDependencyPkgPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// IsDependencyResponse is returned by IsDependency on success.
type IsDependencyResponse struct {
	// Ingest a new package. Returns the ingested package trie
	Pkg IsDependencyPkgPackage `json:"pkg"`
	// Ingest a new package. Returns the ingested package trie
	DependentPkg IsDependencyDependentPkgPackage `json:"dependentPkg"`
	// Adds dependency between two packages
	IngestDependency IsDependencyIngestDependencyIsDependency `json:"ingestDependency"`
}

// GetPkg returns IsDependencyResponse.Pkg, and is useful for accessing the field via an interface.
func (v *IsDependencyResponse) GetPkg() IsDependencyPkgPackage { return v.Pkg }

// GetDependentPkg returns IsDependencyResponse.DependentPkg, and is useful for accessing the field via an interface.
func (v *IsDependencyResponse) GetDependentPkg() IsDependencyDependentPkgPackage {
	return v.DependentPkg
}

// GetIngestDependency returns IsDependencyResponse.IngestDependency, and is useful for accessing the field via an interface.
func (v *IsDependencyResponse) GetIngestDependency() IsDependencyIngestDependencyIsDependency {
	return v.IngestDependency
}

// IsOccurrenceInputSpec is the same as IsOccurrence but for mutation input.
//
// All fields are required.
type IsOccurrenceInputSpec struct {
	Justification string `json:"justification"`
	Origin        string `json:"origin"`
	Collector     string `json:"collector"`
}

// GetJustification returns IsOccurrenceInputSpec.Justification, and is useful for accessing the field via an interface.
func (v *IsOccurrenceInputSpec) GetJustification() string { return v.Justification }

// GetOrigin returns IsOccurrenceInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *IsOccurrenceInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns IsOccurrenceInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *IsOccurrenceInputSpec) GetCollector() string { return v.Collector }

// IsOccurrencePkgIngestArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type IsOccurrencePkgIngestArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns IsOccurrencePkgIngestArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns IsOccurrencePkgIngestArtifact.Digest, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *IsOccurrencePkgIngestArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrencePkgIngestArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrencePkgIngestArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrencePkgIngestArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *IsOccurrencePkgIngestArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrencePkgIngestArtifact) __premarshalJSON() (*__premarshalIsOccurrencePkgIngestArtifact, error) {
	var retval __premarshalIsOccurrencePkgIngestArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// IsOccurrencePkgIngestOccurrenceIsOccurrence includes the requested fields of the GraphQL type IsOccurrence.
// The GraphQL type's documentation follows.
//
// # IsOccurrence is an attestation represents when either a package or source is represented by an artifact
//
// Note: Package or Source must be specified but not both at the same time.
// Attestation must occur at the PackageVersion or at the SourceName.
type IsOccurrencePkgIngestOccurrenceIsOccurrence struct {
	allIsOccurrencesTree `json:"-"`
}

// GetSubject returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Subject, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetSubject() allIsOccurrencesTreeSubjectPackageOrSource {
	return v.allIsOccurrencesTree.Subject
}

// GetArtifact returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Artifact, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetArtifact() allIsOccurrencesTreeArtifact {
	return v.allIsOccurrencesTree.Artifact
}

// GetJustification returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Justification, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetJustification() string {
	return v.allIsOccurrencesTree.Justification
}

// GetOrigin returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Origin, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetOrigin() string {
	return v.allIsOccurrencesTree.Origin
}

// GetCollector returns IsOccurrencePkgIngestOccurrenceIsOccurrence.Collector, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) GetCollector() string {
	return v.allIsOccurrencesTree.Collector
}

func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrencePkgIngestOccurrenceIsOccurrence
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrencePkgIngestOccurrenceIsOccurrence = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allIsOccurrencesTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrencePkgIngestOccurrenceIsOccurrence struct {
	Subject json.RawMessage `json:"subject"`

	Artifact allIsOccurrencesTreeArtifact `json:"artifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrencePkgIngestOccurrenceIsOccurrence) __premarshalJSON() (*__premarshalIsOccurrencePkgIngestOccurrenceIsOccurrence, error) {
	var retval __premarshalIsOccurrencePkgIngestOccurrenceIsOccurrence

	{

		dst := &retval.Subject
		src := v.allIsOccurrencesTree.Subject
		var err error
		*dst, err = __marshalallIsOccurrencesTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal IsOccurrencePkgIngestOccurrenceIsOccurrence.allIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.Artifact = v.allIsOccurrencesTree.Artifact
	retval.Justification = v.allIsOccurrencesTree.Justification
	retval.Origin = v.allIsOccurrencesTree.Origin
	retval.Collector = v.allIsOccurrencesTree.Collector
	return &retval, nil
}

// IsOccurrencePkgIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type IsOccurrencePkgIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns IsOccurrencePkgIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns IsOccurrencePkgIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *IsOccurrencePkgIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrencePkgIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrencePkgIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrencePkgIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *IsOccurrencePkgIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrencePkgIngestPackage) __premarshalJSON() (*__premarshalIsOccurrencePkgIngestPackage, error) {
	var retval __premarshalIsOccurrencePkgIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// IsOccurrencePkgResponse is returned by IsOccurrencePkg on success.
type IsOccurrencePkgResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage IsOccurrencePkgIngestPackage `json:"ingestPackage"`
	// Ingest a new artifact. Returns the ingested artifact
	IngestArtifact IsOccurrencePkgIngestArtifact `json:"ingestArtifact"`
	// Adds an artifact as an occurrence for either a package or a source
	IngestOccurrence IsOccurrencePkgIngestOccurrenceIsOccurrence `json:"ingestOccurrence"`
}

// GetIngestPackage returns IsOccurrencePkgResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgResponse) GetIngestPackage() IsOccurrencePkgIngestPackage {
	return v.IngestPackage
}

// GetIngestArtifact returns IsOccurrencePkgResponse.IngestArtifact, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgResponse) GetIngestArtifact() IsOccurrencePkgIngestArtifact {
	return v.IngestArtifact
}

// GetIngestOccurrence returns IsOccurrencePkgResponse.IngestOccurrence, and is useful for accessing the field via an interface.
func (v *IsOccurrencePkgResponse) GetIngestOccurrence() IsOccurrencePkgIngestOccurrenceIsOccurrence {
	return v.IngestOccurrence
}

// IsOccurrenceSrcIngestArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type IsOccurrenceSrcIngestArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns IsOccurrenceSrcIngestArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns IsOccurrenceSrcIngestArtifact.Digest, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *IsOccurrenceSrcIngestArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrenceSrcIngestArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrenceSrcIngestArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrenceSrcIngestArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *IsOccurrenceSrcIngestArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrenceSrcIngestArtifact) __premarshalJSON() (*__premarshalIsOccurrenceSrcIngestArtifact, error) {
	var retval __premarshalIsOccurrenceSrcIngestArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// IsOccurrenceSrcIngestOccurrenceIsOccurrence includes the requested fields of the GraphQL type IsOccurrence.
// The GraphQL type's documentation follows.
//
// # IsOccurrence is an attestation represents when either a package or source is represented by an artifact
//
// Note: Package or Source must be specified but not both at the same time.
// Attestation must occur at the PackageVersion or at the SourceName.
type IsOccurrenceSrcIngestOccurrenceIsOccurrence struct {
	allIsOccurrencesTree `json:"-"`
}

// GetSubject returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Subject, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetSubject() allIsOccurrencesTreeSubjectPackageOrSource {
	return v.allIsOccurrencesTree.Subject
}

// GetArtifact returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Artifact, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetArtifact() allIsOccurrencesTreeArtifact {
	return v.allIsOccurrencesTree.Artifact
}

// GetJustification returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Justification, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetJustification() string {
	return v.allIsOccurrencesTree.Justification
}

// GetOrigin returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Origin, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetOrigin() string {
	return v.allIsOccurrencesTree.Origin
}

// GetCollector returns IsOccurrenceSrcIngestOccurrenceIsOccurrence.Collector, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) GetCollector() string {
	return v.allIsOccurrencesTree.Collector
}

func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrenceSrcIngestOccurrenceIsOccurrence
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrenceSrcIngestOccurrenceIsOccurrence = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allIsOccurrencesTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrenceSrcIngestOccurrenceIsOccurrence struct {
	Subject json.RawMessage `json:"subject"`

	Artifact allIsOccurrencesTreeArtifact `json:"artifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrenceSrcIngestOccurrenceIsOccurrence) __premarshalJSON() (*__premarshalIsOccurrenceSrcIngestOccurrenceIsOccurrence, error) {
	var retval __premarshalIsOccurrenceSrcIngestOccurrenceIsOccurrence

	{

		dst := &retval.Subject
		src := v.allIsOccurrencesTree.Subject
		var err error
		*dst, err = __marshalallIsOccurrencesTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal IsOccurrenceSrcIngestOccurrenceIsOccurrence.allIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.Artifact = v.allIsOccurrencesTree.Artifact
	retval.Justification = v.allIsOccurrencesTree.Justification
	retval.Origin = v.allIsOccurrencesTree.Origin
	retval.Collector = v.allIsOccurrencesTree.Collector
	return &retval, nil
}

// IsOccurrenceSrcIngestSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type IsOccurrenceSrcIngestSource struct {
	allSourceTree `json:"-"`
}

// GetType returns IsOccurrenceSrcIngestSource.Type, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns IsOccurrenceSrcIngestSource.Namespaces, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcIngestSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *IsOccurrenceSrcIngestSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*IsOccurrenceSrcIngestSource
		graphql.NoUnmarshalJSON
	}
	firstPass.IsOccurrenceSrcIngestSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalIsOccurrenceSrcIngestSource struct {
	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *IsOccurrenceSrcIngestSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *IsOccurrenceSrcIngestSource) __premarshalJSON() (*__premarshalIsOccurrenceSrcIngestSource, error) {
	var retval __premarshalIsOccurrenceSrcIngestSource

	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// IsOccurrenceSrcResponse is returned by IsOccurrenceSrc on success.
type IsOccurrenceSrcResponse struct {
	// Ingest a new source. Returns the ingested source trie
	IngestSource IsOccurrenceSrcIngestSource `json:"ingestSource"`
	// Ingest a new artifact. Returns the ingested artifact
	IngestArtifact IsOccurrenceSrcIngestArtifact `json:"ingestArtifact"`
	// Adds an artifact as an occurrence for either a package or a source
	IngestOccurrence IsOccurrenceSrcIngestOccurrenceIsOccurrence `json:"ingestOccurrence"`
}

// GetIngestSource returns IsOccurrenceSrcResponse.IngestSource, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcResponse) GetIngestSource() IsOccurrenceSrcIngestSource {
	return v.IngestSource
}

// GetIngestArtifact returns IsOccurrenceSrcResponse.IngestArtifact, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcResponse) GetIngestArtifact() IsOccurrenceSrcIngestArtifact {
	return v.IngestArtifact
}

// GetIngestOccurrence returns IsOccurrenceSrcResponse.IngestOccurrence, and is useful for accessing the field via an interface.
func (v *IsOccurrenceSrcResponse) GetIngestOccurrence() IsOccurrenceSrcIngestOccurrenceIsOccurrence {
	return v.IngestOccurrence
}

// MatchFlags is used to input the PkgMatchType enum.
type MatchFlags struct {
	Pkg PkgMatchType `json:"pkg"`
}

// GetPkg returns MatchFlags.Pkg, and is useful for accessing the field via an interface.
func (v *MatchFlags) GetPkg() PkgMatchType { return v.Pkg }

// OSVInputSpec is the same as OSVSpec, but used for mutation ingestion.
type OSVInputSpec struct {
	OsvId string `json:"osvId"`
}

// GetOsvId returns OSVInputSpec.OsvId, and is useful for accessing the field via an interface.
func (v *OSVInputSpec) GetOsvId() string { return v.OsvId }

// PackageQualifierInputSpec is the same as PackageQualifier, but usable as
// mutation input.
//
// GraphQL does not allow input types to contain composite types and does not allow
// composite types to contain input types. So, although in this case these two
// types are semantically the same, we have to duplicate the definition.
//
// Both fields are mandatory.
type PackageQualifierInputSpec struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns PackageQualifierInputSpec.Key, and is useful for accessing the field via an interface.
func (v *PackageQualifierInputSpec) GetKey() string { return v.Key }

// GetValue returns PackageQualifierInputSpec.Value, and is useful for accessing the field via an interface.
func (v *PackageQualifierInputSpec) GetValue() string { return v.Value }

// PackageSourceOrArtifactInput allows using PackageSourceOrArtifact union as
// input type to be used in mutations.
//
// Exactly one of the value must be set to non-nil.
type PackageSourceOrArtifactInput struct {
	Package  *PkgInputSpec      `json:"package"`
	Source   *SourceInputSpec   `json:"source"`
	Artifact *ArtifactInputSpec `json:"artifact"`
}

// GetPackage returns PackageSourceOrArtifactInput.Package, and is useful for accessing the field via an interface.
func (v *PackageSourceOrArtifactInput) GetPackage() *PkgInputSpec { return v.Package }

// GetSource returns PackageSourceOrArtifactInput.Source, and is useful for accessing the field via an interface.
func (v *PackageSourceOrArtifactInput) GetSource() *SourceInputSpec { return v.Source }

// GetArtifact returns PackageSourceOrArtifactInput.Artifact, and is useful for accessing the field via an interface.
func (v *PackageSourceOrArtifactInput) GetArtifact() *ArtifactInputSpec { return v.Artifact }

// PkgInputSpec specifies a package for a mutation.
//
// This is different than PkgSpec because we want to encode mandatory fields:
// `type` and `name`. All optional fields are given empty default values.
type PkgInputSpec struct {
	Type       string                      `json:"type"`
	Namespace  *string                     `json:"namespace"`
	Name       string                      `json:"name"`
	Version    *string                     `json:"version"`
	Qualifiers []PackageQualifierInputSpec `json:"qualifiers"`
	Subpath    *string                     `json:"subpath"`
}

// GetType returns PkgInputSpec.Type, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetType() string { return v.Type }

// GetNamespace returns PkgInputSpec.Namespace, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetNamespace() *string { return v.Namespace }

// GetName returns PkgInputSpec.Name, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetName() string { return v.Name }

// GetVersion returns PkgInputSpec.Version, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetVersion() *string { return v.Version }

// GetQualifiers returns PkgInputSpec.Qualifiers, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetQualifiers() []PackageQualifierInputSpec { return v.Qualifiers }

// GetSubpath returns PkgInputSpec.Subpath, and is useful for accessing the field via an interface.
func (v *PkgInputSpec) GetSubpath() *string { return v.Subpath }

// PkgMatchType is an enum to determine if the attestation should be done at the
// specific version or package name
type PkgMatchType string

const (
	PkgMatchTypeAllVersions     PkgMatchType = "ALL_VERSIONS"
	PkgMatchTypeSpecificVersion PkgMatchType = "SPECIFIC_VERSION"
)

// SLSAForArtifactIngestArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type SLSAForArtifactIngestArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns SLSAForArtifactIngestArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns SLSAForArtifactIngestArtifact.Digest, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *SLSAForArtifactIngestArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForArtifactIngestArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForArtifactIngestArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForArtifactIngestArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *SLSAForArtifactIngestArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForArtifactIngestArtifact) __premarshalJSON() (*__premarshalSLSAForArtifactIngestArtifact, error) {
	var retval __premarshalSLSAForArtifactIngestArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// SLSAForArtifactIngestBuilder includes the requested fields of the GraphQL type Builder.
// The GraphQL type's documentation follows.
//
// Builder represents the builder such as (FRSCA or github actions).
//
// Currently builders are identified by the `uri` field, which is mandatory.
type SLSAForArtifactIngestBuilder struct {
	Uri string `json:"uri"`
}

// GetUri returns SLSAForArtifactIngestBuilder.Uri, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestBuilder) GetUri() string { return v.Uri }

// SLSAForArtifactIngestMaterialsArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type SLSAForArtifactIngestMaterialsArtifact struct {
	Typename        *string `json:"__typename"`
	allArtifactTree `json:"-"`
}

// GetTypename returns SLSAForArtifactIngestMaterialsArtifact.Typename, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestMaterialsArtifact) GetTypename() *string { return v.Typename }

// GetAlgorithm returns SLSAForArtifactIngestMaterialsArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestMaterialsArtifact) GetAlgorithm() string {
	return v.allArtifactTree.Algorithm
}

// GetDigest returns SLSAForArtifactIngestMaterialsArtifact.Digest, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestMaterialsArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *SLSAForArtifactIngestMaterialsArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForArtifactIngestMaterialsArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForArtifactIngestMaterialsArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForArtifactIngestMaterialsArtifact struct {
	Typename *string `json:"__typename"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *SLSAForArtifactIngestMaterialsArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForArtifactIngestMaterialsArtifact) __premarshalJSON() (*__premarshalSLSAForArtifactIngestMaterialsArtifact, error) {
	var retval __premarshalSLSAForArtifactIngestMaterialsArtifact

	retval.Typename = v.Typename
	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// SLSAForArtifactIngestMaterialsPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type SLSAForArtifactIngestMaterialsPackage struct {
	Typename   *string `json:"__typename"`
	allPkgTree `json:"-"`
}

// GetTypename returns SLSAForArtifactIngestMaterialsPackage.Typename, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestMaterialsPackage) GetTypename() *string { return v.Typename }

// GetType returns SLSAForArtifactIngestMaterialsPackage.Type, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestMaterialsPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns SLSAForArtifactIngestMaterialsPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestMaterialsPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *SLSAForArtifactIngestMaterialsPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForArtifactIngestMaterialsPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForArtifactIngestMaterialsPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForArtifactIngestMaterialsPackage struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *SLSAForArtifactIngestMaterialsPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForArtifactIngestMaterialsPackage) __premarshalJSON() (*__premarshalSLSAForArtifactIngestMaterialsPackage, error) {
	var retval __premarshalSLSAForArtifactIngestMaterialsPackage

	retval.Typename = v.Typename
	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// SLSAForArtifactIngestMaterialsPackageSourceOrArtifact includes the requested fields of the GraphQL interface PackageSourceOrArtifact.
//
// SLSAForArtifactIngestMaterialsPackageSourceOrArtifact is implemented by the following types:
// SLSAForArtifactIngestMaterialsPackage
// SLSAForArtifactIngestMaterialsSource
// SLSAForArtifactIngestMaterialsArtifact
// The GraphQL type's documentation follows.
//
// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type SLSAForArtifactIngestMaterialsPackageSourceOrArtifact interface {
	implementsGraphQLInterfaceSLSAForArtifactIngestMaterialsPackageSourceOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *SLSAForArtifactIngestMaterialsPackage) implementsGraphQLInterfaceSLSAForArtifactIngestMaterialsPackageSourceOrArtifact() {
}
func (v *SLSAForArtifactIngestMaterialsSource) implementsGraphQLInterfaceSLSAForArtifactIngestMaterialsPackageSourceOrArtifact() {
}
func (v *SLSAForArtifactIngestMaterialsArtifact) implementsGraphQLInterfaceSLSAForArtifactIngestMaterialsPackageSourceOrArtifact() {
}

func __unmarshalSLSAForArtifactIngestMaterialsPackageSourceOrArtifact(b []byte, v *SLSAForArtifactIngestMaterialsPackageSourceOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(SLSAForArtifactIngestMaterialsPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(SLSAForArtifactIngestMaterialsSource)
		return json.Unmarshal(b, *v)
	case "Artifact":
		*v = new(SLSAForArtifactIngestMaterialsArtifact)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageSourceOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for SLSAForArtifactIngestMaterialsPackageSourceOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalSLSAForArtifactIngestMaterialsPackageSourceOrArtifact(v *SLSAForArtifactIngestMaterialsPackageSourceOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *SLSAForArtifactIngestMaterialsPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalSLSAForArtifactIngestMaterialsPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *SLSAForArtifactIngestMaterialsSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalSLSAForArtifactIngestMaterialsSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case *SLSAForArtifactIngestMaterialsArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalSLSAForArtifactIngestMaterialsArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for SLSAForArtifactIngestMaterialsPackageSourceOrArtifact: "%T"`, v)
	}
}

// SLSAForArtifactIngestMaterialsSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type SLSAForArtifactIngestMaterialsSource struct {
	Typename      *string `json:"__typename"`
	allSourceTree `json:"-"`
}

// GetTypename returns SLSAForArtifactIngestMaterialsSource.Typename, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestMaterialsSource) GetTypename() *string { return v.Typename }

// GetType returns SLSAForArtifactIngestMaterialsSource.Type, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestMaterialsSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns SLSAForArtifactIngestMaterialsSource.Namespaces, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestMaterialsSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *SLSAForArtifactIngestMaterialsSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForArtifactIngestMaterialsSource
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForArtifactIngestMaterialsSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForArtifactIngestMaterialsSource struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *SLSAForArtifactIngestMaterialsSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForArtifactIngestMaterialsSource) __premarshalJSON() (*__premarshalSLSAForArtifactIngestMaterialsSource, error) {
	var retval __premarshalSLSAForArtifactIngestMaterialsSource

	retval.Typename = v.Typename
	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// SLSAForArtifactIngestSLSAHasSLSA includes the requested fields of the GraphQL type HasSLSA.
// The GraphQL type's documentation follows.
//
// HasSLSA records that a subject node has a SLSA attestation.
type SLSAForArtifactIngestSLSAHasSLSA struct {
	allSLSATree `json:"-"`
}

// GetSubject returns SLSAForArtifactIngestSLSAHasSLSA.Subject, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestSLSAHasSLSA) GetSubject() allSLSATreeSubjectPackageSourceOrArtifact {
	return v.allSLSATree.Subject
}

// GetSlsa returns SLSAForArtifactIngestSLSAHasSLSA.Slsa, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactIngestSLSAHasSLSA) GetSlsa() *allSLSATreeSlsaSLSA { return v.allSLSATree.Slsa }

func (v *SLSAForArtifactIngestSLSAHasSLSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForArtifactIngestSLSAHasSLSA
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForArtifactIngestSLSAHasSLSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSLSATree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForArtifactIngestSLSAHasSLSA struct {
	Subject json.RawMessage `json:"subject"`

	Slsa *allSLSATreeSlsaSLSA `json:"slsa"`
}

func (v *SLSAForArtifactIngestSLSAHasSLSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForArtifactIngestSLSAHasSLSA) __premarshalJSON() (*__premarshalSLSAForArtifactIngestSLSAHasSLSA, error) {
	var retval __premarshalSLSAForArtifactIngestSLSAHasSLSA

	{

		dst := &retval.Subject
		src := v.allSLSATree.Subject
		var err error
		*dst, err = __marshalallSLSATreeSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal SLSAForArtifactIngestSLSAHasSLSA.allSLSATree.Subject: %w", err)
		}
	}
	retval.Slsa = v.allSLSATree.Slsa
	return &retval, nil
}

// SLSAForArtifactResponse is returned by SLSAForArtifact on success.
type SLSAForArtifactResponse struct {
	// Ingest a new artifact. Returns the ingested artifact
	IngestArtifact SLSAForArtifactIngestArtifact `json:"ingestArtifact"`
	// Ingests a set of packages, sources, and artifacts.
	//
	// This is a helper mutation for ingesting SLSA nodes. It should be more
	// efficient to call this method to ingest a set materials instead of ingesting
	// them one by one.
	IngestMaterials []SLSAForArtifactIngestMaterialsPackageSourceOrArtifact `json:"-"`
	// Ingest a new builder. Returns the ingested builder
	IngestBuilder SLSAForArtifactIngestBuilder `json:"ingestBuilder"`
	// Ingests a SLSA attestation.
	//
	// Note that materials and builder are extracted as separate arguments. This is
	// because this ingestion method assumes that the subject and the materials are
	// already ingested and only creates the SLSA node.
	IngestSLSA SLSAForArtifactIngestSLSAHasSLSA `json:"ingestSLSA"`
}

// GetIngestArtifact returns SLSAForArtifactResponse.IngestArtifact, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactResponse) GetIngestArtifact() SLSAForArtifactIngestArtifact {
	return v.IngestArtifact
}

// GetIngestMaterials returns SLSAForArtifactResponse.IngestMaterials, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactResponse) GetIngestMaterials() []SLSAForArtifactIngestMaterialsPackageSourceOrArtifact {
	return v.IngestMaterials
}

// GetIngestBuilder returns SLSAForArtifactResponse.IngestBuilder, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactResponse) GetIngestBuilder() SLSAForArtifactIngestBuilder {
	return v.IngestBuilder
}

// GetIngestSLSA returns SLSAForArtifactResponse.IngestSLSA, and is useful for accessing the field via an interface.
func (v *SLSAForArtifactResponse) GetIngestSLSA() SLSAForArtifactIngestSLSAHasSLSA {
	return v.IngestSLSA
}

func (v *SLSAForArtifactResponse) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForArtifactResponse
		IngestMaterials []json.RawMessage `json:"ingestMaterials"`
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForArtifactResponse = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.IngestMaterials
		src := firstPass.IngestMaterials
		*dst = make(
			[]SLSAForArtifactIngestMaterialsPackageSourceOrArtifact,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				err = __unmarshalSLSAForArtifactIngestMaterialsPackageSourceOrArtifact(
					src, dst)
				if err != nil {
					return fmt.Errorf(
						"Unable to unmarshal SLSAForArtifactResponse.IngestMaterials: %w", err)
				}
			}
		}
	}
	return nil
}

type __premarshalSLSAForArtifactResponse struct {
	IngestArtifact SLSAForArtifactIngestArtifact `json:"ingestArtifact"`

	IngestMaterials []json.RawMessage `json:"ingestMaterials"`

	IngestBuilder SLSAForArtifactIngestBuilder `json:"ingestBuilder"`

	IngestSLSA SLSAForArtifactIngestSLSAHasSLSA `json:"ingestSLSA"`
}

func (v *SLSAForArtifactResponse) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForArtifactResponse) __premarshalJSON() (*__premarshalSLSAForArtifactResponse, error) {
	var retval __premarshalSLSAForArtifactResponse

	retval.IngestArtifact = v.IngestArtifact
	{

		dst := &retval.IngestMaterials
		src := v.IngestMaterials
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			var err error
			*dst, err = __marshalSLSAForArtifactIngestMaterialsPackageSourceOrArtifact(
				&src)
			if err != nil {
				return nil, fmt.Errorf(
					"Unable to marshal SLSAForArtifactResponse.IngestMaterials: %w", err)
			}
		}
	}
	retval.IngestBuilder = v.IngestBuilder
	retval.IngestSLSA = v.IngestSLSA
	return &retval, nil
}

// SLSAForPackageIngestBuilder includes the requested fields of the GraphQL type Builder.
// The GraphQL type's documentation follows.
//
// Builder represents the builder such as (FRSCA or github actions).
//
// Currently builders are identified by the `uri` field, which is mandatory.
type SLSAForPackageIngestBuilder struct {
	Uri string `json:"uri"`
}

// GetUri returns SLSAForPackageIngestBuilder.Uri, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestBuilder) GetUri() string { return v.Uri }

// SLSAForPackageIngestMaterialsArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type SLSAForPackageIngestMaterialsArtifact struct {
	Typename        *string `json:"__typename"`
	allArtifactTree `json:"-"`
}

// GetTypename returns SLSAForPackageIngestMaterialsArtifact.Typename, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestMaterialsArtifact) GetTypename() *string { return v.Typename }

// GetAlgorithm returns SLSAForPackageIngestMaterialsArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestMaterialsArtifact) GetAlgorithm() string {
	return v.allArtifactTree.Algorithm
}

// GetDigest returns SLSAForPackageIngestMaterialsArtifact.Digest, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestMaterialsArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *SLSAForPackageIngestMaterialsArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForPackageIngestMaterialsArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForPackageIngestMaterialsArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForPackageIngestMaterialsArtifact struct {
	Typename *string `json:"__typename"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *SLSAForPackageIngestMaterialsArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForPackageIngestMaterialsArtifact) __premarshalJSON() (*__premarshalSLSAForPackageIngestMaterialsArtifact, error) {
	var retval __premarshalSLSAForPackageIngestMaterialsArtifact

	retval.Typename = v.Typename
	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// SLSAForPackageIngestMaterialsPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type SLSAForPackageIngestMaterialsPackage struct {
	Typename   *string `json:"__typename"`
	allPkgTree `json:"-"`
}

// GetTypename returns SLSAForPackageIngestMaterialsPackage.Typename, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestMaterialsPackage) GetTypename() *string { return v.Typename }

// GetType returns SLSAForPackageIngestMaterialsPackage.Type, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestMaterialsPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns SLSAForPackageIngestMaterialsPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestMaterialsPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *SLSAForPackageIngestMaterialsPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForPackageIngestMaterialsPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForPackageIngestMaterialsPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForPackageIngestMaterialsPackage struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *SLSAForPackageIngestMaterialsPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForPackageIngestMaterialsPackage) __premarshalJSON() (*__premarshalSLSAForPackageIngestMaterialsPackage, error) {
	var retval __premarshalSLSAForPackageIngestMaterialsPackage

	retval.Typename = v.Typename
	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// SLSAForPackageIngestMaterialsPackageSourceOrArtifact includes the requested fields of the GraphQL interface PackageSourceOrArtifact.
//
// SLSAForPackageIngestMaterialsPackageSourceOrArtifact is implemented by the following types:
// SLSAForPackageIngestMaterialsPackage
// SLSAForPackageIngestMaterialsSource
// SLSAForPackageIngestMaterialsArtifact
// The GraphQL type's documentation follows.
//
// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type SLSAForPackageIngestMaterialsPackageSourceOrArtifact interface {
	implementsGraphQLInterfaceSLSAForPackageIngestMaterialsPackageSourceOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *SLSAForPackageIngestMaterialsPackage) implementsGraphQLInterfaceSLSAForPackageIngestMaterialsPackageSourceOrArtifact() {
}
func (v *SLSAForPackageIngestMaterialsSource) implementsGraphQLInterfaceSLSAForPackageIngestMaterialsPackageSourceOrArtifact() {
}
func (v *SLSAForPackageIngestMaterialsArtifact) implementsGraphQLInterfaceSLSAForPackageIngestMaterialsPackageSourceOrArtifact() {
}

func __unmarshalSLSAForPackageIngestMaterialsPackageSourceOrArtifact(b []byte, v *SLSAForPackageIngestMaterialsPackageSourceOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(SLSAForPackageIngestMaterialsPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(SLSAForPackageIngestMaterialsSource)
		return json.Unmarshal(b, *v)
	case "Artifact":
		*v = new(SLSAForPackageIngestMaterialsArtifact)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageSourceOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for SLSAForPackageIngestMaterialsPackageSourceOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalSLSAForPackageIngestMaterialsPackageSourceOrArtifact(v *SLSAForPackageIngestMaterialsPackageSourceOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *SLSAForPackageIngestMaterialsPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalSLSAForPackageIngestMaterialsPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *SLSAForPackageIngestMaterialsSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalSLSAForPackageIngestMaterialsSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case *SLSAForPackageIngestMaterialsArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalSLSAForPackageIngestMaterialsArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for SLSAForPackageIngestMaterialsPackageSourceOrArtifact: "%T"`, v)
	}
}

// SLSAForPackageIngestMaterialsSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type SLSAForPackageIngestMaterialsSource struct {
	Typename      *string `json:"__typename"`
	allSourceTree `json:"-"`
}

// GetTypename returns SLSAForPackageIngestMaterialsSource.Typename, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestMaterialsSource) GetTypename() *string { return v.Typename }

// GetType returns SLSAForPackageIngestMaterialsSource.Type, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestMaterialsSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns SLSAForPackageIngestMaterialsSource.Namespaces, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestMaterialsSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *SLSAForPackageIngestMaterialsSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForPackageIngestMaterialsSource
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForPackageIngestMaterialsSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForPackageIngestMaterialsSource struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *SLSAForPackageIngestMaterialsSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForPackageIngestMaterialsSource) __premarshalJSON() (*__premarshalSLSAForPackageIngestMaterialsSource, error) {
	var retval __premarshalSLSAForPackageIngestMaterialsSource

	retval.Typename = v.Typename
	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// SLSAForPackageIngestPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type SLSAForPackageIngestPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns SLSAForPackageIngestPackage.Type, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns SLSAForPackageIngestPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *SLSAForPackageIngestPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForPackageIngestPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForPackageIngestPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForPackageIngestPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *SLSAForPackageIngestPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForPackageIngestPackage) __premarshalJSON() (*__premarshalSLSAForPackageIngestPackage, error) {
	var retval __premarshalSLSAForPackageIngestPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// SLSAForPackageIngestSLSAHasSLSA includes the requested fields of the GraphQL type HasSLSA.
// The GraphQL type's documentation follows.
//
// HasSLSA records that a subject node has a SLSA attestation.
type SLSAForPackageIngestSLSAHasSLSA struct {
	allSLSATree `json:"-"`
}

// GetSubject returns SLSAForPackageIngestSLSAHasSLSA.Subject, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestSLSAHasSLSA) GetSubject() allSLSATreeSubjectPackageSourceOrArtifact {
	return v.allSLSATree.Subject
}

// GetSlsa returns SLSAForPackageIngestSLSAHasSLSA.Slsa, and is useful for accessing the field via an interface.
func (v *SLSAForPackageIngestSLSAHasSLSA) GetSlsa() *allSLSATreeSlsaSLSA { return v.allSLSATree.Slsa }

func (v *SLSAForPackageIngestSLSAHasSLSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForPackageIngestSLSAHasSLSA
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForPackageIngestSLSAHasSLSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSLSATree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForPackageIngestSLSAHasSLSA struct {
	Subject json.RawMessage `json:"subject"`

	Slsa *allSLSATreeSlsaSLSA `json:"slsa"`
}

func (v *SLSAForPackageIngestSLSAHasSLSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForPackageIngestSLSAHasSLSA) __premarshalJSON() (*__premarshalSLSAForPackageIngestSLSAHasSLSA, error) {
	var retval __premarshalSLSAForPackageIngestSLSAHasSLSA

	{

		dst := &retval.Subject
		src := v.allSLSATree.Subject
		var err error
		*dst, err = __marshalallSLSATreeSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal SLSAForPackageIngestSLSAHasSLSA.allSLSATree.Subject: %w", err)
		}
	}
	retval.Slsa = v.allSLSATree.Slsa
	return &retval, nil
}

// SLSAForPackageResponse is returned by SLSAForPackage on success.
type SLSAForPackageResponse struct {
	// Ingest a new package. Returns the ingested package trie
	IngestPackage SLSAForPackageIngestPackage `json:"ingestPackage"`
	// Ingests a set of packages, sources, and artifacts.
	//
	// This is a helper mutation for ingesting SLSA nodes. It should be more
	// efficient to call this method to ingest a set materials instead of ingesting
	// them one by one.
	IngestMaterials []SLSAForPackageIngestMaterialsPackageSourceOrArtifact `json:"-"`
	// Ingest a new builder. Returns the ingested builder
	IngestBuilder SLSAForPackageIngestBuilder `json:"ingestBuilder"`
	// Ingests a SLSA attestation.
	//
	// Note that materials and builder are extracted as separate arguments. This is
	// because this ingestion method assumes that the subject and the materials are
	// already ingested and only creates the SLSA node.
	IngestSLSA SLSAForPackageIngestSLSAHasSLSA `json:"ingestSLSA"`
}

// GetIngestPackage returns SLSAForPackageResponse.IngestPackage, and is useful for accessing the field via an interface.
func (v *SLSAForPackageResponse) GetIngestPackage() SLSAForPackageIngestPackage {
	return v.IngestPackage
}

// GetIngestMaterials returns SLSAForPackageResponse.IngestMaterials, and is useful for accessing the field via an interface.
func (v *SLSAForPackageResponse) GetIngestMaterials() []SLSAForPackageIngestMaterialsPackageSourceOrArtifact {
	return v.IngestMaterials
}

// GetIngestBuilder returns SLSAForPackageResponse.IngestBuilder, and is useful for accessing the field via an interface.
func (v *SLSAForPackageResponse) GetIngestBuilder() SLSAForPackageIngestBuilder {
	return v.IngestBuilder
}

// GetIngestSLSA returns SLSAForPackageResponse.IngestSLSA, and is useful for accessing the field via an interface.
func (v *SLSAForPackageResponse) GetIngestSLSA() SLSAForPackageIngestSLSAHasSLSA { return v.IngestSLSA }

func (v *SLSAForPackageResponse) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForPackageResponse
		IngestMaterials []json.RawMessage `json:"ingestMaterials"`
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForPackageResponse = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.IngestMaterials
		src := firstPass.IngestMaterials
		*dst = make(
			[]SLSAForPackageIngestMaterialsPackageSourceOrArtifact,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				err = __unmarshalSLSAForPackageIngestMaterialsPackageSourceOrArtifact(
					src, dst)
				if err != nil {
					return fmt.Errorf(
						"Unable to unmarshal SLSAForPackageResponse.IngestMaterials: %w", err)
				}
			}
		}
	}
	return nil
}

type __premarshalSLSAForPackageResponse struct {
	IngestPackage SLSAForPackageIngestPackage `json:"ingestPackage"`

	IngestMaterials []json.RawMessage `json:"ingestMaterials"`

	IngestBuilder SLSAForPackageIngestBuilder `json:"ingestBuilder"`

	IngestSLSA SLSAForPackageIngestSLSAHasSLSA `json:"ingestSLSA"`
}

func (v *SLSAForPackageResponse) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForPackageResponse) __premarshalJSON() (*__premarshalSLSAForPackageResponse, error) {
	var retval __premarshalSLSAForPackageResponse

	retval.IngestPackage = v.IngestPackage
	{

		dst := &retval.IngestMaterials
		src := v.IngestMaterials
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			var err error
			*dst, err = __marshalSLSAForPackageIngestMaterialsPackageSourceOrArtifact(
				&src)
			if err != nil {
				return nil, fmt.Errorf(
					"Unable to marshal SLSAForPackageResponse.IngestMaterials: %w", err)
			}
		}
	}
	retval.IngestBuilder = v.IngestBuilder
	retval.IngestSLSA = v.IngestSLSA
	return &retval, nil
}

// SLSAForSourceIngestBuilder includes the requested fields of the GraphQL type Builder.
// The GraphQL type's documentation follows.
//
// Builder represents the builder such as (FRSCA or github actions).
//
// Currently builders are identified by the `uri` field, which is mandatory.
type SLSAForSourceIngestBuilder struct {
	Uri string `json:"uri"`
}

// GetUri returns SLSAForSourceIngestBuilder.Uri, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestBuilder) GetUri() string { return v.Uri }

// SLSAForSourceIngestMaterialsArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type SLSAForSourceIngestMaterialsArtifact struct {
	Typename        *string `json:"__typename"`
	allArtifactTree `json:"-"`
}

// GetTypename returns SLSAForSourceIngestMaterialsArtifact.Typename, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestMaterialsArtifact) GetTypename() *string { return v.Typename }

// GetAlgorithm returns SLSAForSourceIngestMaterialsArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestMaterialsArtifact) GetAlgorithm() string {
	return v.allArtifactTree.Algorithm
}

// GetDigest returns SLSAForSourceIngestMaterialsArtifact.Digest, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestMaterialsArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *SLSAForSourceIngestMaterialsArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForSourceIngestMaterialsArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForSourceIngestMaterialsArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForSourceIngestMaterialsArtifact struct {
	Typename *string `json:"__typename"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *SLSAForSourceIngestMaterialsArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForSourceIngestMaterialsArtifact) __premarshalJSON() (*__premarshalSLSAForSourceIngestMaterialsArtifact, error) {
	var retval __premarshalSLSAForSourceIngestMaterialsArtifact

	retval.Typename = v.Typename
	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// SLSAForSourceIngestMaterialsPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type SLSAForSourceIngestMaterialsPackage struct {
	Typename   *string `json:"__typename"`
	allPkgTree `json:"-"`
}

// GetTypename returns SLSAForSourceIngestMaterialsPackage.Typename, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestMaterialsPackage) GetTypename() *string { return v.Typename }

// GetType returns SLSAForSourceIngestMaterialsPackage.Type, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestMaterialsPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns SLSAForSourceIngestMaterialsPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestMaterialsPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *SLSAForSourceIngestMaterialsPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForSourceIngestMaterialsPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForSourceIngestMaterialsPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForSourceIngestMaterialsPackage struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *SLSAForSourceIngestMaterialsPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForSourceIngestMaterialsPackage) __premarshalJSON() (*__premarshalSLSAForSourceIngestMaterialsPackage, error) {
	var retval __premarshalSLSAForSourceIngestMaterialsPackage

	retval.Typename = v.Typename
	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// SLSAForSourceIngestMaterialsPackageSourceOrArtifact includes the requested fields of the GraphQL interface PackageSourceOrArtifact.
//
// SLSAForSourceIngestMaterialsPackageSourceOrArtifact is implemented by the following types:
// SLSAForSourceIngestMaterialsPackage
// SLSAForSourceIngestMaterialsSource
// SLSAForSourceIngestMaterialsArtifact
// The GraphQL type's documentation follows.
//
// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type SLSAForSourceIngestMaterialsPackageSourceOrArtifact interface {
	implementsGraphQLInterfaceSLSAForSourceIngestMaterialsPackageSourceOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *SLSAForSourceIngestMaterialsPackage) implementsGraphQLInterfaceSLSAForSourceIngestMaterialsPackageSourceOrArtifact() {
}
func (v *SLSAForSourceIngestMaterialsSource) implementsGraphQLInterfaceSLSAForSourceIngestMaterialsPackageSourceOrArtifact() {
}
func (v *SLSAForSourceIngestMaterialsArtifact) implementsGraphQLInterfaceSLSAForSourceIngestMaterialsPackageSourceOrArtifact() {
}

func __unmarshalSLSAForSourceIngestMaterialsPackageSourceOrArtifact(b []byte, v *SLSAForSourceIngestMaterialsPackageSourceOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(SLSAForSourceIngestMaterialsPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(SLSAForSourceIngestMaterialsSource)
		return json.Unmarshal(b, *v)
	case "Artifact":
		*v = new(SLSAForSourceIngestMaterialsArtifact)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageSourceOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for SLSAForSourceIngestMaterialsPackageSourceOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalSLSAForSourceIngestMaterialsPackageSourceOrArtifact(v *SLSAForSourceIngestMaterialsPackageSourceOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *SLSAForSourceIngestMaterialsPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalSLSAForSourceIngestMaterialsPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *SLSAForSourceIngestMaterialsSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalSLSAForSourceIngestMaterialsSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case *SLSAForSourceIngestMaterialsArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalSLSAForSourceIngestMaterialsArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for SLSAForSourceIngestMaterialsPackageSourceOrArtifact: "%T"`, v)
	}
}

// SLSAForSourceIngestMaterialsSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type SLSAForSourceIngestMaterialsSource struct {
	Typename      *string `json:"__typename"`
	allSourceTree `json:"-"`
}

// GetTypename returns SLSAForSourceIngestMaterialsSource.Typename, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestMaterialsSource) GetTypename() *string { return v.Typename }

// GetType returns SLSAForSourceIngestMaterialsSource.Type, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestMaterialsSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns SLSAForSourceIngestMaterialsSource.Namespaces, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestMaterialsSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *SLSAForSourceIngestMaterialsSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForSourceIngestMaterialsSource
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForSourceIngestMaterialsSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForSourceIngestMaterialsSource struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *SLSAForSourceIngestMaterialsSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForSourceIngestMaterialsSource) __premarshalJSON() (*__premarshalSLSAForSourceIngestMaterialsSource, error) {
	var retval __premarshalSLSAForSourceIngestMaterialsSource

	retval.Typename = v.Typename
	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// SLSAForSourceIngestSLSAHasSLSA includes the requested fields of the GraphQL type HasSLSA.
// The GraphQL type's documentation follows.
//
// HasSLSA records that a subject node has a SLSA attestation.
type SLSAForSourceIngestSLSAHasSLSA struct {
	allSLSATree `json:"-"`
}

// GetSubject returns SLSAForSourceIngestSLSAHasSLSA.Subject, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestSLSAHasSLSA) GetSubject() allSLSATreeSubjectPackageSourceOrArtifact {
	return v.allSLSATree.Subject
}

// GetSlsa returns SLSAForSourceIngestSLSAHasSLSA.Slsa, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestSLSAHasSLSA) GetSlsa() *allSLSATreeSlsaSLSA { return v.allSLSATree.Slsa }

func (v *SLSAForSourceIngestSLSAHasSLSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForSourceIngestSLSAHasSLSA
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForSourceIngestSLSAHasSLSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSLSATree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForSourceIngestSLSAHasSLSA struct {
	Subject json.RawMessage `json:"subject"`

	Slsa *allSLSATreeSlsaSLSA `json:"slsa"`
}

func (v *SLSAForSourceIngestSLSAHasSLSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForSourceIngestSLSAHasSLSA) __premarshalJSON() (*__premarshalSLSAForSourceIngestSLSAHasSLSA, error) {
	var retval __premarshalSLSAForSourceIngestSLSAHasSLSA

	{

		dst := &retval.Subject
		src := v.allSLSATree.Subject
		var err error
		*dst, err = __marshalallSLSATreeSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal SLSAForSourceIngestSLSAHasSLSA.allSLSATree.Subject: %w", err)
		}
	}
	retval.Slsa = v.allSLSATree.Slsa
	return &retval, nil
}

// SLSAForSourceIngestSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type SLSAForSourceIngestSource struct {
	allSourceTree `json:"-"`
}

// GetType returns SLSAForSourceIngestSource.Type, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns SLSAForSourceIngestSource.Namespaces, and is useful for accessing the field via an interface.
func (v *SLSAForSourceIngestSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *SLSAForSourceIngestSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForSourceIngestSource
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForSourceIngestSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalSLSAForSourceIngestSource struct {
	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *SLSAForSourceIngestSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForSourceIngestSource) __premarshalJSON() (*__premarshalSLSAForSourceIngestSource, error) {
	var retval __premarshalSLSAForSourceIngestSource

	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// SLSAForSourceResponse is returned by SLSAForSource on success.
type SLSAForSourceResponse struct {
	// Ingest a new source. Returns the ingested source trie
	IngestSource SLSAForSourceIngestSource `json:"ingestSource"`
	// Ingests a set of packages, sources, and artifacts.
	//
	// This is a helper mutation for ingesting SLSA nodes. It should be more
	// efficient to call this method to ingest a set materials instead of ingesting
	// them one by one.
	IngestMaterials []SLSAForSourceIngestMaterialsPackageSourceOrArtifact `json:"-"`
	// Ingest a new builder. Returns the ingested builder
	IngestBuilder SLSAForSourceIngestBuilder `json:"ingestBuilder"`
	// Ingests a SLSA attestation.
	//
	// Note that materials and builder are extracted as separate arguments. This is
	// because this ingestion method assumes that the subject and the materials are
	// already ingested and only creates the SLSA node.
	IngestSLSA SLSAForSourceIngestSLSAHasSLSA `json:"ingestSLSA"`
}

// GetIngestSource returns SLSAForSourceResponse.IngestSource, and is useful for accessing the field via an interface.
func (v *SLSAForSourceResponse) GetIngestSource() SLSAForSourceIngestSource { return v.IngestSource }

// GetIngestMaterials returns SLSAForSourceResponse.IngestMaterials, and is useful for accessing the field via an interface.
func (v *SLSAForSourceResponse) GetIngestMaterials() []SLSAForSourceIngestMaterialsPackageSourceOrArtifact {
	return v.IngestMaterials
}

// GetIngestBuilder returns SLSAForSourceResponse.IngestBuilder, and is useful for accessing the field via an interface.
func (v *SLSAForSourceResponse) GetIngestBuilder() SLSAForSourceIngestBuilder { return v.IngestBuilder }

// GetIngestSLSA returns SLSAForSourceResponse.IngestSLSA, and is useful for accessing the field via an interface.
func (v *SLSAForSourceResponse) GetIngestSLSA() SLSAForSourceIngestSLSAHasSLSA { return v.IngestSLSA }

func (v *SLSAForSourceResponse) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*SLSAForSourceResponse
		IngestMaterials []json.RawMessage `json:"ingestMaterials"`
		graphql.NoUnmarshalJSON
	}
	firstPass.SLSAForSourceResponse = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.IngestMaterials
		src := firstPass.IngestMaterials
		*dst = make(
			[]SLSAForSourceIngestMaterialsPackageSourceOrArtifact,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				err = __unmarshalSLSAForSourceIngestMaterialsPackageSourceOrArtifact(
					src, dst)
				if err != nil {
					return fmt.Errorf(
						"Unable to unmarshal SLSAForSourceResponse.IngestMaterials: %w", err)
				}
			}
		}
	}
	return nil
}

type __premarshalSLSAForSourceResponse struct {
	IngestSource SLSAForSourceIngestSource `json:"ingestSource"`

	IngestMaterials []json.RawMessage `json:"ingestMaterials"`

	IngestBuilder SLSAForSourceIngestBuilder `json:"ingestBuilder"`

	IngestSLSA SLSAForSourceIngestSLSAHasSLSA `json:"ingestSLSA"`
}

func (v *SLSAForSourceResponse) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *SLSAForSourceResponse) __premarshalJSON() (*__premarshalSLSAForSourceResponse, error) {
	var retval __premarshalSLSAForSourceResponse

	retval.IngestSource = v.IngestSource
	{

		dst := &retval.IngestMaterials
		src := v.IngestMaterials
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			var err error
			*dst, err = __marshalSLSAForSourceIngestMaterialsPackageSourceOrArtifact(
				&src)
			if err != nil {
				return nil, fmt.Errorf(
					"Unable to marshal SLSAForSourceResponse.IngestMaterials: %w", err)
			}
		}
	}
	retval.IngestBuilder = v.IngestBuilder
	retval.IngestSLSA = v.IngestSLSA
	return &retval, nil
}

// SLSAInputSpec is the same as SLSA but for mutation input.
//
// All fields are required.
type SLSAInputSpec struct {
	BuildType     string                   `json:"buildType"`
	SlsaPredicate []SLSAPredicateInputSpec `json:"slsaPredicate"`
	SlsaVersion   string                   `json:"slsaVersion"`
	StartedOn     time.Time                `json:"startedOn"`
	FinishedOn    time.Time                `json:"finishedOn"`
	Origin        string                   `json:"origin"`
	Collector     string                   `json:"collector"`
}

// GetBuildType returns SLSAInputSpec.BuildType, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetBuildType() string { return v.BuildType }

// GetSlsaPredicate returns SLSAInputSpec.SlsaPredicate, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetSlsaPredicate() []SLSAPredicateInputSpec { return v.SlsaPredicate }

// GetSlsaVersion returns SLSAInputSpec.SlsaVersion, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetSlsaVersion() string { return v.SlsaVersion }

// GetStartedOn returns SLSAInputSpec.StartedOn, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetStartedOn() time.Time { return v.StartedOn }

// GetFinishedOn returns SLSAInputSpec.FinishedOn, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetFinishedOn() time.Time { return v.FinishedOn }

// GetOrigin returns SLSAInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns SLSAInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *SLSAInputSpec) GetCollector() string { return v.Collector }

// SLSAPredicateInputSpec is the same as SLSAPredicateSpec, but for mutation
// input.
type SLSAPredicateInputSpec struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns SLSAPredicateInputSpec.Key, and is useful for accessing the field via an interface.
func (v *SLSAPredicateInputSpec) GetKey() string { return v.Key }

// GetValue returns SLSAPredicateInputSpec.Value, and is useful for accessing the field via an interface.
func (v *SLSAPredicateInputSpec) GetValue() string { return v.Value }

// ScorecardCertifyScorecard includes the requested fields of the GraphQL type CertifyScorecard.
// The GraphQL type's documentation follows.
//
// CertifyScorecard is an attestation which represents the scorecard of a
// particular source repository.
type ScorecardCertifyScorecard struct {
	allCertifyScorecard `json:"-"`
}

// GetSource returns ScorecardCertifyScorecard.Source, and is useful for accessing the field via an interface.
func (v *ScorecardCertifyScorecard) GetSource() allCertifyScorecardSource {
	return v.allCertifyScorecard.Source
}

// GetScorecard returns ScorecardCertifyScorecard.Scorecard, and is useful for accessing the field via an interface.
func (v *ScorecardCertifyScorecard) GetScorecard() allCertifyScorecardScorecard {
	return v.allCertifyScorecard.Scorecard
}

func (v *ScorecardCertifyScorecard) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*ScorecardCertifyScorecard
		graphql.NoUnmarshalJSON
	}
	firstPass.ScorecardCertifyScorecard = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allCertifyScorecard)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalScorecardCertifyScorecard struct {
	Source allCertifyScorecardSource `json:"source"`

	Scorecard allCertifyScorecardScorecard `json:"scorecard"`
}

func (v *ScorecardCertifyScorecard) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *ScorecardCertifyScorecard) __premarshalJSON() (*__premarshalScorecardCertifyScorecard, error) {
	var retval __premarshalScorecardCertifyScorecard

	retval.Source = v.allCertifyScorecard.Source
	retval.Scorecard = v.allCertifyScorecard.Scorecard
	return &retval, nil
}

// ScorecardCheckInputSpec is the same as ScorecardCheck, but for mutation input.
type ScorecardCheckInputSpec struct {
	Check string `json:"check"`
	Score int    `json:"score"`
}

// GetCheck returns ScorecardCheckInputSpec.Check, and is useful for accessing the field via an interface.
func (v *ScorecardCheckInputSpec) GetCheck() string { return v.Check }

// GetScore returns ScorecardCheckInputSpec.Score, and is useful for accessing the field via an interface.
func (v *ScorecardCheckInputSpec) GetScore() int { return v.Score }

// ScorecardIngestSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type ScorecardIngestSource struct {
	allSourceTree `json:"-"`
}

// GetType returns ScorecardIngestSource.Type, and is useful for accessing the field via an interface.
func (v *ScorecardIngestSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns ScorecardIngestSource.Namespaces, and is useful for accessing the field via an interface.
func (v *ScorecardIngestSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *ScorecardIngestSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*ScorecardIngestSource
		graphql.NoUnmarshalJSON
	}
	firstPass.ScorecardIngestSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalScorecardIngestSource struct {
	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *ScorecardIngestSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *ScorecardIngestSource) __premarshalJSON() (*__premarshalScorecardIngestSource, error) {
	var retval __premarshalScorecardIngestSource

	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// ScorecardInputSpec is the same as Scorecard but for mutation input.
//
// All fields are required.
type ScorecardInputSpec struct {
	Checks           []ScorecardCheckInputSpec `json:"checks"`
	AggregateScore   float64                   `json:"aggregateScore"`
	TimeScanned      time.Time                 `json:"timeScanned"`
	ScorecardVersion string                    `json:"scorecardVersion"`
	ScorecardCommit  string                    `json:"scorecardCommit"`
	Origin           string                    `json:"origin"`
	Collector        string                    `json:"collector"`
}

// GetChecks returns ScorecardInputSpec.Checks, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetChecks() []ScorecardCheckInputSpec { return v.Checks }

// GetAggregateScore returns ScorecardInputSpec.AggregateScore, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetAggregateScore() float64 { return v.AggregateScore }

// GetTimeScanned returns ScorecardInputSpec.TimeScanned, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetTimeScanned() time.Time { return v.TimeScanned }

// GetScorecardVersion returns ScorecardInputSpec.ScorecardVersion, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetScorecardVersion() string { return v.ScorecardVersion }

// GetScorecardCommit returns ScorecardInputSpec.ScorecardCommit, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetScorecardCommit() string { return v.ScorecardCommit }

// GetOrigin returns ScorecardInputSpec.Origin, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetOrigin() string { return v.Origin }

// GetCollector returns ScorecardInputSpec.Collector, and is useful for accessing the field via an interface.
func (v *ScorecardInputSpec) GetCollector() string { return v.Collector }

// ScorecardResponse is returned by Scorecard on success.
type ScorecardResponse struct {
	// Ingest a new source. Returns the ingested source trie
	IngestSource ScorecardIngestSource `json:"ingestSource"`
	// Certifies the Scorecard scanning of a source repository
	CertifyScorecard ScorecardCertifyScorecard `json:"certifyScorecard"`
}

// GetIngestSource returns ScorecardResponse.IngestSource, and is useful for accessing the field via an interface.
func (v *ScorecardResponse) GetIngestSource() ScorecardIngestSource { return v.IngestSource }

// GetCertifyScorecard returns ScorecardResponse.CertifyScorecard, and is useful for accessing the field via an interface.
func (v *ScorecardResponse) GetCertifyScorecard() ScorecardCertifyScorecard {
	return v.CertifyScorecard
}

// SourceInputSpec specifies a source for a mutation.
//
// This is different than SourceSpec because we want to encode that all fields
// except tag and commit are mandatory fields. All optional fields are given
// empty default values.
//
// It is an error to set both `tag` and `commit` fields to values different than
// the default.
type SourceInputSpec struct {
	Type      string  `json:"type"`
	Namespace string  `json:"namespace"`
	Name      string  `json:"name"`
	Tag       *string `json:"tag"`
	Commit    *string `json:"commit"`
}

// GetType returns SourceInputSpec.Type, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetType() string { return v.Type }

// GetNamespace returns SourceInputSpec.Namespace, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetNamespace() string { return v.Namespace }

// GetName returns SourceInputSpec.Name, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetName() string { return v.Name }

// GetTag returns SourceInputSpec.Tag, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetTag() *string { return v.Tag }

// GetCommit returns SourceInputSpec.Commit, and is useful for accessing the field via an interface.
func (v *SourceInputSpec) GetCommit() *string { return v.Commit }

// VulnerabilityInputSpec is the same as VulnerabilityMetaData but for mutation input.
//
// All fields are required.
type VulnerabilityMetaDataInput struct {
	TimeScanned    time.Time `json:"timeScanned"`
	DbUri          string    `json:"dbUri"`
	DbVersion      string    `json:"dbVersion"`
	ScannerUri     string    `json:"scannerUri"`
	ScannerVersion string    `json:"scannerVersion"`
	Origin         string    `json:"origin"`
	Collector      string    `json:"collector"`
}

// GetTimeScanned returns VulnerabilityMetaDataInput.TimeScanned, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetTimeScanned() time.Time { return v.TimeScanned }

// GetDbUri returns VulnerabilityMetaDataInput.DbUri, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetDbUri() string { return v.DbUri }

// GetDbVersion returns VulnerabilityMetaDataInput.DbVersion, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetDbVersion() string { return v.DbVersion }

// GetScannerUri returns VulnerabilityMetaDataInput.ScannerUri, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetScannerUri() string { return v.ScannerUri }

// GetScannerVersion returns VulnerabilityMetaDataInput.ScannerVersion, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetScannerVersion() string { return v.ScannerVersion }

// GetOrigin returns VulnerabilityMetaDataInput.Origin, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetOrigin() string { return v.Origin }

// GetCollector returns VulnerabilityMetaDataInput.Collector, and is useful for accessing the field via an interface.
func (v *VulnerabilityMetaDataInput) GetCollector() string { return v.Collector }

// __CertifyBadArtifactInput is used internally by genqlient
type __CertifyBadArtifactInput struct {
	Artifact   ArtifactInputSpec   `json:"artifact"`
	CertifyBad CertifyBadInputSpec `json:"certifyBad"`
}

// GetArtifact returns __CertifyBadArtifactInput.Artifact, and is useful for accessing the field via an interface.
func (v *__CertifyBadArtifactInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetCertifyBad returns __CertifyBadArtifactInput.CertifyBad, and is useful for accessing the field via an interface.
func (v *__CertifyBadArtifactInput) GetCertifyBad() CertifyBadInputSpec { return v.CertifyBad }

// __CertifyBadPkgInput is used internally by genqlient
type __CertifyBadPkgInput struct {
	Pkg          PkgInputSpec        `json:"pkg"`
	PkgMatchType *MatchFlags         `json:"pkgMatchType"`
	CertifyBad   CertifyBadInputSpec `json:"certifyBad"`
}

// GetPkg returns __CertifyBadPkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyBadPkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetPkgMatchType returns __CertifyBadPkgInput.PkgMatchType, and is useful for accessing the field via an interface.
func (v *__CertifyBadPkgInput) GetPkgMatchType() *MatchFlags { return v.PkgMatchType }

// GetCertifyBad returns __CertifyBadPkgInput.CertifyBad, and is useful for accessing the field via an interface.
func (v *__CertifyBadPkgInput) GetCertifyBad() CertifyBadInputSpec { return v.CertifyBad }

// __CertifyBadSrcInput is used internally by genqlient
type __CertifyBadSrcInput struct {
	Source     SourceInputSpec     `json:"source"`
	CertifyBad CertifyBadInputSpec `json:"certifyBad"`
}

// GetSource returns __CertifyBadSrcInput.Source, and is useful for accessing the field via an interface.
func (v *__CertifyBadSrcInput) GetSource() SourceInputSpec { return v.Source }

// GetCertifyBad returns __CertifyBadSrcInput.CertifyBad, and is useful for accessing the field via an interface.
func (v *__CertifyBadSrcInput) GetCertifyBad() CertifyBadInputSpec { return v.CertifyBad }

// __CertifyCVEInput is used internally by genqlient
type __CertifyCVEInput struct {
	Pkg         PkgInputSpec               `json:"pkg"`
	Cve         CVEInputSpec               `json:"cve"`
	CertifyVuln VulnerabilityMetaDataInput `json:"certifyVuln"`
}

// GetPkg returns __CertifyCVEInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyCVEInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetCve returns __CertifyCVEInput.Cve, and is useful for accessing the field via an interface.
func (v *__CertifyCVEInput) GetCve() CVEInputSpec { return v.Cve }

// GetCertifyVuln returns __CertifyCVEInput.CertifyVuln, and is useful for accessing the field via an interface.
func (v *__CertifyCVEInput) GetCertifyVuln() VulnerabilityMetaDataInput { return v.CertifyVuln }

// __CertifyGHSAInput is used internally by genqlient
type __CertifyGHSAInput struct {
	Pkg         PkgInputSpec               `json:"pkg"`
	Ghsa        GHSAInputSpec              `json:"ghsa"`
	CertifyVuln VulnerabilityMetaDataInput `json:"certifyVuln"`
}

// GetPkg returns __CertifyGHSAInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyGHSAInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetGhsa returns __CertifyGHSAInput.Ghsa, and is useful for accessing the field via an interface.
func (v *__CertifyGHSAInput) GetGhsa() GHSAInputSpec { return v.Ghsa }

// GetCertifyVuln returns __CertifyGHSAInput.CertifyVuln, and is useful for accessing the field via an interface.
func (v *__CertifyGHSAInput) GetCertifyVuln() VulnerabilityMetaDataInput { return v.CertifyVuln }

// __CertifyOSVInput is used internally by genqlient
type __CertifyOSVInput struct {
	Pkg         PkgInputSpec               `json:"pkg"`
	Osv         OSVInputSpec               `json:"osv"`
	CertifyVuln VulnerabilityMetaDataInput `json:"certifyVuln"`
}

// GetPkg returns __CertifyOSVInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyOSVInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetOsv returns __CertifyOSVInput.Osv, and is useful for accessing the field via an interface.
func (v *__CertifyOSVInput) GetOsv() OSVInputSpec { return v.Osv }

// GetCertifyVuln returns __CertifyOSVInput.CertifyVuln, and is useful for accessing the field via an interface.
func (v *__CertifyOSVInput) GetCertifyVuln() VulnerabilityMetaDataInput { return v.CertifyVuln }

// __CertifyPkgInput is used internally by genqlient
type __CertifyPkgInput struct {
	Pkg        PkgInputSpec        `json:"pkg"`
	DepPkg     PkgInputSpec        `json:"depPkg"`
	CertifyPkg CertifyPkgInputSpec `json:"certifyPkg"`
}

// GetPkg returns __CertifyPkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__CertifyPkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetDepPkg returns __CertifyPkgInput.DepPkg, and is useful for accessing the field via an interface.
func (v *__CertifyPkgInput) GetDepPkg() PkgInputSpec { return v.DepPkg }

// GetCertifyPkg returns __CertifyPkgInput.CertifyPkg, and is useful for accessing the field via an interface.
func (v *__CertifyPkgInput) GetCertifyPkg() CertifyPkgInputSpec { return v.CertifyPkg }

// __HasSBOMPkgInput is used internally by genqlient
type __HasSBOMPkgInput struct {
	Pkg     PkgInputSpec     `json:"pkg"`
	HasSBOM HasSBOMInputSpec `json:"hasSBOM"`
}

// GetPkg returns __HasSBOMPkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__HasSBOMPkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetHasSBOM returns __HasSBOMPkgInput.HasSBOM, and is useful for accessing the field via an interface.
func (v *__HasSBOMPkgInput) GetHasSBOM() HasSBOMInputSpec { return v.HasSBOM }

// __HasSBOMSrcInput is used internally by genqlient
type __HasSBOMSrcInput struct {
	Source  SourceInputSpec  `json:"source"`
	HasSBOM HasSBOMInputSpec `json:"hasSBOM"`
}

// GetSource returns __HasSBOMSrcInput.Source, and is useful for accessing the field via an interface.
func (v *__HasSBOMSrcInput) GetSource() SourceInputSpec { return v.Source }

// GetHasSBOM returns __HasSBOMSrcInput.HasSBOM, and is useful for accessing the field via an interface.
func (v *__HasSBOMSrcInput) GetHasSBOM() HasSBOMInputSpec { return v.HasSBOM }

// __HasSourceAtInput is used internally by genqlient
type __HasSourceAtInput struct {
	Pkg          PkgInputSpec         `json:"pkg"`
	PkgMatchType MatchFlags           `json:"pkgMatchType"`
	Source       SourceInputSpec      `json:"source"`
	HasSourceAt  HasSourceAtInputSpec `json:"hasSourceAt"`
}

// GetPkg returns __HasSourceAtInput.Pkg, and is useful for accessing the field via an interface.
func (v *__HasSourceAtInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetPkgMatchType returns __HasSourceAtInput.PkgMatchType, and is useful for accessing the field via an interface.
func (v *__HasSourceAtInput) GetPkgMatchType() MatchFlags { return v.PkgMatchType }

// GetSource returns __HasSourceAtInput.Source, and is useful for accessing the field via an interface.
func (v *__HasSourceAtInput) GetSource() SourceInputSpec { return v.Source }

// GetHasSourceAt returns __HasSourceAtInput.HasSourceAt, and is useful for accessing the field via an interface.
func (v *__HasSourceAtInput) GetHasSourceAt() HasSourceAtInputSpec { return v.HasSourceAt }

// __HashEqualInput is used internally by genqlient
type __HashEqualInput struct {
	Artifact      ArtifactInputSpec  `json:"artifact"`
	EqualArtifact ArtifactInputSpec  `json:"equalArtifact"`
	HashEqual     HashEqualInputSpec `json:"hashEqual"`
}

// GetArtifact returns __HashEqualInput.Artifact, and is useful for accessing the field via an interface.
func (v *__HashEqualInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetEqualArtifact returns __HashEqualInput.EqualArtifact, and is useful for accessing the field via an interface.
func (v *__HashEqualInput) GetEqualArtifact() ArtifactInputSpec { return v.EqualArtifact }

// GetHashEqual returns __HashEqualInput.HashEqual, and is useful for accessing the field via an interface.
func (v *__HashEqualInput) GetHashEqual() HashEqualInputSpec { return v.HashEqual }

// __IsDependencyInput is used internally by genqlient
type __IsDependencyInput struct {
	Pkg        PkgInputSpec          `json:"pkg"`
	DepPkg     PkgInputSpec          `json:"depPkg"`
	Dependency IsDependencyInputSpec `json:"dependency"`
}

// GetPkg returns __IsDependencyInput.Pkg, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetDepPkg returns __IsDependencyInput.DepPkg, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetDepPkg() PkgInputSpec { return v.DepPkg }

// GetDependency returns __IsDependencyInput.Dependency, and is useful for accessing the field via an interface.
func (v *__IsDependencyInput) GetDependency() IsDependencyInputSpec { return v.Dependency }

// __IsOccurrencePkgInput is used internally by genqlient
type __IsOccurrencePkgInput struct {
	Pkg        PkgInputSpec          `json:"pkg"`
	Artifact   ArtifactInputSpec     `json:"artifact"`
	Occurrence IsOccurrenceInputSpec `json:"occurrence"`
}

// GetPkg returns __IsOccurrencePkgInput.Pkg, and is useful for accessing the field via an interface.
func (v *__IsOccurrencePkgInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetArtifact returns __IsOccurrencePkgInput.Artifact, and is useful for accessing the field via an interface.
func (v *__IsOccurrencePkgInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetOccurrence returns __IsOccurrencePkgInput.Occurrence, and is useful for accessing the field via an interface.
func (v *__IsOccurrencePkgInput) GetOccurrence() IsOccurrenceInputSpec { return v.Occurrence }

// __IsOccurrenceSrcInput is used internally by genqlient
type __IsOccurrenceSrcInput struct {
	Source     SourceInputSpec       `json:"source"`
	Artifact   ArtifactInputSpec     `json:"artifact"`
	Occurrence IsOccurrenceInputSpec `json:"occurrence"`
}

// GetSource returns __IsOccurrenceSrcInput.Source, and is useful for accessing the field via an interface.
func (v *__IsOccurrenceSrcInput) GetSource() SourceInputSpec { return v.Source }

// GetArtifact returns __IsOccurrenceSrcInput.Artifact, and is useful for accessing the field via an interface.
func (v *__IsOccurrenceSrcInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetOccurrence returns __IsOccurrenceSrcInput.Occurrence, and is useful for accessing the field via an interface.
func (v *__IsOccurrenceSrcInput) GetOccurrence() IsOccurrenceInputSpec { return v.Occurrence }

// __SLSAForArtifactInput is used internally by genqlient
type __SLSAForArtifactInput struct {
	Artifact  ArtifactInputSpec              `json:"artifact"`
	Materials []PackageSourceOrArtifactInput `json:"materials"`
	Builder   BuilderInputSpec               `json:"builder"`
	Slsa      SLSAInputSpec                  `json:"slsa"`
}

// GetArtifact returns __SLSAForArtifactInput.Artifact, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactInput) GetArtifact() ArtifactInputSpec { return v.Artifact }

// GetMaterials returns __SLSAForArtifactInput.Materials, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactInput) GetMaterials() []PackageSourceOrArtifactInput { return v.Materials }

// GetBuilder returns __SLSAForArtifactInput.Builder, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactInput) GetBuilder() BuilderInputSpec { return v.Builder }

// GetSlsa returns __SLSAForArtifactInput.Slsa, and is useful for accessing the field via an interface.
func (v *__SLSAForArtifactInput) GetSlsa() SLSAInputSpec { return v.Slsa }

// __SLSAForPackageInput is used internally by genqlient
type __SLSAForPackageInput struct {
	Pkg       PkgInputSpec                   `json:"pkg"`
	Materials []PackageSourceOrArtifactInput `json:"materials"`
	Builder   BuilderInputSpec               `json:"builder"`
	Slsa      SLSAInputSpec                  `json:"slsa"`
}

// GetPkg returns __SLSAForPackageInput.Pkg, and is useful for accessing the field via an interface.
func (v *__SLSAForPackageInput) GetPkg() PkgInputSpec { return v.Pkg }

// GetMaterials returns __SLSAForPackageInput.Materials, and is useful for accessing the field via an interface.
func (v *__SLSAForPackageInput) GetMaterials() []PackageSourceOrArtifactInput { return v.Materials }

// GetBuilder returns __SLSAForPackageInput.Builder, and is useful for accessing the field via an interface.
func (v *__SLSAForPackageInput) GetBuilder() BuilderInputSpec { return v.Builder }

// GetSlsa returns __SLSAForPackageInput.Slsa, and is useful for accessing the field via an interface.
func (v *__SLSAForPackageInput) GetSlsa() SLSAInputSpec { return v.Slsa }

// __SLSAForSourceInput is used internally by genqlient
type __SLSAForSourceInput struct {
	Source    SourceInputSpec                `json:"source"`
	Materials []PackageSourceOrArtifactInput `json:"materials"`
	Builder   BuilderInputSpec               `json:"builder"`
	Slsa      SLSAInputSpec                  `json:"slsa"`
}

// GetSource returns __SLSAForSourceInput.Source, and is useful for accessing the field via an interface.
func (v *__SLSAForSourceInput) GetSource() SourceInputSpec { return v.Source }

// GetMaterials returns __SLSAForSourceInput.Materials, and is useful for accessing the field via an interface.
func (v *__SLSAForSourceInput) GetMaterials() []PackageSourceOrArtifactInput { return v.Materials }

// GetBuilder returns __SLSAForSourceInput.Builder, and is useful for accessing the field via an interface.
func (v *__SLSAForSourceInput) GetBuilder() BuilderInputSpec { return v.Builder }

// GetSlsa returns __SLSAForSourceInput.Slsa, and is useful for accessing the field via an interface.
func (v *__SLSAForSourceInput) GetSlsa() SLSAInputSpec { return v.Slsa }

// __ScorecardInput is used internally by genqlient
type __ScorecardInput struct {
	Source    SourceInputSpec    `json:"source"`
	Scorecard ScorecardInputSpec `json:"scorecard"`
}

// GetSource returns __ScorecardInput.Source, and is useful for accessing the field via an interface.
func (v *__ScorecardInput) GetSource() SourceInputSpec { return v.Source }

// GetScorecard returns __ScorecardInput.Scorecard, and is useful for accessing the field via an interface.
func (v *__ScorecardInput) GetScorecard() ScorecardInputSpec { return v.Scorecard }

// allArtifactTree includes the GraphQL fields of Artifact requested by the fragment allArtifactTree.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type allArtifactTree struct {
	Algorithm string `json:"algorithm"`
	Digest    string `json:"digest"`
}

// GetAlgorithm returns allArtifactTree.Algorithm, and is useful for accessing the field via an interface.
func (v *allArtifactTree) GetAlgorithm() string { return v.Algorithm }

// GetDigest returns allArtifactTree.Digest, and is useful for accessing the field via an interface.
func (v *allArtifactTree) GetDigest() string { return v.Digest }

// allCertifyBad includes the GraphQL fields of CertifyBad requested by the fragment allCertifyBad.
// The GraphQL type's documentation follows.
//
// # CertifyBad is an attestation represents when a package, source or artifact is considered bad
//
// subject - union type that can be either a package, source or artifact object type
// justification (property) - string value representing why the subject is considered bad
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
//
// Note: Attestation must occur at the PackageName or the PackageVersion or at the SourceName.
type allCertifyBad struct {
	Justification string                                      `json:"justification"`
	Subject       allCertifyBadSubjectPackageSourceOrArtifact `json:"-"`
}

// GetJustification returns allCertifyBad.Justification, and is useful for accessing the field via an interface.
func (v *allCertifyBad) GetJustification() string { return v.Justification }

// GetSubject returns allCertifyBad.Subject, and is useful for accessing the field via an interface.
func (v *allCertifyBad) GetSubject() allCertifyBadSubjectPackageSourceOrArtifact { return v.Subject }

func (v *allCertifyBad) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allCertifyBad
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.allCertifyBad = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalallCertifyBadSubjectPackageSourceOrArtifact(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"Unable to unmarshal allCertifyBad.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalallCertifyBad struct {
	Justification string `json:"justification"`

	Subject json.RawMessage `json:"subject"`
}

func (v *allCertifyBad) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allCertifyBad) __premarshalJSON() (*__premarshalallCertifyBad, error) {
	var retval __premarshalallCertifyBad

	retval.Justification = v.Justification
	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalallCertifyBadSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal allCertifyBad.Subject: %w", err)
		}
	}
	return &retval, nil
}

// allCertifyBadSubjectArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type allCertifyBadSubjectArtifact struct {
	Typename        *string `json:"__typename"`
	allArtifactTree `json:"-"`
}

// GetTypename returns allCertifyBadSubjectArtifact.Typename, and is useful for accessing the field via an interface.
func (v *allCertifyBadSubjectArtifact) GetTypename() *string { return v.Typename }

// GetAlgorithm returns allCertifyBadSubjectArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *allCertifyBadSubjectArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns allCertifyBadSubjectArtifact.Digest, and is useful for accessing the field via an interface.
func (v *allCertifyBadSubjectArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *allCertifyBadSubjectArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allCertifyBadSubjectArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.allCertifyBadSubjectArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallCertifyBadSubjectArtifact struct {
	Typename *string `json:"__typename"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *allCertifyBadSubjectArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allCertifyBadSubjectArtifact) __premarshalJSON() (*__premarshalallCertifyBadSubjectArtifact, error) {
	var retval __premarshalallCertifyBadSubjectArtifact

	retval.Typename = v.Typename
	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// allCertifyBadSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allCertifyBadSubjectPackage struct {
	Typename   *string `json:"__typename"`
	allPkgTree `json:"-"`
}

// GetTypename returns allCertifyBadSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *allCertifyBadSubjectPackage) GetTypename() *string { return v.Typename }

// GetType returns allCertifyBadSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *allCertifyBadSubjectPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allCertifyBadSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allCertifyBadSubjectPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allCertifyBadSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allCertifyBadSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allCertifyBadSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallCertifyBadSubjectPackage struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allCertifyBadSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allCertifyBadSubjectPackage) __premarshalJSON() (*__premarshalallCertifyBadSubjectPackage, error) {
	var retval __premarshalallCertifyBadSubjectPackage

	retval.Typename = v.Typename
	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allCertifyBadSubjectPackageSourceOrArtifact includes the requested fields of the GraphQL interface PackageSourceOrArtifact.
//
// allCertifyBadSubjectPackageSourceOrArtifact is implemented by the following types:
// allCertifyBadSubjectPackage
// allCertifyBadSubjectSource
// allCertifyBadSubjectArtifact
// The GraphQL type's documentation follows.
//
// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type allCertifyBadSubjectPackageSourceOrArtifact interface {
	implementsGraphQLInterfaceallCertifyBadSubjectPackageSourceOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *allCertifyBadSubjectPackage) implementsGraphQLInterfaceallCertifyBadSubjectPackageSourceOrArtifact() {
}
func (v *allCertifyBadSubjectSource) implementsGraphQLInterfaceallCertifyBadSubjectPackageSourceOrArtifact() {
}
func (v *allCertifyBadSubjectArtifact) implementsGraphQLInterfaceallCertifyBadSubjectPackageSourceOrArtifact() {
}

func __unmarshalallCertifyBadSubjectPackageSourceOrArtifact(b []byte, v *allCertifyBadSubjectPackageSourceOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(allCertifyBadSubjectPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(allCertifyBadSubjectSource)
		return json.Unmarshal(b, *v)
	case "Artifact":
		*v = new(allCertifyBadSubjectArtifact)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageSourceOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for allCertifyBadSubjectPackageSourceOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalallCertifyBadSubjectPackageSourceOrArtifact(v *allCertifyBadSubjectPackageSourceOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *allCertifyBadSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallCertifyBadSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allCertifyBadSubjectSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallCertifyBadSubjectSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allCertifyBadSubjectArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallCertifyBadSubjectArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for allCertifyBadSubjectPackageSourceOrArtifact: "%T"`, v)
	}
}

// allCertifyBadSubjectSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allCertifyBadSubjectSource struct {
	Typename      *string `json:"__typename"`
	allSourceTree `json:"-"`
}

// GetTypename returns allCertifyBadSubjectSource.Typename, and is useful for accessing the field via an interface.
func (v *allCertifyBadSubjectSource) GetTypename() *string { return v.Typename }

// GetType returns allCertifyBadSubjectSource.Type, and is useful for accessing the field via an interface.
func (v *allCertifyBadSubjectSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns allCertifyBadSubjectSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allCertifyBadSubjectSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *allCertifyBadSubjectSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allCertifyBadSubjectSource
		graphql.NoUnmarshalJSON
	}
	firstPass.allCertifyBadSubjectSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallCertifyBadSubjectSource struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *allCertifyBadSubjectSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allCertifyBadSubjectSource) __premarshalJSON() (*__premarshalallCertifyBadSubjectSource, error) {
	var retval __premarshalallCertifyBadSubjectSource

	retval.Typename = v.Typename
	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// allCertifyPkg includes the GraphQL fields of CertifyPkg requested by the fragment allCertifyPkg.
// The GraphQL type's documentation follows.
//
// # CertifyPkg is an attestation that represents when a package objects are similar
//
// packages (subject) - list of package objects
// justification (property) - string value representing why the packages are similar
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type allCertifyPkg struct {
	Justification string                         `json:"justification"`
	Packages      []allCertifyPkgPackagesPackage `json:"packages"`
	Origin        string                         `json:"origin"`
	Collector     string                         `json:"collector"`
}

// GetJustification returns allCertifyPkg.Justification, and is useful for accessing the field via an interface.
func (v *allCertifyPkg) GetJustification() string { return v.Justification }

// GetPackages returns allCertifyPkg.Packages, and is useful for accessing the field via an interface.
func (v *allCertifyPkg) GetPackages() []allCertifyPkgPackagesPackage { return v.Packages }

// GetOrigin returns allCertifyPkg.Origin, and is useful for accessing the field via an interface.
func (v *allCertifyPkg) GetOrigin() string { return v.Origin }

// GetCollector returns allCertifyPkg.Collector, and is useful for accessing the field via an interface.
func (v *allCertifyPkg) GetCollector() string { return v.Collector }

// allCertifyPkgPackagesPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allCertifyPkgPackagesPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns allCertifyPkgPackagesPackage.Type, and is useful for accessing the field via an interface.
func (v *allCertifyPkgPackagesPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allCertifyPkgPackagesPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allCertifyPkgPackagesPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allCertifyPkgPackagesPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allCertifyPkgPackagesPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allCertifyPkgPackagesPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallCertifyPkgPackagesPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allCertifyPkgPackagesPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allCertifyPkgPackagesPackage) __premarshalJSON() (*__premarshalallCertifyPkgPackagesPackage, error) {
	var retval __premarshalallCertifyPkgPackagesPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allCertifyScorecard includes the GraphQL fields of CertifyScorecard requested by the fragment allCertifyScorecard.
// The GraphQL type's documentation follows.
//
// CertifyScorecard is an attestation which represents the scorecard of a
// particular source repository.
type allCertifyScorecard struct {
	// The source repository that is being scanned (attestation subject)
	Source allCertifyScorecardSource `json:"source"`
	// The Scorecard attached to the repository (attestation object)
	Scorecard allCertifyScorecardScorecard `json:"scorecard"`
}

// GetSource returns allCertifyScorecard.Source, and is useful for accessing the field via an interface.
func (v *allCertifyScorecard) GetSource() allCertifyScorecardSource { return v.Source }

// GetScorecard returns allCertifyScorecard.Scorecard, and is useful for accessing the field via an interface.
func (v *allCertifyScorecard) GetScorecard() allCertifyScorecardScorecard { return v.Scorecard }

// allCertifyScorecardScorecard includes the requested fields of the GraphQL type Scorecard.
// The GraphQL type's documentation follows.
//
// Scorecard contains all of the fields present in a Scorecard attestation.
//
// We also include fields to specify under what conditions the check was performed
// (time of scan, version of scanners, etc.) as well as how this information got
// included into GUAC (origin document and the collector for that document).
type allCertifyScorecardScorecard struct {
	// Exact timestamp when the source was last scanned (in RFC 3339 format)
	TimeScanned time.Time `json:"timeScanned"`
	// Overall Scorecard score for the source
	AggregateScore float64 `json:"aggregateScore"`
	// Individual Scorecard check scores (Branch-Protection, Code-Review, ...)
	Checks []allCertifyScorecardScorecardChecksScorecardCheck `json:"checks"`
	// Version of the Scorecard scanner used to analyze the source
	ScorecardVersion string `json:"scorecardVersion"`
	// Commit of the Scorecards repository at the time of scanning the source
	ScorecardCommit string `json:"scorecardCommit"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetTimeScanned returns allCertifyScorecardScorecard.TimeScanned, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetTimeScanned() time.Time { return v.TimeScanned }

// GetAggregateScore returns allCertifyScorecardScorecard.AggregateScore, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetAggregateScore() float64 { return v.AggregateScore }

// GetChecks returns allCertifyScorecardScorecard.Checks, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetChecks() []allCertifyScorecardScorecardChecksScorecardCheck {
	return v.Checks
}

// GetScorecardVersion returns allCertifyScorecardScorecard.ScorecardVersion, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetScorecardVersion() string { return v.ScorecardVersion }

// GetScorecardCommit returns allCertifyScorecardScorecard.ScorecardCommit, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetScorecardCommit() string { return v.ScorecardCommit }

// GetOrigin returns allCertifyScorecardScorecard.Origin, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetOrigin() string { return v.Origin }

// GetCollector returns allCertifyScorecardScorecard.Collector, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecard) GetCollector() string { return v.Collector }

// allCertifyScorecardScorecardChecksScorecardCheck includes the requested fields of the GraphQL type ScorecardCheck.
// The GraphQL type's documentation follows.
//
// ScorecardCheck are the individual checks from scorecard and their values as a
// key-value pair.
//
// For example:  Branch-Protection, Code-Review...etc
//
// Based off scorecard's:
// type jsonCheckResultV2 struct {
// Details []string                 `json:"details"`
// Score   int                      `json:"score"`
// Reason  string                   `json:"reason"`
// Name    string                   `json:"name"`
// Doc     jsonCheckDocumentationV2 `json:"documentation"`
// }
// This node cannot be directly referred by other parts of GUAC.
type allCertifyScorecardScorecardChecksScorecardCheck struct {
	Check string `json:"check"`
	Score int    `json:"score"`
}

// GetCheck returns allCertifyScorecardScorecardChecksScorecardCheck.Check, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecardChecksScorecardCheck) GetCheck() string { return v.Check }

// GetScore returns allCertifyScorecardScorecardChecksScorecardCheck.Score, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardScorecardChecksScorecardCheck) GetScore() int { return v.Score }

// allCertifyScorecardSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allCertifyScorecardSource struct {
	allSourceTree `json:"-"`
}

// GetType returns allCertifyScorecardSource.Type, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns allCertifyScorecardSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allCertifyScorecardSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *allCertifyScorecardSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allCertifyScorecardSource
		graphql.NoUnmarshalJSON
	}
	firstPass.allCertifyScorecardSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallCertifyScorecardSource struct {
	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *allCertifyScorecardSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allCertifyScorecardSource) __premarshalJSON() (*__premarshalallCertifyScorecardSource, error) {
	var retval __premarshalallCertifyScorecardSource

	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// allCertifyVuln includes the GraphQL fields of CertifyVuln requested by the fragment allCertifyVuln.
// The GraphQL type's documentation follows.
//
// CertifyVuln is an attestation that represents when a package has a vulnerability
type allCertifyVuln struct {
	// package (subject) - the package object type that represents the package
	Package allCertifyVulnPackage `json:"package"`
	// vulnerability (object) - union type that consists of osv, cve or ghsa
	Vulnerability allCertifyVulnVulnerabilityOsvCveOrGhsa `json:"-"`
	// metadata (property) - contains all the vulnerability metadata
	Metadata allCertifyVulnMetadataVulnerabilityMetaData `json:"metadata"`
}

// GetPackage returns allCertifyVuln.Package, and is useful for accessing the field via an interface.
func (v *allCertifyVuln) GetPackage() allCertifyVulnPackage { return v.Package }

// GetVulnerability returns allCertifyVuln.Vulnerability, and is useful for accessing the field via an interface.
func (v *allCertifyVuln) GetVulnerability() allCertifyVulnVulnerabilityOsvCveOrGhsa {
	return v.Vulnerability
}

// GetMetadata returns allCertifyVuln.Metadata, and is useful for accessing the field via an interface.
func (v *allCertifyVuln) GetMetadata() allCertifyVulnMetadataVulnerabilityMetaData { return v.Metadata }

func (v *allCertifyVuln) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allCertifyVuln
		Vulnerability json.RawMessage `json:"vulnerability"`
		graphql.NoUnmarshalJSON
	}
	firstPass.allCertifyVuln = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Vulnerability
		src := firstPass.Vulnerability
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalallCertifyVulnVulnerabilityOsvCveOrGhsa(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"Unable to unmarshal allCertifyVuln.Vulnerability: %w", err)
			}
		}
	}
	return nil
}

type __premarshalallCertifyVuln struct {
	Package allCertifyVulnPackage `json:"package"`

	Vulnerability json.RawMessage `json:"vulnerability"`

	Metadata allCertifyVulnMetadataVulnerabilityMetaData `json:"metadata"`
}

func (v *allCertifyVuln) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allCertifyVuln) __premarshalJSON() (*__premarshalallCertifyVuln, error) {
	var retval __premarshalallCertifyVuln

	retval.Package = v.Package
	{

		dst := &retval.Vulnerability
		src := v.Vulnerability
		var err error
		*dst, err = __marshalallCertifyVulnVulnerabilityOsvCveOrGhsa(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal allCertifyVuln.Vulnerability: %w", err)
		}
	}
	retval.Metadata = v.Metadata
	return &retval, nil
}

// allCertifyVulnMetadataVulnerabilityMetaData includes the requested fields of the GraphQL type VulnerabilityMetaData.
type allCertifyVulnMetadataVulnerabilityMetaData struct {
	// dbUri (property) - scanner vulnerability database uri
	DbUri string `json:"dbUri"`
	// dbVersion (property) - scanner vulnerability database version
	DbVersion string `json:"dbVersion"`
	// scannerUri (property) - vulnerability scanner's uri
	ScannerUri string `json:"scannerUri"`
	// scannerVersion (property) - vulnerability scanner version
	ScannerVersion string `json:"scannerVersion"`
	// timeScanned (property) - timestamp of when the package was last scanned
	TimeScanned time.Time `json:"timeScanned"`
	// origin (property) - where this attestation was generated from (based on which document)
	Origin string `json:"origin"`
	// collector (property) - the GUAC collector that collected the document that generated this attestation
	Collector string `json:"collector"`
}

// GetDbUri returns allCertifyVulnMetadataVulnerabilityMetaData.DbUri, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetDbUri() string { return v.DbUri }

// GetDbVersion returns allCertifyVulnMetadataVulnerabilityMetaData.DbVersion, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetDbVersion() string { return v.DbVersion }

// GetScannerUri returns allCertifyVulnMetadataVulnerabilityMetaData.ScannerUri, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetScannerUri() string { return v.ScannerUri }

// GetScannerVersion returns allCertifyVulnMetadataVulnerabilityMetaData.ScannerVersion, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetScannerVersion() string {
	return v.ScannerVersion
}

// GetTimeScanned returns allCertifyVulnMetadataVulnerabilityMetaData.TimeScanned, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetTimeScanned() time.Time {
	return v.TimeScanned
}

// GetOrigin returns allCertifyVulnMetadataVulnerabilityMetaData.Origin, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetOrigin() string { return v.Origin }

// GetCollector returns allCertifyVulnMetadataVulnerabilityMetaData.Collector, and is useful for accessing the field via an interface.
func (v *allCertifyVulnMetadataVulnerabilityMetaData) GetCollector() string { return v.Collector }

// allCertifyVulnPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allCertifyVulnPackage struct {
	Type       string                                            `json:"type"`
	Namespaces []allCertifyVulnPackageNamespacesPackageNamespace `json:"namespaces"`
}

// GetType returns allCertifyVulnPackage.Type, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackage) GetType() string { return v.Type }

// GetNamespaces returns allCertifyVulnPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackage) GetNamespaces() []allCertifyVulnPackageNamespacesPackageNamespace {
	return v.Namespaces
}

// allCertifyVulnPackageNamespacesPackageNamespace includes the requested fields of the GraphQL type PackageNamespace.
// The GraphQL type's documentation follows.
//
// PackageNamespace is a namespace for packages.
//
// In the pURL representation, each PackageNamespace matches the
// `pkg:<type>/<namespace>/` partial pURL.
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type allCertifyVulnPackageNamespacesPackageNamespace struct {
	Namespace string                                                            `json:"namespace"`
	Names     []allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName `json:"names"`
}

// GetNamespace returns allCertifyVulnPackageNamespacesPackageNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns allCertifyVulnPackageNamespacesPackageNamespace.Names, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespace) GetNames() []allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName {
	return v.Names
}

// allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName includes the requested fields of the GraphQL type PackageName.
// The GraphQL type's documentation follows.
//
// PackageName is a name for packages.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>` pURL.
//
// Names are always mandatory.
//
// This is the first node in the trie that can be referred to by other parts of
// GUAC.
type allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName struct {
	Name     string                                                                                  `json:"name"`
	Versions []allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion `json:"versions"`
}

// GetName returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName.Name, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName) GetName() string {
	return v.Name
}

// GetVersions returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName.Versions, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageName) GetVersions() []allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion {
	return v.Versions
}

// allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion includes the requested fields of the GraphQL type PackageVersion.
// The GraphQL type's documentation follows.
//
// PackageVersion is a package version.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>@<version>` pURL.
//
// Versions are optional and each Package type defines own rules for handling them.
// For this level of GUAC, these are just opaque strings.
//
// This node can be referred to by other parts of GUAC.
//
// Subpath and qualifiers are optional. Lack of qualifiers is represented by an
// empty list and lack of subpath by empty string (to be consistent with
// optionality of namespace and version). Two nodes that have different qualifiers
// and/or subpath but the same version mean two different packages in the trie
// (they are different). Two nodes that have same version but qualifiers of one are
// a subset of the qualifier of the other also mean two different packages in the
// trie.
type allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion struct {
	Version    string                                                                                                            `json:"version"`
	Qualifiers []allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier `json:"qualifiers"`
	Subpath    string                                                                                                            `json:"subpath"`
}

// GetVersion returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Version, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetVersion() string {
	return v.Version
}

// GetQualifiers returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Qualifiers, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetQualifiers() []allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier {
	return v.Qualifiers
}

// GetSubpath returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Subpath, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetSubpath() string {
	return v.Subpath
}

// allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier includes the requested fields of the GraphQL type PackageQualifier.
// The GraphQL type's documentation follows.
//
// PackageQualifier is a qualifier for a package, a key-value pair.
//
// In the pURL representation, it is a part of the `<qualifiers>` part of the
// `pkg:<type>/<namespace>/<name>@<version>?<qualifiers>` pURL.
//
// Qualifiers are optional, each Package type defines own rules for handling them,
// and multiple qualifiers could be attached to the same package.
//
// This node cannot be directly referred by other parts of GUAC.
type allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Key, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetKey() string {
	return v.Key
}

// GetValue returns allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Value, and is useful for accessing the field via an interface.
func (v *allCertifyVulnPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetValue() string {
	return v.Value
}

// allCertifyVulnVulnerabilityCVE includes the requested fields of the GraphQL type CVE.
// The GraphQL type's documentation follows.
//
// CVE represents common vulnerabilities and exposures. It contains the year along
// with the CVE ID.
//
// The year is mandatory.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `year` value.
type allCertifyVulnVulnerabilityCVE struct {
	Typename *string                                    `json:"__typename"`
	Year     string                                     `json:"year"`
	CveId    []allCertifyVulnVulnerabilityCVECveIdCVEId `json:"cveId"`
}

// GetTypename returns allCertifyVulnVulnerabilityCVE.Typename, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityCVE) GetTypename() *string { return v.Typename }

// GetYear returns allCertifyVulnVulnerabilityCVE.Year, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityCVE) GetYear() string { return v.Year }

// GetCveId returns allCertifyVulnVulnerabilityCVE.CveId, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityCVE) GetCveId() []allCertifyVulnVulnerabilityCVECveIdCVEId {
	return v.CveId
}

// allCertifyVulnVulnerabilityCVECveIdCVEId includes the requested fields of the GraphQL type CVEId.
// The GraphQL type's documentation follows.
//
// # CVEId is the actual ID that is given to a specific vulnerability
//
// The `id` field is mandatory and canonicalized to be lowercase.
//
// This node can be referred to by other parts of GUAC.
type allCertifyVulnVulnerabilityCVECveIdCVEId struct {
	Id string `json:"id"`
}

// GetId returns allCertifyVulnVulnerabilityCVECveIdCVEId.Id, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityCVECveIdCVEId) GetId() string { return v.Id }

// allCertifyVulnVulnerabilityGHSA includes the requested fields of the GraphQL type GHSA.
// The GraphQL type's documentation follows.
//
// GHSA represents GitHub security advisories.
//
// We create a separate node to allow retrieving all GHSAs.
type allCertifyVulnVulnerabilityGHSA struct {
	Typename *string                                       `json:"__typename"`
	GhsaId   []allCertifyVulnVulnerabilityGHSAGhsaIdGHSAId `json:"ghsaId"`
}

// GetTypename returns allCertifyVulnVulnerabilityGHSA.Typename, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityGHSA) GetTypename() *string { return v.Typename }

// GetGhsaId returns allCertifyVulnVulnerabilityGHSA.GhsaId, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityGHSA) GetGhsaId() []allCertifyVulnVulnerabilityGHSAGhsaIdGHSAId {
	return v.GhsaId
}

// allCertifyVulnVulnerabilityGHSAGhsaIdGHSAId includes the requested fields of the GraphQL type GHSAId.
// The GraphQL type's documentation follows.
//
// # GHSAId is the actual ID that is given to a specific vulnerability on GitHub
//
// The `id` field is mandatory and canonicalized to be lowercase.
//
// This node can be referred to by other parts of GUAC.
type allCertifyVulnVulnerabilityGHSAGhsaIdGHSAId struct {
	Id string `json:"id"`
}

// GetId returns allCertifyVulnVulnerabilityGHSAGhsaIdGHSAId.Id, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityGHSAGhsaIdGHSAId) GetId() string { return v.Id }

// allCertifyVulnVulnerabilityOSV includes the requested fields of the GraphQL type OSV.
// The GraphQL type's documentation follows.
//
// OSV represents an Open Source Vulnerability.
//
// We create a separate node to allow retrieving all OSVs.
type allCertifyVulnVulnerabilityOSV struct {
	Typename *string                                    `json:"__typename"`
	OsvId    []allCertifyVulnVulnerabilityOSVOsvIdOSVId `json:"osvId"`
}

// GetTypename returns allCertifyVulnVulnerabilityOSV.Typename, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityOSV) GetTypename() *string { return v.Typename }

// GetOsvId returns allCertifyVulnVulnerabilityOSV.OsvId, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityOSV) GetOsvId() []allCertifyVulnVulnerabilityOSVOsvIdOSVId {
	return v.OsvId
}

// allCertifyVulnVulnerabilityOSVOsvIdOSVId includes the requested fields of the GraphQL type OSVId.
// The GraphQL type's documentation follows.
//
// OSVId is the actual ID that is given to a specific vulnerability.
//
// The `id` field is mandatory and canonicalized to be lowercase.
//
// This maps to a vulnerability ID specific to the environment (e.g., GHSA ID or
// CVE ID).
//
// This node can be referred to by other parts of GUAC.
type allCertifyVulnVulnerabilityOSVOsvIdOSVId struct {
	Id string `json:"id"`
}

// GetId returns allCertifyVulnVulnerabilityOSVOsvIdOSVId.Id, and is useful for accessing the field via an interface.
func (v *allCertifyVulnVulnerabilityOSVOsvIdOSVId) GetId() string { return v.Id }

// allCertifyVulnVulnerabilityOsvCveOrGhsa includes the requested fields of the GraphQL interface OsvCveOrGhsa.
//
// allCertifyVulnVulnerabilityOsvCveOrGhsa is implemented by the following types:
// allCertifyVulnVulnerabilityOSV
// allCertifyVulnVulnerabilityCVE
// allCertifyVulnVulnerabilityGHSA
// The GraphQL type's documentation follows.
//
// OsvCveGhsaObject is a union of OSV, CVE and GHSA. Any of these objects can be specified for vulnerability
type allCertifyVulnVulnerabilityOsvCveOrGhsa interface {
	implementsGraphQLInterfaceallCertifyVulnVulnerabilityOsvCveOrGhsa()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *allCertifyVulnVulnerabilityOSV) implementsGraphQLInterfaceallCertifyVulnVulnerabilityOsvCveOrGhsa() {
}
func (v *allCertifyVulnVulnerabilityCVE) implementsGraphQLInterfaceallCertifyVulnVulnerabilityOsvCveOrGhsa() {
}
func (v *allCertifyVulnVulnerabilityGHSA) implementsGraphQLInterfaceallCertifyVulnVulnerabilityOsvCveOrGhsa() {
}

func __unmarshalallCertifyVulnVulnerabilityOsvCveOrGhsa(b []byte, v *allCertifyVulnVulnerabilityOsvCveOrGhsa) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "OSV":
		*v = new(allCertifyVulnVulnerabilityOSV)
		return json.Unmarshal(b, *v)
	case "CVE":
		*v = new(allCertifyVulnVulnerabilityCVE)
		return json.Unmarshal(b, *v)
	case "GHSA":
		*v = new(allCertifyVulnVulnerabilityGHSA)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing OsvCveOrGhsa.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for allCertifyVulnVulnerabilityOsvCveOrGhsa: "%v"`, tn.TypeName)
	}
}

func __marshalallCertifyVulnVulnerabilityOsvCveOrGhsa(v *allCertifyVulnVulnerabilityOsvCveOrGhsa) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *allCertifyVulnVulnerabilityOSV:
		typename = "OSV"

		result := struct {
			TypeName string `json:"__typename"`
			*allCertifyVulnVulnerabilityOSV
		}{typename, v}
		return json.Marshal(result)
	case *allCertifyVulnVulnerabilityCVE:
		typename = "CVE"

		result := struct {
			TypeName string `json:"__typename"`
			*allCertifyVulnVulnerabilityCVE
		}{typename, v}
		return json.Marshal(result)
	case *allCertifyVulnVulnerabilityGHSA:
		typename = "GHSA"

		result := struct {
			TypeName string `json:"__typename"`
			*allCertifyVulnVulnerabilityGHSA
		}{typename, v}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for allCertifyVulnVulnerabilityOsvCveOrGhsa: "%T"`, v)
	}
}

// allCveTree includes the GraphQL fields of CVE requested by the fragment allCveTree.
// The GraphQL type's documentation follows.
//
// CVE represents common vulnerabilities and exposures. It contains the year along
// with the CVE ID.
//
// The year is mandatory.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `year` value.
type allCveTree struct {
	Year  string                 `json:"year"`
	CveId []allCveTreeCveIdCVEId `json:"cveId"`
}

// GetYear returns allCveTree.Year, and is useful for accessing the field via an interface.
func (v *allCveTree) GetYear() string { return v.Year }

// GetCveId returns allCveTree.CveId, and is useful for accessing the field via an interface.
func (v *allCveTree) GetCveId() []allCveTreeCveIdCVEId { return v.CveId }

// allCveTreeCveIdCVEId includes the requested fields of the GraphQL type CVEId.
// The GraphQL type's documentation follows.
//
// # CVEId is the actual ID that is given to a specific vulnerability
//
// The `id` field is mandatory and canonicalized to be lowercase.
//
// This node can be referred to by other parts of GUAC.
type allCveTreeCveIdCVEId struct {
	Id string `json:"id"`
}

// GetId returns allCveTreeCveIdCVEId.Id, and is useful for accessing the field via an interface.
func (v *allCveTreeCveIdCVEId) GetId() string { return v.Id }

// allGHSATree includes the GraphQL fields of GHSA requested by the fragment allGHSATree.
// The GraphQL type's documentation follows.
//
// GHSA represents GitHub security advisories.
//
// We create a separate node to allow retrieving all GHSAs.
type allGHSATree struct {
	GhsaId []allGHSATreeGhsaIdGHSAId `json:"ghsaId"`
}

// GetGhsaId returns allGHSATree.GhsaId, and is useful for accessing the field via an interface.
func (v *allGHSATree) GetGhsaId() []allGHSATreeGhsaIdGHSAId { return v.GhsaId }

// allGHSATreeGhsaIdGHSAId includes the requested fields of the GraphQL type GHSAId.
// The GraphQL type's documentation follows.
//
// # GHSAId is the actual ID that is given to a specific vulnerability on GitHub
//
// The `id` field is mandatory and canonicalized to be lowercase.
//
// This node can be referred to by other parts of GUAC.
type allGHSATreeGhsaIdGHSAId struct {
	Id string `json:"id"`
}

// GetId returns allGHSATreeGhsaIdGHSAId.Id, and is useful for accessing the field via an interface.
func (v *allGHSATreeGhsaIdGHSAId) GetId() string { return v.Id }

// allHasSBOMTree includes the GraphQL fields of HasSBOM requested by the fragment allHasSBOMTree.
// The GraphQL type's documentation follows.
//
// # HasSBOM is an attestation represents that a package object or source object has an SBOM associated with a uri
//
// subject - union type that can be either a package or source object type
// uri (property) - identifier string for the SBOM
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
//
// Note: Only package object or source object can be defined. Not both.
type allHasSBOMTree struct {
	Uri       string                               `json:"uri"`
	Subject   allHasSBOMTreeSubjectPackageOrSource `json:"-"`
	Origin    string                               `json:"origin"`
	Collector string                               `json:"collector"`
}

// GetUri returns allHasSBOMTree.Uri, and is useful for accessing the field via an interface.
func (v *allHasSBOMTree) GetUri() string { return v.Uri }

// GetSubject returns allHasSBOMTree.Subject, and is useful for accessing the field via an interface.
func (v *allHasSBOMTree) GetSubject() allHasSBOMTreeSubjectPackageOrSource { return v.Subject }

// GetOrigin returns allHasSBOMTree.Origin, and is useful for accessing the field via an interface.
func (v *allHasSBOMTree) GetOrigin() string { return v.Origin }

// GetCollector returns allHasSBOMTree.Collector, and is useful for accessing the field via an interface.
func (v *allHasSBOMTree) GetCollector() string { return v.Collector }

func (v *allHasSBOMTree) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allHasSBOMTree
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.allHasSBOMTree = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalallHasSBOMTreeSubjectPackageOrSource(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"Unable to unmarshal allHasSBOMTree.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalallHasSBOMTree struct {
	Uri string `json:"uri"`

	Subject json.RawMessage `json:"subject"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *allHasSBOMTree) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allHasSBOMTree) __premarshalJSON() (*__premarshalallHasSBOMTree, error) {
	var retval __premarshalallHasSBOMTree

	retval.Uri = v.Uri
	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalallHasSBOMTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal allHasSBOMTree.Subject: %w", err)
		}
	}
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// allHasSBOMTreeSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allHasSBOMTreeSubjectPackage struct {
	Typename   *string `json:"__typename"`
	allPkgTree `json:"-"`
}

// GetTypename returns allHasSBOMTreeSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *allHasSBOMTreeSubjectPackage) GetTypename() *string { return v.Typename }

// GetType returns allHasSBOMTreeSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *allHasSBOMTreeSubjectPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allHasSBOMTreeSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allHasSBOMTreeSubjectPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allHasSBOMTreeSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allHasSBOMTreeSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allHasSBOMTreeSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallHasSBOMTreeSubjectPackage struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allHasSBOMTreeSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allHasSBOMTreeSubjectPackage) __premarshalJSON() (*__premarshalallHasSBOMTreeSubjectPackage, error) {
	var retval __premarshalallHasSBOMTreeSubjectPackage

	retval.Typename = v.Typename
	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allHasSBOMTreeSubjectPackageOrSource includes the requested fields of the GraphQL interface PackageOrSource.
//
// allHasSBOMTreeSubjectPackageOrSource is implemented by the following types:
// allHasSBOMTreeSubjectPackage
// allHasSBOMTreeSubjectSource
// The GraphQL type's documentation follows.
//
// PackageOrSource is a union of Package and Source. Any of these objects can be specified
type allHasSBOMTreeSubjectPackageOrSource interface {
	implementsGraphQLInterfaceallHasSBOMTreeSubjectPackageOrSource()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *allHasSBOMTreeSubjectPackage) implementsGraphQLInterfaceallHasSBOMTreeSubjectPackageOrSource() {
}
func (v *allHasSBOMTreeSubjectSource) implementsGraphQLInterfaceallHasSBOMTreeSubjectPackageOrSource() {
}

func __unmarshalallHasSBOMTreeSubjectPackageOrSource(b []byte, v *allHasSBOMTreeSubjectPackageOrSource) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(allHasSBOMTreeSubjectPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(allHasSBOMTreeSubjectSource)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageOrSource.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for allHasSBOMTreeSubjectPackageOrSource: "%v"`, tn.TypeName)
	}
}

func __marshalallHasSBOMTreeSubjectPackageOrSource(v *allHasSBOMTreeSubjectPackageOrSource) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *allHasSBOMTreeSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallHasSBOMTreeSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allHasSBOMTreeSubjectSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallHasSBOMTreeSubjectSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for allHasSBOMTreeSubjectPackageOrSource: "%T"`, v)
	}
}

// allHasSBOMTreeSubjectSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allHasSBOMTreeSubjectSource struct {
	Typename      *string `json:"__typename"`
	allSourceTree `json:"-"`
}

// GetTypename returns allHasSBOMTreeSubjectSource.Typename, and is useful for accessing the field via an interface.
func (v *allHasSBOMTreeSubjectSource) GetTypename() *string { return v.Typename }

// GetType returns allHasSBOMTreeSubjectSource.Type, and is useful for accessing the field via an interface.
func (v *allHasSBOMTreeSubjectSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns allHasSBOMTreeSubjectSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allHasSBOMTreeSubjectSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *allHasSBOMTreeSubjectSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allHasSBOMTreeSubjectSource
		graphql.NoUnmarshalJSON
	}
	firstPass.allHasSBOMTreeSubjectSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallHasSBOMTreeSubjectSource struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *allHasSBOMTreeSubjectSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allHasSBOMTreeSubjectSource) __premarshalJSON() (*__premarshalallHasSBOMTreeSubjectSource, error) {
	var retval __premarshalallHasSBOMTreeSubjectSource

	retval.Typename = v.Typename
	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// allHasSourceAt includes the GraphQL fields of HasSourceAt requested by the fragment allHasSourceAt.
// The GraphQL type's documentation follows.
//
// # HasSourceAt is an attestation represents that a package object has a source object since a timestamp
//
// package (subject) - the package object type that represents the package
// source (object) - the source object type that represents the source
// knownSince (property) - timestamp when this was last checked (exact time)
// justification (property) - string value representing why the package has a source specified
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type allHasSourceAt struct {
	Justification string                `json:"justification"`
	KnownSince    time.Time             `json:"knownSince"`
	Package       allHasSourceAtPackage `json:"package"`
	Source        allHasSourceAtSource  `json:"source"`
	Origin        string                `json:"origin"`
	Collector     string                `json:"collector"`
}

// GetJustification returns allHasSourceAt.Justification, and is useful for accessing the field via an interface.
func (v *allHasSourceAt) GetJustification() string { return v.Justification }

// GetKnownSince returns allHasSourceAt.KnownSince, and is useful for accessing the field via an interface.
func (v *allHasSourceAt) GetKnownSince() time.Time { return v.KnownSince }

// GetPackage returns allHasSourceAt.Package, and is useful for accessing the field via an interface.
func (v *allHasSourceAt) GetPackage() allHasSourceAtPackage { return v.Package }

// GetSource returns allHasSourceAt.Source, and is useful for accessing the field via an interface.
func (v *allHasSourceAt) GetSource() allHasSourceAtSource { return v.Source }

// GetOrigin returns allHasSourceAt.Origin, and is useful for accessing the field via an interface.
func (v *allHasSourceAt) GetOrigin() string { return v.Origin }

// GetCollector returns allHasSourceAt.Collector, and is useful for accessing the field via an interface.
func (v *allHasSourceAt) GetCollector() string { return v.Collector }

// allHasSourceAtPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allHasSourceAtPackage struct {
	Type       string                                            `json:"type"`
	Namespaces []allHasSourceAtPackageNamespacesPackageNamespace `json:"namespaces"`
}

// GetType returns allHasSourceAtPackage.Type, and is useful for accessing the field via an interface.
func (v *allHasSourceAtPackage) GetType() string { return v.Type }

// GetNamespaces returns allHasSourceAtPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allHasSourceAtPackage) GetNamespaces() []allHasSourceAtPackageNamespacesPackageNamespace {
	return v.Namespaces
}

// allHasSourceAtPackageNamespacesPackageNamespace includes the requested fields of the GraphQL type PackageNamespace.
// The GraphQL type's documentation follows.
//
// PackageNamespace is a namespace for packages.
//
// In the pURL representation, each PackageNamespace matches the
// `pkg:<type>/<namespace>/` partial pURL.
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type allHasSourceAtPackageNamespacesPackageNamespace struct {
	Namespace string                                                            `json:"namespace"`
	Names     []allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageName `json:"names"`
}

// GetNamespace returns allHasSourceAtPackageNamespacesPackageNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *allHasSourceAtPackageNamespacesPackageNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns allHasSourceAtPackageNamespacesPackageNamespace.Names, and is useful for accessing the field via an interface.
func (v *allHasSourceAtPackageNamespacesPackageNamespace) GetNames() []allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageName {
	return v.Names
}

// allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageName includes the requested fields of the GraphQL type PackageName.
// The GraphQL type's documentation follows.
//
// PackageName is a name for packages.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>` pURL.
//
// Names are always mandatory.
//
// This is the first node in the trie that can be referred to by other parts of
// GUAC.
type allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageName struct {
	Name     string                                                                                  `json:"name"`
	Versions []allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion `json:"versions"`
}

// GetName returns allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageName.Name, and is useful for accessing the field via an interface.
func (v *allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageName) GetName() string {
	return v.Name
}

// GetVersions returns allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageName.Versions, and is useful for accessing the field via an interface.
func (v *allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageName) GetVersions() []allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion {
	return v.Versions
}

// allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion includes the requested fields of the GraphQL type PackageVersion.
// The GraphQL type's documentation follows.
//
// PackageVersion is a package version.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>@<version>` pURL.
//
// Versions are optional and each Package type defines own rules for handling them.
// For this level of GUAC, these are just opaque strings.
//
// This node can be referred to by other parts of GUAC.
//
// Subpath and qualifiers are optional. Lack of qualifiers is represented by an
// empty list and lack of subpath by empty string (to be consistent with
// optionality of namespace and version). Two nodes that have different qualifiers
// and/or subpath but the same version mean two different packages in the trie
// (they are different). Two nodes that have same version but qualifiers of one are
// a subset of the qualifier of the other also mean two different packages in the
// trie.
type allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion struct {
	Version    string                                                                                                            `json:"version"`
	Qualifiers []allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier `json:"qualifiers"`
	Subpath    string                                                                                                            `json:"subpath"`
}

// GetVersion returns allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Version, and is useful for accessing the field via an interface.
func (v *allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetVersion() string {
	return v.Version
}

// GetQualifiers returns allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Qualifiers, and is useful for accessing the field via an interface.
func (v *allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetQualifiers() []allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier {
	return v.Qualifiers
}

// GetSubpath returns allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Subpath, and is useful for accessing the field via an interface.
func (v *allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetSubpath() string {
	return v.Subpath
}

// allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier includes the requested fields of the GraphQL type PackageQualifier.
// The GraphQL type's documentation follows.
//
// PackageQualifier is a qualifier for a package, a key-value pair.
//
// In the pURL representation, it is a part of the `<qualifiers>` part of the
// `pkg:<type>/<namespace>/<name>@<version>?<qualifiers>` pURL.
//
// Qualifiers are optional, each Package type defines own rules for handling them,
// and multiple qualifiers could be attached to the same package.
//
// This node cannot be directly referred by other parts of GUAC.
type allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Key, and is useful for accessing the field via an interface.
func (v *allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetKey() string {
	return v.Key
}

// GetValue returns allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Value, and is useful for accessing the field via an interface.
func (v *allHasSourceAtPackageNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetValue() string {
	return v.Value
}

// allHasSourceAtSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allHasSourceAtSource struct {
	Type       string                                          `json:"type"`
	Namespaces []allHasSourceAtSourceNamespacesSourceNamespace `json:"namespaces"`
}

// GetType returns allHasSourceAtSource.Type, and is useful for accessing the field via an interface.
func (v *allHasSourceAtSource) GetType() string { return v.Type }

// GetNamespaces returns allHasSourceAtSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allHasSourceAtSource) GetNamespaces() []allHasSourceAtSourceNamespacesSourceNamespace {
	return v.Namespaces
}

// allHasSourceAtSourceNamespacesSourceNamespace includes the requested fields of the GraphQL type SourceNamespace.
// The GraphQL type's documentation follows.
//
// SourceNamespace is a namespace for sources.
//
// This is the location of the repository (such as github/gitlab/bitbucket).
//
// The `namespace` field is mandatory.
type allHasSourceAtSourceNamespacesSourceNamespace struct {
	Namespace string                                                         `json:"namespace"`
	Names     []allHasSourceAtSourceNamespacesSourceNamespaceNamesSourceName `json:"names"`
}

// GetNamespace returns allHasSourceAtSourceNamespacesSourceNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *allHasSourceAtSourceNamespacesSourceNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns allHasSourceAtSourceNamespacesSourceNamespace.Names, and is useful for accessing the field via an interface.
func (v *allHasSourceAtSourceNamespacesSourceNamespace) GetNames() []allHasSourceAtSourceNamespacesSourceNamespaceNamesSourceName {
	return v.Names
}

// allHasSourceAtSourceNamespacesSourceNamespaceNamesSourceName includes the requested fields of the GraphQL type SourceName.
// The GraphQL type's documentation follows.
//
// SourceName is a url of the repository and its tag or commit.
//
// The `name` field is mandatory. The `tag` and `commit` fields are optional, but
// it is an error to specify both.
//
// This is the only source trie node that can be referenced by other parts of
// GUAC.
type allHasSourceAtSourceNamespacesSourceNamespaceNamesSourceName struct {
	Name   string  `json:"name"`
	Tag    *string `json:"tag"`
	Commit *string `json:"commit"`
}

// GetName returns allHasSourceAtSourceNamespacesSourceNamespaceNamesSourceName.Name, and is useful for accessing the field via an interface.
func (v *allHasSourceAtSourceNamespacesSourceNamespaceNamesSourceName) GetName() string {
	return v.Name
}

// GetTag returns allHasSourceAtSourceNamespacesSourceNamespaceNamesSourceName.Tag, and is useful for accessing the field via an interface.
func (v *allHasSourceAtSourceNamespacesSourceNamespaceNamesSourceName) GetTag() *string { return v.Tag }

// GetCommit returns allHasSourceAtSourceNamespacesSourceNamespaceNamesSourceName.Commit, and is useful for accessing the field via an interface.
func (v *allHasSourceAtSourceNamespacesSourceNamespaceNamesSourceName) GetCommit() *string {
	return v.Commit
}

// allHashEqualTree includes the GraphQL fields of HashEqual requested by the fragment allHashEqualTree.
// The GraphQL type's documentation follows.
//
// HashEqual is an attestation that represents when two artifact hash are similar based on a justification.
//
// artifacts (subject) - the artifacts (represented by algorithm and digest) that are equal
// justification (property) - string value representing why the artifacts are the equal
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type allHashEqualTree struct {
	Justification string                              `json:"justification"`
	Artifacts     []allHashEqualTreeArtifactsArtifact `json:"artifacts"`
	Origin        string                              `json:"origin"`
	Collector     string                              `json:"collector"`
}

// GetJustification returns allHashEqualTree.Justification, and is useful for accessing the field via an interface.
func (v *allHashEqualTree) GetJustification() string { return v.Justification }

// GetArtifacts returns allHashEqualTree.Artifacts, and is useful for accessing the field via an interface.
func (v *allHashEqualTree) GetArtifacts() []allHashEqualTreeArtifactsArtifact { return v.Artifacts }

// GetOrigin returns allHashEqualTree.Origin, and is useful for accessing the field via an interface.
func (v *allHashEqualTree) GetOrigin() string { return v.Origin }

// GetCollector returns allHashEqualTree.Collector, and is useful for accessing the field via an interface.
func (v *allHashEqualTree) GetCollector() string { return v.Collector }

// allHashEqualTreeArtifactsArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type allHashEqualTreeArtifactsArtifact struct {
	Algorithm string `json:"algorithm"`
	Digest    string `json:"digest"`
}

// GetAlgorithm returns allHashEqualTreeArtifactsArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *allHashEqualTreeArtifactsArtifact) GetAlgorithm() string { return v.Algorithm }

// GetDigest returns allHashEqualTreeArtifactsArtifact.Digest, and is useful for accessing the field via an interface.
func (v *allHashEqualTreeArtifactsArtifact) GetDigest() string { return v.Digest }

// allIsDependencyTree includes the GraphQL fields of IsDependency requested by the fragment allIsDependencyTree.
// The GraphQL type's documentation follows.
//
// # IsDependency is an attestation that represents when a package is dependent on another package
//
// package (subject) - the package object type that represents the package
// dependentPackage (object) - the package object type that represents the packageName (cannot be to the packageVersion)
// versionRange (property) - string value for version range that applies to the dependent package
// justification (property) - string value representing why the artifacts are the equal
// origin (property) - where this attestation was generated from (based on which document)
// collector (property) - the GUAC collector that collected the document that generated this attestation
type allIsDependencyTree struct {
	Justification    string                              `json:"justification"`
	Package          allIsDependencyTreePackage          `json:"package"`
	DependentPackage allIsDependencyTreeDependentPackage `json:"dependentPackage"`
	VersionRange     string                              `json:"versionRange"`
	Origin           string                              `json:"origin"`
	Collector        string                              `json:"collector"`
}

// GetJustification returns allIsDependencyTree.Justification, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetJustification() string { return v.Justification }

// GetPackage returns allIsDependencyTree.Package, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetPackage() allIsDependencyTreePackage { return v.Package }

// GetDependentPackage returns allIsDependencyTree.DependentPackage, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetDependentPackage() allIsDependencyTreeDependentPackage {
	return v.DependentPackage
}

// GetVersionRange returns allIsDependencyTree.VersionRange, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetVersionRange() string { return v.VersionRange }

// GetOrigin returns allIsDependencyTree.Origin, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetOrigin() string { return v.Origin }

// GetCollector returns allIsDependencyTree.Collector, and is useful for accessing the field via an interface.
func (v *allIsDependencyTree) GetCollector() string { return v.Collector }

// allIsDependencyTreeDependentPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allIsDependencyTreeDependentPackage struct {
	allPkgTree `json:"-"`
}

// GetType returns allIsDependencyTreeDependentPackage.Type, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreeDependentPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allIsDependencyTreeDependentPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreeDependentPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allIsDependencyTreeDependentPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsDependencyTreeDependentPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsDependencyTreeDependentPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsDependencyTreeDependentPackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allIsDependencyTreeDependentPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsDependencyTreeDependentPackage) __premarshalJSON() (*__premarshalallIsDependencyTreeDependentPackage, error) {
	var retval __premarshalallIsDependencyTreeDependentPackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allIsDependencyTreePackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allIsDependencyTreePackage struct {
	allPkgTree `json:"-"`
}

// GetType returns allIsDependencyTreePackage.Type, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreePackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allIsDependencyTreePackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsDependencyTreePackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allIsDependencyTreePackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsDependencyTreePackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsDependencyTreePackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsDependencyTreePackage struct {
	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allIsDependencyTreePackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsDependencyTreePackage) __premarshalJSON() (*__premarshalallIsDependencyTreePackage, error) {
	var retval __premarshalallIsDependencyTreePackage

	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allIsOccurrencesTree includes the GraphQL fields of IsOccurrence requested by the fragment allIsOccurrencesTree.
// The GraphQL type's documentation follows.
//
// # IsOccurrence is an attestation represents when either a package or source is represented by an artifact
//
// Note: Package or Source must be specified but not both at the same time.
// Attestation must occur at the PackageVersion or at the SourceName.
type allIsOccurrencesTree struct {
	// subject - union type that can be either a package or source object type
	Subject allIsOccurrencesTreeSubjectPackageOrSource `json:"-"`
	// artifact (object) - artifact that represent the the package or source
	Artifact allIsOccurrencesTreeArtifact `json:"artifact"`
	// justification (property) - string value representing why the package or source is represented by the specified artifact
	Justification string `json:"justification"`
	// origin (property) - where this attestation was generated from (based on which document)
	Origin string `json:"origin"`
	// collector (property) - the GUAC collector that collected the document that generated this attestation
	Collector string `json:"collector"`
}

// GetSubject returns allIsOccurrencesTree.Subject, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetSubject() allIsOccurrencesTreeSubjectPackageOrSource {
	return v.Subject
}

// GetArtifact returns allIsOccurrencesTree.Artifact, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetArtifact() allIsOccurrencesTreeArtifact { return v.Artifact }

// GetJustification returns allIsOccurrencesTree.Justification, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetJustification() string { return v.Justification }

// GetOrigin returns allIsOccurrencesTree.Origin, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetOrigin() string { return v.Origin }

// GetCollector returns allIsOccurrencesTree.Collector, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTree) GetCollector() string { return v.Collector }

func (v *allIsOccurrencesTree) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsOccurrencesTree
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsOccurrencesTree = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalallIsOccurrencesTreeSubjectPackageOrSource(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"Unable to unmarshal allIsOccurrencesTree.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalallIsOccurrencesTree struct {
	Subject json.RawMessage `json:"subject"`

	Artifact allIsOccurrencesTreeArtifact `json:"artifact"`

	Justification string `json:"justification"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *allIsOccurrencesTree) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsOccurrencesTree) __premarshalJSON() (*__premarshalallIsOccurrencesTree, error) {
	var retval __premarshalallIsOccurrencesTree

	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalallIsOccurrencesTreeSubjectPackageOrSource(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal allIsOccurrencesTree.Subject: %w", err)
		}
	}
	retval.Artifact = v.Artifact
	retval.Justification = v.Justification
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// allIsOccurrencesTreeArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type allIsOccurrencesTreeArtifact struct {
	allArtifactTree `json:"-"`
}

// GetAlgorithm returns allIsOccurrencesTreeArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns allIsOccurrencesTreeArtifact.Digest, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *allIsOccurrencesTreeArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsOccurrencesTreeArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsOccurrencesTreeArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsOccurrencesTreeArtifact struct {
	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *allIsOccurrencesTreeArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsOccurrencesTreeArtifact) __premarshalJSON() (*__premarshalallIsOccurrencesTreeArtifact, error) {
	var retval __premarshalallIsOccurrencesTreeArtifact

	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// allIsOccurrencesTreeSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allIsOccurrencesTreeSubjectPackage struct {
	Typename   *string `json:"__typename"`
	allPkgTree `json:"-"`
}

// GetTypename returns allIsOccurrencesTreeSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectPackage) GetTypename() *string { return v.Typename }

// GetType returns allIsOccurrencesTreeSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allIsOccurrencesTreeSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allIsOccurrencesTreeSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsOccurrencesTreeSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsOccurrencesTreeSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsOccurrencesTreeSubjectPackage struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allIsOccurrencesTreeSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsOccurrencesTreeSubjectPackage) __premarshalJSON() (*__premarshalallIsOccurrencesTreeSubjectPackage, error) {
	var retval __premarshalallIsOccurrencesTreeSubjectPackage

	retval.Typename = v.Typename
	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allIsOccurrencesTreeSubjectPackageOrSource includes the requested fields of the GraphQL interface PackageOrSource.
//
// allIsOccurrencesTreeSubjectPackageOrSource is implemented by the following types:
// allIsOccurrencesTreeSubjectPackage
// allIsOccurrencesTreeSubjectSource
// The GraphQL type's documentation follows.
//
// PackageOrSource is a union of Package and Source. Any of these objects can be specified
type allIsOccurrencesTreeSubjectPackageOrSource interface {
	implementsGraphQLInterfaceallIsOccurrencesTreeSubjectPackageOrSource()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *allIsOccurrencesTreeSubjectPackage) implementsGraphQLInterfaceallIsOccurrencesTreeSubjectPackageOrSource() {
}
func (v *allIsOccurrencesTreeSubjectSource) implementsGraphQLInterfaceallIsOccurrencesTreeSubjectPackageOrSource() {
}

func __unmarshalallIsOccurrencesTreeSubjectPackageOrSource(b []byte, v *allIsOccurrencesTreeSubjectPackageOrSource) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(allIsOccurrencesTreeSubjectPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(allIsOccurrencesTreeSubjectSource)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageOrSource.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for allIsOccurrencesTreeSubjectPackageOrSource: "%v"`, tn.TypeName)
	}
}

func __marshalallIsOccurrencesTreeSubjectPackageOrSource(v *allIsOccurrencesTreeSubjectPackageOrSource) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *allIsOccurrencesTreeSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallIsOccurrencesTreeSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allIsOccurrencesTreeSubjectSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallIsOccurrencesTreeSubjectSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for allIsOccurrencesTreeSubjectPackageOrSource: "%T"`, v)
	}
}

// allIsOccurrencesTreeSubjectSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allIsOccurrencesTreeSubjectSource struct {
	Typename      *string `json:"__typename"`
	allSourceTree `json:"-"`
}

// GetTypename returns allIsOccurrencesTreeSubjectSource.Typename, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectSource) GetTypename() *string { return v.Typename }

// GetType returns allIsOccurrencesTreeSubjectSource.Type, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns allIsOccurrencesTreeSubjectSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allIsOccurrencesTreeSubjectSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *allIsOccurrencesTreeSubjectSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allIsOccurrencesTreeSubjectSource
		graphql.NoUnmarshalJSON
	}
	firstPass.allIsOccurrencesTreeSubjectSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallIsOccurrencesTreeSubjectSource struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *allIsOccurrencesTreeSubjectSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allIsOccurrencesTreeSubjectSource) __premarshalJSON() (*__premarshalallIsOccurrencesTreeSubjectSource, error) {
	var retval __premarshalallIsOccurrencesTreeSubjectSource

	retval.Typename = v.Typename
	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// allOSVTree includes the GraphQL fields of OSV requested by the fragment allOSVTree.
// The GraphQL type's documentation follows.
//
// OSV represents an Open Source Vulnerability.
//
// We create a separate node to allow retrieving all OSVs.
type allOSVTree struct {
	OsvId []allOSVTreeOsvIdOSVId `json:"osvId"`
}

// GetOsvId returns allOSVTree.OsvId, and is useful for accessing the field via an interface.
func (v *allOSVTree) GetOsvId() []allOSVTreeOsvIdOSVId { return v.OsvId }

// allOSVTreeOsvIdOSVId includes the requested fields of the GraphQL type OSVId.
// The GraphQL type's documentation follows.
//
// OSVId is the actual ID that is given to a specific vulnerability.
//
// The `id` field is mandatory and canonicalized to be lowercase.
//
// This maps to a vulnerability ID specific to the environment (e.g., GHSA ID or
// CVE ID).
//
// This node can be referred to by other parts of GUAC.
type allOSVTreeOsvIdOSVId struct {
	Id string `json:"id"`
}

// GetId returns allOSVTreeOsvIdOSVId.Id, and is useful for accessing the field via an interface.
func (v *allOSVTreeOsvIdOSVId) GetId() string { return v.Id }

// allPkgTree includes the GraphQL fields of Package requested by the fragment allPkgTree.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allPkgTree struct {
	Type       string                                 `json:"type"`
	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

// GetType returns allPkgTree.Type, and is useful for accessing the field via an interface.
func (v *allPkgTree) GetType() string { return v.Type }

// GetNamespaces returns allPkgTree.Namespaces, and is useful for accessing the field via an interface.
func (v *allPkgTree) GetNamespaces() []allPkgTreeNamespacesPackageNamespace { return v.Namespaces }

// allPkgTreeNamespacesPackageNamespace includes the requested fields of the GraphQL type PackageNamespace.
// The GraphQL type's documentation follows.
//
// PackageNamespace is a namespace for packages.
//
// In the pURL representation, each PackageNamespace matches the
// `pkg:<type>/<namespace>/` partial pURL.
//
// Namespaces are optional and type specific. Because they are optional, we use
// empty string to denote missing namespaces.
type allPkgTreeNamespacesPackageNamespace struct {
	Namespace string                                                 `json:"namespace"`
	Names     []allPkgTreeNamespacesPackageNamespaceNamesPackageName `json:"names"`
}

// GetNamespace returns allPkgTreeNamespacesPackageNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns allPkgTreeNamespacesPackageNamespace.Names, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespace) GetNames() []allPkgTreeNamespacesPackageNamespaceNamesPackageName {
	return v.Names
}

// allPkgTreeNamespacesPackageNamespaceNamesPackageName includes the requested fields of the GraphQL type PackageName.
// The GraphQL type's documentation follows.
//
// PackageName is a name for packages.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>` pURL.
//
// Names are always mandatory.
//
// This is the first node in the trie that can be referred to by other parts of
// GUAC.
type allPkgTreeNamespacesPackageNamespaceNamesPackageName struct {
	Name     string                                                                       `json:"name"`
	Versions []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion `json:"versions"`
}

// GetName returns allPkgTreeNamespacesPackageNamespaceNamesPackageName.Name, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageName) GetName() string { return v.Name }

// GetVersions returns allPkgTreeNamespacesPackageNamespaceNamesPackageName.Versions, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageName) GetVersions() []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion {
	return v.Versions
}

// allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion includes the requested fields of the GraphQL type PackageVersion.
// The GraphQL type's documentation follows.
//
// PackageVersion is a package version.
//
// In the pURL representation, each PackageName matches the
// `pkg:<type>/<namespace>/<name>@<version>` pURL.
//
// Versions are optional and each Package type defines own rules for handling them.
// For this level of GUAC, these are just opaque strings.
//
// This node can be referred to by other parts of GUAC.
//
// Subpath and qualifiers are optional. Lack of qualifiers is represented by an
// empty list and lack of subpath by empty string (to be consistent with
// optionality of namespace and version). Two nodes that have different qualifiers
// and/or subpath but the same version mean two different packages in the trie
// (they are different). Two nodes that have same version but qualifiers of one are
// a subset of the qualifier of the other also mean two different packages in the
// trie.
type allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion struct {
	Version    string                                                                                                 `json:"version"`
	Qualifiers []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier `json:"qualifiers"`
	Subpath    string                                                                                                 `json:"subpath"`
}

// GetVersion returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Version, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetVersion() string {
	return v.Version
}

// GetQualifiers returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Qualifiers, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetQualifiers() []allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier {
	return v.Qualifiers
}

// GetSubpath returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion.Subpath, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersion) GetSubpath() string {
	return v.Subpath
}

// allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier includes the requested fields of the GraphQL type PackageQualifier.
// The GraphQL type's documentation follows.
//
// PackageQualifier is a qualifier for a package, a key-value pair.
//
// In the pURL representation, it is a part of the `<qualifiers>` part of the
// `pkg:<type>/<namespace>/<name>@<version>?<qualifiers>` pURL.
//
// Qualifiers are optional, each Package type defines own rules for handling them,
// and multiple qualifiers could be attached to the same package.
//
// This node cannot be directly referred by other parts of GUAC.
type allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Key, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetKey() string {
	return v.Key
}

// GetValue returns allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier.Value, and is useful for accessing the field via an interface.
func (v *allPkgTreeNamespacesPackageNamespaceNamesPackageNameVersionsPackageVersionQualifiersPackageQualifier) GetValue() string {
	return v.Value
}

// allSLSATree includes the GraphQL fields of HasSLSA requested by the fragment allSLSATree.
// The GraphQL type's documentation follows.
//
// HasSLSA records that a subject node has a SLSA attestation.
type allSLSATree struct {
	// The subject of SLSA attestation: package, source, or artifact.
	Subject allSLSATreeSubjectPackageSourceOrArtifact `json:"-"`
	// The SLSA attestation.
	Slsa *allSLSATreeSlsaSLSA `json:"slsa"`
}

// GetSubject returns allSLSATree.Subject, and is useful for accessing the field via an interface.
func (v *allSLSATree) GetSubject() allSLSATreeSubjectPackageSourceOrArtifact { return v.Subject }

// GetSlsa returns allSLSATree.Slsa, and is useful for accessing the field via an interface.
func (v *allSLSATree) GetSlsa() *allSLSATreeSlsaSLSA { return v.Slsa }

func (v *allSLSATree) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATree
		Subject json.RawMessage `json:"subject"`
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATree = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.Subject
		src := firstPass.Subject
		if len(src) != 0 && string(src) != "null" {
			err = __unmarshalallSLSATreeSubjectPackageSourceOrArtifact(
				src, dst)
			if err != nil {
				return fmt.Errorf(
					"Unable to unmarshal allSLSATree.Subject: %w", err)
			}
		}
	}
	return nil
}

type __premarshalallSLSATree struct {
	Subject json.RawMessage `json:"subject"`

	Slsa *allSLSATreeSlsaSLSA `json:"slsa"`
}

func (v *allSLSATree) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATree) __premarshalJSON() (*__premarshalallSLSATree, error) {
	var retval __premarshalallSLSATree

	{

		dst := &retval.Subject
		src := v.Subject
		var err error
		*dst, err = __marshalallSLSATreeSubjectPackageSourceOrArtifact(
			&src)
		if err != nil {
			return nil, fmt.Errorf(
				"Unable to marshal allSLSATree.Subject: %w", err)
		}
	}
	retval.Slsa = v.Slsa
	return &retval, nil
}

// allSLSATreeSlsaSLSA includes the requested fields of the GraphQL type SLSA.
// The GraphQL type's documentation follows.
//
// SLSA contains all of the fields present in a SLSA attestation.
//
// The materials and builders are objects of the HasSLSA predicate, everything
// else are properties extracted from the attestation.
//
// We also include fields to specify under what conditions the check was performed
// (time of scan, version of scanners, etc.) as well as how this information got
// included into GUAC (origin document and the collector for that document).
type allSLSATreeSlsaSLSA struct {
	// Sources of the build resulting in subject (materials)
	BuiltFrom []allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact `json:"-"`
	// Builder performing the build
	BuiltBy allSLSATreeSlsaSLSABuiltByBuilder `json:"builtBy"`
	// Type of the builder
	BuildType string `json:"buildType"`
	// Individual predicates found in the attestation
	SlsaPredicate []allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate `json:"slsaPredicate"`
	// Version of the SLSA predicate
	SlsaVersion string `json:"slsaVersion"`
	// Timestamp (RFC3339Nano format) of build start time
	StartedOn time.Time `json:"startedOn"`
	// Timestamp (RFC3339Nano format) of build end time
	FinishedOn time.Time `json:"finishedOn"`
	// Document from which this attestation is generated from
	Origin string `json:"origin"`
	// GUAC collector for the document
	Collector string `json:"collector"`
}

// GetBuiltFrom returns allSLSATreeSlsaSLSA.BuiltFrom, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetBuiltFrom() []allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact {
	return v.BuiltFrom
}

// GetBuiltBy returns allSLSATreeSlsaSLSA.BuiltBy, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetBuiltBy() allSLSATreeSlsaSLSABuiltByBuilder { return v.BuiltBy }

// GetBuildType returns allSLSATreeSlsaSLSA.BuildType, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetBuildType() string { return v.BuildType }

// GetSlsaPredicate returns allSLSATreeSlsaSLSA.SlsaPredicate, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetSlsaPredicate() []allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate {
	return v.SlsaPredicate
}

// GetSlsaVersion returns allSLSATreeSlsaSLSA.SlsaVersion, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetSlsaVersion() string { return v.SlsaVersion }

// GetStartedOn returns allSLSATreeSlsaSLSA.StartedOn, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetStartedOn() time.Time { return v.StartedOn }

// GetFinishedOn returns allSLSATreeSlsaSLSA.FinishedOn, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetFinishedOn() time.Time { return v.FinishedOn }

// GetOrigin returns allSLSATreeSlsaSLSA.Origin, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetOrigin() string { return v.Origin }

// GetCollector returns allSLSATreeSlsaSLSA.Collector, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSA) GetCollector() string { return v.Collector }

func (v *allSLSATreeSlsaSLSA) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSlsaSLSA
		BuiltFrom []json.RawMessage `json:"builtFrom"`
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSlsaSLSA = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	{
		dst := &v.BuiltFrom
		src := firstPass.BuiltFrom
		*dst = make(
			[]allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			if len(src) != 0 && string(src) != "null" {
				err = __unmarshalallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact(
					src, dst)
				if err != nil {
					return fmt.Errorf(
						"Unable to unmarshal allSLSATreeSlsaSLSA.BuiltFrom: %w", err)
				}
			}
		}
	}
	return nil
}

type __premarshalallSLSATreeSlsaSLSA struct {
	BuiltFrom []json.RawMessage `json:"builtFrom"`

	BuiltBy allSLSATreeSlsaSLSABuiltByBuilder `json:"builtBy"`

	BuildType string `json:"buildType"`

	SlsaPredicate []allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate `json:"slsaPredicate"`

	SlsaVersion string `json:"slsaVersion"`

	StartedOn time.Time `json:"startedOn"`

	FinishedOn time.Time `json:"finishedOn"`

	Origin string `json:"origin"`

	Collector string `json:"collector"`
}

func (v *allSLSATreeSlsaSLSA) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSlsaSLSA) __premarshalJSON() (*__premarshalallSLSATreeSlsaSLSA, error) {
	var retval __premarshalallSLSATreeSlsaSLSA

	{

		dst := &retval.BuiltFrom
		src := v.BuiltFrom
		*dst = make(
			[]json.RawMessage,
			len(src))
		for i, src := range src {
			dst := &(*dst)[i]
			var err error
			*dst, err = __marshalallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact(
				&src)
			if err != nil {
				return nil, fmt.Errorf(
					"Unable to marshal allSLSATreeSlsaSLSA.BuiltFrom: %w", err)
			}
		}
	}
	retval.BuiltBy = v.BuiltBy
	retval.BuildType = v.BuildType
	retval.SlsaPredicate = v.SlsaPredicate
	retval.SlsaVersion = v.SlsaVersion
	retval.StartedOn = v.StartedOn
	retval.FinishedOn = v.FinishedOn
	retval.Origin = v.Origin
	retval.Collector = v.Collector
	return &retval, nil
}

// allSLSATreeSlsaSLSABuiltByBuilder includes the requested fields of the GraphQL type Builder.
// The GraphQL type's documentation follows.
//
// Builder represents the builder such as (FRSCA or github actions).
//
// Currently builders are identified by the `uri` field, which is mandatory.
type allSLSATreeSlsaSLSABuiltByBuilder struct {
	Uri string `json:"uri"`
}

// GetUri returns allSLSATreeSlsaSLSABuiltByBuilder.Uri, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltByBuilder) GetUri() string { return v.Uri }

// allSLSATreeSlsaSLSABuiltFromArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type allSLSATreeSlsaSLSABuiltFromArtifact struct {
	Typename        *string `json:"__typename"`
	allArtifactTree `json:"-"`
}

// GetTypename returns allSLSATreeSlsaSLSABuiltFromArtifact.Typename, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromArtifact) GetTypename() *string { return v.Typename }

// GetAlgorithm returns allSLSATreeSlsaSLSABuiltFromArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromArtifact) GetAlgorithm() string {
	return v.allArtifactTree.Algorithm
}

// GetDigest returns allSLSATreeSlsaSLSABuiltFromArtifact.Digest, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *allSLSATreeSlsaSLSABuiltFromArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSlsaSLSABuiltFromArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSlsaSLSABuiltFromArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallSLSATreeSlsaSLSABuiltFromArtifact struct {
	Typename *string `json:"__typename"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *allSLSATreeSlsaSLSABuiltFromArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSlsaSLSABuiltFromArtifact) __premarshalJSON() (*__premarshalallSLSATreeSlsaSLSABuiltFromArtifact, error) {
	var retval __premarshalallSLSATreeSlsaSLSABuiltFromArtifact

	retval.Typename = v.Typename
	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// allSLSATreeSlsaSLSABuiltFromPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allSLSATreeSlsaSLSABuiltFromPackage struct {
	Typename   *string `json:"__typename"`
	allPkgTree `json:"-"`
}

// GetTypename returns allSLSATreeSlsaSLSABuiltFromPackage.Typename, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromPackage) GetTypename() *string { return v.Typename }

// GetType returns allSLSATreeSlsaSLSABuiltFromPackage.Type, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allSLSATreeSlsaSLSABuiltFromPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allSLSATreeSlsaSLSABuiltFromPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSlsaSLSABuiltFromPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSlsaSLSABuiltFromPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallSLSATreeSlsaSLSABuiltFromPackage struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allSLSATreeSlsaSLSABuiltFromPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSlsaSLSABuiltFromPackage) __premarshalJSON() (*__premarshalallSLSATreeSlsaSLSABuiltFromPackage, error) {
	var retval __premarshalallSLSATreeSlsaSLSABuiltFromPackage

	retval.Typename = v.Typename
	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact includes the requested fields of the GraphQL interface PackageSourceOrArtifact.
//
// allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact is implemented by the following types:
// allSLSATreeSlsaSLSABuiltFromPackage
// allSLSATreeSlsaSLSABuiltFromSource
// allSLSATreeSlsaSLSABuiltFromArtifact
// The GraphQL type's documentation follows.
//
// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact interface {
	implementsGraphQLInterfaceallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *allSLSATreeSlsaSLSABuiltFromPackage) implementsGraphQLInterfaceallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact() {
}
func (v *allSLSATreeSlsaSLSABuiltFromSource) implementsGraphQLInterfaceallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact() {
}
func (v *allSLSATreeSlsaSLSABuiltFromArtifact) implementsGraphQLInterfaceallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact() {
}

func __unmarshalallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact(b []byte, v *allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(allSLSATreeSlsaSLSABuiltFromPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(allSLSATreeSlsaSLSABuiltFromSource)
		return json.Unmarshal(b, *v)
	case "Artifact":
		*v = new(allSLSATreeSlsaSLSABuiltFromArtifact)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageSourceOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalallSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact(v *allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *allSLSATreeSlsaSLSABuiltFromPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallSLSATreeSlsaSLSABuiltFromPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allSLSATreeSlsaSLSABuiltFromSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallSLSATreeSlsaSLSABuiltFromSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allSLSATreeSlsaSLSABuiltFromArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallSLSATreeSlsaSLSABuiltFromArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for allSLSATreeSlsaSLSABuiltFromPackageSourceOrArtifact: "%T"`, v)
	}
}

// allSLSATreeSlsaSLSABuiltFromSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allSLSATreeSlsaSLSABuiltFromSource struct {
	Typename      *string `json:"__typename"`
	allSourceTree `json:"-"`
}

// GetTypename returns allSLSATreeSlsaSLSABuiltFromSource.Typename, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromSource) GetTypename() *string { return v.Typename }

// GetType returns allSLSATreeSlsaSLSABuiltFromSource.Type, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns allSLSATreeSlsaSLSABuiltFromSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSABuiltFromSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *allSLSATreeSlsaSLSABuiltFromSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSlsaSLSABuiltFromSource
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSlsaSLSABuiltFromSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallSLSATreeSlsaSLSABuiltFromSource struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *allSLSATreeSlsaSLSABuiltFromSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSlsaSLSABuiltFromSource) __premarshalJSON() (*__premarshalallSLSATreeSlsaSLSABuiltFromSource, error) {
	var retval __premarshalallSLSATreeSlsaSLSABuiltFromSource

	retval.Typename = v.Typename
	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate includes the requested fields of the GraphQL type SLSAPredicate.
// The GraphQL type's documentation follows.
//
// SLSAPredicate are the values from the SLSA predicate in key-value pair form.
//
// # For example, given the following predicate
//
// ```
// "predicate": {
// "buildDefinition": {
// "externalParameters": {
// "repository": "https://github.com/octocat/hello-world",
// ...
// },
// ...
// },
// ...
// }
// ```
//
// we have
//
// ```
// key   = "buildDefinition.externalParameters.repository"
// value = "https://github.com/octocat/hello-world"
// ```
//
// This node cannot be directly referred by other parts of GUAC.
//
// TODO(mihaimaruseac): Can we define these directly?
type allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// GetKey returns allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate.Key, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate) GetKey() string { return v.Key }

// GetValue returns allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate.Value, and is useful for accessing the field via an interface.
func (v *allSLSATreeSlsaSLSASlsaPredicateSLSAPredicate) GetValue() string { return v.Value }

// allSLSATreeSubjectArtifact includes the requested fields of the GraphQL type Artifact.
// The GraphQL type's documentation follows.
//
// # Artifact represents the artifact and contains a digest field
//
// Both field are mandatory and canonicalized to be lowercase.
//
// If having a `checksum` Go object, `algorithm` can be
// `strings.ToLower(string(checksum.Algorithm))` and `digest` can be
// `checksum.Value`.
type allSLSATreeSubjectArtifact struct {
	Typename        *string `json:"__typename"`
	allArtifactTree `json:"-"`
}

// GetTypename returns allSLSATreeSubjectArtifact.Typename, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectArtifact) GetTypename() *string { return v.Typename }

// GetAlgorithm returns allSLSATreeSubjectArtifact.Algorithm, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectArtifact) GetAlgorithm() string { return v.allArtifactTree.Algorithm }

// GetDigest returns allSLSATreeSubjectArtifact.Digest, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectArtifact) GetDigest() string { return v.allArtifactTree.Digest }

func (v *allSLSATreeSubjectArtifact) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSubjectArtifact
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSubjectArtifact = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allArtifactTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallSLSATreeSubjectArtifact struct {
	Typename *string `json:"__typename"`

	Algorithm string `json:"algorithm"`

	Digest string `json:"digest"`
}

func (v *allSLSATreeSubjectArtifact) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSubjectArtifact) __premarshalJSON() (*__premarshalallSLSATreeSubjectArtifact, error) {
	var retval __premarshalallSLSATreeSubjectArtifact

	retval.Typename = v.Typename
	retval.Algorithm = v.allArtifactTree.Algorithm
	retval.Digest = v.allArtifactTree.Digest
	return &retval, nil
}

// allSLSATreeSubjectPackage includes the requested fields of the GraphQL type Package.
// The GraphQL type's documentation follows.
//
// Package represents a package.
//
// In the pURL representation, each Package matches a `pkg:<type>` partial pURL.
// The `type` field matches the pURL types but we might also use `"guac"` for the
// cases where the pURL representation is not complete or when we have custom
// rules.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Package`, not `PackageType`. This is only to make
// queries more readable.
type allSLSATreeSubjectPackage struct {
	Typename   *string `json:"__typename"`
	allPkgTree `json:"-"`
}

// GetTypename returns allSLSATreeSubjectPackage.Typename, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectPackage) GetTypename() *string { return v.Typename }

// GetType returns allSLSATreeSubjectPackage.Type, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectPackage) GetType() string { return v.allPkgTree.Type }

// GetNamespaces returns allSLSATreeSubjectPackage.Namespaces, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectPackage) GetNamespaces() []allPkgTreeNamespacesPackageNamespace {
	return v.allPkgTree.Namespaces
}

func (v *allSLSATreeSubjectPackage) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSubjectPackage
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSubjectPackage = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allPkgTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallSLSATreeSubjectPackage struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allPkgTreeNamespacesPackageNamespace `json:"namespaces"`
}

func (v *allSLSATreeSubjectPackage) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSubjectPackage) __premarshalJSON() (*__premarshalallSLSATreeSubjectPackage, error) {
	var retval __premarshalallSLSATreeSubjectPackage

	retval.Typename = v.Typename
	retval.Type = v.allPkgTree.Type
	retval.Namespaces = v.allPkgTree.Namespaces
	return &retval, nil
}

// allSLSATreeSubjectPackageSourceOrArtifact includes the requested fields of the GraphQL interface PackageSourceOrArtifact.
//
// allSLSATreeSubjectPackageSourceOrArtifact is implemented by the following types:
// allSLSATreeSubjectPackage
// allSLSATreeSubjectSource
// allSLSATreeSubjectArtifact
// The GraphQL type's documentation follows.
//
// PackageSourceOrArtifact is a union of Package, Source, and Artifact.
type allSLSATreeSubjectPackageSourceOrArtifact interface {
	implementsGraphQLInterfaceallSLSATreeSubjectPackageSourceOrArtifact()
	// GetTypename returns the receiver's concrete GraphQL type-name (see interface doc for possible values).
	GetTypename() *string
}

func (v *allSLSATreeSubjectPackage) implementsGraphQLInterfaceallSLSATreeSubjectPackageSourceOrArtifact() {
}
func (v *allSLSATreeSubjectSource) implementsGraphQLInterfaceallSLSATreeSubjectPackageSourceOrArtifact() {
}
func (v *allSLSATreeSubjectArtifact) implementsGraphQLInterfaceallSLSATreeSubjectPackageSourceOrArtifact() {
}

func __unmarshalallSLSATreeSubjectPackageSourceOrArtifact(b []byte, v *allSLSATreeSubjectPackageSourceOrArtifact) error {
	if string(b) == "null" {
		return nil
	}

	var tn struct {
		TypeName string `json:"__typename"`
	}
	err := json.Unmarshal(b, &tn)
	if err != nil {
		return err
	}

	switch tn.TypeName {
	case "Package":
		*v = new(allSLSATreeSubjectPackage)
		return json.Unmarshal(b, *v)
	case "Source":
		*v = new(allSLSATreeSubjectSource)
		return json.Unmarshal(b, *v)
	case "Artifact":
		*v = new(allSLSATreeSubjectArtifact)
		return json.Unmarshal(b, *v)
	case "":
		return fmt.Errorf(
			"response was missing PackageSourceOrArtifact.__typename")
	default:
		return fmt.Errorf(
			`unexpected concrete type for allSLSATreeSubjectPackageSourceOrArtifact: "%v"`, tn.TypeName)
	}
}

func __marshalallSLSATreeSubjectPackageSourceOrArtifact(v *allSLSATreeSubjectPackageSourceOrArtifact) ([]byte, error) {

	var typename string
	switch v := (*v).(type) {
	case *allSLSATreeSubjectPackage:
		typename = "Package"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallSLSATreeSubjectPackage
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allSLSATreeSubjectSource:
		typename = "Source"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallSLSATreeSubjectSource
		}{typename, premarshaled}
		return json.Marshal(result)
	case *allSLSATreeSubjectArtifact:
		typename = "Artifact"

		premarshaled, err := v.__premarshalJSON()
		if err != nil {
			return nil, err
		}
		result := struct {
			TypeName string `json:"__typename"`
			*__premarshalallSLSATreeSubjectArtifact
		}{typename, premarshaled}
		return json.Marshal(result)
	case nil:
		return []byte("null"), nil
	default:
		return nil, fmt.Errorf(
			`unexpected concrete type for allSLSATreeSubjectPackageSourceOrArtifact: "%T"`, v)
	}
}

// allSLSATreeSubjectSource includes the requested fields of the GraphQL type Source.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allSLSATreeSubjectSource struct {
	Typename      *string `json:"__typename"`
	allSourceTree `json:"-"`
}

// GetTypename returns allSLSATreeSubjectSource.Typename, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectSource) GetTypename() *string { return v.Typename }

// GetType returns allSLSATreeSubjectSource.Type, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectSource) GetType() string { return v.allSourceTree.Type }

// GetNamespaces returns allSLSATreeSubjectSource.Namespaces, and is useful for accessing the field via an interface.
func (v *allSLSATreeSubjectSource) GetNamespaces() []allSourceTreeNamespacesSourceNamespace {
	return v.allSourceTree.Namespaces
}

func (v *allSLSATreeSubjectSource) UnmarshalJSON(b []byte) error {

	if string(b) == "null" {
		return nil
	}

	var firstPass struct {
		*allSLSATreeSubjectSource
		graphql.NoUnmarshalJSON
	}
	firstPass.allSLSATreeSubjectSource = v

	err := json.Unmarshal(b, &firstPass)
	if err != nil {
		return err
	}

	err = json.Unmarshal(
		b, &v.allSourceTree)
	if err != nil {
		return err
	}
	return nil
}

type __premarshalallSLSATreeSubjectSource struct {
	Typename *string `json:"__typename"`

	Type string `json:"type"`

	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

func (v *allSLSATreeSubjectSource) MarshalJSON() ([]byte, error) {
	premarshaled, err := v.__premarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.Marshal(premarshaled)
}

func (v *allSLSATreeSubjectSource) __premarshalJSON() (*__premarshalallSLSATreeSubjectSource, error) {
	var retval __premarshalallSLSATreeSubjectSource

	retval.Typename = v.Typename
	retval.Type = v.allSourceTree.Type
	retval.Namespaces = v.allSourceTree.Namespaces
	return &retval, nil
}

// allSourceTree includes the GraphQL fields of Source requested by the fragment allSourceTree.
// The GraphQL type's documentation follows.
//
// Source represents a source.
//
// This can be the version control system that is being used.
//
// This node is a singleton: backends guarantee that there is exactly one node
// with the same `type` value.
//
// Also note that this is named `Source`, not `SourceType`. This is only to make
// queries more readable.
type allSourceTree struct {
	Type       string                                   `json:"type"`
	Namespaces []allSourceTreeNamespacesSourceNamespace `json:"namespaces"`
}

// GetType returns allSourceTree.Type, and is useful for accessing the field via an interface.
func (v *allSourceTree) GetType() string { return v.Type }

// GetNamespaces returns allSourceTree.Namespaces, and is useful for accessing the field via an interface.
func (v *allSourceTree) GetNamespaces() []allSourceTreeNamespacesSourceNamespace { return v.Namespaces }

// allSourceTreeNamespacesSourceNamespace includes the requested fields of the GraphQL type SourceNamespace.
// The GraphQL type's documentation follows.
//
// SourceNamespace is a namespace for sources.
//
// This is the location of the repository (such as github/gitlab/bitbucket).
//
// The `namespace` field is mandatory.
type allSourceTreeNamespacesSourceNamespace struct {
	Namespace string                                                  `json:"namespace"`
	Names     []allSourceTreeNamespacesSourceNamespaceNamesSourceName `json:"names"`
}

// GetNamespace returns allSourceTreeNamespacesSourceNamespace.Namespace, and is useful for accessing the field via an interface.
func (v *allSourceTreeNamespacesSourceNamespace) GetNamespace() string { return v.Namespace }

// GetNames returns allSourceTreeNamespacesSourceNamespace.Names, and is useful for accessing the field via an interface.
func (v *allSourceTreeNamespacesSourceNamespace) GetNames() []allSourceTreeNamespacesSourceNamespaceNamesSourceName {
	return v.Names
}

// allSourceTreeNamespacesSourceNamespaceNamesSourceName includes the requested fields of the GraphQL type SourceName.
// The GraphQL type's documentation follows.
//
// SourceName is a url of the repository and its tag or commit.
//
// The `name` field is mandatory. The `tag` and `commit` fields are optional, but
// it is an error to specify both.
//
// This is the only source trie node that can be referenced by other parts of
// GUAC.
type allSourceTreeNamespacesSourceNamespaceNamesSourceName struct {
	Name   string  `json:"name"`
	Tag    *string `json:"tag"`
	Commit *string `json:"commit"`
}

// GetName returns allSourceTreeNamespacesSourceNamespaceNamesSourceName.Name, and is useful for accessing the field via an interface.
func (v *allSourceTreeNamespacesSourceNamespaceNamesSourceName) GetName() string { return v.Name }

// GetTag returns allSourceTreeNamespacesSourceNamespaceNamesSourceName.Tag, and is useful for accessing the field via an interface.
func (v *allSourceTreeNamespacesSourceNamespaceNamesSourceName) GetTag() *string { return v.Tag }

// GetCommit returns allSourceTreeNamespacesSourceNamespaceNamesSourceName.Commit, and is useful for accessing the field via an interface.
func (v *allSourceTreeNamespacesSourceNamespaceNamesSourceName) GetCommit() *string { return v.Commit }

func CertifyBadArtifact(
	ctx context.Context,
	client graphql.Client,
	artifact ArtifactInputSpec,
	certifyBad CertifyBadInputSpec,
) (*CertifyBadArtifactResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyBadArtifact",
		Query: `
mutation CertifyBadArtifact ($artifact: ArtifactInputSpec!, $certifyBad: CertifyBadInputSpec!) {
	ingestArtifact(artifact: $artifact) {
		... allArtifactTree
	}
	ingestCertifyBad(subject: {artifact:$artifact}, certifyBad: $certifyBad) {
		... allCertifyBad
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
fragment allCertifyBad on CertifyBad {
	justification
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
		... on Artifact {
			... allArtifactTree
		}
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
`,
		Variables: &__CertifyBadArtifactInput{
			Artifact:   artifact,
			CertifyBad: certifyBad,
		},
	}
	var err error

	var data CertifyBadArtifactResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func CertifyBadPkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	pkgMatchType *MatchFlags,
	certifyBad CertifyBadInputSpec,
) (*CertifyBadPkgResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyBadPkg",
		Query: `
mutation CertifyBadPkg ($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags, $certifyBad: CertifyBadInputSpec!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestCertifyBad(subject: {package:$pkg}, pkgMatchType: $pkgMatchType, certifyBad: $certifyBad) {
		... allCertifyBad
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allCertifyBad on CertifyBad {
	justification
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
		... on Artifact {
			... allArtifactTree
		}
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
`,
		Variables: &__CertifyBadPkgInput{
			Pkg:          pkg,
			PkgMatchType: pkgMatchType,
			CertifyBad:   certifyBad,
		},
	}
	var err error

	var data CertifyBadPkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func CertifyBadSrc(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	certifyBad CertifyBadInputSpec,
) (*CertifyBadSrcResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyBadSrc",
		Query: `
mutation CertifyBadSrc ($source: SourceInputSpec!, $certifyBad: CertifyBadInputSpec!) {
	ingestSource(source: $source) {
		... allSourceTree
	}
	ingestCertifyBad(subject: {source:$source}, certifyBad: $certifyBad) {
		... allCertifyBad
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allCertifyBad on CertifyBad {
	justification
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
		... on Artifact {
			... allArtifactTree
		}
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
`,
		Variables: &__CertifyBadSrcInput{
			Source:     source,
			CertifyBad: certifyBad,
		},
	}
	var err error

	var data CertifyBadSrcResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func CertifyCVE(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	cve CVEInputSpec,
	certifyVuln VulnerabilityMetaDataInput,
) (*CertifyCVEResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyCVE",
		Query: `
mutation CertifyCVE ($pkg: PkgInputSpec!, $cve: CVEInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestCVE(cve: $cve) {
		... allCveTree
	}
	ingestVulnerability(pkg: $pkg, vulnerability: {cve:$cve}, certifyVuln: $certifyVuln) {
		... allCertifyVuln
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allCveTree on CVE {
	year
	cveId {
		id
	}
}
fragment allCertifyVuln on CertifyVuln {
	package {
		type
		namespaces {
			namespace
			names {
				name
				versions {
					version
					qualifiers {
						key
						value
					}
					subpath
				}
			}
		}
	}
	vulnerability {
		__typename
		... on CVE {
			year
			cveId {
				id
			}
		}
		... on OSV {
			osvId {
				id
			}
		}
		... on GHSA {
			ghsaId {
				id
			}
		}
	}
	metadata {
		dbUri
		dbVersion
		scannerUri
		scannerVersion
		timeScanned
		origin
		collector
	}
}
`,
		Variables: &__CertifyCVEInput{
			Pkg:         pkg,
			Cve:         cve,
			CertifyVuln: certifyVuln,
		},
	}
	var err error

	var data CertifyCVEResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func CertifyGHSA(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	ghsa GHSAInputSpec,
	certifyVuln VulnerabilityMetaDataInput,
) (*CertifyGHSAResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyGHSA",
		Query: `
mutation CertifyGHSA ($pkg: PkgInputSpec!, $ghsa: GHSAInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestGHSA(ghsa: $ghsa) {
		... allGHSATree
	}
	ingestVulnerability(pkg: $pkg, vulnerability: {ghsa:$ghsa}, certifyVuln: $certifyVuln) {
		... allCertifyVuln
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allGHSATree on GHSA {
	ghsaId {
		id
	}
}
fragment allCertifyVuln on CertifyVuln {
	package {
		type
		namespaces {
			namespace
			names {
				name
				versions {
					version
					qualifiers {
						key
						value
					}
					subpath
				}
			}
		}
	}
	vulnerability {
		__typename
		... on CVE {
			year
			cveId {
				id
			}
		}
		... on OSV {
			osvId {
				id
			}
		}
		... on GHSA {
			ghsaId {
				id
			}
		}
	}
	metadata {
		dbUri
		dbVersion
		scannerUri
		scannerVersion
		timeScanned
		origin
		collector
	}
}
`,
		Variables: &__CertifyGHSAInput{
			Pkg:         pkg,
			Ghsa:        ghsa,
			CertifyVuln: certifyVuln,
		},
	}
	var err error

	var data CertifyGHSAResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func CertifyOSV(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	osv OSVInputSpec,
	certifyVuln VulnerabilityMetaDataInput,
) (*CertifyOSVResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyOSV",
		Query: `
mutation CertifyOSV ($pkg: PkgInputSpec!, $osv: OSVInputSpec!, $certifyVuln: VulnerabilityMetaDataInput!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestOSV(osv: $osv) {
		... allOSVTree
	}
	ingestVulnerability(pkg: $pkg, vulnerability: {osv:$osv}, certifyVuln: $certifyVuln) {
		... allCertifyVuln
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allOSVTree on OSV {
	osvId {
		id
	}
}
fragment allCertifyVuln on CertifyVuln {
	package {
		type
		namespaces {
			namespace
			names {
				name
				versions {
					version
					qualifiers {
						key
						value
					}
					subpath
				}
			}
		}
	}
	vulnerability {
		__typename
		... on CVE {
			year
			cveId {
				id
			}
		}
		... on OSV {
			osvId {
				id
			}
		}
		... on GHSA {
			ghsaId {
				id
			}
		}
	}
	metadata {
		dbUri
		dbVersion
		scannerUri
		scannerVersion
		timeScanned
		origin
		collector
	}
}
`,
		Variables: &__CertifyOSVInput{
			Pkg:         pkg,
			Osv:         osv,
			CertifyVuln: certifyVuln,
		},
	}
	var err error

	var data CertifyOSVResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func CertifyPkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	depPkg PkgInputSpec,
	certifyPkg CertifyPkgInputSpec,
) (*CertifyPkgResponse, error) {
	req := &graphql.Request{
		OpName: "CertifyPkg",
		Query: `
mutation CertifyPkg ($pkg: PkgInputSpec!, $depPkg: PkgInputSpec!, $certifyPkg: CertifyPkgInputSpec!) {
	pkg: ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	dependentPkg: ingestPackage(pkg: $depPkg) {
		... allPkgTree
	}
	ingestCertifyPkg(pkg: $pkg, depPkg: $depPkg, certifyPkg: $certifyPkg) {
		... allCertifyPkg
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allCertifyPkg on CertifyPkg {
	justification
	packages {
		... allPkgTree
	}
	origin
	collector
}
`,
		Variables: &__CertifyPkgInput{
			Pkg:        pkg,
			DepPkg:     depPkg,
			CertifyPkg: certifyPkg,
		},
	}
	var err error

	var data CertifyPkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func HasSBOMPkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	hasSBOM HasSBOMInputSpec,
) (*HasSBOMPkgResponse, error) {
	req := &graphql.Request{
		OpName: "HasSBOMPkg",
		Query: `
mutation HasSBOMPkg ($pkg: PkgInputSpec!, $hasSBOM: HasSBOMInputSpec!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestHasSBOM(subject: {package:$pkg}, hasSBOM: $hasSBOM) {
		... allHasSBOMTree
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allHasSBOMTree on HasSBOM {
	uri
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
	}
	origin
	collector
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
`,
		Variables: &__HasSBOMPkgInput{
			Pkg:     pkg,
			HasSBOM: hasSBOM,
		},
	}
	var err error

	var data HasSBOMPkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func HasSBOMSrc(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	hasSBOM HasSBOMInputSpec,
) (*HasSBOMSrcResponse, error) {
	req := &graphql.Request{
		OpName: "HasSBOMSrc",
		Query: `
mutation HasSBOMSrc ($source: SourceInputSpec!, $hasSBOM: HasSBOMInputSpec!) {
	ingestSource(source: $source) {
		... allSourceTree
	}
	ingestHasSBOM(subject: {source:$source}, hasSBOM: $hasSBOM) {
		... allHasSBOMTree
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allHasSBOMTree on HasSBOM {
	uri
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
	}
	origin
	collector
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
`,
		Variables: &__HasSBOMSrcInput{
			Source:  source,
			HasSBOM: hasSBOM,
		},
	}
	var err error

	var data HasSBOMSrcResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func HasSourceAt(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	pkgMatchType MatchFlags,
	source SourceInputSpec,
	hasSourceAt HasSourceAtInputSpec,
) (*HasSourceAtResponse, error) {
	req := &graphql.Request{
		OpName: "HasSourceAt",
		Query: `
mutation HasSourceAt ($pkg: PkgInputSpec!, $pkgMatchType: MatchFlags!, $source: SourceInputSpec!, $hasSourceAt: HasSourceAtInputSpec!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestSource(source: $source) {
		... allSourceTree
	}
	ingestHasSourceAt(pkg: $pkg, pkgMatchType: $pkgMatchType, source: $source, hasSourceAt: $hasSourceAt) {
		... allHasSourceAt
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allHasSourceAt on HasSourceAt {
	justification
	knownSince
	package {
		type
		namespaces {
			namespace
			names {
				name
				versions {
					version
					qualifiers {
						key
						value
					}
					subpath
				}
			}
		}
	}
	source {
		type
		namespaces {
			namespace
			names {
				name
				tag
				commit
			}
		}
	}
	origin
	collector
}
`,
		Variables: &__HasSourceAtInput{
			Pkg:          pkg,
			PkgMatchType: pkgMatchType,
			Source:       source,
			HasSourceAt:  hasSourceAt,
		},
	}
	var err error

	var data HasSourceAtResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func HashEqual(
	ctx context.Context,
	client graphql.Client,
	artifact ArtifactInputSpec,
	equalArtifact ArtifactInputSpec,
	hashEqual HashEqualInputSpec,
) (*HashEqualResponse, error) {
	req := &graphql.Request{
		OpName: "HashEqual",
		Query: `
mutation HashEqual ($artifact: ArtifactInputSpec!, $equalArtifact: ArtifactInputSpec!, $hashEqual: HashEqualInputSpec!) {
	artifact: ingestArtifact(artifact: $artifact) {
		... allArtifactTree
	}
	equalArtifact: ingestArtifact(artifact: $equalArtifact) {
		... allArtifactTree
	}
	ingestHashEqual(artifact: $artifact, equalArtifact: $equalArtifact, hashEqual: $hashEqual) {
		... allHashEqualTree
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
fragment allHashEqualTree on HashEqual {
	justification
	artifacts {
		algorithm
		digest
	}
	origin
	collector
}
`,
		Variables: &__HashEqualInput{
			Artifact:      artifact,
			EqualArtifact: equalArtifact,
			HashEqual:     hashEqual,
		},
	}
	var err error

	var data HashEqualResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func IsDependency(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	depPkg PkgInputSpec,
	dependency IsDependencyInputSpec,
) (*IsDependencyResponse, error) {
	req := &graphql.Request{
		OpName: "IsDependency",
		Query: `
mutation IsDependency ($pkg: PkgInputSpec!, $depPkg: PkgInputSpec!, $dependency: IsDependencyInputSpec!) {
	pkg: ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	dependentPkg: ingestPackage(pkg: $depPkg) {
		... allPkgTree
	}
	ingestDependency(pkg: $pkg, depPkg: $depPkg, dependency: $dependency) {
		... allIsDependencyTree
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allIsDependencyTree on IsDependency {
	justification
	package {
		... allPkgTree
	}
	dependentPackage {
		... allPkgTree
	}
	versionRange
	origin
	collector
}
`,
		Variables: &__IsDependencyInput{
			Pkg:        pkg,
			DepPkg:     depPkg,
			Dependency: dependency,
		},
	}
	var err error

	var data IsDependencyResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func IsOccurrencePkg(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	artifact ArtifactInputSpec,
	occurrence IsOccurrenceInputSpec,
) (*IsOccurrencePkgResponse, error) {
	req := &graphql.Request{
		OpName: "IsOccurrencePkg",
		Query: `
mutation IsOccurrencePkg ($pkg: PkgInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestArtifact(artifact: $artifact) {
		... allArtifactTree
	}
	ingestOccurrence(subject: {package:$pkg}, artifact: $artifact, occurrence: $occurrence) {
		... allIsOccurrencesTree
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
fragment allIsOccurrencesTree on IsOccurrence {
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
	}
	artifact {
		... allArtifactTree
	}
	justification
	origin
	collector
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
`,
		Variables: &__IsOccurrencePkgInput{
			Pkg:        pkg,
			Artifact:   artifact,
			Occurrence: occurrence,
		},
	}
	var err error

	var data IsOccurrencePkgResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func IsOccurrenceSrc(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	artifact ArtifactInputSpec,
	occurrence IsOccurrenceInputSpec,
) (*IsOccurrenceSrcResponse, error) {
	req := &graphql.Request{
		OpName: "IsOccurrenceSrc",
		Query: `
mutation IsOccurrenceSrc ($source: SourceInputSpec!, $artifact: ArtifactInputSpec!, $occurrence: IsOccurrenceInputSpec!) {
	ingestSource(source: $source) {
		... allSourceTree
	}
	ingestArtifact(artifact: $artifact) {
		... allArtifactTree
	}
	ingestOccurrence(subject: {source:$source}, artifact: $artifact, occurrence: $occurrence) {
		... allIsOccurrencesTree
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
fragment allIsOccurrencesTree on IsOccurrence {
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
	}
	artifact {
		... allArtifactTree
	}
	justification
	origin
	collector
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
`,
		Variables: &__IsOccurrenceSrcInput{
			Source:     source,
			Artifact:   artifact,
			Occurrence: occurrence,
		},
	}
	var err error

	var data IsOccurrenceSrcResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func SLSAForArtifact(
	ctx context.Context,
	client graphql.Client,
	artifact ArtifactInputSpec,
	materials []PackageSourceOrArtifactInput,
	builder BuilderInputSpec,
	slsa SLSAInputSpec,
) (*SLSAForArtifactResponse, error) {
	req := &graphql.Request{
		OpName: "SLSAForArtifact",
		Query: `
mutation SLSAForArtifact ($artifact: ArtifactInputSpec!, $materials: [PackageSourceOrArtifactInput!]!, $builder: BuilderInputSpec!, $slsa: SLSAInputSpec!) {
	ingestArtifact(artifact: $artifact) {
		... allArtifactTree
	}
	ingestMaterials(materials: $materials) {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
		... on Artifact {
			... allArtifactTree
		}
	}
	ingestBuilder(builder: $builder) {
		uri
	}
	ingestSLSA(subject: {artifact:$artifact}, builtFrom: $materials, builtBy: $builder, slsa: $slsa) {
		... allSLSATree
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allSLSATree on HasSLSA {
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
		... on Artifact {
			... allArtifactTree
		}
	}
	slsa {
		builtFrom {
			__typename
			... on Package {
				... allPkgTree
			}
			... on Source {
				... allSourceTree
			}
			... on Artifact {
				... allArtifactTree
			}
		}
		builtBy {
			uri
		}
		buildType
		slsaPredicate {
			key
			value
		}
		slsaVersion
		startedOn
		finishedOn
		origin
		collector
	}
}
`,
		Variables: &__SLSAForArtifactInput{
			Artifact:  artifact,
			Materials: materials,
			Builder:   builder,
			Slsa:      slsa,
		},
	}
	var err error

	var data SLSAForArtifactResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func SLSAForPackage(
	ctx context.Context,
	client graphql.Client,
	pkg PkgInputSpec,
	materials []PackageSourceOrArtifactInput,
	builder BuilderInputSpec,
	slsa SLSAInputSpec,
) (*SLSAForPackageResponse, error) {
	req := &graphql.Request{
		OpName: "SLSAForPackage",
		Query: `
mutation SLSAForPackage ($pkg: PkgInputSpec!, $materials: [PackageSourceOrArtifactInput!]!, $builder: BuilderInputSpec!, $slsa: SLSAInputSpec!) {
	ingestPackage(pkg: $pkg) {
		... allPkgTree
	}
	ingestMaterials(materials: $materials) {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
		... on Artifact {
			... allArtifactTree
		}
	}
	ingestBuilder(builder: $builder) {
		uri
	}
	ingestSLSA(subject: {package:$pkg}, builtFrom: $materials, builtBy: $builder, slsa: $slsa) {
		... allSLSATree
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
fragment allSLSATree on HasSLSA {
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
		... on Artifact {
			... allArtifactTree
		}
	}
	slsa {
		builtFrom {
			__typename
			... on Package {
				... allPkgTree
			}
			... on Source {
				... allSourceTree
			}
			... on Artifact {
				... allArtifactTree
			}
		}
		builtBy {
			uri
		}
		buildType
		slsaPredicate {
			key
			value
		}
		slsaVersion
		startedOn
		finishedOn
		origin
		collector
	}
}
`,
		Variables: &__SLSAForPackageInput{
			Pkg:       pkg,
			Materials: materials,
			Builder:   builder,
			Slsa:      slsa,
		},
	}
	var err error

	var data SLSAForPackageResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func SLSAForSource(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	materials []PackageSourceOrArtifactInput,
	builder BuilderInputSpec,
	slsa SLSAInputSpec,
) (*SLSAForSourceResponse, error) {
	req := &graphql.Request{
		OpName: "SLSAForSource",
		Query: `
mutation SLSAForSource ($source: SourceInputSpec!, $materials: [PackageSourceOrArtifactInput!]!, $builder: BuilderInputSpec!, $slsa: SLSAInputSpec!) {
	ingestSource(source: $source) {
		... allSourceTree
	}
	ingestMaterials(materials: $materials) {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
		... on Artifact {
			... allArtifactTree
		}
	}
	ingestBuilder(builder: $builder) {
		uri
	}
	ingestSLSA(subject: {source:$source}, builtFrom: $materials, builtBy: $builder, slsa: $slsa) {
		... allSLSATree
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allPkgTree on Package {
	type
	namespaces {
		namespace
		names {
			name
			versions {
				version
				qualifiers {
					key
					value
				}
				subpath
			}
		}
	}
}
fragment allArtifactTree on Artifact {
	algorithm
	digest
}
fragment allSLSATree on HasSLSA {
	subject {
		__typename
		... on Package {
			... allPkgTree
		}
		... on Source {
			... allSourceTree
		}
		... on Artifact {
			... allArtifactTree
		}
	}
	slsa {
		builtFrom {
			__typename
			... on Package {
				... allPkgTree
			}
			... on Source {
				... allSourceTree
			}
			... on Artifact {
				... allArtifactTree
			}
		}
		builtBy {
			uri
		}
		buildType
		slsaPredicate {
			key
			value
		}
		slsaVersion
		startedOn
		finishedOn
		origin
		collector
	}
}
`,
		Variables: &__SLSAForSourceInput{
			Source:    source,
			Materials: materials,
			Builder:   builder,
			Slsa:      slsa,
		},
	}
	var err error

	var data SLSAForSourceResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}

func Scorecard(
	ctx context.Context,
	client graphql.Client,
	source SourceInputSpec,
	scorecard ScorecardInputSpec,
) (*ScorecardResponse, error) {
	req := &graphql.Request{
		OpName: "Scorecard",
		Query: `
mutation Scorecard ($source: SourceInputSpec!, $scorecard: ScorecardInputSpec!) {
	ingestSource(source: $source) {
		... allSourceTree
	}
	certifyScorecard(source: $source, scorecard: $scorecard) {
		... allCertifyScorecard
	}
}
fragment allSourceTree on Source {
	type
	namespaces {
		namespace
		names {
			name
			tag
			commit
		}
	}
}
fragment allCertifyScorecard on CertifyScorecard {
	source {
		... allSourceTree
	}
	scorecard {
		timeScanned
		aggregateScore
		checks {
			check
			score
		}
		scorecardVersion
		scorecardCommit
		origin
		collector
	}
}
`,
		Variables: &__ScorecardInput{
			Source:    source,
			Scorecard: scorecard,
		},
	}
	var err error

	var data ScorecardResponse
	resp := &graphql.Response{Data: &data}

	err = client.MakeRequest(
		ctx,
		req,
		resp,
	)

	return &data, err
}
