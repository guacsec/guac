//
// Copyright 2023 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package testing

import (
	"context"
	"errors"
	"strconv"

	"github.com/guacsec/guac/pkg/assembler/backends/helper"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Internal data: link between equal vulnerabilities (isVulnerability)
type equalVulnerabilityList []*equalVulnerabilityLink
type equalVulnerabilityLink struct {
	id            uint32
	osvID         uint32
	cveID         uint32
	ghsaID        uint32
	justification string
	origin        string
	collector     string
}

func (n *equalVulnerabilityLink) getID() uint32 { return n.id }

func (n *equalVulnerabilityLink) neighbors() []uint32 {
	out := make([]uint32, 0, 2)
	if n.osvID != 0 {
		out = append(out, n.osvID)
	}
	if n.cveID != 0 {
		out = append(out, n.cveID)
	}
	if n.ghsaID != 0 {
		out = append(out, n.ghsaID)
	}
	return out
}

func (n *equalVulnerabilityLink) buildModelNode(c *demoClient) (model.Node, error) {
	return c.buildIsVulnerability(n, nil, true)
}

// Ingest CertifyPkg
func (c *demoClient) IngestIsVulnerability(ctx context.Context, osv model.OSVInputSpec, vulnerability model.CveOrGhsaInput, isVulnerability model.IsVulnerabilityInputSpec) (*model.IsVulnerability, error) {
	err := helper.ValidateCveOrGhsaIngestionInput(vulnerability, "IngestIsVulnerability")
	if err != nil {
		return nil, err
	}

	osvID, err := getOsvIDFromInput(c, osv)
	if err != nil {
		return nil, err
	}

	osvEqualVulns := []uint32{}
	osvNode, ok := c.index[osvID].(*osvIDNode)
	if ok {
		osvEqualVulns = append(osvEqualVulns, osvNode.equalVulnLinks...)
	}

	var cveID uint32
	var ghsaID uint32
	vulnerabilityLinks := []uint32{}
	if vulnerability.Cve != nil {
		cveID, err = getCveIDFromInput(c, *vulnerability.Cve)
		if err != nil {
			return nil, err
		}
		cveNode, ok := c.index[cveID].(*cveIDNode)
		if ok {
			vulnerabilityLinks = append(vulnerabilityLinks, cveNode.equalVulnLinks...)
		}
	}

	if vulnerability.Ghsa != nil {
		ghsaID, err = getGhsaIDFromInput(c, *vulnerability.Ghsa)
		if err != nil {
			return nil, err
		}
		ghsaNode, ok := c.index[ghsaID].(*ghsaIDNode)
		if ok {
			vulnerabilityLinks = append(vulnerabilityLinks, ghsaNode.equalVulnLinks...)
		}
	}

	searchIDs := []uint32{}
	if len(osvEqualVulns) > len(vulnerabilityLinks) {
		searchIDs = append(searchIDs, vulnerabilityLinks...)
	} else {
		searchIDs = append(searchIDs, osvEqualVulns...)
	}

	// Don't insert duplicates
	duplicate := false
	collectedEqualVulnLink := equalVulnerabilityLink{}
	for _, id := range searchIDs {
		v, _ := c.equalVulnByID(id)
		vulnMatch := false
		if cveID != 0 && cveID == v.cveID {
			vulnMatch = true
		}
		if ghsaID != 0 && ghsaID == v.ghsaID {
			vulnMatch = true
		}
		if vulnMatch && osvID == v.osvID && isVulnerability.Justification == v.justification &&
			isVulnerability.Origin == v.origin && isVulnerability.Collector == v.collector {

			collectedEqualVulnLink = *v
			duplicate = true
			break
		}
	}
	if !duplicate {
		// store the link
		collectedEqualVulnLink = equalVulnerabilityLink{
			id:            c.getNextID(),
			osvID:         osvID,
			cveID:         cveID,
			ghsaID:        ghsaID,
			justification: isVulnerability.Justification,
			origin:        isVulnerability.Origin,
			collector:     isVulnerability.Collector,
		}
		c.index[collectedEqualVulnLink.id] = &collectedEqualVulnLink
		c.equalVulnerabilities = append(c.equalVulnerabilities, &collectedEqualVulnLink)
		// set the backlinks
		c.index[osvID].(*osvIDNode).setEqualVulnLinks(collectedEqualVulnLink.id)
		if cveID != 0 {
			c.index[cveID].(*cveIDNode).setEqualVulnLinks(collectedEqualVulnLink.id)
		}
		if ghsaID != 0 {
			c.index[ghsaID].(*ghsaIDNode).setEqualVulnLinks(collectedEqualVulnLink.id)
		}
	}

	// build return GraphQL type
	builtIsVuln, err := c.buildIsVulnerability(&collectedEqualVulnLink, nil, true)
	if err != nil {
		return nil, err
	}
	return builtIsVuln, nil
}

// Query CertifyPkg
func (c *demoClient) IsVulnerability(ctx context.Context, filter *model.IsVulnerabilitySpec) ([]*model.IsVulnerability, error) {
	err := helper.ValidateCveOrGhsaQueryFilter(filter.Vulnerability)
	if err != nil {
		return nil, err
	}

	out := []*model.IsVulnerability{}

	if filter != nil && filter.ID != nil {
		id, err := strconv.Atoi(*filter.ID)
		if err != nil {
			return nil, err
		}
		node, ok := c.index[uint32(id)]
		if !ok {
			return nil, gqlerror.Errorf("ID does not match existing node")
		}
		if link, ok := node.(*equalVulnerabilityLink); ok {
			foundIsVuln, err := c.buildIsVulnerability(link, filter, true)
			if err != nil {
				return nil, err
			}
			return []*model.IsVulnerability{foundIsVuln}, nil
		} else {
			return nil, gqlerror.Errorf("ID does not match expected node type for equalVulnerabilityLink")
		}
	}

	// TODO if any of the osv/vulnerabilities are specified, ony search those backedges
	for _, link := range c.equalVulnerabilities {
		if filter != nil && noMatch(filter.Justification, link.justification) {
			continue
		}
		if filter != nil && noMatch(filter.Collector, link.collector) {
			continue
		}
		if filter != nil && noMatch(filter.Origin, link.origin) {
			continue
		}

		foundIsVuln, err := c.buildIsVulnerability(link, filter, false)
		if err != nil {
			return nil, err
		}
		if foundIsVuln == nil {
			continue
		}
		out = append(out, foundIsVuln)
	}

	return out, nil
}

func (c *demoClient) buildIsVulnerability(link *equalVulnerabilityLink, filter *model.IsVulnerabilitySpec, ingestOrIDProvided bool) (*model.IsVulnerability, error) {
	var osv *model.Osv
	var cve *model.Cve
	var ghsa *model.Ghsa
	var err error
	if filter != nil {
		osv, err = c.buildOsvResponse(link.osvID, filter.Osv)
		if err != nil {
			return nil, err
		}

	} else {
		osv, err = c.buildOsvResponse(link.osvID, nil)
		if err != nil {
			return nil, err
		}
	}

	if filter != nil && filter.Vulnerability != nil {
		if filter.Vulnerability.Cve != nil && link.cveID != 0 {
			cve, err = c.buildCveResponse(link.cveID, filter.Vulnerability.Cve)
			if err != nil {
				return nil, err
			}
		}
		if filter.Vulnerability.Ghsa != nil && link.ghsaID != 0 {
			ghsa, err = c.buildGhsaResponse(link.ghsaID, filter.Vulnerability.Ghsa)
			if err != nil {
				return nil, err
			}
		}
	} else {
		if link.cveID != 0 {
			cve, err = c.buildCveResponse(link.cveID, nil)
			if err != nil {
				return nil, err
			}
		}
		if link.ghsaID != 0 {
			ghsa, err = c.buildGhsaResponse(link.ghsaID, nil)
			if err != nil {
				return nil, err
			}
		}
	}
	// if osv not found during ingestion or if ID is provided in filter, send error. On query do not send error to continue search
	if osv == nil && ingestOrIDProvided {
		return nil, gqlerror.Errorf("failed to retrieve osv via osvID")
	} else if osv == nil && !ingestOrIDProvided {
		return nil, nil
	}

	var vuln model.CveOrGhsa
	if link.cveID != 0 {
		if cve == nil && ingestOrIDProvided {
			return nil, gqlerror.Errorf("failed to retrieve cve via cveID")
		} else if cve == nil && !ingestOrIDProvided {
			return nil, nil
		}
		vuln = cve
	}
	if link.ghsaID != 0 {
		if ghsa == nil && ingestOrIDProvided {
			return nil, gqlerror.Errorf("failed to retrieve ghsa via ghsaID")
		} else if ghsa == nil && !ingestOrIDProvided {
			return nil, nil
		}
		vuln = ghsa
	}

	isVuln := model.IsVulnerability{
		ID:            nodeID(link.id),
		Osv:           osv,
		Vulnerability: vuln,
		Justification: link.justification,
		Origin:        link.origin,
		Collector:     link.collector,
	}
	return &isVuln, nil
}

func (c *demoClient) equalVulnByID(id uint32) (*equalVulnerabilityLink, error) {
	node, ok := c.index[id]
	if !ok {
		return nil, errors.New("could not find equalVulnerabilityLink")
	}
	link, ok := node.(*equalVulnerabilityLink)
	if !ok {
		return nil, errors.New("not an equalVulnerabilityLink")
	}
	return link, nil
}
