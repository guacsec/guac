//
// Copyright 2023 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package inmem

import (
	"context"
	"strconv"

	"github.com/vektah/gqlparser/v2/gqlerror"

	"github.com/guacsec/guac/pkg/assembler/backends/helper"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

// Internal data: link between equal vulnerabilities (isVulnerability)
type equalVulnerabilityList []*equalVulnerabilityLink
type equalVulnerabilityLink struct {
	id            uint32
	osvID         uint32
	cveID         uint32
	ghsaID        uint32
	justification string
	origin        string
	collector     string
}

func (n *equalVulnerabilityLink) ID() uint32 { return n.id }

func (n *equalVulnerabilityLink) Neighbors(allowedEdges edgeMap) []uint32 {
	out := make([]uint32, 0, 2)
	if n.osvID != 0 && allowedEdges[model.EdgeIsVulnerabilityOsv] {
		out = append(out, n.osvID)
	}
	if n.cveID != 0 && allowedEdges[model.EdgeIsVulnerabilityCve] {
		out = append(out, n.cveID)
	}
	if n.ghsaID != 0 && allowedEdges[model.EdgeIsVulnerabilityGhsa] {
		out = append(out, n.ghsaID)
	}
	return out
}

func (n *equalVulnerabilityLink) BuildModelNode(c *demoClient) (model.Node, error) {
	return c.buildIsVulnerability(n, nil, true)
}

// Ingest IsVulnerability
func (c *demoClient) IngestIsVulnerability(ctx context.Context, osv model.OSVInputSpec, vulnerability model.CveOrGhsaInput, isVulnerability model.IsVulnerabilityInputSpec) (*model.IsVulnerability, error) {
	return c.ingestIsVulnerability(ctx, osv, vulnerability, isVulnerability, true)
}

func (c *demoClient) ingestIsVulnerability(ctx context.Context, osv model.OSVInputSpec, vulnerability model.CveOrGhsaInput, isVulnerability model.IsVulnerabilityInputSpec, readOnly bool) (*model.IsVulnerability, error) {
	funcName := "IngestIsVulnerability"
	if err := helper.ValidateCveOrGhsaIngestionInput(vulnerability, "IngestIsVulnerability"); err != nil {
		return nil, gqlerror.Errorf("%v ::  %s", funcName, err)
	}

	lock(&c.m, readOnly)
	defer unlock(&c.m, readOnly)

	osvID, err := getOsvIDFromInput(c, osv)
	if err != nil {
		return nil, gqlerror.Errorf("%v ::  %s", funcName, err)
	}
	osvN, err := byID[*osvNode](osvID, c)
	if err != nil {
		return nil, gqlerror.Errorf("%v ::  %s", funcName, err)
	}
	osvEqualVulns := osvN.equalVulnLinks

	var cveID uint32
	var foundCveNode *cveNode
	var ghsaID uint32
	var foundGhsaNode *ghsaNode
	var vulnerabilityLinks []uint32
	if vulnerability.Cve != nil {
		cveID, err = getCveIDFromInput(c, *vulnerability.Cve)
		if err != nil {
			return nil, gqlerror.Errorf("%v ::  %s", funcName, err)
		}
		foundCveNode, err = byID[*cveNode](cveID, c)
		if err != nil {
			return nil, gqlerror.Errorf("%v ::  %s", funcName, err)
		}
		vulnerabilityLinks = foundCveNode.equalVulnLinks
	} else {
		ghsaID, err = getGhsaIDFromInput(c, *vulnerability.Ghsa)
		if err != nil {
			return nil, gqlerror.Errorf("%v ::  %s", funcName, err)
		}
		foundGhsaNode, err = byID[*ghsaNode](ghsaID, c)
		if err != nil {
			return nil, gqlerror.Errorf("%v ::  %s", funcName, err)
		}
		vulnerabilityLinks = foundGhsaNode.equalVulnLinks
	}

	var searchIDs []uint32
	if len(osvEqualVulns) < len(vulnerabilityLinks) {
		searchIDs = osvEqualVulns
	} else {
		searchIDs = vulnerabilityLinks
	}

	// Don't insert duplicates
	duplicate := false
	collectedEqualVulnLink := equalVulnerabilityLink{}
	for _, id := range searchIDs {
		v, err := byID[*equalVulnerabilityLink](id, c)
		if err != nil {
			return nil, gqlerror.Errorf("%v ::  %s", funcName, err)
		}
		vulnMatch := false
		if cveID != 0 && cveID == v.cveID {
			vulnMatch = true
		}
		if ghsaID != 0 && ghsaID == v.ghsaID {
			vulnMatch = true
		}
		if vulnMatch && osvID == v.osvID && isVulnerability.Justification == v.justification &&
			isVulnerability.Origin == v.origin && isVulnerability.Collector == v.collector {

			collectedEqualVulnLink = *v
			duplicate = true
			break
		}
	}
	if !duplicate {
		if readOnly {
			c.m.RUnlock()
			iv, err := c.ingestIsVulnerability(ctx, osv, vulnerability, isVulnerability, false)
			c.m.RLock() // relock so that defer unlock does not panic
			return iv, err
		}
		// store the link
		collectedEqualVulnLink = equalVulnerabilityLink{
			id:            c.getNextID(),
			osvID:         osvID,
			cveID:         cveID,
			ghsaID:        ghsaID,
			justification: isVulnerability.Justification,
			origin:        isVulnerability.Origin,
			collector:     isVulnerability.Collector,
		}
		c.index[collectedEqualVulnLink.id] = &collectedEqualVulnLink
		c.equalVulnerabilities = append(c.equalVulnerabilities, &collectedEqualVulnLink)
		// set the backlinks
		osvN.setEqualVulnLinks(collectedEqualVulnLink.id)
		if cveID != 0 {
			foundCveNode.setEqualVulnLinks(collectedEqualVulnLink.id)
		}
		if ghsaID != 0 {
			foundGhsaNode.setEqualVulnLinks(collectedEqualVulnLink.id)
		}
	}

	// build return GraphQL type
	builtIsVuln, err := c.buildIsVulnerability(&collectedEqualVulnLink, nil, true)
	if err != nil {
		return nil, err
	}
	return builtIsVuln, nil
}

// Query IsVulnerability
func (c *demoClient) IsVulnerability(ctx context.Context, filter *model.IsVulnerabilitySpec) ([]*model.IsVulnerability, error) {
	funcName := "IsVulnerability"
	if filter != nil {
		if err := helper.ValidateCveOrGhsaQueryFilter(filter.Vulnerability); err != nil {
			return nil, err
		}
	}

	c.m.RLock()
	defer c.m.RUnlock()
	if filter != nil && filter.ID != nil {
		id64, err := strconv.ParseUint(*filter.ID, 10, 32)
		if err != nil {
			return nil, gqlerror.Errorf("%v :: invalid ID %s", funcName, err)
		}
		id := uint32(id64)
		link, err := byID[*equalVulnerabilityLink](id, c)
		if err != nil {
			return nil, nil
		}
		foundIsVuln, err := c.buildIsVulnerability(link, filter, true)
		if err != nil {
			return nil, gqlerror.Errorf("%v :: %v", funcName, err)
		}
		return []*model.IsVulnerability{foundIsVuln}, nil
	}

	var search []uint32
	foundOne := false
	if filter != nil && filter.Osv != nil {
		exactOSV, err := c.exactOSV(filter.Osv)
		if err != nil {
			return nil, gqlerror.Errorf("%v :: %v", funcName, err)
		}
		if exactOSV != nil {
			search = append(search, exactOSV.equalVulnLinks...)
			foundOne = true
		}
	}
	if !foundOne && filter != nil && filter.Vulnerability != nil && filter.Vulnerability.Cve != nil {
		exactCVE, err := c.exactCVE(filter.Vulnerability.Cve)
		if err != nil {
			return nil, gqlerror.Errorf("%v :: %v", funcName, err)
		}
		if exactCVE != nil {
			search = append(search, exactCVE.equalVulnLinks...)
			foundOne = true
		}
	}
	if !foundOne && filter != nil && filter.Vulnerability != nil && filter.Vulnerability.Ghsa != nil {
		exactGHSA, err := c.exactGHSA(filter.Vulnerability.Ghsa)
		if err != nil {
			return nil, gqlerror.Errorf("%v :: %v", funcName, err)
		}
		if exactGHSA != nil {
			search = append(search, exactGHSA.equalVulnLinks...)
			foundOne = true
		}
	}
	var out []*model.IsVulnerability
	if foundOne {
		for _, id := range search {
			link, err := byID[*equalVulnerabilityLink](id, c)
			if err != nil {
				return nil, gqlerror.Errorf("%v :: %v", funcName, err)
			}
			out, err = c.addVulnIfMatch(out, filter, link)
			if err != nil {
				return nil, gqlerror.Errorf("%v :: %v", funcName, err)
			}
		}
	} else {
		for _, link := range c.equalVulnerabilities {
			var err error
			out, err = c.addVulnIfMatch(out, filter, link)
			if err != nil {
				return nil, gqlerror.Errorf("%v :: %v", funcName, err)
			}
		}
	}

	return out, nil
}

func (c *demoClient) addVulnIfMatch(out []*model.IsVulnerability,
	filter *model.IsVulnerabilitySpec, link *equalVulnerabilityLink) (
	[]*model.IsVulnerability, error) {

	if filter != nil && noMatch(filter.Justification, link.justification) {
		return out, nil
	}
	if filter != nil && noMatch(filter.Collector, link.collector) {
		return out, nil
	}
	if filter != nil && noMatch(filter.Origin, link.origin) {
		return out, nil
	}

	foundIsVuln, err := c.buildIsVulnerability(link, filter, false)
	if err != nil {
		return nil, err
	}
	if foundIsVuln == nil {
		return out, nil
	}
	return append(out, foundIsVuln), nil
}

func (c *demoClient) buildIsVulnerability(link *equalVulnerabilityLink, filter *model.IsVulnerabilitySpec, ingestOrIDProvided bool) (*model.IsVulnerability, error) {
	var osv *model.Osv
	var cve *model.Cve
	var ghsa *model.Ghsa
	var err error
	if filter != nil {
		osv, err = c.buildOsvResponse(link.osvID, filter.Osv)
		if err != nil {
			return nil, err
		}

	} else {
		osv, err = c.buildOsvResponse(link.osvID, nil)
		if err != nil {
			return nil, err
		}
	}

	if filter != nil && filter.Vulnerability != nil {
		if filter.Vulnerability.Cve != nil && link.cveID != 0 {
			cve, err = c.buildCveResponse(link.cveID, filter.Vulnerability.Cve)
			if err != nil {
				return nil, err
			}
		}
		if filter.Vulnerability.Ghsa != nil && link.ghsaID != 0 {
			ghsa, err = c.buildGhsaResponse(link.ghsaID, filter.Vulnerability.Ghsa)
			if err != nil {
				return nil, err
			}
		}
	} else {
		if link.cveID != 0 {
			cve, err = c.buildCveResponse(link.cveID, nil)
			if err != nil {
				return nil, err
			}
		}
		if link.ghsaID != 0 {
			ghsa, err = c.buildGhsaResponse(link.ghsaID, nil)
			if err != nil {
				return nil, err
			}
		}
	}
	// if osv not found during ingestion or if ID is provided in filter, send error. On query do not send error to continue search
	if osv == nil && ingestOrIDProvided {
		return nil, gqlerror.Errorf("failed to retrieve osv via osvID")
	} else if osv == nil && !ingestOrIDProvided {
		return nil, nil
	}

	var vuln model.CveOrGhsa
	if link.cveID != 0 {
		if cve == nil && ingestOrIDProvided {
			return nil, gqlerror.Errorf("failed to retrieve cve via cveID")
		} else if cve == nil && !ingestOrIDProvided {
			return nil, nil
		}
		vuln = cve
	}
	if link.ghsaID != 0 {
		if ghsa == nil && ingestOrIDProvided {
			return nil, gqlerror.Errorf("failed to retrieve ghsa via ghsaID")
		} else if ghsa == nil && !ingestOrIDProvided {
			return nil, nil
		}
		vuln = ghsa
	}

	isVuln := model.IsVulnerability{
		ID:            nodeID(link.id),
		Osv:           osv,
		Vulnerability: vuln,
		Justification: link.justification,
		Origin:        link.origin,
		Collector:     link.collector,
	}
	return &isVuln, nil
}
