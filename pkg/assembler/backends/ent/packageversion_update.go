// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/dialect/sql/sqljson"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/billofmaterials"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certification"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifylegal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvex"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvuln"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/dependency"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hasmetadata"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hassourceat"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/occurrence"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pkgequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pointofcontact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/predicate"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

// PackageVersionUpdate is the builder for updating PackageVersion entities.
type PackageVersionUpdate struct {
	config
	hooks    []Hook
	mutation *PackageVersionMutation
}

// Where appends a list predicates to the PackageVersionUpdate builder.
func (_u *PackageVersionUpdate) Where(ps ...predicate.PackageVersion) *PackageVersionUpdate {
	_u.mutation.Where(ps...)
	return _u
}

// SetNameID sets the "name_id" field.
func (_u *PackageVersionUpdate) SetNameID(v uuid.UUID) *PackageVersionUpdate {
	_u.mutation.SetNameID(v)
	return _u
}

// SetNillableNameID sets the "name_id" field if the given value is not nil.
func (_u *PackageVersionUpdate) SetNillableNameID(v *uuid.UUID) *PackageVersionUpdate {
	if v != nil {
		_u.SetNameID(*v)
	}
	return _u
}

// SetVersion sets the "version" field.
func (_u *PackageVersionUpdate) SetVersion(v string) *PackageVersionUpdate {
	_u.mutation.SetVersion(v)
	return _u
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (_u *PackageVersionUpdate) SetNillableVersion(v *string) *PackageVersionUpdate {
	if v != nil {
		_u.SetVersion(*v)
	}
	return _u
}

// SetSubpath sets the "subpath" field.
func (_u *PackageVersionUpdate) SetSubpath(v string) *PackageVersionUpdate {
	_u.mutation.SetSubpath(v)
	return _u
}

// SetNillableSubpath sets the "subpath" field if the given value is not nil.
func (_u *PackageVersionUpdate) SetNillableSubpath(v *string) *PackageVersionUpdate {
	if v != nil {
		_u.SetSubpath(*v)
	}
	return _u
}

// SetQualifiers sets the "qualifiers" field.
func (_u *PackageVersionUpdate) SetQualifiers(v []model.PackageQualifier) *PackageVersionUpdate {
	_u.mutation.SetQualifiers(v)
	return _u
}

// AppendQualifiers appends value to the "qualifiers" field.
func (_u *PackageVersionUpdate) AppendQualifiers(v []model.PackageQualifier) *PackageVersionUpdate {
	_u.mutation.AppendQualifiers(v)
	return _u
}

// ClearQualifiers clears the value of the "qualifiers" field.
func (_u *PackageVersionUpdate) ClearQualifiers() *PackageVersionUpdate {
	_u.mutation.ClearQualifiers()
	return _u
}

// SetHash sets the "hash" field.
func (_u *PackageVersionUpdate) SetHash(v string) *PackageVersionUpdate {
	_u.mutation.SetHash(v)
	return _u
}

// SetNillableHash sets the "hash" field if the given value is not nil.
func (_u *PackageVersionUpdate) SetNillableHash(v *string) *PackageVersionUpdate {
	if v != nil {
		_u.SetHash(*v)
	}
	return _u
}

// SetName sets the "name" edge to the PackageName entity.
func (_u *PackageVersionUpdate) SetName(v *PackageName) *PackageVersionUpdate {
	return _u.SetNameID(v.ID)
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by IDs.
func (_u *PackageVersionUpdate) AddOccurrenceIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddOccurrenceIDs(ids...)
	return _u
}

// AddOccurrences adds the "occurrences" edges to the Occurrence entity.
func (_u *PackageVersionUpdate) AddOccurrences(v ...*Occurrence) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddOccurrenceIDs(ids...)
}

// AddSbomIDs adds the "sbom" edge to the BillOfMaterials entity by IDs.
func (_u *PackageVersionUpdate) AddSbomIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddSbomIDs(ids...)
	return _u
}

// AddSbom adds the "sbom" edges to the BillOfMaterials entity.
func (_u *PackageVersionUpdate) AddSbom(v ...*BillOfMaterials) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSbomIDs(ids...)
}

// AddVulnIDs adds the "vuln" edge to the CertifyVuln entity by IDs.
func (_u *PackageVersionUpdate) AddVulnIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddVulnIDs(ids...)
	return _u
}

// AddVuln adds the "vuln" edges to the CertifyVuln entity.
func (_u *PackageVersionUpdate) AddVuln(v ...*CertifyVuln) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddVulnIDs(ids...)
}

// AddVexIDs adds the "vex" edge to the CertifyVex entity by IDs.
func (_u *PackageVersionUpdate) AddVexIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddVexIDs(ids...)
	return _u
}

// AddVex adds the "vex" edges to the CertifyVex entity.
func (_u *PackageVersionUpdate) AddVex(v ...*CertifyVex) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddVexIDs(ids...)
}

// AddHasSourceAtIDs adds the "has_source_at" edge to the HasSourceAt entity by IDs.
func (_u *PackageVersionUpdate) AddHasSourceAtIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddHasSourceAtIDs(ids...)
	return _u
}

// AddHasSourceAt adds the "has_source_at" edges to the HasSourceAt entity.
func (_u *PackageVersionUpdate) AddHasSourceAt(v ...*HasSourceAt) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddHasSourceAtIDs(ids...)
}

// AddCertificationIDs adds the "certification" edge to the Certification entity by IDs.
func (_u *PackageVersionUpdate) AddCertificationIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddCertificationIDs(ids...)
	return _u
}

// AddCertification adds the "certification" edges to the Certification entity.
func (_u *PackageVersionUpdate) AddCertification(v ...*Certification) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddCertificationIDs(ids...)
}

// AddMetadatumIDs adds the "metadata" edge to the HasMetadata entity by IDs.
func (_u *PackageVersionUpdate) AddMetadatumIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddMetadatumIDs(ids...)
	return _u
}

// AddMetadata adds the "metadata" edges to the HasMetadata entity.
func (_u *PackageVersionUpdate) AddMetadata(v ...*HasMetadata) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddMetadatumIDs(ids...)
}

// AddDependencyIDs adds the "dependency" edge to the Dependency entity by IDs.
func (_u *PackageVersionUpdate) AddDependencyIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddDependencyIDs(ids...)
	return _u
}

// AddDependency adds the "dependency" edges to the Dependency entity.
func (_u *PackageVersionUpdate) AddDependency(v ...*Dependency) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddDependencyIDs(ids...)
}

// AddDependencySubjectIDs adds the "dependency_subject" edge to the Dependency entity by IDs.
func (_u *PackageVersionUpdate) AddDependencySubjectIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddDependencySubjectIDs(ids...)
	return _u
}

// AddDependencySubject adds the "dependency_subject" edges to the Dependency entity.
func (_u *PackageVersionUpdate) AddDependencySubject(v ...*Dependency) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddDependencySubjectIDs(ids...)
}

// AddIncludedInSbomIDs adds the "included_in_sboms" edge to the BillOfMaterials entity by IDs.
func (_u *PackageVersionUpdate) AddIncludedInSbomIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddIncludedInSbomIDs(ids...)
	return _u
}

// AddIncludedInSboms adds the "included_in_sboms" edges to the BillOfMaterials entity.
func (_u *PackageVersionUpdate) AddIncludedInSboms(v ...*BillOfMaterials) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddIncludedInSbomIDs(ids...)
}

// AddPkgEqualPkgAIDs adds the "pkg_equal_pkg_a" edge to the PkgEqual entity by IDs.
func (_u *PackageVersionUpdate) AddPkgEqualPkgAIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddPkgEqualPkgAIDs(ids...)
	return _u
}

// AddPkgEqualPkgA adds the "pkg_equal_pkg_a" edges to the PkgEqual entity.
func (_u *PackageVersionUpdate) AddPkgEqualPkgA(v ...*PkgEqual) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddPkgEqualPkgAIDs(ids...)
}

// AddPkgEqualPkgBIDs adds the "pkg_equal_pkg_b" edge to the PkgEqual entity by IDs.
func (_u *PackageVersionUpdate) AddPkgEqualPkgBIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddPkgEqualPkgBIDs(ids...)
	return _u
}

// AddPkgEqualPkgB adds the "pkg_equal_pkg_b" edges to the PkgEqual entity.
func (_u *PackageVersionUpdate) AddPkgEqualPkgB(v ...*PkgEqual) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddPkgEqualPkgBIDs(ids...)
}

// AddPocIDs adds the "poc" edge to the PointOfContact entity by IDs.
func (_u *PackageVersionUpdate) AddPocIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddPocIDs(ids...)
	return _u
}

// AddPoc adds the "poc" edges to the PointOfContact entity.
func (_u *PackageVersionUpdate) AddPoc(v ...*PointOfContact) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddPocIDs(ids...)
}

// AddCertifyLegalIDs adds the "certify_legal" edge to the CertifyLegal entity by IDs.
func (_u *PackageVersionUpdate) AddCertifyLegalIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.AddCertifyLegalIDs(ids...)
	return _u
}

// AddCertifyLegal adds the "certify_legal" edges to the CertifyLegal entity.
func (_u *PackageVersionUpdate) AddCertifyLegal(v ...*CertifyLegal) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddCertifyLegalIDs(ids...)
}

// Mutation returns the PackageVersionMutation object of the builder.
func (_u *PackageVersionUpdate) Mutation() *PackageVersionMutation {
	return _u.mutation
}

// ClearName clears the "name" edge to the PackageName entity.
func (_u *PackageVersionUpdate) ClearName() *PackageVersionUpdate {
	_u.mutation.ClearName()
	return _u
}

// ClearOccurrences clears all "occurrences" edges to the Occurrence entity.
func (_u *PackageVersionUpdate) ClearOccurrences() *PackageVersionUpdate {
	_u.mutation.ClearOccurrences()
	return _u
}

// RemoveOccurrenceIDs removes the "occurrences" edge to Occurrence entities by IDs.
func (_u *PackageVersionUpdate) RemoveOccurrenceIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemoveOccurrenceIDs(ids...)
	return _u
}

// RemoveOccurrences removes "occurrences" edges to Occurrence entities.
func (_u *PackageVersionUpdate) RemoveOccurrences(v ...*Occurrence) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveOccurrenceIDs(ids...)
}

// ClearSbom clears all "sbom" edges to the BillOfMaterials entity.
func (_u *PackageVersionUpdate) ClearSbom() *PackageVersionUpdate {
	_u.mutation.ClearSbom()
	return _u
}

// RemoveSbomIDs removes the "sbom" edge to BillOfMaterials entities by IDs.
func (_u *PackageVersionUpdate) RemoveSbomIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemoveSbomIDs(ids...)
	return _u
}

// RemoveSbom removes "sbom" edges to BillOfMaterials entities.
func (_u *PackageVersionUpdate) RemoveSbom(v ...*BillOfMaterials) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSbomIDs(ids...)
}

// ClearVuln clears all "vuln" edges to the CertifyVuln entity.
func (_u *PackageVersionUpdate) ClearVuln() *PackageVersionUpdate {
	_u.mutation.ClearVuln()
	return _u
}

// RemoveVulnIDs removes the "vuln" edge to CertifyVuln entities by IDs.
func (_u *PackageVersionUpdate) RemoveVulnIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemoveVulnIDs(ids...)
	return _u
}

// RemoveVuln removes "vuln" edges to CertifyVuln entities.
func (_u *PackageVersionUpdate) RemoveVuln(v ...*CertifyVuln) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveVulnIDs(ids...)
}

// ClearVex clears all "vex" edges to the CertifyVex entity.
func (_u *PackageVersionUpdate) ClearVex() *PackageVersionUpdate {
	_u.mutation.ClearVex()
	return _u
}

// RemoveVexIDs removes the "vex" edge to CertifyVex entities by IDs.
func (_u *PackageVersionUpdate) RemoveVexIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemoveVexIDs(ids...)
	return _u
}

// RemoveVex removes "vex" edges to CertifyVex entities.
func (_u *PackageVersionUpdate) RemoveVex(v ...*CertifyVex) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveVexIDs(ids...)
}

// ClearHasSourceAt clears all "has_source_at" edges to the HasSourceAt entity.
func (_u *PackageVersionUpdate) ClearHasSourceAt() *PackageVersionUpdate {
	_u.mutation.ClearHasSourceAt()
	return _u
}

// RemoveHasSourceAtIDs removes the "has_source_at" edge to HasSourceAt entities by IDs.
func (_u *PackageVersionUpdate) RemoveHasSourceAtIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemoveHasSourceAtIDs(ids...)
	return _u
}

// RemoveHasSourceAt removes "has_source_at" edges to HasSourceAt entities.
func (_u *PackageVersionUpdate) RemoveHasSourceAt(v ...*HasSourceAt) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveHasSourceAtIDs(ids...)
}

// ClearCertification clears all "certification" edges to the Certification entity.
func (_u *PackageVersionUpdate) ClearCertification() *PackageVersionUpdate {
	_u.mutation.ClearCertification()
	return _u
}

// RemoveCertificationIDs removes the "certification" edge to Certification entities by IDs.
func (_u *PackageVersionUpdate) RemoveCertificationIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemoveCertificationIDs(ids...)
	return _u
}

// RemoveCertification removes "certification" edges to Certification entities.
func (_u *PackageVersionUpdate) RemoveCertification(v ...*Certification) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveCertificationIDs(ids...)
}

// ClearMetadata clears all "metadata" edges to the HasMetadata entity.
func (_u *PackageVersionUpdate) ClearMetadata() *PackageVersionUpdate {
	_u.mutation.ClearMetadata()
	return _u
}

// RemoveMetadatumIDs removes the "metadata" edge to HasMetadata entities by IDs.
func (_u *PackageVersionUpdate) RemoveMetadatumIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemoveMetadatumIDs(ids...)
	return _u
}

// RemoveMetadata removes "metadata" edges to HasMetadata entities.
func (_u *PackageVersionUpdate) RemoveMetadata(v ...*HasMetadata) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveMetadatumIDs(ids...)
}

// ClearDependency clears all "dependency" edges to the Dependency entity.
func (_u *PackageVersionUpdate) ClearDependency() *PackageVersionUpdate {
	_u.mutation.ClearDependency()
	return _u
}

// RemoveDependencyIDs removes the "dependency" edge to Dependency entities by IDs.
func (_u *PackageVersionUpdate) RemoveDependencyIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemoveDependencyIDs(ids...)
	return _u
}

// RemoveDependency removes "dependency" edges to Dependency entities.
func (_u *PackageVersionUpdate) RemoveDependency(v ...*Dependency) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveDependencyIDs(ids...)
}

// ClearDependencySubject clears all "dependency_subject" edges to the Dependency entity.
func (_u *PackageVersionUpdate) ClearDependencySubject() *PackageVersionUpdate {
	_u.mutation.ClearDependencySubject()
	return _u
}

// RemoveDependencySubjectIDs removes the "dependency_subject" edge to Dependency entities by IDs.
func (_u *PackageVersionUpdate) RemoveDependencySubjectIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemoveDependencySubjectIDs(ids...)
	return _u
}

// RemoveDependencySubject removes "dependency_subject" edges to Dependency entities.
func (_u *PackageVersionUpdate) RemoveDependencySubject(v ...*Dependency) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveDependencySubjectIDs(ids...)
}

// ClearIncludedInSboms clears all "included_in_sboms" edges to the BillOfMaterials entity.
func (_u *PackageVersionUpdate) ClearIncludedInSboms() *PackageVersionUpdate {
	_u.mutation.ClearIncludedInSboms()
	return _u
}

// RemoveIncludedInSbomIDs removes the "included_in_sboms" edge to BillOfMaterials entities by IDs.
func (_u *PackageVersionUpdate) RemoveIncludedInSbomIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemoveIncludedInSbomIDs(ids...)
	return _u
}

// RemoveIncludedInSboms removes "included_in_sboms" edges to BillOfMaterials entities.
func (_u *PackageVersionUpdate) RemoveIncludedInSboms(v ...*BillOfMaterials) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveIncludedInSbomIDs(ids...)
}

// ClearPkgEqualPkgA clears all "pkg_equal_pkg_a" edges to the PkgEqual entity.
func (_u *PackageVersionUpdate) ClearPkgEqualPkgA() *PackageVersionUpdate {
	_u.mutation.ClearPkgEqualPkgA()
	return _u
}

// RemovePkgEqualPkgAIDs removes the "pkg_equal_pkg_a" edge to PkgEqual entities by IDs.
func (_u *PackageVersionUpdate) RemovePkgEqualPkgAIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemovePkgEqualPkgAIDs(ids...)
	return _u
}

// RemovePkgEqualPkgA removes "pkg_equal_pkg_a" edges to PkgEqual entities.
func (_u *PackageVersionUpdate) RemovePkgEqualPkgA(v ...*PkgEqual) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemovePkgEqualPkgAIDs(ids...)
}

// ClearPkgEqualPkgB clears all "pkg_equal_pkg_b" edges to the PkgEqual entity.
func (_u *PackageVersionUpdate) ClearPkgEqualPkgB() *PackageVersionUpdate {
	_u.mutation.ClearPkgEqualPkgB()
	return _u
}

// RemovePkgEqualPkgBIDs removes the "pkg_equal_pkg_b" edge to PkgEqual entities by IDs.
func (_u *PackageVersionUpdate) RemovePkgEqualPkgBIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemovePkgEqualPkgBIDs(ids...)
	return _u
}

// RemovePkgEqualPkgB removes "pkg_equal_pkg_b" edges to PkgEqual entities.
func (_u *PackageVersionUpdate) RemovePkgEqualPkgB(v ...*PkgEqual) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemovePkgEqualPkgBIDs(ids...)
}

// ClearPoc clears all "poc" edges to the PointOfContact entity.
func (_u *PackageVersionUpdate) ClearPoc() *PackageVersionUpdate {
	_u.mutation.ClearPoc()
	return _u
}

// RemovePocIDs removes the "poc" edge to PointOfContact entities by IDs.
func (_u *PackageVersionUpdate) RemovePocIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemovePocIDs(ids...)
	return _u
}

// RemovePoc removes "poc" edges to PointOfContact entities.
func (_u *PackageVersionUpdate) RemovePoc(v ...*PointOfContact) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemovePocIDs(ids...)
}

// ClearCertifyLegal clears all "certify_legal" edges to the CertifyLegal entity.
func (_u *PackageVersionUpdate) ClearCertifyLegal() *PackageVersionUpdate {
	_u.mutation.ClearCertifyLegal()
	return _u
}

// RemoveCertifyLegalIDs removes the "certify_legal" edge to CertifyLegal entities by IDs.
func (_u *PackageVersionUpdate) RemoveCertifyLegalIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	_u.mutation.RemoveCertifyLegalIDs(ids...)
	return _u
}

// RemoveCertifyLegal removes "certify_legal" edges to CertifyLegal entities.
func (_u *PackageVersionUpdate) RemoveCertifyLegal(v ...*CertifyLegal) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveCertifyLegalIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (_u *PackageVersionUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (_u *PackageVersionUpdate) SaveX(ctx context.Context) int {
	affected, err := _u.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (_u *PackageVersionUpdate) Exec(ctx context.Context) error {
	_, err := _u.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (_u *PackageVersionUpdate) ExecX(ctx context.Context) {
	if err := _u.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (_u *PackageVersionUpdate) check() error {
	if _u.mutation.NameCleared() && len(_u.mutation.NameIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "PackageVersion.name"`)
	}
	return nil
}

func (_u *PackageVersionUpdate) sqlSave(ctx context.Context) (_node int, err error) {
	if err := _u.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(packageversion.Table, packageversion.Columns, sqlgraph.NewFieldSpec(packageversion.FieldID, field.TypeUUID))
	if ps := _u.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := _u.mutation.Version(); ok {
		_spec.SetField(packageversion.FieldVersion, field.TypeString, value)
	}
	if value, ok := _u.mutation.Subpath(); ok {
		_spec.SetField(packageversion.FieldSubpath, field.TypeString, value)
	}
	if value, ok := _u.mutation.Qualifiers(); ok {
		_spec.SetField(packageversion.FieldQualifiers, field.TypeJSON, value)
	}
	if value, ok := _u.mutation.AppendedQualifiers(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, packageversion.FieldQualifiers, value)
		})
	}
	if _u.mutation.QualifiersCleared() {
		_spec.ClearField(packageversion.FieldQualifiers, field.TypeJSON)
	}
	if value, ok := _u.mutation.Hash(); ok {
		_spec.SetField(packageversion.FieldHash, field.TypeString, value)
	}
	if _u.mutation.NameCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   packageversion.NameTable,
			Columns: []string{packageversion.NameColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(packagename.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.NameIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   packageversion.NameTable,
			Columns: []string{packageversion.NameColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(packagename.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.OccurrencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.OccurrencesTable,
			Columns: []string{packageversion.OccurrencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(occurrence.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedOccurrencesIDs(); len(nodes) > 0 && !_u.mutation.OccurrencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.OccurrencesTable,
			Columns: []string{packageversion.OccurrencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(occurrence.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.OccurrencesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.OccurrencesTable,
			Columns: []string{packageversion.OccurrencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(occurrence.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SbomCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.SbomTable,
			Columns: []string{packageversion.SbomColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSbomIDs(); len(nodes) > 0 && !_u.mutation.SbomCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.SbomTable,
			Columns: []string{packageversion.SbomColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SbomIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.SbomTable,
			Columns: []string{packageversion.SbomColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.VulnCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VulnTable,
			Columns: []string{packageversion.VulnColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvuln.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedVulnIDs(); len(nodes) > 0 && !_u.mutation.VulnCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VulnTable,
			Columns: []string{packageversion.VulnColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvuln.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.VulnIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VulnTable,
			Columns: []string{packageversion.VulnColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvuln.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.VexCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VexTable,
			Columns: []string{packageversion.VexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvex.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedVexIDs(); len(nodes) > 0 && !_u.mutation.VexCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VexTable,
			Columns: []string{packageversion.VexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvex.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.VexIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VexTable,
			Columns: []string{packageversion.VexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvex.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.HasSourceAtCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.HasSourceAtTable,
			Columns: []string{packageversion.HasSourceAtColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hassourceat.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedHasSourceAtIDs(); len(nodes) > 0 && !_u.mutation.HasSourceAtCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.HasSourceAtTable,
			Columns: []string{packageversion.HasSourceAtColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hassourceat.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.HasSourceAtIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.HasSourceAtTable,
			Columns: []string{packageversion.HasSourceAtColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hassourceat.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.CertificationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertificationTable,
			Columns: []string{packageversion.CertificationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certification.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedCertificationIDs(); len(nodes) > 0 && !_u.mutation.CertificationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertificationTable,
			Columns: []string{packageversion.CertificationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certification.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.CertificationIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertificationTable,
			Columns: []string{packageversion.CertificationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certification.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.MetadataCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.MetadataTable,
			Columns: []string{packageversion.MetadataColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hasmetadata.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedMetadataIDs(); len(nodes) > 0 && !_u.mutation.MetadataCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.MetadataTable,
			Columns: []string{packageversion.MetadataColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hasmetadata.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.MetadataIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.MetadataTable,
			Columns: []string{packageversion.MetadataColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hasmetadata.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.DependencyCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencyTable,
			Columns: []string{packageversion.DependencyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedDependencyIDs(); len(nodes) > 0 && !_u.mutation.DependencyCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencyTable,
			Columns: []string{packageversion.DependencyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.DependencyIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencyTable,
			Columns: []string{packageversion.DependencyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.DependencySubjectCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencySubjectTable,
			Columns: []string{packageversion.DependencySubjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedDependencySubjectIDs(); len(nodes) > 0 && !_u.mutation.DependencySubjectCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencySubjectTable,
			Columns: []string{packageversion.DependencySubjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.DependencySubjectIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencySubjectTable,
			Columns: []string{packageversion.DependencySubjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.IncludedInSbomsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   packageversion.IncludedInSbomsTable,
			Columns: packageversion.IncludedInSbomsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedIncludedInSbomsIDs(); len(nodes) > 0 && !_u.mutation.IncludedInSbomsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   packageversion.IncludedInSbomsTable,
			Columns: packageversion.IncludedInSbomsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.IncludedInSbomsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   packageversion.IncludedInSbomsTable,
			Columns: packageversion.IncludedInSbomsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.PkgEqualPkgACleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgATable,
			Columns: []string{packageversion.PkgEqualPkgAColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedPkgEqualPkgAIDs(); len(nodes) > 0 && !_u.mutation.PkgEqualPkgACleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgATable,
			Columns: []string{packageversion.PkgEqualPkgAColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PkgEqualPkgAIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgATable,
			Columns: []string{packageversion.PkgEqualPkgAColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.PkgEqualPkgBCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgBTable,
			Columns: []string{packageversion.PkgEqualPkgBColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedPkgEqualPkgBIDs(); len(nodes) > 0 && !_u.mutation.PkgEqualPkgBCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgBTable,
			Columns: []string{packageversion.PkgEqualPkgBColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PkgEqualPkgBIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgBTable,
			Columns: []string{packageversion.PkgEqualPkgBColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.PocCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PocTable,
			Columns: []string{packageversion.PocColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pointofcontact.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedPocIDs(); len(nodes) > 0 && !_u.mutation.PocCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PocTable,
			Columns: []string{packageversion.PocColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pointofcontact.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PocIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PocTable,
			Columns: []string{packageversion.PocColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pointofcontact.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.CertifyLegalCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertifyLegalTable,
			Columns: []string{packageversion.CertifyLegalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifylegal.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedCertifyLegalIDs(); len(nodes) > 0 && !_u.mutation.CertifyLegalCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertifyLegalTable,
			Columns: []string{packageversion.CertifyLegalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifylegal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.CertifyLegalIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertifyLegalTable,
			Columns: []string{packageversion.CertifyLegalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifylegal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _node, err = sqlgraph.UpdateNodes(ctx, _u.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{packageversion.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	_u.mutation.done = true
	return _node, nil
}

// PackageVersionUpdateOne is the builder for updating a single PackageVersion entity.
type PackageVersionUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *PackageVersionMutation
}

// SetNameID sets the "name_id" field.
func (_u *PackageVersionUpdateOne) SetNameID(v uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.SetNameID(v)
	return _u
}

// SetNillableNameID sets the "name_id" field if the given value is not nil.
func (_u *PackageVersionUpdateOne) SetNillableNameID(v *uuid.UUID) *PackageVersionUpdateOne {
	if v != nil {
		_u.SetNameID(*v)
	}
	return _u
}

// SetVersion sets the "version" field.
func (_u *PackageVersionUpdateOne) SetVersion(v string) *PackageVersionUpdateOne {
	_u.mutation.SetVersion(v)
	return _u
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (_u *PackageVersionUpdateOne) SetNillableVersion(v *string) *PackageVersionUpdateOne {
	if v != nil {
		_u.SetVersion(*v)
	}
	return _u
}

// SetSubpath sets the "subpath" field.
func (_u *PackageVersionUpdateOne) SetSubpath(v string) *PackageVersionUpdateOne {
	_u.mutation.SetSubpath(v)
	return _u
}

// SetNillableSubpath sets the "subpath" field if the given value is not nil.
func (_u *PackageVersionUpdateOne) SetNillableSubpath(v *string) *PackageVersionUpdateOne {
	if v != nil {
		_u.SetSubpath(*v)
	}
	return _u
}

// SetQualifiers sets the "qualifiers" field.
func (_u *PackageVersionUpdateOne) SetQualifiers(v []model.PackageQualifier) *PackageVersionUpdateOne {
	_u.mutation.SetQualifiers(v)
	return _u
}

// AppendQualifiers appends value to the "qualifiers" field.
func (_u *PackageVersionUpdateOne) AppendQualifiers(v []model.PackageQualifier) *PackageVersionUpdateOne {
	_u.mutation.AppendQualifiers(v)
	return _u
}

// ClearQualifiers clears the value of the "qualifiers" field.
func (_u *PackageVersionUpdateOne) ClearQualifiers() *PackageVersionUpdateOne {
	_u.mutation.ClearQualifiers()
	return _u
}

// SetHash sets the "hash" field.
func (_u *PackageVersionUpdateOne) SetHash(v string) *PackageVersionUpdateOne {
	_u.mutation.SetHash(v)
	return _u
}

// SetNillableHash sets the "hash" field if the given value is not nil.
func (_u *PackageVersionUpdateOne) SetNillableHash(v *string) *PackageVersionUpdateOne {
	if v != nil {
		_u.SetHash(*v)
	}
	return _u
}

// SetName sets the "name" edge to the PackageName entity.
func (_u *PackageVersionUpdateOne) SetName(v *PackageName) *PackageVersionUpdateOne {
	return _u.SetNameID(v.ID)
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by IDs.
func (_u *PackageVersionUpdateOne) AddOccurrenceIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddOccurrenceIDs(ids...)
	return _u
}

// AddOccurrences adds the "occurrences" edges to the Occurrence entity.
func (_u *PackageVersionUpdateOne) AddOccurrences(v ...*Occurrence) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddOccurrenceIDs(ids...)
}

// AddSbomIDs adds the "sbom" edge to the BillOfMaterials entity by IDs.
func (_u *PackageVersionUpdateOne) AddSbomIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddSbomIDs(ids...)
	return _u
}

// AddSbom adds the "sbom" edges to the BillOfMaterials entity.
func (_u *PackageVersionUpdateOne) AddSbom(v ...*BillOfMaterials) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSbomIDs(ids...)
}

// AddVulnIDs adds the "vuln" edge to the CertifyVuln entity by IDs.
func (_u *PackageVersionUpdateOne) AddVulnIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddVulnIDs(ids...)
	return _u
}

// AddVuln adds the "vuln" edges to the CertifyVuln entity.
func (_u *PackageVersionUpdateOne) AddVuln(v ...*CertifyVuln) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddVulnIDs(ids...)
}

// AddVexIDs adds the "vex" edge to the CertifyVex entity by IDs.
func (_u *PackageVersionUpdateOne) AddVexIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddVexIDs(ids...)
	return _u
}

// AddVex adds the "vex" edges to the CertifyVex entity.
func (_u *PackageVersionUpdateOne) AddVex(v ...*CertifyVex) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddVexIDs(ids...)
}

// AddHasSourceAtIDs adds the "has_source_at" edge to the HasSourceAt entity by IDs.
func (_u *PackageVersionUpdateOne) AddHasSourceAtIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddHasSourceAtIDs(ids...)
	return _u
}

// AddHasSourceAt adds the "has_source_at" edges to the HasSourceAt entity.
func (_u *PackageVersionUpdateOne) AddHasSourceAt(v ...*HasSourceAt) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddHasSourceAtIDs(ids...)
}

// AddCertificationIDs adds the "certification" edge to the Certification entity by IDs.
func (_u *PackageVersionUpdateOne) AddCertificationIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddCertificationIDs(ids...)
	return _u
}

// AddCertification adds the "certification" edges to the Certification entity.
func (_u *PackageVersionUpdateOne) AddCertification(v ...*Certification) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddCertificationIDs(ids...)
}

// AddMetadatumIDs adds the "metadata" edge to the HasMetadata entity by IDs.
func (_u *PackageVersionUpdateOne) AddMetadatumIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddMetadatumIDs(ids...)
	return _u
}

// AddMetadata adds the "metadata" edges to the HasMetadata entity.
func (_u *PackageVersionUpdateOne) AddMetadata(v ...*HasMetadata) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddMetadatumIDs(ids...)
}

// AddDependencyIDs adds the "dependency" edge to the Dependency entity by IDs.
func (_u *PackageVersionUpdateOne) AddDependencyIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddDependencyIDs(ids...)
	return _u
}

// AddDependency adds the "dependency" edges to the Dependency entity.
func (_u *PackageVersionUpdateOne) AddDependency(v ...*Dependency) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddDependencyIDs(ids...)
}

// AddDependencySubjectIDs adds the "dependency_subject" edge to the Dependency entity by IDs.
func (_u *PackageVersionUpdateOne) AddDependencySubjectIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddDependencySubjectIDs(ids...)
	return _u
}

// AddDependencySubject adds the "dependency_subject" edges to the Dependency entity.
func (_u *PackageVersionUpdateOne) AddDependencySubject(v ...*Dependency) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddDependencySubjectIDs(ids...)
}

// AddIncludedInSbomIDs adds the "included_in_sboms" edge to the BillOfMaterials entity by IDs.
func (_u *PackageVersionUpdateOne) AddIncludedInSbomIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddIncludedInSbomIDs(ids...)
	return _u
}

// AddIncludedInSboms adds the "included_in_sboms" edges to the BillOfMaterials entity.
func (_u *PackageVersionUpdateOne) AddIncludedInSboms(v ...*BillOfMaterials) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddIncludedInSbomIDs(ids...)
}

// AddPkgEqualPkgAIDs adds the "pkg_equal_pkg_a" edge to the PkgEqual entity by IDs.
func (_u *PackageVersionUpdateOne) AddPkgEqualPkgAIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddPkgEqualPkgAIDs(ids...)
	return _u
}

// AddPkgEqualPkgA adds the "pkg_equal_pkg_a" edges to the PkgEqual entity.
func (_u *PackageVersionUpdateOne) AddPkgEqualPkgA(v ...*PkgEqual) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddPkgEqualPkgAIDs(ids...)
}

// AddPkgEqualPkgBIDs adds the "pkg_equal_pkg_b" edge to the PkgEqual entity by IDs.
func (_u *PackageVersionUpdateOne) AddPkgEqualPkgBIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddPkgEqualPkgBIDs(ids...)
	return _u
}

// AddPkgEqualPkgB adds the "pkg_equal_pkg_b" edges to the PkgEqual entity.
func (_u *PackageVersionUpdateOne) AddPkgEqualPkgB(v ...*PkgEqual) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddPkgEqualPkgBIDs(ids...)
}

// AddPocIDs adds the "poc" edge to the PointOfContact entity by IDs.
func (_u *PackageVersionUpdateOne) AddPocIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddPocIDs(ids...)
	return _u
}

// AddPoc adds the "poc" edges to the PointOfContact entity.
func (_u *PackageVersionUpdateOne) AddPoc(v ...*PointOfContact) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddPocIDs(ids...)
}

// AddCertifyLegalIDs adds the "certify_legal" edge to the CertifyLegal entity by IDs.
func (_u *PackageVersionUpdateOne) AddCertifyLegalIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.AddCertifyLegalIDs(ids...)
	return _u
}

// AddCertifyLegal adds the "certify_legal" edges to the CertifyLegal entity.
func (_u *PackageVersionUpdateOne) AddCertifyLegal(v ...*CertifyLegal) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddCertifyLegalIDs(ids...)
}

// Mutation returns the PackageVersionMutation object of the builder.
func (_u *PackageVersionUpdateOne) Mutation() *PackageVersionMutation {
	return _u.mutation
}

// ClearName clears the "name" edge to the PackageName entity.
func (_u *PackageVersionUpdateOne) ClearName() *PackageVersionUpdateOne {
	_u.mutation.ClearName()
	return _u
}

// ClearOccurrences clears all "occurrences" edges to the Occurrence entity.
func (_u *PackageVersionUpdateOne) ClearOccurrences() *PackageVersionUpdateOne {
	_u.mutation.ClearOccurrences()
	return _u
}

// RemoveOccurrenceIDs removes the "occurrences" edge to Occurrence entities by IDs.
func (_u *PackageVersionUpdateOne) RemoveOccurrenceIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemoveOccurrenceIDs(ids...)
	return _u
}

// RemoveOccurrences removes "occurrences" edges to Occurrence entities.
func (_u *PackageVersionUpdateOne) RemoveOccurrences(v ...*Occurrence) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveOccurrenceIDs(ids...)
}

// ClearSbom clears all "sbom" edges to the BillOfMaterials entity.
func (_u *PackageVersionUpdateOne) ClearSbom() *PackageVersionUpdateOne {
	_u.mutation.ClearSbom()
	return _u
}

// RemoveSbomIDs removes the "sbom" edge to BillOfMaterials entities by IDs.
func (_u *PackageVersionUpdateOne) RemoveSbomIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemoveSbomIDs(ids...)
	return _u
}

// RemoveSbom removes "sbom" edges to BillOfMaterials entities.
func (_u *PackageVersionUpdateOne) RemoveSbom(v ...*BillOfMaterials) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSbomIDs(ids...)
}

// ClearVuln clears all "vuln" edges to the CertifyVuln entity.
func (_u *PackageVersionUpdateOne) ClearVuln() *PackageVersionUpdateOne {
	_u.mutation.ClearVuln()
	return _u
}

// RemoveVulnIDs removes the "vuln" edge to CertifyVuln entities by IDs.
func (_u *PackageVersionUpdateOne) RemoveVulnIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemoveVulnIDs(ids...)
	return _u
}

// RemoveVuln removes "vuln" edges to CertifyVuln entities.
func (_u *PackageVersionUpdateOne) RemoveVuln(v ...*CertifyVuln) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveVulnIDs(ids...)
}

// ClearVex clears all "vex" edges to the CertifyVex entity.
func (_u *PackageVersionUpdateOne) ClearVex() *PackageVersionUpdateOne {
	_u.mutation.ClearVex()
	return _u
}

// RemoveVexIDs removes the "vex" edge to CertifyVex entities by IDs.
func (_u *PackageVersionUpdateOne) RemoveVexIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemoveVexIDs(ids...)
	return _u
}

// RemoveVex removes "vex" edges to CertifyVex entities.
func (_u *PackageVersionUpdateOne) RemoveVex(v ...*CertifyVex) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveVexIDs(ids...)
}

// ClearHasSourceAt clears all "has_source_at" edges to the HasSourceAt entity.
func (_u *PackageVersionUpdateOne) ClearHasSourceAt() *PackageVersionUpdateOne {
	_u.mutation.ClearHasSourceAt()
	return _u
}

// RemoveHasSourceAtIDs removes the "has_source_at" edge to HasSourceAt entities by IDs.
func (_u *PackageVersionUpdateOne) RemoveHasSourceAtIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemoveHasSourceAtIDs(ids...)
	return _u
}

// RemoveHasSourceAt removes "has_source_at" edges to HasSourceAt entities.
func (_u *PackageVersionUpdateOne) RemoveHasSourceAt(v ...*HasSourceAt) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveHasSourceAtIDs(ids...)
}

// ClearCertification clears all "certification" edges to the Certification entity.
func (_u *PackageVersionUpdateOne) ClearCertification() *PackageVersionUpdateOne {
	_u.mutation.ClearCertification()
	return _u
}

// RemoveCertificationIDs removes the "certification" edge to Certification entities by IDs.
func (_u *PackageVersionUpdateOne) RemoveCertificationIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemoveCertificationIDs(ids...)
	return _u
}

// RemoveCertification removes "certification" edges to Certification entities.
func (_u *PackageVersionUpdateOne) RemoveCertification(v ...*Certification) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveCertificationIDs(ids...)
}

// ClearMetadata clears all "metadata" edges to the HasMetadata entity.
func (_u *PackageVersionUpdateOne) ClearMetadata() *PackageVersionUpdateOne {
	_u.mutation.ClearMetadata()
	return _u
}

// RemoveMetadatumIDs removes the "metadata" edge to HasMetadata entities by IDs.
func (_u *PackageVersionUpdateOne) RemoveMetadatumIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemoveMetadatumIDs(ids...)
	return _u
}

// RemoveMetadata removes "metadata" edges to HasMetadata entities.
func (_u *PackageVersionUpdateOne) RemoveMetadata(v ...*HasMetadata) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveMetadatumIDs(ids...)
}

// ClearDependency clears all "dependency" edges to the Dependency entity.
func (_u *PackageVersionUpdateOne) ClearDependency() *PackageVersionUpdateOne {
	_u.mutation.ClearDependency()
	return _u
}

// RemoveDependencyIDs removes the "dependency" edge to Dependency entities by IDs.
func (_u *PackageVersionUpdateOne) RemoveDependencyIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemoveDependencyIDs(ids...)
	return _u
}

// RemoveDependency removes "dependency" edges to Dependency entities.
func (_u *PackageVersionUpdateOne) RemoveDependency(v ...*Dependency) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveDependencyIDs(ids...)
}

// ClearDependencySubject clears all "dependency_subject" edges to the Dependency entity.
func (_u *PackageVersionUpdateOne) ClearDependencySubject() *PackageVersionUpdateOne {
	_u.mutation.ClearDependencySubject()
	return _u
}

// RemoveDependencySubjectIDs removes the "dependency_subject" edge to Dependency entities by IDs.
func (_u *PackageVersionUpdateOne) RemoveDependencySubjectIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemoveDependencySubjectIDs(ids...)
	return _u
}

// RemoveDependencySubject removes "dependency_subject" edges to Dependency entities.
func (_u *PackageVersionUpdateOne) RemoveDependencySubject(v ...*Dependency) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveDependencySubjectIDs(ids...)
}

// ClearIncludedInSboms clears all "included_in_sboms" edges to the BillOfMaterials entity.
func (_u *PackageVersionUpdateOne) ClearIncludedInSboms() *PackageVersionUpdateOne {
	_u.mutation.ClearIncludedInSboms()
	return _u
}

// RemoveIncludedInSbomIDs removes the "included_in_sboms" edge to BillOfMaterials entities by IDs.
func (_u *PackageVersionUpdateOne) RemoveIncludedInSbomIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemoveIncludedInSbomIDs(ids...)
	return _u
}

// RemoveIncludedInSboms removes "included_in_sboms" edges to BillOfMaterials entities.
func (_u *PackageVersionUpdateOne) RemoveIncludedInSboms(v ...*BillOfMaterials) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveIncludedInSbomIDs(ids...)
}

// ClearPkgEqualPkgA clears all "pkg_equal_pkg_a" edges to the PkgEqual entity.
func (_u *PackageVersionUpdateOne) ClearPkgEqualPkgA() *PackageVersionUpdateOne {
	_u.mutation.ClearPkgEqualPkgA()
	return _u
}

// RemovePkgEqualPkgAIDs removes the "pkg_equal_pkg_a" edge to PkgEqual entities by IDs.
func (_u *PackageVersionUpdateOne) RemovePkgEqualPkgAIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemovePkgEqualPkgAIDs(ids...)
	return _u
}

// RemovePkgEqualPkgA removes "pkg_equal_pkg_a" edges to PkgEqual entities.
func (_u *PackageVersionUpdateOne) RemovePkgEqualPkgA(v ...*PkgEqual) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemovePkgEqualPkgAIDs(ids...)
}

// ClearPkgEqualPkgB clears all "pkg_equal_pkg_b" edges to the PkgEqual entity.
func (_u *PackageVersionUpdateOne) ClearPkgEqualPkgB() *PackageVersionUpdateOne {
	_u.mutation.ClearPkgEqualPkgB()
	return _u
}

// RemovePkgEqualPkgBIDs removes the "pkg_equal_pkg_b" edge to PkgEqual entities by IDs.
func (_u *PackageVersionUpdateOne) RemovePkgEqualPkgBIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemovePkgEqualPkgBIDs(ids...)
	return _u
}

// RemovePkgEqualPkgB removes "pkg_equal_pkg_b" edges to PkgEqual entities.
func (_u *PackageVersionUpdateOne) RemovePkgEqualPkgB(v ...*PkgEqual) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemovePkgEqualPkgBIDs(ids...)
}

// ClearPoc clears all "poc" edges to the PointOfContact entity.
func (_u *PackageVersionUpdateOne) ClearPoc() *PackageVersionUpdateOne {
	_u.mutation.ClearPoc()
	return _u
}

// RemovePocIDs removes the "poc" edge to PointOfContact entities by IDs.
func (_u *PackageVersionUpdateOne) RemovePocIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemovePocIDs(ids...)
	return _u
}

// RemovePoc removes "poc" edges to PointOfContact entities.
func (_u *PackageVersionUpdateOne) RemovePoc(v ...*PointOfContact) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemovePocIDs(ids...)
}

// ClearCertifyLegal clears all "certify_legal" edges to the CertifyLegal entity.
func (_u *PackageVersionUpdateOne) ClearCertifyLegal() *PackageVersionUpdateOne {
	_u.mutation.ClearCertifyLegal()
	return _u
}

// RemoveCertifyLegalIDs removes the "certify_legal" edge to CertifyLegal entities by IDs.
func (_u *PackageVersionUpdateOne) RemoveCertifyLegalIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	_u.mutation.RemoveCertifyLegalIDs(ids...)
	return _u
}

// RemoveCertifyLegal removes "certify_legal" edges to CertifyLegal entities.
func (_u *PackageVersionUpdateOne) RemoveCertifyLegal(v ...*CertifyLegal) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveCertifyLegalIDs(ids...)
}

// Where appends a list predicates to the PackageVersionUpdate builder.
func (_u *PackageVersionUpdateOne) Where(ps ...predicate.PackageVersion) *PackageVersionUpdateOne {
	_u.mutation.Where(ps...)
	return _u
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (_u *PackageVersionUpdateOne) Select(field string, fields ...string) *PackageVersionUpdateOne {
	_u.fields = append([]string{field}, fields...)
	return _u
}

// Save executes the query and returns the updated PackageVersion entity.
func (_u *PackageVersionUpdateOne) Save(ctx context.Context) (*PackageVersion, error) {
	return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (_u *PackageVersionUpdateOne) SaveX(ctx context.Context) *PackageVersion {
	node, err := _u.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (_u *PackageVersionUpdateOne) Exec(ctx context.Context) error {
	_, err := _u.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (_u *PackageVersionUpdateOne) ExecX(ctx context.Context) {
	if err := _u.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (_u *PackageVersionUpdateOne) check() error {
	if _u.mutation.NameCleared() && len(_u.mutation.NameIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "PackageVersion.name"`)
	}
	return nil
}

func (_u *PackageVersionUpdateOne) sqlSave(ctx context.Context) (_node *PackageVersion, err error) {
	if err := _u.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(packageversion.Table, packageversion.Columns, sqlgraph.NewFieldSpec(packageversion.FieldID, field.TypeUUID))
	id, ok := _u.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "PackageVersion.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := _u.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, packageversion.FieldID)
		for _, f := range fields {
			if !packageversion.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != packageversion.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := _u.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := _u.mutation.Version(); ok {
		_spec.SetField(packageversion.FieldVersion, field.TypeString, value)
	}
	if value, ok := _u.mutation.Subpath(); ok {
		_spec.SetField(packageversion.FieldSubpath, field.TypeString, value)
	}
	if value, ok := _u.mutation.Qualifiers(); ok {
		_spec.SetField(packageversion.FieldQualifiers, field.TypeJSON, value)
	}
	if value, ok := _u.mutation.AppendedQualifiers(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, packageversion.FieldQualifiers, value)
		})
	}
	if _u.mutation.QualifiersCleared() {
		_spec.ClearField(packageversion.FieldQualifiers, field.TypeJSON)
	}
	if value, ok := _u.mutation.Hash(); ok {
		_spec.SetField(packageversion.FieldHash, field.TypeString, value)
	}
	if _u.mutation.NameCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   packageversion.NameTable,
			Columns: []string{packageversion.NameColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(packagename.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.NameIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   packageversion.NameTable,
			Columns: []string{packageversion.NameColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(packagename.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.OccurrencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.OccurrencesTable,
			Columns: []string{packageversion.OccurrencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(occurrence.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedOccurrencesIDs(); len(nodes) > 0 && !_u.mutation.OccurrencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.OccurrencesTable,
			Columns: []string{packageversion.OccurrencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(occurrence.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.OccurrencesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.OccurrencesTable,
			Columns: []string{packageversion.OccurrencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(occurrence.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SbomCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.SbomTable,
			Columns: []string{packageversion.SbomColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSbomIDs(); len(nodes) > 0 && !_u.mutation.SbomCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.SbomTable,
			Columns: []string{packageversion.SbomColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SbomIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.SbomTable,
			Columns: []string{packageversion.SbomColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.VulnCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VulnTable,
			Columns: []string{packageversion.VulnColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvuln.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedVulnIDs(); len(nodes) > 0 && !_u.mutation.VulnCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VulnTable,
			Columns: []string{packageversion.VulnColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvuln.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.VulnIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VulnTable,
			Columns: []string{packageversion.VulnColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvuln.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.VexCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VexTable,
			Columns: []string{packageversion.VexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvex.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedVexIDs(); len(nodes) > 0 && !_u.mutation.VexCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VexTable,
			Columns: []string{packageversion.VexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvex.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.VexIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VexTable,
			Columns: []string{packageversion.VexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvex.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.HasSourceAtCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.HasSourceAtTable,
			Columns: []string{packageversion.HasSourceAtColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hassourceat.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedHasSourceAtIDs(); len(nodes) > 0 && !_u.mutation.HasSourceAtCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.HasSourceAtTable,
			Columns: []string{packageversion.HasSourceAtColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hassourceat.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.HasSourceAtIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.HasSourceAtTable,
			Columns: []string{packageversion.HasSourceAtColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hassourceat.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.CertificationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertificationTable,
			Columns: []string{packageversion.CertificationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certification.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedCertificationIDs(); len(nodes) > 0 && !_u.mutation.CertificationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertificationTable,
			Columns: []string{packageversion.CertificationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certification.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.CertificationIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertificationTable,
			Columns: []string{packageversion.CertificationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certification.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.MetadataCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.MetadataTable,
			Columns: []string{packageversion.MetadataColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hasmetadata.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedMetadataIDs(); len(nodes) > 0 && !_u.mutation.MetadataCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.MetadataTable,
			Columns: []string{packageversion.MetadataColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hasmetadata.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.MetadataIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.MetadataTable,
			Columns: []string{packageversion.MetadataColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hasmetadata.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.DependencyCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencyTable,
			Columns: []string{packageversion.DependencyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedDependencyIDs(); len(nodes) > 0 && !_u.mutation.DependencyCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencyTable,
			Columns: []string{packageversion.DependencyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.DependencyIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencyTable,
			Columns: []string{packageversion.DependencyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.DependencySubjectCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencySubjectTable,
			Columns: []string{packageversion.DependencySubjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedDependencySubjectIDs(); len(nodes) > 0 && !_u.mutation.DependencySubjectCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencySubjectTable,
			Columns: []string{packageversion.DependencySubjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.DependencySubjectIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencySubjectTable,
			Columns: []string{packageversion.DependencySubjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.IncludedInSbomsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   packageversion.IncludedInSbomsTable,
			Columns: packageversion.IncludedInSbomsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedIncludedInSbomsIDs(); len(nodes) > 0 && !_u.mutation.IncludedInSbomsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   packageversion.IncludedInSbomsTable,
			Columns: packageversion.IncludedInSbomsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.IncludedInSbomsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   packageversion.IncludedInSbomsTable,
			Columns: packageversion.IncludedInSbomsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.PkgEqualPkgACleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgATable,
			Columns: []string{packageversion.PkgEqualPkgAColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedPkgEqualPkgAIDs(); len(nodes) > 0 && !_u.mutation.PkgEqualPkgACleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgATable,
			Columns: []string{packageversion.PkgEqualPkgAColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PkgEqualPkgAIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgATable,
			Columns: []string{packageversion.PkgEqualPkgAColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.PkgEqualPkgBCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgBTable,
			Columns: []string{packageversion.PkgEqualPkgBColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedPkgEqualPkgBIDs(); len(nodes) > 0 && !_u.mutation.PkgEqualPkgBCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgBTable,
			Columns: []string{packageversion.PkgEqualPkgBColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PkgEqualPkgBIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgBTable,
			Columns: []string{packageversion.PkgEqualPkgBColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.PocCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PocTable,
			Columns: []string{packageversion.PocColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pointofcontact.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedPocIDs(); len(nodes) > 0 && !_u.mutation.PocCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PocTable,
			Columns: []string{packageversion.PocColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pointofcontact.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PocIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PocTable,
			Columns: []string{packageversion.PocColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pointofcontact.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.CertifyLegalCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertifyLegalTable,
			Columns: []string{packageversion.CertifyLegalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifylegal.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedCertifyLegalIDs(); len(nodes) > 0 && !_u.mutation.CertifyLegalCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertifyLegalTable,
			Columns: []string{packageversion.CertifyLegalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifylegal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.CertifyLegalIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertifyLegalTable,
			Columns: []string{packageversion.CertifyLegalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifylegal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &PackageVersion{config: _u.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, _u.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{packageversion.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	_u.mutation.done = true
	return _node, nil
}
