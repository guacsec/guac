// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/dialect/sql/sqljson"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/billofmaterials"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certification"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifylegal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvex"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvuln"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/dependency"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hasmetadata"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hassourceat"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/occurrence"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pkgequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pointofcontact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/predicate"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

// PackageVersionUpdate is the builder for updating PackageVersion entities.
type PackageVersionUpdate struct {
	config
	hooks    []Hook
	mutation *PackageVersionMutation
}

// Where appends a list predicates to the PackageVersionUpdate builder.
func (pvu *PackageVersionUpdate) Where(ps ...predicate.PackageVersion) *PackageVersionUpdate {
	pvu.mutation.Where(ps...)
	return pvu
}

// SetNameID sets the "name_id" field.
func (pvu *PackageVersionUpdate) SetNameID(u uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.SetNameID(u)
	return pvu
}

// SetNillableNameID sets the "name_id" field if the given value is not nil.
func (pvu *PackageVersionUpdate) SetNillableNameID(u *uuid.UUID) *PackageVersionUpdate {
	if u != nil {
		pvu.SetNameID(*u)
	}
	return pvu
}

// SetVersion sets the "version" field.
func (pvu *PackageVersionUpdate) SetVersion(s string) *PackageVersionUpdate {
	pvu.mutation.SetVersion(s)
	return pvu
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (pvu *PackageVersionUpdate) SetNillableVersion(s *string) *PackageVersionUpdate {
	if s != nil {
		pvu.SetVersion(*s)
	}
	return pvu
}

// SetSubpath sets the "subpath" field.
func (pvu *PackageVersionUpdate) SetSubpath(s string) *PackageVersionUpdate {
	pvu.mutation.SetSubpath(s)
	return pvu
}

// SetNillableSubpath sets the "subpath" field if the given value is not nil.
func (pvu *PackageVersionUpdate) SetNillableSubpath(s *string) *PackageVersionUpdate {
	if s != nil {
		pvu.SetSubpath(*s)
	}
	return pvu
}

// SetQualifiers sets the "qualifiers" field.
func (pvu *PackageVersionUpdate) SetQualifiers(mq []model.PackageQualifier) *PackageVersionUpdate {
	pvu.mutation.SetQualifiers(mq)
	return pvu
}

// AppendQualifiers appends mq to the "qualifiers" field.
func (pvu *PackageVersionUpdate) AppendQualifiers(mq []model.PackageQualifier) *PackageVersionUpdate {
	pvu.mutation.AppendQualifiers(mq)
	return pvu
}

// ClearQualifiers clears the value of the "qualifiers" field.
func (pvu *PackageVersionUpdate) ClearQualifiers() *PackageVersionUpdate {
	pvu.mutation.ClearQualifiers()
	return pvu
}

// SetHash sets the "hash" field.
func (pvu *PackageVersionUpdate) SetHash(s string) *PackageVersionUpdate {
	pvu.mutation.SetHash(s)
	return pvu
}

// SetNillableHash sets the "hash" field if the given value is not nil.
func (pvu *PackageVersionUpdate) SetNillableHash(s *string) *PackageVersionUpdate {
	if s != nil {
		pvu.SetHash(*s)
	}
	return pvu
}

// SetName sets the "name" edge to the PackageName entity.
func (pvu *PackageVersionUpdate) SetName(p *PackageName) *PackageVersionUpdate {
	return pvu.SetNameID(p.ID)
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by IDs.
func (pvu *PackageVersionUpdate) AddOccurrenceIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddOccurrenceIDs(ids...)
	return pvu
}

// AddOccurrences adds the "occurrences" edges to the Occurrence entity.
func (pvu *PackageVersionUpdate) AddOccurrences(o ...*Occurrence) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(o))
	for i := range o {
		ids[i] = o[i].ID
	}
	return pvu.AddOccurrenceIDs(ids...)
}

// AddSbomIDs adds the "sbom" edge to the BillOfMaterials entity by IDs.
func (pvu *PackageVersionUpdate) AddSbomIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddSbomIDs(ids...)
	return pvu
}

// AddSbom adds the "sbom" edges to the BillOfMaterials entity.
func (pvu *PackageVersionUpdate) AddSbom(b ...*BillOfMaterials) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return pvu.AddSbomIDs(ids...)
}

// AddVulnIDs adds the "vuln" edge to the CertifyVuln entity by IDs.
func (pvu *PackageVersionUpdate) AddVulnIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddVulnIDs(ids...)
	return pvu
}

// AddVuln adds the "vuln" edges to the CertifyVuln entity.
func (pvu *PackageVersionUpdate) AddVuln(c ...*CertifyVuln) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvu.AddVulnIDs(ids...)
}

// AddVexIDs adds the "vex" edge to the CertifyVex entity by IDs.
func (pvu *PackageVersionUpdate) AddVexIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddVexIDs(ids...)
	return pvu
}

// AddVex adds the "vex" edges to the CertifyVex entity.
func (pvu *PackageVersionUpdate) AddVex(c ...*CertifyVex) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvu.AddVexIDs(ids...)
}

// AddHasSourceAtIDs adds the "has_source_at" edge to the HasSourceAt entity by IDs.
func (pvu *PackageVersionUpdate) AddHasSourceAtIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddHasSourceAtIDs(ids...)
	return pvu
}

// AddHasSourceAt adds the "has_source_at" edges to the HasSourceAt entity.
func (pvu *PackageVersionUpdate) AddHasSourceAt(h ...*HasSourceAt) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return pvu.AddHasSourceAtIDs(ids...)
}

// AddCertificationIDs adds the "certification" edge to the Certification entity by IDs.
func (pvu *PackageVersionUpdate) AddCertificationIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddCertificationIDs(ids...)
	return pvu
}

// AddCertification adds the "certification" edges to the Certification entity.
func (pvu *PackageVersionUpdate) AddCertification(c ...*Certification) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvu.AddCertificationIDs(ids...)
}

// AddMetadatumIDs adds the "metadata" edge to the HasMetadata entity by IDs.
func (pvu *PackageVersionUpdate) AddMetadatumIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddMetadatumIDs(ids...)
	return pvu
}

// AddMetadata adds the "metadata" edges to the HasMetadata entity.
func (pvu *PackageVersionUpdate) AddMetadata(h ...*HasMetadata) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return pvu.AddMetadatumIDs(ids...)
}

// AddDependencyIDs adds the "dependency" edge to the Dependency entity by IDs.
func (pvu *PackageVersionUpdate) AddDependencyIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddDependencyIDs(ids...)
	return pvu
}

// AddDependency adds the "dependency" edges to the Dependency entity.
func (pvu *PackageVersionUpdate) AddDependency(d ...*Dependency) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return pvu.AddDependencyIDs(ids...)
}

// AddDependencySubjectIDs adds the "dependency_subject" edge to the Dependency entity by IDs.
func (pvu *PackageVersionUpdate) AddDependencySubjectIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddDependencySubjectIDs(ids...)
	return pvu
}

// AddDependencySubject adds the "dependency_subject" edges to the Dependency entity.
func (pvu *PackageVersionUpdate) AddDependencySubject(d ...*Dependency) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return pvu.AddDependencySubjectIDs(ids...)
}

// AddIncludedInSbomIDs adds the "included_in_sboms" edge to the BillOfMaterials entity by IDs.
func (pvu *PackageVersionUpdate) AddIncludedInSbomIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddIncludedInSbomIDs(ids...)
	return pvu
}

// AddIncludedInSboms adds the "included_in_sboms" edges to the BillOfMaterials entity.
func (pvu *PackageVersionUpdate) AddIncludedInSboms(b ...*BillOfMaterials) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return pvu.AddIncludedInSbomIDs(ids...)
}

// AddPkgEqualPkgAIDs adds the "pkg_equal_pkg_a" edge to the PkgEqual entity by IDs.
func (pvu *PackageVersionUpdate) AddPkgEqualPkgAIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddPkgEqualPkgAIDs(ids...)
	return pvu
}

// AddPkgEqualPkgA adds the "pkg_equal_pkg_a" edges to the PkgEqual entity.
func (pvu *PackageVersionUpdate) AddPkgEqualPkgA(p ...*PkgEqual) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pvu.AddPkgEqualPkgAIDs(ids...)
}

// AddPkgEqualPkgBIDs adds the "pkg_equal_pkg_b" edge to the PkgEqual entity by IDs.
func (pvu *PackageVersionUpdate) AddPkgEqualPkgBIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddPkgEqualPkgBIDs(ids...)
	return pvu
}

// AddPkgEqualPkgB adds the "pkg_equal_pkg_b" edges to the PkgEqual entity.
func (pvu *PackageVersionUpdate) AddPkgEqualPkgB(p ...*PkgEqual) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pvu.AddPkgEqualPkgBIDs(ids...)
}

// AddPocIDs adds the "poc" edge to the PointOfContact entity by IDs.
func (pvu *PackageVersionUpdate) AddPocIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddPocIDs(ids...)
	return pvu
}

// AddPoc adds the "poc" edges to the PointOfContact entity.
func (pvu *PackageVersionUpdate) AddPoc(p ...*PointOfContact) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pvu.AddPocIDs(ids...)
}

// AddCertifyLegalIDs adds the "certify_legal" edge to the CertifyLegal entity by IDs.
func (pvu *PackageVersionUpdate) AddCertifyLegalIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.AddCertifyLegalIDs(ids...)
	return pvu
}

// AddCertifyLegal adds the "certify_legal" edges to the CertifyLegal entity.
func (pvu *PackageVersionUpdate) AddCertifyLegal(c ...*CertifyLegal) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvu.AddCertifyLegalIDs(ids...)
}

// Mutation returns the PackageVersionMutation object of the builder.
func (pvu *PackageVersionUpdate) Mutation() *PackageVersionMutation {
	return pvu.mutation
}

// ClearName clears the "name" edge to the PackageName entity.
func (pvu *PackageVersionUpdate) ClearName() *PackageVersionUpdate {
	pvu.mutation.ClearName()
	return pvu
}

// ClearOccurrences clears all "occurrences" edges to the Occurrence entity.
func (pvu *PackageVersionUpdate) ClearOccurrences() *PackageVersionUpdate {
	pvu.mutation.ClearOccurrences()
	return pvu
}

// RemoveOccurrenceIDs removes the "occurrences" edge to Occurrence entities by IDs.
func (pvu *PackageVersionUpdate) RemoveOccurrenceIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemoveOccurrenceIDs(ids...)
	return pvu
}

// RemoveOccurrences removes "occurrences" edges to Occurrence entities.
func (pvu *PackageVersionUpdate) RemoveOccurrences(o ...*Occurrence) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(o))
	for i := range o {
		ids[i] = o[i].ID
	}
	return pvu.RemoveOccurrenceIDs(ids...)
}

// ClearSbom clears all "sbom" edges to the BillOfMaterials entity.
func (pvu *PackageVersionUpdate) ClearSbom() *PackageVersionUpdate {
	pvu.mutation.ClearSbom()
	return pvu
}

// RemoveSbomIDs removes the "sbom" edge to BillOfMaterials entities by IDs.
func (pvu *PackageVersionUpdate) RemoveSbomIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemoveSbomIDs(ids...)
	return pvu
}

// RemoveSbom removes "sbom" edges to BillOfMaterials entities.
func (pvu *PackageVersionUpdate) RemoveSbom(b ...*BillOfMaterials) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return pvu.RemoveSbomIDs(ids...)
}

// ClearVuln clears all "vuln" edges to the CertifyVuln entity.
func (pvu *PackageVersionUpdate) ClearVuln() *PackageVersionUpdate {
	pvu.mutation.ClearVuln()
	return pvu
}

// RemoveVulnIDs removes the "vuln" edge to CertifyVuln entities by IDs.
func (pvu *PackageVersionUpdate) RemoveVulnIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemoveVulnIDs(ids...)
	return pvu
}

// RemoveVuln removes "vuln" edges to CertifyVuln entities.
func (pvu *PackageVersionUpdate) RemoveVuln(c ...*CertifyVuln) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvu.RemoveVulnIDs(ids...)
}

// ClearVex clears all "vex" edges to the CertifyVex entity.
func (pvu *PackageVersionUpdate) ClearVex() *PackageVersionUpdate {
	pvu.mutation.ClearVex()
	return pvu
}

// RemoveVexIDs removes the "vex" edge to CertifyVex entities by IDs.
func (pvu *PackageVersionUpdate) RemoveVexIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemoveVexIDs(ids...)
	return pvu
}

// RemoveVex removes "vex" edges to CertifyVex entities.
func (pvu *PackageVersionUpdate) RemoveVex(c ...*CertifyVex) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvu.RemoveVexIDs(ids...)
}

// ClearHasSourceAt clears all "has_source_at" edges to the HasSourceAt entity.
func (pvu *PackageVersionUpdate) ClearHasSourceAt() *PackageVersionUpdate {
	pvu.mutation.ClearHasSourceAt()
	return pvu
}

// RemoveHasSourceAtIDs removes the "has_source_at" edge to HasSourceAt entities by IDs.
func (pvu *PackageVersionUpdate) RemoveHasSourceAtIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemoveHasSourceAtIDs(ids...)
	return pvu
}

// RemoveHasSourceAt removes "has_source_at" edges to HasSourceAt entities.
func (pvu *PackageVersionUpdate) RemoveHasSourceAt(h ...*HasSourceAt) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return pvu.RemoveHasSourceAtIDs(ids...)
}

// ClearCertification clears all "certification" edges to the Certification entity.
func (pvu *PackageVersionUpdate) ClearCertification() *PackageVersionUpdate {
	pvu.mutation.ClearCertification()
	return pvu
}

// RemoveCertificationIDs removes the "certification" edge to Certification entities by IDs.
func (pvu *PackageVersionUpdate) RemoveCertificationIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemoveCertificationIDs(ids...)
	return pvu
}

// RemoveCertification removes "certification" edges to Certification entities.
func (pvu *PackageVersionUpdate) RemoveCertification(c ...*Certification) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvu.RemoveCertificationIDs(ids...)
}

// ClearMetadata clears all "metadata" edges to the HasMetadata entity.
func (pvu *PackageVersionUpdate) ClearMetadata() *PackageVersionUpdate {
	pvu.mutation.ClearMetadata()
	return pvu
}

// RemoveMetadatumIDs removes the "metadata" edge to HasMetadata entities by IDs.
func (pvu *PackageVersionUpdate) RemoveMetadatumIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemoveMetadatumIDs(ids...)
	return pvu
}

// RemoveMetadata removes "metadata" edges to HasMetadata entities.
func (pvu *PackageVersionUpdate) RemoveMetadata(h ...*HasMetadata) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return pvu.RemoveMetadatumIDs(ids...)
}

// ClearDependency clears all "dependency" edges to the Dependency entity.
func (pvu *PackageVersionUpdate) ClearDependency() *PackageVersionUpdate {
	pvu.mutation.ClearDependency()
	return pvu
}

// RemoveDependencyIDs removes the "dependency" edge to Dependency entities by IDs.
func (pvu *PackageVersionUpdate) RemoveDependencyIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemoveDependencyIDs(ids...)
	return pvu
}

// RemoveDependency removes "dependency" edges to Dependency entities.
func (pvu *PackageVersionUpdate) RemoveDependency(d ...*Dependency) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return pvu.RemoveDependencyIDs(ids...)
}

// ClearDependencySubject clears all "dependency_subject" edges to the Dependency entity.
func (pvu *PackageVersionUpdate) ClearDependencySubject() *PackageVersionUpdate {
	pvu.mutation.ClearDependencySubject()
	return pvu
}

// RemoveDependencySubjectIDs removes the "dependency_subject" edge to Dependency entities by IDs.
func (pvu *PackageVersionUpdate) RemoveDependencySubjectIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemoveDependencySubjectIDs(ids...)
	return pvu
}

// RemoveDependencySubject removes "dependency_subject" edges to Dependency entities.
func (pvu *PackageVersionUpdate) RemoveDependencySubject(d ...*Dependency) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return pvu.RemoveDependencySubjectIDs(ids...)
}

// ClearIncludedInSboms clears all "included_in_sboms" edges to the BillOfMaterials entity.
func (pvu *PackageVersionUpdate) ClearIncludedInSboms() *PackageVersionUpdate {
	pvu.mutation.ClearIncludedInSboms()
	return pvu
}

// RemoveIncludedInSbomIDs removes the "included_in_sboms" edge to BillOfMaterials entities by IDs.
func (pvu *PackageVersionUpdate) RemoveIncludedInSbomIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemoveIncludedInSbomIDs(ids...)
	return pvu
}

// RemoveIncludedInSboms removes "included_in_sboms" edges to BillOfMaterials entities.
func (pvu *PackageVersionUpdate) RemoveIncludedInSboms(b ...*BillOfMaterials) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return pvu.RemoveIncludedInSbomIDs(ids...)
}

// ClearPkgEqualPkgA clears all "pkg_equal_pkg_a" edges to the PkgEqual entity.
func (pvu *PackageVersionUpdate) ClearPkgEqualPkgA() *PackageVersionUpdate {
	pvu.mutation.ClearPkgEqualPkgA()
	return pvu
}

// RemovePkgEqualPkgAIDs removes the "pkg_equal_pkg_a" edge to PkgEqual entities by IDs.
func (pvu *PackageVersionUpdate) RemovePkgEqualPkgAIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemovePkgEqualPkgAIDs(ids...)
	return pvu
}

// RemovePkgEqualPkgA removes "pkg_equal_pkg_a" edges to PkgEqual entities.
func (pvu *PackageVersionUpdate) RemovePkgEqualPkgA(p ...*PkgEqual) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pvu.RemovePkgEqualPkgAIDs(ids...)
}

// ClearPkgEqualPkgB clears all "pkg_equal_pkg_b" edges to the PkgEqual entity.
func (pvu *PackageVersionUpdate) ClearPkgEqualPkgB() *PackageVersionUpdate {
	pvu.mutation.ClearPkgEqualPkgB()
	return pvu
}

// RemovePkgEqualPkgBIDs removes the "pkg_equal_pkg_b" edge to PkgEqual entities by IDs.
func (pvu *PackageVersionUpdate) RemovePkgEqualPkgBIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemovePkgEqualPkgBIDs(ids...)
	return pvu
}

// RemovePkgEqualPkgB removes "pkg_equal_pkg_b" edges to PkgEqual entities.
func (pvu *PackageVersionUpdate) RemovePkgEqualPkgB(p ...*PkgEqual) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pvu.RemovePkgEqualPkgBIDs(ids...)
}

// ClearPoc clears all "poc" edges to the PointOfContact entity.
func (pvu *PackageVersionUpdate) ClearPoc() *PackageVersionUpdate {
	pvu.mutation.ClearPoc()
	return pvu
}

// RemovePocIDs removes the "poc" edge to PointOfContact entities by IDs.
func (pvu *PackageVersionUpdate) RemovePocIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemovePocIDs(ids...)
	return pvu
}

// RemovePoc removes "poc" edges to PointOfContact entities.
func (pvu *PackageVersionUpdate) RemovePoc(p ...*PointOfContact) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pvu.RemovePocIDs(ids...)
}

// ClearCertifyLegal clears all "certify_legal" edges to the CertifyLegal entity.
func (pvu *PackageVersionUpdate) ClearCertifyLegal() *PackageVersionUpdate {
	pvu.mutation.ClearCertifyLegal()
	return pvu
}

// RemoveCertifyLegalIDs removes the "certify_legal" edge to CertifyLegal entities by IDs.
func (pvu *PackageVersionUpdate) RemoveCertifyLegalIDs(ids ...uuid.UUID) *PackageVersionUpdate {
	pvu.mutation.RemoveCertifyLegalIDs(ids...)
	return pvu
}

// RemoveCertifyLegal removes "certify_legal" edges to CertifyLegal entities.
func (pvu *PackageVersionUpdate) RemoveCertifyLegal(c ...*CertifyLegal) *PackageVersionUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvu.RemoveCertifyLegalIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (pvu *PackageVersionUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, pvu.sqlSave, pvu.mutation, pvu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (pvu *PackageVersionUpdate) SaveX(ctx context.Context) int {
	affected, err := pvu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (pvu *PackageVersionUpdate) Exec(ctx context.Context) error {
	_, err := pvu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (pvu *PackageVersionUpdate) ExecX(ctx context.Context) {
	if err := pvu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (pvu *PackageVersionUpdate) check() error {
	if pvu.mutation.NameCleared() && len(pvu.mutation.NameIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "PackageVersion.name"`)
	}
	return nil
}

func (pvu *PackageVersionUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := pvu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(packageversion.Table, packageversion.Columns, sqlgraph.NewFieldSpec(packageversion.FieldID, field.TypeUUID))
	if ps := pvu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := pvu.mutation.Version(); ok {
		_spec.SetField(packageversion.FieldVersion, field.TypeString, value)
	}
	if value, ok := pvu.mutation.Subpath(); ok {
		_spec.SetField(packageversion.FieldSubpath, field.TypeString, value)
	}
	if value, ok := pvu.mutation.Qualifiers(); ok {
		_spec.SetField(packageversion.FieldQualifiers, field.TypeJSON, value)
	}
	if value, ok := pvu.mutation.AppendedQualifiers(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, packageversion.FieldQualifiers, value)
		})
	}
	if pvu.mutation.QualifiersCleared() {
		_spec.ClearField(packageversion.FieldQualifiers, field.TypeJSON)
	}
	if value, ok := pvu.mutation.Hash(); ok {
		_spec.SetField(packageversion.FieldHash, field.TypeString, value)
	}
	if pvu.mutation.NameCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   packageversion.NameTable,
			Columns: []string{packageversion.NameColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(packagename.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.NameIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   packageversion.NameTable,
			Columns: []string{packageversion.NameColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(packagename.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.OccurrencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.OccurrencesTable,
			Columns: []string{packageversion.OccurrencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(occurrence.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedOccurrencesIDs(); len(nodes) > 0 && !pvu.mutation.OccurrencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.OccurrencesTable,
			Columns: []string{packageversion.OccurrencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(occurrence.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.OccurrencesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.OccurrencesTable,
			Columns: []string{packageversion.OccurrencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(occurrence.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.SbomCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.SbomTable,
			Columns: []string{packageversion.SbomColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedSbomIDs(); len(nodes) > 0 && !pvu.mutation.SbomCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.SbomTable,
			Columns: []string{packageversion.SbomColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.SbomIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.SbomTable,
			Columns: []string{packageversion.SbomColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.VulnCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VulnTable,
			Columns: []string{packageversion.VulnColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvuln.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedVulnIDs(); len(nodes) > 0 && !pvu.mutation.VulnCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VulnTable,
			Columns: []string{packageversion.VulnColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvuln.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.VulnIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VulnTable,
			Columns: []string{packageversion.VulnColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvuln.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.VexCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VexTable,
			Columns: []string{packageversion.VexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvex.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedVexIDs(); len(nodes) > 0 && !pvu.mutation.VexCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VexTable,
			Columns: []string{packageversion.VexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvex.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.VexIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VexTable,
			Columns: []string{packageversion.VexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvex.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.HasSourceAtCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.HasSourceAtTable,
			Columns: []string{packageversion.HasSourceAtColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hassourceat.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedHasSourceAtIDs(); len(nodes) > 0 && !pvu.mutation.HasSourceAtCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.HasSourceAtTable,
			Columns: []string{packageversion.HasSourceAtColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hassourceat.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.HasSourceAtIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.HasSourceAtTable,
			Columns: []string{packageversion.HasSourceAtColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hassourceat.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.CertificationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertificationTable,
			Columns: []string{packageversion.CertificationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certification.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedCertificationIDs(); len(nodes) > 0 && !pvu.mutation.CertificationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertificationTable,
			Columns: []string{packageversion.CertificationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certification.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.CertificationIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertificationTable,
			Columns: []string{packageversion.CertificationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certification.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.MetadataCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.MetadataTable,
			Columns: []string{packageversion.MetadataColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hasmetadata.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedMetadataIDs(); len(nodes) > 0 && !pvu.mutation.MetadataCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.MetadataTable,
			Columns: []string{packageversion.MetadataColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hasmetadata.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.MetadataIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.MetadataTable,
			Columns: []string{packageversion.MetadataColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hasmetadata.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.DependencyCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencyTable,
			Columns: []string{packageversion.DependencyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedDependencyIDs(); len(nodes) > 0 && !pvu.mutation.DependencyCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencyTable,
			Columns: []string{packageversion.DependencyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.DependencyIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencyTable,
			Columns: []string{packageversion.DependencyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.DependencySubjectCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencySubjectTable,
			Columns: []string{packageversion.DependencySubjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedDependencySubjectIDs(); len(nodes) > 0 && !pvu.mutation.DependencySubjectCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencySubjectTable,
			Columns: []string{packageversion.DependencySubjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.DependencySubjectIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencySubjectTable,
			Columns: []string{packageversion.DependencySubjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.IncludedInSbomsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   packageversion.IncludedInSbomsTable,
			Columns: packageversion.IncludedInSbomsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedIncludedInSbomsIDs(); len(nodes) > 0 && !pvu.mutation.IncludedInSbomsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   packageversion.IncludedInSbomsTable,
			Columns: packageversion.IncludedInSbomsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.IncludedInSbomsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   packageversion.IncludedInSbomsTable,
			Columns: packageversion.IncludedInSbomsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.PkgEqualPkgACleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgATable,
			Columns: []string{packageversion.PkgEqualPkgAColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedPkgEqualPkgAIDs(); len(nodes) > 0 && !pvu.mutation.PkgEqualPkgACleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgATable,
			Columns: []string{packageversion.PkgEqualPkgAColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.PkgEqualPkgAIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgATable,
			Columns: []string{packageversion.PkgEqualPkgAColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.PkgEqualPkgBCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgBTable,
			Columns: []string{packageversion.PkgEqualPkgBColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedPkgEqualPkgBIDs(); len(nodes) > 0 && !pvu.mutation.PkgEqualPkgBCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgBTable,
			Columns: []string{packageversion.PkgEqualPkgBColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.PkgEqualPkgBIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgBTable,
			Columns: []string{packageversion.PkgEqualPkgBColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.PocCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PocTable,
			Columns: []string{packageversion.PocColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pointofcontact.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedPocIDs(); len(nodes) > 0 && !pvu.mutation.PocCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PocTable,
			Columns: []string{packageversion.PocColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pointofcontact.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.PocIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PocTable,
			Columns: []string{packageversion.PocColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pointofcontact.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvu.mutation.CertifyLegalCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertifyLegalTable,
			Columns: []string{packageversion.CertifyLegalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifylegal.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.RemovedCertifyLegalIDs(); len(nodes) > 0 && !pvu.mutation.CertifyLegalCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertifyLegalTable,
			Columns: []string{packageversion.CertifyLegalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifylegal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvu.mutation.CertifyLegalIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertifyLegalTable,
			Columns: []string{packageversion.CertifyLegalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifylegal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, pvu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{packageversion.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	pvu.mutation.done = true
	return n, nil
}

// PackageVersionUpdateOne is the builder for updating a single PackageVersion entity.
type PackageVersionUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *PackageVersionMutation
}

// SetNameID sets the "name_id" field.
func (pvuo *PackageVersionUpdateOne) SetNameID(u uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.SetNameID(u)
	return pvuo
}

// SetNillableNameID sets the "name_id" field if the given value is not nil.
func (pvuo *PackageVersionUpdateOne) SetNillableNameID(u *uuid.UUID) *PackageVersionUpdateOne {
	if u != nil {
		pvuo.SetNameID(*u)
	}
	return pvuo
}

// SetVersion sets the "version" field.
func (pvuo *PackageVersionUpdateOne) SetVersion(s string) *PackageVersionUpdateOne {
	pvuo.mutation.SetVersion(s)
	return pvuo
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (pvuo *PackageVersionUpdateOne) SetNillableVersion(s *string) *PackageVersionUpdateOne {
	if s != nil {
		pvuo.SetVersion(*s)
	}
	return pvuo
}

// SetSubpath sets the "subpath" field.
func (pvuo *PackageVersionUpdateOne) SetSubpath(s string) *PackageVersionUpdateOne {
	pvuo.mutation.SetSubpath(s)
	return pvuo
}

// SetNillableSubpath sets the "subpath" field if the given value is not nil.
func (pvuo *PackageVersionUpdateOne) SetNillableSubpath(s *string) *PackageVersionUpdateOne {
	if s != nil {
		pvuo.SetSubpath(*s)
	}
	return pvuo
}

// SetQualifiers sets the "qualifiers" field.
func (pvuo *PackageVersionUpdateOne) SetQualifiers(mq []model.PackageQualifier) *PackageVersionUpdateOne {
	pvuo.mutation.SetQualifiers(mq)
	return pvuo
}

// AppendQualifiers appends mq to the "qualifiers" field.
func (pvuo *PackageVersionUpdateOne) AppendQualifiers(mq []model.PackageQualifier) *PackageVersionUpdateOne {
	pvuo.mutation.AppendQualifiers(mq)
	return pvuo
}

// ClearQualifiers clears the value of the "qualifiers" field.
func (pvuo *PackageVersionUpdateOne) ClearQualifiers() *PackageVersionUpdateOne {
	pvuo.mutation.ClearQualifiers()
	return pvuo
}

// SetHash sets the "hash" field.
func (pvuo *PackageVersionUpdateOne) SetHash(s string) *PackageVersionUpdateOne {
	pvuo.mutation.SetHash(s)
	return pvuo
}

// SetNillableHash sets the "hash" field if the given value is not nil.
func (pvuo *PackageVersionUpdateOne) SetNillableHash(s *string) *PackageVersionUpdateOne {
	if s != nil {
		pvuo.SetHash(*s)
	}
	return pvuo
}

// SetName sets the "name" edge to the PackageName entity.
func (pvuo *PackageVersionUpdateOne) SetName(p *PackageName) *PackageVersionUpdateOne {
	return pvuo.SetNameID(p.ID)
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddOccurrenceIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddOccurrenceIDs(ids...)
	return pvuo
}

// AddOccurrences adds the "occurrences" edges to the Occurrence entity.
func (pvuo *PackageVersionUpdateOne) AddOccurrences(o ...*Occurrence) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(o))
	for i := range o {
		ids[i] = o[i].ID
	}
	return pvuo.AddOccurrenceIDs(ids...)
}

// AddSbomIDs adds the "sbom" edge to the BillOfMaterials entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddSbomIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddSbomIDs(ids...)
	return pvuo
}

// AddSbom adds the "sbom" edges to the BillOfMaterials entity.
func (pvuo *PackageVersionUpdateOne) AddSbom(b ...*BillOfMaterials) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return pvuo.AddSbomIDs(ids...)
}

// AddVulnIDs adds the "vuln" edge to the CertifyVuln entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddVulnIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddVulnIDs(ids...)
	return pvuo
}

// AddVuln adds the "vuln" edges to the CertifyVuln entity.
func (pvuo *PackageVersionUpdateOne) AddVuln(c ...*CertifyVuln) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvuo.AddVulnIDs(ids...)
}

// AddVexIDs adds the "vex" edge to the CertifyVex entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddVexIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddVexIDs(ids...)
	return pvuo
}

// AddVex adds the "vex" edges to the CertifyVex entity.
func (pvuo *PackageVersionUpdateOne) AddVex(c ...*CertifyVex) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvuo.AddVexIDs(ids...)
}

// AddHasSourceAtIDs adds the "has_source_at" edge to the HasSourceAt entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddHasSourceAtIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddHasSourceAtIDs(ids...)
	return pvuo
}

// AddHasSourceAt adds the "has_source_at" edges to the HasSourceAt entity.
func (pvuo *PackageVersionUpdateOne) AddHasSourceAt(h ...*HasSourceAt) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return pvuo.AddHasSourceAtIDs(ids...)
}

// AddCertificationIDs adds the "certification" edge to the Certification entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddCertificationIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddCertificationIDs(ids...)
	return pvuo
}

// AddCertification adds the "certification" edges to the Certification entity.
func (pvuo *PackageVersionUpdateOne) AddCertification(c ...*Certification) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvuo.AddCertificationIDs(ids...)
}

// AddMetadatumIDs adds the "metadata" edge to the HasMetadata entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddMetadatumIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddMetadatumIDs(ids...)
	return pvuo
}

// AddMetadata adds the "metadata" edges to the HasMetadata entity.
func (pvuo *PackageVersionUpdateOne) AddMetadata(h ...*HasMetadata) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return pvuo.AddMetadatumIDs(ids...)
}

// AddDependencyIDs adds the "dependency" edge to the Dependency entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddDependencyIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddDependencyIDs(ids...)
	return pvuo
}

// AddDependency adds the "dependency" edges to the Dependency entity.
func (pvuo *PackageVersionUpdateOne) AddDependency(d ...*Dependency) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return pvuo.AddDependencyIDs(ids...)
}

// AddDependencySubjectIDs adds the "dependency_subject" edge to the Dependency entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddDependencySubjectIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddDependencySubjectIDs(ids...)
	return pvuo
}

// AddDependencySubject adds the "dependency_subject" edges to the Dependency entity.
func (pvuo *PackageVersionUpdateOne) AddDependencySubject(d ...*Dependency) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return pvuo.AddDependencySubjectIDs(ids...)
}

// AddIncludedInSbomIDs adds the "included_in_sboms" edge to the BillOfMaterials entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddIncludedInSbomIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddIncludedInSbomIDs(ids...)
	return pvuo
}

// AddIncludedInSboms adds the "included_in_sboms" edges to the BillOfMaterials entity.
func (pvuo *PackageVersionUpdateOne) AddIncludedInSboms(b ...*BillOfMaterials) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return pvuo.AddIncludedInSbomIDs(ids...)
}

// AddPkgEqualPkgAIDs adds the "pkg_equal_pkg_a" edge to the PkgEqual entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddPkgEqualPkgAIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddPkgEqualPkgAIDs(ids...)
	return pvuo
}

// AddPkgEqualPkgA adds the "pkg_equal_pkg_a" edges to the PkgEqual entity.
func (pvuo *PackageVersionUpdateOne) AddPkgEqualPkgA(p ...*PkgEqual) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pvuo.AddPkgEqualPkgAIDs(ids...)
}

// AddPkgEqualPkgBIDs adds the "pkg_equal_pkg_b" edge to the PkgEqual entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddPkgEqualPkgBIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddPkgEqualPkgBIDs(ids...)
	return pvuo
}

// AddPkgEqualPkgB adds the "pkg_equal_pkg_b" edges to the PkgEqual entity.
func (pvuo *PackageVersionUpdateOne) AddPkgEqualPkgB(p ...*PkgEqual) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pvuo.AddPkgEqualPkgBIDs(ids...)
}

// AddPocIDs adds the "poc" edge to the PointOfContact entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddPocIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddPocIDs(ids...)
	return pvuo
}

// AddPoc adds the "poc" edges to the PointOfContact entity.
func (pvuo *PackageVersionUpdateOne) AddPoc(p ...*PointOfContact) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pvuo.AddPocIDs(ids...)
}

// AddCertifyLegalIDs adds the "certify_legal" edge to the CertifyLegal entity by IDs.
func (pvuo *PackageVersionUpdateOne) AddCertifyLegalIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.AddCertifyLegalIDs(ids...)
	return pvuo
}

// AddCertifyLegal adds the "certify_legal" edges to the CertifyLegal entity.
func (pvuo *PackageVersionUpdateOne) AddCertifyLegal(c ...*CertifyLegal) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvuo.AddCertifyLegalIDs(ids...)
}

// Mutation returns the PackageVersionMutation object of the builder.
func (pvuo *PackageVersionUpdateOne) Mutation() *PackageVersionMutation {
	return pvuo.mutation
}

// ClearName clears the "name" edge to the PackageName entity.
func (pvuo *PackageVersionUpdateOne) ClearName() *PackageVersionUpdateOne {
	pvuo.mutation.ClearName()
	return pvuo
}

// ClearOccurrences clears all "occurrences" edges to the Occurrence entity.
func (pvuo *PackageVersionUpdateOne) ClearOccurrences() *PackageVersionUpdateOne {
	pvuo.mutation.ClearOccurrences()
	return pvuo
}

// RemoveOccurrenceIDs removes the "occurrences" edge to Occurrence entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemoveOccurrenceIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemoveOccurrenceIDs(ids...)
	return pvuo
}

// RemoveOccurrences removes "occurrences" edges to Occurrence entities.
func (pvuo *PackageVersionUpdateOne) RemoveOccurrences(o ...*Occurrence) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(o))
	for i := range o {
		ids[i] = o[i].ID
	}
	return pvuo.RemoveOccurrenceIDs(ids...)
}

// ClearSbom clears all "sbom" edges to the BillOfMaterials entity.
func (pvuo *PackageVersionUpdateOne) ClearSbom() *PackageVersionUpdateOne {
	pvuo.mutation.ClearSbom()
	return pvuo
}

// RemoveSbomIDs removes the "sbom" edge to BillOfMaterials entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemoveSbomIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemoveSbomIDs(ids...)
	return pvuo
}

// RemoveSbom removes "sbom" edges to BillOfMaterials entities.
func (pvuo *PackageVersionUpdateOne) RemoveSbom(b ...*BillOfMaterials) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return pvuo.RemoveSbomIDs(ids...)
}

// ClearVuln clears all "vuln" edges to the CertifyVuln entity.
func (pvuo *PackageVersionUpdateOne) ClearVuln() *PackageVersionUpdateOne {
	pvuo.mutation.ClearVuln()
	return pvuo
}

// RemoveVulnIDs removes the "vuln" edge to CertifyVuln entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemoveVulnIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemoveVulnIDs(ids...)
	return pvuo
}

// RemoveVuln removes "vuln" edges to CertifyVuln entities.
func (pvuo *PackageVersionUpdateOne) RemoveVuln(c ...*CertifyVuln) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvuo.RemoveVulnIDs(ids...)
}

// ClearVex clears all "vex" edges to the CertifyVex entity.
func (pvuo *PackageVersionUpdateOne) ClearVex() *PackageVersionUpdateOne {
	pvuo.mutation.ClearVex()
	return pvuo
}

// RemoveVexIDs removes the "vex" edge to CertifyVex entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemoveVexIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemoveVexIDs(ids...)
	return pvuo
}

// RemoveVex removes "vex" edges to CertifyVex entities.
func (pvuo *PackageVersionUpdateOne) RemoveVex(c ...*CertifyVex) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvuo.RemoveVexIDs(ids...)
}

// ClearHasSourceAt clears all "has_source_at" edges to the HasSourceAt entity.
func (pvuo *PackageVersionUpdateOne) ClearHasSourceAt() *PackageVersionUpdateOne {
	pvuo.mutation.ClearHasSourceAt()
	return pvuo
}

// RemoveHasSourceAtIDs removes the "has_source_at" edge to HasSourceAt entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemoveHasSourceAtIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemoveHasSourceAtIDs(ids...)
	return pvuo
}

// RemoveHasSourceAt removes "has_source_at" edges to HasSourceAt entities.
func (pvuo *PackageVersionUpdateOne) RemoveHasSourceAt(h ...*HasSourceAt) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return pvuo.RemoveHasSourceAtIDs(ids...)
}

// ClearCertification clears all "certification" edges to the Certification entity.
func (pvuo *PackageVersionUpdateOne) ClearCertification() *PackageVersionUpdateOne {
	pvuo.mutation.ClearCertification()
	return pvuo
}

// RemoveCertificationIDs removes the "certification" edge to Certification entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemoveCertificationIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemoveCertificationIDs(ids...)
	return pvuo
}

// RemoveCertification removes "certification" edges to Certification entities.
func (pvuo *PackageVersionUpdateOne) RemoveCertification(c ...*Certification) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvuo.RemoveCertificationIDs(ids...)
}

// ClearMetadata clears all "metadata" edges to the HasMetadata entity.
func (pvuo *PackageVersionUpdateOne) ClearMetadata() *PackageVersionUpdateOne {
	pvuo.mutation.ClearMetadata()
	return pvuo
}

// RemoveMetadatumIDs removes the "metadata" edge to HasMetadata entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemoveMetadatumIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemoveMetadatumIDs(ids...)
	return pvuo
}

// RemoveMetadata removes "metadata" edges to HasMetadata entities.
func (pvuo *PackageVersionUpdateOne) RemoveMetadata(h ...*HasMetadata) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return pvuo.RemoveMetadatumIDs(ids...)
}

// ClearDependency clears all "dependency" edges to the Dependency entity.
func (pvuo *PackageVersionUpdateOne) ClearDependency() *PackageVersionUpdateOne {
	pvuo.mutation.ClearDependency()
	return pvuo
}

// RemoveDependencyIDs removes the "dependency" edge to Dependency entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemoveDependencyIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemoveDependencyIDs(ids...)
	return pvuo
}

// RemoveDependency removes "dependency" edges to Dependency entities.
func (pvuo *PackageVersionUpdateOne) RemoveDependency(d ...*Dependency) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return pvuo.RemoveDependencyIDs(ids...)
}

// ClearDependencySubject clears all "dependency_subject" edges to the Dependency entity.
func (pvuo *PackageVersionUpdateOne) ClearDependencySubject() *PackageVersionUpdateOne {
	pvuo.mutation.ClearDependencySubject()
	return pvuo
}

// RemoveDependencySubjectIDs removes the "dependency_subject" edge to Dependency entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemoveDependencySubjectIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemoveDependencySubjectIDs(ids...)
	return pvuo
}

// RemoveDependencySubject removes "dependency_subject" edges to Dependency entities.
func (pvuo *PackageVersionUpdateOne) RemoveDependencySubject(d ...*Dependency) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return pvuo.RemoveDependencySubjectIDs(ids...)
}

// ClearIncludedInSboms clears all "included_in_sboms" edges to the BillOfMaterials entity.
func (pvuo *PackageVersionUpdateOne) ClearIncludedInSboms() *PackageVersionUpdateOne {
	pvuo.mutation.ClearIncludedInSboms()
	return pvuo
}

// RemoveIncludedInSbomIDs removes the "included_in_sboms" edge to BillOfMaterials entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemoveIncludedInSbomIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemoveIncludedInSbomIDs(ids...)
	return pvuo
}

// RemoveIncludedInSboms removes "included_in_sboms" edges to BillOfMaterials entities.
func (pvuo *PackageVersionUpdateOne) RemoveIncludedInSboms(b ...*BillOfMaterials) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return pvuo.RemoveIncludedInSbomIDs(ids...)
}

// ClearPkgEqualPkgA clears all "pkg_equal_pkg_a" edges to the PkgEqual entity.
func (pvuo *PackageVersionUpdateOne) ClearPkgEqualPkgA() *PackageVersionUpdateOne {
	pvuo.mutation.ClearPkgEqualPkgA()
	return pvuo
}

// RemovePkgEqualPkgAIDs removes the "pkg_equal_pkg_a" edge to PkgEqual entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemovePkgEqualPkgAIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemovePkgEqualPkgAIDs(ids...)
	return pvuo
}

// RemovePkgEqualPkgA removes "pkg_equal_pkg_a" edges to PkgEqual entities.
func (pvuo *PackageVersionUpdateOne) RemovePkgEqualPkgA(p ...*PkgEqual) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pvuo.RemovePkgEqualPkgAIDs(ids...)
}

// ClearPkgEqualPkgB clears all "pkg_equal_pkg_b" edges to the PkgEqual entity.
func (pvuo *PackageVersionUpdateOne) ClearPkgEqualPkgB() *PackageVersionUpdateOne {
	pvuo.mutation.ClearPkgEqualPkgB()
	return pvuo
}

// RemovePkgEqualPkgBIDs removes the "pkg_equal_pkg_b" edge to PkgEqual entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemovePkgEqualPkgBIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemovePkgEqualPkgBIDs(ids...)
	return pvuo
}

// RemovePkgEqualPkgB removes "pkg_equal_pkg_b" edges to PkgEqual entities.
func (pvuo *PackageVersionUpdateOne) RemovePkgEqualPkgB(p ...*PkgEqual) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pvuo.RemovePkgEqualPkgBIDs(ids...)
}

// ClearPoc clears all "poc" edges to the PointOfContact entity.
func (pvuo *PackageVersionUpdateOne) ClearPoc() *PackageVersionUpdateOne {
	pvuo.mutation.ClearPoc()
	return pvuo
}

// RemovePocIDs removes the "poc" edge to PointOfContact entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemovePocIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemovePocIDs(ids...)
	return pvuo
}

// RemovePoc removes "poc" edges to PointOfContact entities.
func (pvuo *PackageVersionUpdateOne) RemovePoc(p ...*PointOfContact) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return pvuo.RemovePocIDs(ids...)
}

// ClearCertifyLegal clears all "certify_legal" edges to the CertifyLegal entity.
func (pvuo *PackageVersionUpdateOne) ClearCertifyLegal() *PackageVersionUpdateOne {
	pvuo.mutation.ClearCertifyLegal()
	return pvuo
}

// RemoveCertifyLegalIDs removes the "certify_legal" edge to CertifyLegal entities by IDs.
func (pvuo *PackageVersionUpdateOne) RemoveCertifyLegalIDs(ids ...uuid.UUID) *PackageVersionUpdateOne {
	pvuo.mutation.RemoveCertifyLegalIDs(ids...)
	return pvuo
}

// RemoveCertifyLegal removes "certify_legal" edges to CertifyLegal entities.
func (pvuo *PackageVersionUpdateOne) RemoveCertifyLegal(c ...*CertifyLegal) *PackageVersionUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return pvuo.RemoveCertifyLegalIDs(ids...)
}

// Where appends a list predicates to the PackageVersionUpdate builder.
func (pvuo *PackageVersionUpdateOne) Where(ps ...predicate.PackageVersion) *PackageVersionUpdateOne {
	pvuo.mutation.Where(ps...)
	return pvuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (pvuo *PackageVersionUpdateOne) Select(field string, fields ...string) *PackageVersionUpdateOne {
	pvuo.fields = append([]string{field}, fields...)
	return pvuo
}

// Save executes the query and returns the updated PackageVersion entity.
func (pvuo *PackageVersionUpdateOne) Save(ctx context.Context) (*PackageVersion, error) {
	return withHooks(ctx, pvuo.sqlSave, pvuo.mutation, pvuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (pvuo *PackageVersionUpdateOne) SaveX(ctx context.Context) *PackageVersion {
	node, err := pvuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (pvuo *PackageVersionUpdateOne) Exec(ctx context.Context) error {
	_, err := pvuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (pvuo *PackageVersionUpdateOne) ExecX(ctx context.Context) {
	if err := pvuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (pvuo *PackageVersionUpdateOne) check() error {
	if pvuo.mutation.NameCleared() && len(pvuo.mutation.NameIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "PackageVersion.name"`)
	}
	return nil
}

func (pvuo *PackageVersionUpdateOne) sqlSave(ctx context.Context) (_node *PackageVersion, err error) {
	if err := pvuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(packageversion.Table, packageversion.Columns, sqlgraph.NewFieldSpec(packageversion.FieldID, field.TypeUUID))
	id, ok := pvuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "PackageVersion.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := pvuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, packageversion.FieldID)
		for _, f := range fields {
			if !packageversion.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != packageversion.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := pvuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := pvuo.mutation.Version(); ok {
		_spec.SetField(packageversion.FieldVersion, field.TypeString, value)
	}
	if value, ok := pvuo.mutation.Subpath(); ok {
		_spec.SetField(packageversion.FieldSubpath, field.TypeString, value)
	}
	if value, ok := pvuo.mutation.Qualifiers(); ok {
		_spec.SetField(packageversion.FieldQualifiers, field.TypeJSON, value)
	}
	if value, ok := pvuo.mutation.AppendedQualifiers(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, packageversion.FieldQualifiers, value)
		})
	}
	if pvuo.mutation.QualifiersCleared() {
		_spec.ClearField(packageversion.FieldQualifiers, field.TypeJSON)
	}
	if value, ok := pvuo.mutation.Hash(); ok {
		_spec.SetField(packageversion.FieldHash, field.TypeString, value)
	}
	if pvuo.mutation.NameCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   packageversion.NameTable,
			Columns: []string{packageversion.NameColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(packagename.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.NameIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   packageversion.NameTable,
			Columns: []string{packageversion.NameColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(packagename.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.OccurrencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.OccurrencesTable,
			Columns: []string{packageversion.OccurrencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(occurrence.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedOccurrencesIDs(); len(nodes) > 0 && !pvuo.mutation.OccurrencesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.OccurrencesTable,
			Columns: []string{packageversion.OccurrencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(occurrence.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.OccurrencesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.OccurrencesTable,
			Columns: []string{packageversion.OccurrencesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(occurrence.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.SbomCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.SbomTable,
			Columns: []string{packageversion.SbomColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedSbomIDs(); len(nodes) > 0 && !pvuo.mutation.SbomCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.SbomTable,
			Columns: []string{packageversion.SbomColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.SbomIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.SbomTable,
			Columns: []string{packageversion.SbomColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.VulnCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VulnTable,
			Columns: []string{packageversion.VulnColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvuln.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedVulnIDs(); len(nodes) > 0 && !pvuo.mutation.VulnCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VulnTable,
			Columns: []string{packageversion.VulnColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvuln.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.VulnIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VulnTable,
			Columns: []string{packageversion.VulnColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvuln.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.VexCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VexTable,
			Columns: []string{packageversion.VexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvex.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedVexIDs(); len(nodes) > 0 && !pvuo.mutation.VexCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VexTable,
			Columns: []string{packageversion.VexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvex.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.VexIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.VexTable,
			Columns: []string{packageversion.VexColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifyvex.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.HasSourceAtCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.HasSourceAtTable,
			Columns: []string{packageversion.HasSourceAtColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hassourceat.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedHasSourceAtIDs(); len(nodes) > 0 && !pvuo.mutation.HasSourceAtCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.HasSourceAtTable,
			Columns: []string{packageversion.HasSourceAtColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hassourceat.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.HasSourceAtIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.HasSourceAtTable,
			Columns: []string{packageversion.HasSourceAtColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hassourceat.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.CertificationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertificationTable,
			Columns: []string{packageversion.CertificationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certification.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedCertificationIDs(); len(nodes) > 0 && !pvuo.mutation.CertificationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertificationTable,
			Columns: []string{packageversion.CertificationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certification.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.CertificationIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertificationTable,
			Columns: []string{packageversion.CertificationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certification.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.MetadataCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.MetadataTable,
			Columns: []string{packageversion.MetadataColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hasmetadata.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedMetadataIDs(); len(nodes) > 0 && !pvuo.mutation.MetadataCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.MetadataTable,
			Columns: []string{packageversion.MetadataColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hasmetadata.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.MetadataIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.MetadataTable,
			Columns: []string{packageversion.MetadataColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(hasmetadata.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.DependencyCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencyTable,
			Columns: []string{packageversion.DependencyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedDependencyIDs(); len(nodes) > 0 && !pvuo.mutation.DependencyCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencyTable,
			Columns: []string{packageversion.DependencyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.DependencyIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencyTable,
			Columns: []string{packageversion.DependencyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.DependencySubjectCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencySubjectTable,
			Columns: []string{packageversion.DependencySubjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedDependencySubjectIDs(); len(nodes) > 0 && !pvuo.mutation.DependencySubjectCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencySubjectTable,
			Columns: []string{packageversion.DependencySubjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.DependencySubjectIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.DependencySubjectTable,
			Columns: []string{packageversion.DependencySubjectColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(dependency.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.IncludedInSbomsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   packageversion.IncludedInSbomsTable,
			Columns: packageversion.IncludedInSbomsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedIncludedInSbomsIDs(); len(nodes) > 0 && !pvuo.mutation.IncludedInSbomsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   packageversion.IncludedInSbomsTable,
			Columns: packageversion.IncludedInSbomsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.IncludedInSbomsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   packageversion.IncludedInSbomsTable,
			Columns: packageversion.IncludedInSbomsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billofmaterials.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.PkgEqualPkgACleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgATable,
			Columns: []string{packageversion.PkgEqualPkgAColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedPkgEqualPkgAIDs(); len(nodes) > 0 && !pvuo.mutation.PkgEqualPkgACleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgATable,
			Columns: []string{packageversion.PkgEqualPkgAColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.PkgEqualPkgAIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgATable,
			Columns: []string{packageversion.PkgEqualPkgAColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.PkgEqualPkgBCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgBTable,
			Columns: []string{packageversion.PkgEqualPkgBColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedPkgEqualPkgBIDs(); len(nodes) > 0 && !pvuo.mutation.PkgEqualPkgBCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgBTable,
			Columns: []string{packageversion.PkgEqualPkgBColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.PkgEqualPkgBIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PkgEqualPkgBTable,
			Columns: []string{packageversion.PkgEqualPkgBColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pkgequal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.PocCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PocTable,
			Columns: []string{packageversion.PocColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pointofcontact.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedPocIDs(); len(nodes) > 0 && !pvuo.mutation.PocCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PocTable,
			Columns: []string{packageversion.PocColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pointofcontact.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.PocIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.PocTable,
			Columns: []string{packageversion.PocColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(pointofcontact.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if pvuo.mutation.CertifyLegalCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertifyLegalTable,
			Columns: []string{packageversion.CertifyLegalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifylegal.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.RemovedCertifyLegalIDs(); len(nodes) > 0 && !pvuo.mutation.CertifyLegalCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertifyLegalTable,
			Columns: []string{packageversion.CertifyLegalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifylegal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := pvuo.mutation.CertifyLegalIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   packageversion.CertifyLegalTable,
			Columns: []string{packageversion.CertifyLegalColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(certifylegal.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &PackageVersion{config: pvuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, pvuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{packageversion.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	pvuo.mutation.done = true
	return _node, nil
}
