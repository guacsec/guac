// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/artifact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/billofmaterials"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/builder"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certification"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifylegal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyscorecard"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvex"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvuln"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/dependency"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hashequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hassourceat"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/isvulnerability"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/license"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/occurrence"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagetype"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pkgequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/scorecard"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/slsaattestation"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcetype"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilityid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilitytype"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *ArtifactQuery) CollectFields(ctx context.Context, satisfies ...string) (*ArtifactQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if err := a.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return a, nil
}

func (a *ArtifactQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(artifact.Columns))
		selectedFields = []string{artifact.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "occurrences":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OccurrenceClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			a.WithNamedOccurrences(alias, func(wq *OccurrenceQuery) {
				*wq = *query
			})
		case "sbom":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BillOfMaterialsClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			a.WithNamedSbom(alias, func(wq *BillOfMaterialsQuery) {
				*wq = *query
			})
		case "attestations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SLSAAttestationClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			a.WithNamedAttestations(alias, func(wq *SLSAAttestationQuery) {
				*wq = *query
			})
		case "same":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HashEqualClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			a.WithNamedSame(alias, func(wq *HashEqualQuery) {
				*wq = *query
			})
		case "algorithm":
			if _, ok := fieldSeen[artifact.FieldAlgorithm]; !ok {
				selectedFields = append(selectedFields, artifact.FieldAlgorithm)
				fieldSeen[artifact.FieldAlgorithm] = struct{}{}
			}
		case "digest":
			if _, ok := fieldSeen[artifact.FieldDigest]; !ok {
				selectedFields = append(selectedFields, artifact.FieldDigest)
				fieldSeen[artifact.FieldDigest] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		a.Select(selectedFields...)
	}
	return nil
}

type artifactPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ArtifactPaginateOption
}

func newArtifactPaginateArgs(rv map[string]any) *artifactPaginateArgs {
	args := &artifactPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (bom *BillOfMaterialsQuery) CollectFields(ctx context.Context, satisfies ...string) (*BillOfMaterialsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return bom, nil
	}
	if err := bom.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return bom, nil
}

func (bom *BillOfMaterialsQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(billofmaterials.Columns))
		selectedFields = []string{billofmaterials.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "package":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageVersionClient{config: bom.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			bom.withPackage = query
			if _, ok := fieldSeen[billofmaterials.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, billofmaterials.FieldPackageID)
				fieldSeen[billofmaterials.FieldPackageID] = struct{}{}
			}
		case "artifact":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: bom.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			bom.withArtifact = query
			if _, ok := fieldSeen[billofmaterials.FieldArtifactID]; !ok {
				selectedFields = append(selectedFields, billofmaterials.FieldArtifactID)
				fieldSeen[billofmaterials.FieldArtifactID] = struct{}{}
			}
		case "packageID":
			if _, ok := fieldSeen[billofmaterials.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, billofmaterials.FieldPackageID)
				fieldSeen[billofmaterials.FieldPackageID] = struct{}{}
			}
		case "artifactID":
			if _, ok := fieldSeen[billofmaterials.FieldArtifactID]; !ok {
				selectedFields = append(selectedFields, billofmaterials.FieldArtifactID)
				fieldSeen[billofmaterials.FieldArtifactID] = struct{}{}
			}
		case "uri":
			if _, ok := fieldSeen[billofmaterials.FieldURI]; !ok {
				selectedFields = append(selectedFields, billofmaterials.FieldURI)
				fieldSeen[billofmaterials.FieldURI] = struct{}{}
			}
		case "algorithm":
			if _, ok := fieldSeen[billofmaterials.FieldAlgorithm]; !ok {
				selectedFields = append(selectedFields, billofmaterials.FieldAlgorithm)
				fieldSeen[billofmaterials.FieldAlgorithm] = struct{}{}
			}
		case "digest":
			if _, ok := fieldSeen[billofmaterials.FieldDigest]; !ok {
				selectedFields = append(selectedFields, billofmaterials.FieldDigest)
				fieldSeen[billofmaterials.FieldDigest] = struct{}{}
			}
		case "downloadLocation":
			if _, ok := fieldSeen[billofmaterials.FieldDownloadLocation]; !ok {
				selectedFields = append(selectedFields, billofmaterials.FieldDownloadLocation)
				fieldSeen[billofmaterials.FieldDownloadLocation] = struct{}{}
			}
		case "origin":
			if _, ok := fieldSeen[billofmaterials.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, billofmaterials.FieldOrigin)
				fieldSeen[billofmaterials.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[billofmaterials.FieldCollector]; !ok {
				selectedFields = append(selectedFields, billofmaterials.FieldCollector)
				fieldSeen[billofmaterials.FieldCollector] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		bom.Select(selectedFields...)
	}
	return nil
}

type billofmaterialsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BillOfMaterialsPaginateOption
}

func newBillOfMaterialsPaginateArgs(rv map[string]any) *billofmaterialsPaginateArgs {
	args := &billofmaterialsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (b *BuilderQuery) CollectFields(ctx context.Context, satisfies ...string) (*BuilderQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return b, nil
	}
	if err := b.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return b, nil
}

func (b *BuilderQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(builder.Columns))
		selectedFields = []string{builder.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "slsaAttestations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SLSAAttestationClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedSlsaAttestations(alias, func(wq *SLSAAttestationQuery) {
				*wq = *query
			})
		case "uri":
			if _, ok := fieldSeen[builder.FieldURI]; !ok {
				selectedFields = append(selectedFields, builder.FieldURI)
				fieldSeen[builder.FieldURI] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		b.Select(selectedFields...)
	}
	return nil
}

type builderPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BuilderPaginateOption
}

func newBuilderPaginateArgs(rv map[string]any) *builderPaginateArgs {
	args := &builderPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CertificationQuery) CollectFields(ctx context.Context, satisfies ...string) (*CertificationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CertificationQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(certification.Columns))
		selectedFields = []string{certification.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "source":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SourceNameClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.withSource = query
			if _, ok := fieldSeen[certification.FieldSourceID]; !ok {
				selectedFields = append(selectedFields, certification.FieldSourceID)
				fieldSeen[certification.FieldSourceID] = struct{}{}
			}
		case "packageVersion":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageVersionClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.withPackageVersion = query
			if _, ok := fieldSeen[certification.FieldPackageVersionID]; !ok {
				selectedFields = append(selectedFields, certification.FieldPackageVersionID)
				fieldSeen[certification.FieldPackageVersionID] = struct{}{}
			}
		case "allVersions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageNameClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.withAllVersions = query
			if _, ok := fieldSeen[certification.FieldPackageNameID]; !ok {
				selectedFields = append(selectedFields, certification.FieldPackageNameID)
				fieldSeen[certification.FieldPackageNameID] = struct{}{}
			}
		case "artifact":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.withArtifact = query
			if _, ok := fieldSeen[certification.FieldArtifactID]; !ok {
				selectedFields = append(selectedFields, certification.FieldArtifactID)
				fieldSeen[certification.FieldArtifactID] = struct{}{}
			}
		case "sourceID":
			if _, ok := fieldSeen[certification.FieldSourceID]; !ok {
				selectedFields = append(selectedFields, certification.FieldSourceID)
				fieldSeen[certification.FieldSourceID] = struct{}{}
			}
		case "packageVersionID":
			if _, ok := fieldSeen[certification.FieldPackageVersionID]; !ok {
				selectedFields = append(selectedFields, certification.FieldPackageVersionID)
				fieldSeen[certification.FieldPackageVersionID] = struct{}{}
			}
		case "packageNameID":
			if _, ok := fieldSeen[certification.FieldPackageNameID]; !ok {
				selectedFields = append(selectedFields, certification.FieldPackageNameID)
				fieldSeen[certification.FieldPackageNameID] = struct{}{}
			}
		case "artifactID":
			if _, ok := fieldSeen[certification.FieldArtifactID]; !ok {
				selectedFields = append(selectedFields, certification.FieldArtifactID)
				fieldSeen[certification.FieldArtifactID] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[certification.FieldType]; !ok {
				selectedFields = append(selectedFields, certification.FieldType)
				fieldSeen[certification.FieldType] = struct{}{}
			}
		case "justification":
			if _, ok := fieldSeen[certification.FieldJustification]; !ok {
				selectedFields = append(selectedFields, certification.FieldJustification)
				fieldSeen[certification.FieldJustification] = struct{}{}
			}
		case "origin":
			if _, ok := fieldSeen[certification.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, certification.FieldOrigin)
				fieldSeen[certification.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[certification.FieldCollector]; !ok {
				selectedFields = append(selectedFields, certification.FieldCollector)
				fieldSeen[certification.FieldCollector] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type certificationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CertificationPaginateOption
}

func newCertificationPaginateArgs(rv map[string]any) *certificationPaginateArgs {
	args := &certificationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cl *CertifyLegalQuery) CollectFields(ctx context.Context, satisfies ...string) (*CertifyLegalQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cl, nil
	}
	if err := cl.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cl, nil
}

func (cl *CertifyLegalQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(certifylegal.Columns))
		selectedFields = []string{certifylegal.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "package":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageVersionClient{config: cl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cl.withPackage = query
			if _, ok := fieldSeen[certifylegal.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, certifylegal.FieldPackageID)
				fieldSeen[certifylegal.FieldPackageID] = struct{}{}
			}
		case "source":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SourceNameClient{config: cl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cl.withSource = query
			if _, ok := fieldSeen[certifylegal.FieldSourceID]; !ok {
				selectedFields = append(selectedFields, certifylegal.FieldSourceID)
				fieldSeen[certifylegal.FieldSourceID] = struct{}{}
			}
		case "declaredLicenses":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LicenseClient{config: cl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cl.WithNamedDeclaredLicenses(alias, func(wq *LicenseQuery) {
				*wq = *query
			})
		case "discoveredLicenses":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LicenseClient{config: cl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cl.WithNamedDiscoveredLicenses(alias, func(wq *LicenseQuery) {
				*wq = *query
			})
		case "packageID":
			if _, ok := fieldSeen[certifylegal.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, certifylegal.FieldPackageID)
				fieldSeen[certifylegal.FieldPackageID] = struct{}{}
			}
		case "sourceID":
			if _, ok := fieldSeen[certifylegal.FieldSourceID]; !ok {
				selectedFields = append(selectedFields, certifylegal.FieldSourceID)
				fieldSeen[certifylegal.FieldSourceID] = struct{}{}
			}
		case "declaredLicense":
			if _, ok := fieldSeen[certifylegal.FieldDeclaredLicense]; !ok {
				selectedFields = append(selectedFields, certifylegal.FieldDeclaredLicense)
				fieldSeen[certifylegal.FieldDeclaredLicense] = struct{}{}
			}
		case "discoveredLicense":
			if _, ok := fieldSeen[certifylegal.FieldDiscoveredLicense]; !ok {
				selectedFields = append(selectedFields, certifylegal.FieldDiscoveredLicense)
				fieldSeen[certifylegal.FieldDiscoveredLicense] = struct{}{}
			}
		case "attribution":
			if _, ok := fieldSeen[certifylegal.FieldAttribution]; !ok {
				selectedFields = append(selectedFields, certifylegal.FieldAttribution)
				fieldSeen[certifylegal.FieldAttribution] = struct{}{}
			}
		case "justification":
			if _, ok := fieldSeen[certifylegal.FieldJustification]; !ok {
				selectedFields = append(selectedFields, certifylegal.FieldJustification)
				fieldSeen[certifylegal.FieldJustification] = struct{}{}
			}
		case "timeScanned":
			if _, ok := fieldSeen[certifylegal.FieldTimeScanned]; !ok {
				selectedFields = append(selectedFields, certifylegal.FieldTimeScanned)
				fieldSeen[certifylegal.FieldTimeScanned] = struct{}{}
			}
		case "origin":
			if _, ok := fieldSeen[certifylegal.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, certifylegal.FieldOrigin)
				fieldSeen[certifylegal.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[certifylegal.FieldCollector]; !ok {
				selectedFields = append(selectedFields, certifylegal.FieldCollector)
				fieldSeen[certifylegal.FieldCollector] = struct{}{}
			}
		case "declaredLicensesHash":
			if _, ok := fieldSeen[certifylegal.FieldDeclaredLicensesHash]; !ok {
				selectedFields = append(selectedFields, certifylegal.FieldDeclaredLicensesHash)
				fieldSeen[certifylegal.FieldDeclaredLicensesHash] = struct{}{}
			}
		case "discoveredLicensesHash":
			if _, ok := fieldSeen[certifylegal.FieldDiscoveredLicensesHash]; !ok {
				selectedFields = append(selectedFields, certifylegal.FieldDiscoveredLicensesHash)
				fieldSeen[certifylegal.FieldDiscoveredLicensesHash] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cl.Select(selectedFields...)
	}
	return nil
}

type certifylegalPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CertifyLegalPaginateOption
}

func newCertifyLegalPaginateArgs(rv map[string]any) *certifylegalPaginateArgs {
	args := &certifylegalPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cs *CertifyScorecardQuery) CollectFields(ctx context.Context, satisfies ...string) (*CertifyScorecardQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cs, nil
	}
	if err := cs.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cs, nil
}

func (cs *CertifyScorecardQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(certifyscorecard.Columns))
		selectedFields = []string{certifyscorecard.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "scorecard":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ScorecardClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cs.withScorecard = query
			if _, ok := fieldSeen[certifyscorecard.FieldScorecardID]; !ok {
				selectedFields = append(selectedFields, certifyscorecard.FieldScorecardID)
				fieldSeen[certifyscorecard.FieldScorecardID] = struct{}{}
			}
		case "source":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SourceNameClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cs.withSource = query
			if _, ok := fieldSeen[certifyscorecard.FieldSourceID]; !ok {
				selectedFields = append(selectedFields, certifyscorecard.FieldSourceID)
				fieldSeen[certifyscorecard.FieldSourceID] = struct{}{}
			}
		case "sourceID":
			if _, ok := fieldSeen[certifyscorecard.FieldSourceID]; !ok {
				selectedFields = append(selectedFields, certifyscorecard.FieldSourceID)
				fieldSeen[certifyscorecard.FieldSourceID] = struct{}{}
			}
		case "scorecardID":
			if _, ok := fieldSeen[certifyscorecard.FieldScorecardID]; !ok {
				selectedFields = append(selectedFields, certifyscorecard.FieldScorecardID)
				fieldSeen[certifyscorecard.FieldScorecardID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cs.Select(selectedFields...)
	}
	return nil
}

type certifyscorecardPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CertifyScorecardPaginateOption
}

func newCertifyScorecardPaginateArgs(rv map[string]any) *certifyscorecardPaginateArgs {
	args := &certifyscorecardPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cv *CertifyVexQuery) CollectFields(ctx context.Context, satisfies ...string) (*CertifyVexQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cv, nil
	}
	if err := cv.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cv, nil
}

func (cv *CertifyVexQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(certifyvex.Columns))
		selectedFields = []string{certifyvex.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "package":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageVersionClient{config: cv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cv.withPackage = query
			if _, ok := fieldSeen[certifyvex.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, certifyvex.FieldPackageID)
				fieldSeen[certifyvex.FieldPackageID] = struct{}{}
			}
		case "artifact":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: cv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cv.withArtifact = query
			if _, ok := fieldSeen[certifyvex.FieldArtifactID]; !ok {
				selectedFields = append(selectedFields, certifyvex.FieldArtifactID)
				fieldSeen[certifyvex.FieldArtifactID] = struct{}{}
			}
		case "vulnerability":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&VulnerabilityTypeClient{config: cv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cv.withVulnerability = query
			if _, ok := fieldSeen[certifyvex.FieldVulnerabilityID]; !ok {
				selectedFields = append(selectedFields, certifyvex.FieldVulnerabilityID)
				fieldSeen[certifyvex.FieldVulnerabilityID] = struct{}{}
			}
		case "packageID":
			if _, ok := fieldSeen[certifyvex.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, certifyvex.FieldPackageID)
				fieldSeen[certifyvex.FieldPackageID] = struct{}{}
			}
		case "artifactID":
			if _, ok := fieldSeen[certifyvex.FieldArtifactID]; !ok {
				selectedFields = append(selectedFields, certifyvex.FieldArtifactID)
				fieldSeen[certifyvex.FieldArtifactID] = struct{}{}
			}
		case "vulnerabilityID":
			if _, ok := fieldSeen[certifyvex.FieldVulnerabilityID]; !ok {
				selectedFields = append(selectedFields, certifyvex.FieldVulnerabilityID)
				fieldSeen[certifyvex.FieldVulnerabilityID] = struct{}{}
			}
		case "knownSince":
			if _, ok := fieldSeen[certifyvex.FieldKnownSince]; !ok {
				selectedFields = append(selectedFields, certifyvex.FieldKnownSince)
				fieldSeen[certifyvex.FieldKnownSince] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[certifyvex.FieldStatus]; !ok {
				selectedFields = append(selectedFields, certifyvex.FieldStatus)
				fieldSeen[certifyvex.FieldStatus] = struct{}{}
			}
		case "statement":
			if _, ok := fieldSeen[certifyvex.FieldStatement]; !ok {
				selectedFields = append(selectedFields, certifyvex.FieldStatement)
				fieldSeen[certifyvex.FieldStatement] = struct{}{}
			}
		case "statusNotes":
			if _, ok := fieldSeen[certifyvex.FieldStatusNotes]; !ok {
				selectedFields = append(selectedFields, certifyvex.FieldStatusNotes)
				fieldSeen[certifyvex.FieldStatusNotes] = struct{}{}
			}
		case "justification":
			if _, ok := fieldSeen[certifyvex.FieldJustification]; !ok {
				selectedFields = append(selectedFields, certifyvex.FieldJustification)
				fieldSeen[certifyvex.FieldJustification] = struct{}{}
			}
		case "origin":
			if _, ok := fieldSeen[certifyvex.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, certifyvex.FieldOrigin)
				fieldSeen[certifyvex.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[certifyvex.FieldCollector]; !ok {
				selectedFields = append(selectedFields, certifyvex.FieldCollector)
				fieldSeen[certifyvex.FieldCollector] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cv.Select(selectedFields...)
	}
	return nil
}

type certifyvexPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CertifyVexPaginateOption
}

func newCertifyVexPaginateArgs(rv map[string]any) *certifyvexPaginateArgs {
	args := &certifyvexPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cv *CertifyVulnQuery) CollectFields(ctx context.Context, satisfies ...string) (*CertifyVulnQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cv, nil
	}
	if err := cv.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cv, nil
}

func (cv *CertifyVulnQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(certifyvuln.Columns))
		selectedFields = []string{certifyvuln.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "vulnerability":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&VulnerabilityIDClient{config: cv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cv.withVulnerability = query
			if _, ok := fieldSeen[certifyvuln.FieldVulnerabilityID]; !ok {
				selectedFields = append(selectedFields, certifyvuln.FieldVulnerabilityID)
				fieldSeen[certifyvuln.FieldVulnerabilityID] = struct{}{}
			}
		case "package":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageVersionClient{config: cv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cv.withPackage = query
			if _, ok := fieldSeen[certifyvuln.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, certifyvuln.FieldPackageID)
				fieldSeen[certifyvuln.FieldPackageID] = struct{}{}
			}
		case "vulnerabilityID":
			if _, ok := fieldSeen[certifyvuln.FieldVulnerabilityID]; !ok {
				selectedFields = append(selectedFields, certifyvuln.FieldVulnerabilityID)
				fieldSeen[certifyvuln.FieldVulnerabilityID] = struct{}{}
			}
		case "packageID":
			if _, ok := fieldSeen[certifyvuln.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, certifyvuln.FieldPackageID)
				fieldSeen[certifyvuln.FieldPackageID] = struct{}{}
			}
		case "timeScanned":
			if _, ok := fieldSeen[certifyvuln.FieldTimeScanned]; !ok {
				selectedFields = append(selectedFields, certifyvuln.FieldTimeScanned)
				fieldSeen[certifyvuln.FieldTimeScanned] = struct{}{}
			}
		case "dbURI":
			if _, ok := fieldSeen[certifyvuln.FieldDbURI]; !ok {
				selectedFields = append(selectedFields, certifyvuln.FieldDbURI)
				fieldSeen[certifyvuln.FieldDbURI] = struct{}{}
			}
		case "dbVersion":
			if _, ok := fieldSeen[certifyvuln.FieldDbVersion]; !ok {
				selectedFields = append(selectedFields, certifyvuln.FieldDbVersion)
				fieldSeen[certifyvuln.FieldDbVersion] = struct{}{}
			}
		case "scannerURI":
			if _, ok := fieldSeen[certifyvuln.FieldScannerURI]; !ok {
				selectedFields = append(selectedFields, certifyvuln.FieldScannerURI)
				fieldSeen[certifyvuln.FieldScannerURI] = struct{}{}
			}
		case "scannerVersion":
			if _, ok := fieldSeen[certifyvuln.FieldScannerVersion]; !ok {
				selectedFields = append(selectedFields, certifyvuln.FieldScannerVersion)
				fieldSeen[certifyvuln.FieldScannerVersion] = struct{}{}
			}
		case "origin":
			if _, ok := fieldSeen[certifyvuln.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, certifyvuln.FieldOrigin)
				fieldSeen[certifyvuln.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[certifyvuln.FieldCollector]; !ok {
				selectedFields = append(selectedFields, certifyvuln.FieldCollector)
				fieldSeen[certifyvuln.FieldCollector] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cv.Select(selectedFields...)
	}
	return nil
}

type certifyvulnPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CertifyVulnPaginateOption
}

func newCertifyVulnPaginateArgs(rv map[string]any) *certifyvulnPaginateArgs {
	args := &certifyvulnPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (d *DependencyQuery) CollectFields(ctx context.Context, satisfies ...string) (*DependencyQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return d, nil
	}
	if err := d.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return d, nil
}

func (d *DependencyQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(dependency.Columns))
		selectedFields = []string{dependency.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "package":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageVersionClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.withPackage = query
			if _, ok := fieldSeen[dependency.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, dependency.FieldPackageID)
				fieldSeen[dependency.FieldPackageID] = struct{}{}
			}
		case "dependentPackageName":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageNameClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.withDependentPackageName = query
			if _, ok := fieldSeen[dependency.FieldDependentPackageNameID]; !ok {
				selectedFields = append(selectedFields, dependency.FieldDependentPackageNameID)
				fieldSeen[dependency.FieldDependentPackageNameID] = struct{}{}
			}
		case "dependentPackageVersion":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageVersionClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.withDependentPackageVersion = query
			if _, ok := fieldSeen[dependency.FieldDependentPackageVersionID]; !ok {
				selectedFields = append(selectedFields, dependency.FieldDependentPackageVersionID)
				fieldSeen[dependency.FieldDependentPackageVersionID] = struct{}{}
			}
		case "packageID":
			if _, ok := fieldSeen[dependency.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, dependency.FieldPackageID)
				fieldSeen[dependency.FieldPackageID] = struct{}{}
			}
		case "dependentPackageNameID":
			if _, ok := fieldSeen[dependency.FieldDependentPackageNameID]; !ok {
				selectedFields = append(selectedFields, dependency.FieldDependentPackageNameID)
				fieldSeen[dependency.FieldDependentPackageNameID] = struct{}{}
			}
		case "dependentPackageVersionID":
			if _, ok := fieldSeen[dependency.FieldDependentPackageVersionID]; !ok {
				selectedFields = append(selectedFields, dependency.FieldDependentPackageVersionID)
				fieldSeen[dependency.FieldDependentPackageVersionID] = struct{}{}
			}
		case "versionRange":
			if _, ok := fieldSeen[dependency.FieldVersionRange]; !ok {
				selectedFields = append(selectedFields, dependency.FieldVersionRange)
				fieldSeen[dependency.FieldVersionRange] = struct{}{}
			}
		case "dependencyType":
			if _, ok := fieldSeen[dependency.FieldDependencyType]; !ok {
				selectedFields = append(selectedFields, dependency.FieldDependencyType)
				fieldSeen[dependency.FieldDependencyType] = struct{}{}
			}
		case "justification":
			if _, ok := fieldSeen[dependency.FieldJustification]; !ok {
				selectedFields = append(selectedFields, dependency.FieldJustification)
				fieldSeen[dependency.FieldJustification] = struct{}{}
			}
		case "origin":
			if _, ok := fieldSeen[dependency.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, dependency.FieldOrigin)
				fieldSeen[dependency.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[dependency.FieldCollector]; !ok {
				selectedFields = append(selectedFields, dependency.FieldCollector)
				fieldSeen[dependency.FieldCollector] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		d.Select(selectedFields...)
	}
	return nil
}

type dependencyPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DependencyPaginateOption
}

func newDependencyPaginateArgs(rv map[string]any) *dependencyPaginateArgs {
	args := &dependencyPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hsa *HasSourceAtQuery) CollectFields(ctx context.Context, satisfies ...string) (*HasSourceAtQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hsa, nil
	}
	if err := hsa.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hsa, nil
}

func (hsa *HasSourceAtQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hassourceat.Columns))
		selectedFields = []string{hassourceat.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "packageVersion":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageVersionClient{config: hsa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hsa.withPackageVersion = query
			if _, ok := fieldSeen[hassourceat.FieldPackageVersionID]; !ok {
				selectedFields = append(selectedFields, hassourceat.FieldPackageVersionID)
				fieldSeen[hassourceat.FieldPackageVersionID] = struct{}{}
			}
		case "allVersions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageNameClient{config: hsa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hsa.withAllVersions = query
			if _, ok := fieldSeen[hassourceat.FieldPackageNameID]; !ok {
				selectedFields = append(selectedFields, hassourceat.FieldPackageNameID)
				fieldSeen[hassourceat.FieldPackageNameID] = struct{}{}
			}
		case "source":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SourceNameClient{config: hsa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hsa.withSource = query
			if _, ok := fieldSeen[hassourceat.FieldSourceID]; !ok {
				selectedFields = append(selectedFields, hassourceat.FieldSourceID)
				fieldSeen[hassourceat.FieldSourceID] = struct{}{}
			}
		case "packageVersionID":
			if _, ok := fieldSeen[hassourceat.FieldPackageVersionID]; !ok {
				selectedFields = append(selectedFields, hassourceat.FieldPackageVersionID)
				fieldSeen[hassourceat.FieldPackageVersionID] = struct{}{}
			}
		case "packageNameID":
			if _, ok := fieldSeen[hassourceat.FieldPackageNameID]; !ok {
				selectedFields = append(selectedFields, hassourceat.FieldPackageNameID)
				fieldSeen[hassourceat.FieldPackageNameID] = struct{}{}
			}
		case "sourceID":
			if _, ok := fieldSeen[hassourceat.FieldSourceID]; !ok {
				selectedFields = append(selectedFields, hassourceat.FieldSourceID)
				fieldSeen[hassourceat.FieldSourceID] = struct{}{}
			}
		case "knownSince":
			if _, ok := fieldSeen[hassourceat.FieldKnownSince]; !ok {
				selectedFields = append(selectedFields, hassourceat.FieldKnownSince)
				fieldSeen[hassourceat.FieldKnownSince] = struct{}{}
			}
		case "justification":
			if _, ok := fieldSeen[hassourceat.FieldJustification]; !ok {
				selectedFields = append(selectedFields, hassourceat.FieldJustification)
				fieldSeen[hassourceat.FieldJustification] = struct{}{}
			}
		case "origin":
			if _, ok := fieldSeen[hassourceat.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, hassourceat.FieldOrigin)
				fieldSeen[hassourceat.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[hassourceat.FieldCollector]; !ok {
				selectedFields = append(selectedFields, hassourceat.FieldCollector)
				fieldSeen[hassourceat.FieldCollector] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hsa.Select(selectedFields...)
	}
	return nil
}

type hassourceatPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HasSourceAtPaginateOption
}

func newHasSourceAtPaginateArgs(rv map[string]any) *hassourceatPaginateArgs {
	args := &hassourceatPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (he *HashEqualQuery) CollectFields(ctx context.Context, satisfies ...string) (*HashEqualQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return he, nil
	}
	if err := he.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return he, nil
}

func (he *HashEqualQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hashequal.Columns))
		selectedFields = []string{hashequal.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: he.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			he.WithNamedArtifacts(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "origin":
			if _, ok := fieldSeen[hashequal.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, hashequal.FieldOrigin)
				fieldSeen[hashequal.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[hashequal.FieldCollector]; !ok {
				selectedFields = append(selectedFields, hashequal.FieldCollector)
				fieldSeen[hashequal.FieldCollector] = struct{}{}
			}
		case "justification":
			if _, ok := fieldSeen[hashequal.FieldJustification]; !ok {
				selectedFields = append(selectedFields, hashequal.FieldJustification)
				fieldSeen[hashequal.FieldJustification] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		he.Select(selectedFields...)
	}
	return nil
}

type hashequalPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HashEqualPaginateOption
}

func newHashEqualPaginateArgs(rv map[string]any) *hashequalPaginateArgs {
	args := &hashequalPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (iv *IsVulnerabilityQuery) CollectFields(ctx context.Context, satisfies ...string) (*IsVulnerabilityQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return iv, nil
	}
	if err := iv.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return iv, nil
}

func (iv *IsVulnerabilityQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(isvulnerability.Columns))
		selectedFields = []string{isvulnerability.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "osv":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&VulnerabilityTypeClient{config: iv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			iv.withOsv = query
			if _, ok := fieldSeen[isvulnerability.FieldOsvID]; !ok {
				selectedFields = append(selectedFields, isvulnerability.FieldOsvID)
				fieldSeen[isvulnerability.FieldOsvID] = struct{}{}
			}
		case "vulnerability":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&VulnerabilityTypeClient{config: iv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			iv.withVulnerability = query
			if _, ok := fieldSeen[isvulnerability.FieldVulnerabilityID]; !ok {
				selectedFields = append(selectedFields, isvulnerability.FieldVulnerabilityID)
				fieldSeen[isvulnerability.FieldVulnerabilityID] = struct{}{}
			}
		case "osvID":
			if _, ok := fieldSeen[isvulnerability.FieldOsvID]; !ok {
				selectedFields = append(selectedFields, isvulnerability.FieldOsvID)
				fieldSeen[isvulnerability.FieldOsvID] = struct{}{}
			}
		case "vulnerabilityID":
			if _, ok := fieldSeen[isvulnerability.FieldVulnerabilityID]; !ok {
				selectedFields = append(selectedFields, isvulnerability.FieldVulnerabilityID)
				fieldSeen[isvulnerability.FieldVulnerabilityID] = struct{}{}
			}
		case "justification":
			if _, ok := fieldSeen[isvulnerability.FieldJustification]; !ok {
				selectedFields = append(selectedFields, isvulnerability.FieldJustification)
				fieldSeen[isvulnerability.FieldJustification] = struct{}{}
			}
		case "origin":
			if _, ok := fieldSeen[isvulnerability.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, isvulnerability.FieldOrigin)
				fieldSeen[isvulnerability.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[isvulnerability.FieldCollector]; !ok {
				selectedFields = append(selectedFields, isvulnerability.FieldCollector)
				fieldSeen[isvulnerability.FieldCollector] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		iv.Select(selectedFields...)
	}
	return nil
}

type isvulnerabilityPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []IsVulnerabilityPaginateOption
}

func newIsVulnerabilityPaginateArgs(rv map[string]any) *isvulnerabilityPaginateArgs {
	args := &isvulnerabilityPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (l *LicenseQuery) CollectFields(ctx context.Context, satisfies ...string) (*LicenseQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return l, nil
	}
	if err := l.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return l, nil
}

func (l *LicenseQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(license.Columns))
		selectedFields = []string{license.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "declaredInCertifyLegals":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CertifyLegalClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			l.WithNamedDeclaredInCertifyLegals(alias, func(wq *CertifyLegalQuery) {
				*wq = *query
			})
		case "discoveredInCertifyLegals":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CertifyLegalClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			l.WithNamedDiscoveredInCertifyLegals(alias, func(wq *CertifyLegalQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[license.FieldName]; !ok {
				selectedFields = append(selectedFields, license.FieldName)
				fieldSeen[license.FieldName] = struct{}{}
			}
		case "inline":
			if _, ok := fieldSeen[license.FieldInline]; !ok {
				selectedFields = append(selectedFields, license.FieldInline)
				fieldSeen[license.FieldInline] = struct{}{}
			}
		case "listVersion":
			if _, ok := fieldSeen[license.FieldListVersion]; !ok {
				selectedFields = append(selectedFields, license.FieldListVersion)
				fieldSeen[license.FieldListVersion] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		l.Select(selectedFields...)
	}
	return nil
}

type licensePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []LicensePaginateOption
}

func newLicensePaginateArgs(rv map[string]any) *licensePaginateArgs {
	args := &licensePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (o *OccurrenceQuery) CollectFields(ctx context.Context, satisfies ...string) (*OccurrenceQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return o, nil
	}
	if err := o.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return o, nil
}

func (o *OccurrenceQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(occurrence.Columns))
		selectedFields = []string{occurrence.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "artifact":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			o.withArtifact = query
			if _, ok := fieldSeen[occurrence.FieldArtifactID]; !ok {
				selectedFields = append(selectedFields, occurrence.FieldArtifactID)
				fieldSeen[occurrence.FieldArtifactID] = struct{}{}
			}
		case "package":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageVersionClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			o.withPackage = query
			if _, ok := fieldSeen[occurrence.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, occurrence.FieldPackageID)
				fieldSeen[occurrence.FieldPackageID] = struct{}{}
			}
		case "source":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SourceNameClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			o.withSource = query
			if _, ok := fieldSeen[occurrence.FieldSourceID]; !ok {
				selectedFields = append(selectedFields, occurrence.FieldSourceID)
				fieldSeen[occurrence.FieldSourceID] = struct{}{}
			}
		case "artifactID":
			if _, ok := fieldSeen[occurrence.FieldArtifactID]; !ok {
				selectedFields = append(selectedFields, occurrence.FieldArtifactID)
				fieldSeen[occurrence.FieldArtifactID] = struct{}{}
			}
		case "justification":
			if _, ok := fieldSeen[occurrence.FieldJustification]; !ok {
				selectedFields = append(selectedFields, occurrence.FieldJustification)
				fieldSeen[occurrence.FieldJustification] = struct{}{}
			}
		case "origin":
			if _, ok := fieldSeen[occurrence.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, occurrence.FieldOrigin)
				fieldSeen[occurrence.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[occurrence.FieldCollector]; !ok {
				selectedFields = append(selectedFields, occurrence.FieldCollector)
				fieldSeen[occurrence.FieldCollector] = struct{}{}
			}
		case "sourceID":
			if _, ok := fieldSeen[occurrence.FieldSourceID]; !ok {
				selectedFields = append(selectedFields, occurrence.FieldSourceID)
				fieldSeen[occurrence.FieldSourceID] = struct{}{}
			}
		case "packageID":
			if _, ok := fieldSeen[occurrence.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, occurrence.FieldPackageID)
				fieldSeen[occurrence.FieldPackageID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		o.Select(selectedFields...)
	}
	return nil
}

type occurrencePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OccurrencePaginateOption
}

func newOccurrencePaginateArgs(rv map[string]any) *occurrencePaginateArgs {
	args := &occurrencePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pn *PackageNameQuery) CollectFields(ctx context.Context, satisfies ...string) (*PackageNameQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pn, nil
	}
	if err := pn.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pn, nil
}

func (pn *PackageNameQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(packagename.Columns))
		selectedFields = []string{packagename.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "namespace":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageNamespaceClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.withNamespace = query
			if _, ok := fieldSeen[packagename.FieldNamespaceID]; !ok {
				selectedFields = append(selectedFields, packagename.FieldNamespaceID)
				fieldSeen[packagename.FieldNamespaceID] = struct{}{}
			}
		case "versions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageVersionClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.WithNamedVersions(alias, func(wq *PackageVersionQuery) {
				*wq = *query
			})
		case "namespaceID":
			if _, ok := fieldSeen[packagename.FieldNamespaceID]; !ok {
				selectedFields = append(selectedFields, packagename.FieldNamespaceID)
				fieldSeen[packagename.FieldNamespaceID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[packagename.FieldName]; !ok {
				selectedFields = append(selectedFields, packagename.FieldName)
				fieldSeen[packagename.FieldName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pn.Select(selectedFields...)
	}
	return nil
}

type packagenamePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PackageNamePaginateOption
}

func newPackageNamePaginateArgs(rv map[string]any) *packagenamePaginateArgs {
	args := &packagenamePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pn *PackageNamespaceQuery) CollectFields(ctx context.Context, satisfies ...string) (*PackageNamespaceQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pn, nil
	}
	if err := pn.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pn, nil
}

func (pn *PackageNamespaceQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(packagenamespace.Columns))
		selectedFields = []string{packagenamespace.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "package":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageTypeClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.withPackage = query
			if _, ok := fieldSeen[packagenamespace.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, packagenamespace.FieldPackageID)
				fieldSeen[packagenamespace.FieldPackageID] = struct{}{}
			}
		case "names":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageNameClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.WithNamedNames(alias, func(wq *PackageNameQuery) {
				*wq = *query
			})
		case "packageID":
			if _, ok := fieldSeen[packagenamespace.FieldPackageID]; !ok {
				selectedFields = append(selectedFields, packagenamespace.FieldPackageID)
				fieldSeen[packagenamespace.FieldPackageID] = struct{}{}
			}
		case "namespace":
			if _, ok := fieldSeen[packagenamespace.FieldNamespace]; !ok {
				selectedFields = append(selectedFields, packagenamespace.FieldNamespace)
				fieldSeen[packagenamespace.FieldNamespace] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pn.Select(selectedFields...)
	}
	return nil
}

type packagenamespacePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PackageNamespacePaginateOption
}

func newPackageNamespacePaginateArgs(rv map[string]any) *packagenamespacePaginateArgs {
	args := &packagenamespacePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pt *PackageTypeQuery) CollectFields(ctx context.Context, satisfies ...string) (*PackageTypeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pt, nil
	}
	if err := pt.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pt, nil
}

func (pt *PackageTypeQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(packagetype.Columns))
		selectedFields = []string{packagetype.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "namespaces":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageNamespaceClient{config: pt.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pt.WithNamedNamespaces(alias, func(wq *PackageNamespaceQuery) {
				*wq = *query
			})
		case "type":
			if _, ok := fieldSeen[packagetype.FieldType]; !ok {
				selectedFields = append(selectedFields, packagetype.FieldType)
				fieldSeen[packagetype.FieldType] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pt.Select(selectedFields...)
	}
	return nil
}

type packagetypePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PackageTypePaginateOption
}

func newPackageTypePaginateArgs(rv map[string]any) *packagetypePaginateArgs {
	args := &packagetypePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pv *PackageVersionQuery) CollectFields(ctx context.Context, satisfies ...string) (*PackageVersionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pv, nil
	}
	if err := pv.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pv, nil
}

func (pv *PackageVersionQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(packageversion.Columns))
		selectedFields = []string{packageversion.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "name":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageNameClient{config: pv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pv.withName = query
			if _, ok := fieldSeen[packageversion.FieldNameID]; !ok {
				selectedFields = append(selectedFields, packageversion.FieldNameID)
				fieldSeen[packageversion.FieldNameID] = struct{}{}
			}
		case "occurrences":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OccurrenceClient{config: pv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pv.WithNamedOccurrences(alias, func(wq *OccurrenceQuery) {
				*wq = *query
			})
		case "sbom":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BillOfMaterialsClient{config: pv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pv.WithNamedSbom(alias, func(wq *BillOfMaterialsQuery) {
				*wq = *query
			})
		case "equalPackages":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PkgEqualClient{config: pv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pv.WithNamedEqualPackages(alias, func(wq *PkgEqualQuery) {
				*wq = *query
			})
		case "nameID":
			if _, ok := fieldSeen[packageversion.FieldNameID]; !ok {
				selectedFields = append(selectedFields, packageversion.FieldNameID)
				fieldSeen[packageversion.FieldNameID] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[packageversion.FieldVersion]; !ok {
				selectedFields = append(selectedFields, packageversion.FieldVersion)
				fieldSeen[packageversion.FieldVersion] = struct{}{}
			}
		case "subpath":
			if _, ok := fieldSeen[packageversion.FieldSubpath]; !ok {
				selectedFields = append(selectedFields, packageversion.FieldSubpath)
				fieldSeen[packageversion.FieldSubpath] = struct{}{}
			}
		case "qualifiers":
			if _, ok := fieldSeen[packageversion.FieldQualifiers]; !ok {
				selectedFields = append(selectedFields, packageversion.FieldQualifiers)
				fieldSeen[packageversion.FieldQualifiers] = struct{}{}
			}
		case "hash":
			if _, ok := fieldSeen[packageversion.FieldHash]; !ok {
				selectedFields = append(selectedFields, packageversion.FieldHash)
				fieldSeen[packageversion.FieldHash] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pv.Select(selectedFields...)
	}
	return nil
}

type packageversionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PackageVersionPaginateOption
}

func newPackageVersionPaginateArgs(rv map[string]any) *packageversionPaginateArgs {
	args := &packageversionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pe *PkgEqualQuery) CollectFields(ctx context.Context, satisfies ...string) (*PkgEqualQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pe, nil
	}
	if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pe, nil
}

func (pe *PkgEqualQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(pkgequal.Columns))
		selectedFields = []string{pkgequal.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "packages":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackageVersionClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pe.WithNamedPackages(alias, func(wq *PackageVersionQuery) {
				*wq = *query
			})
		case "origin":
			if _, ok := fieldSeen[pkgequal.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, pkgequal.FieldOrigin)
				fieldSeen[pkgequal.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[pkgequal.FieldCollector]; !ok {
				selectedFields = append(selectedFields, pkgequal.FieldCollector)
				fieldSeen[pkgequal.FieldCollector] = struct{}{}
			}
		case "justification":
			if _, ok := fieldSeen[pkgequal.FieldJustification]; !ok {
				selectedFields = append(selectedFields, pkgequal.FieldJustification)
				fieldSeen[pkgequal.FieldJustification] = struct{}{}
			}
		case "packagesHash":
			if _, ok := fieldSeen[pkgequal.FieldPackagesHash]; !ok {
				selectedFields = append(selectedFields, pkgequal.FieldPackagesHash)
				fieldSeen[pkgequal.FieldPackagesHash] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pe.Select(selectedFields...)
	}
	return nil
}

type pkgequalPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PkgEqualPaginateOption
}

func newPkgEqualPaginateArgs(rv map[string]any) *pkgequalPaginateArgs {
	args := &pkgequalPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sa *SLSAAttestationQuery) CollectFields(ctx context.Context, satisfies ...string) (*SLSAAttestationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sa, nil
	}
	if err := sa.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sa, nil
}

func (sa *SLSAAttestationQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(slsaattestation.Columns))
		selectedFields = []string{slsaattestation.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "builtFrom":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: sa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			sa.WithNamedBuiltFrom(alias, func(wq *ArtifactQuery) {
				*wq = *query
			})
		case "builtBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuilderClient{config: sa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			sa.withBuiltBy = query
			if _, ok := fieldSeen[slsaattestation.FieldBuiltByID]; !ok {
				selectedFields = append(selectedFields, slsaattestation.FieldBuiltByID)
				fieldSeen[slsaattestation.FieldBuiltByID] = struct{}{}
			}
		case "subject":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ArtifactClient{config: sa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			sa.withSubject = query
			if _, ok := fieldSeen[slsaattestation.FieldSubjectID]; !ok {
				selectedFields = append(selectedFields, slsaattestation.FieldSubjectID)
				fieldSeen[slsaattestation.FieldSubjectID] = struct{}{}
			}
		case "buildType":
			if _, ok := fieldSeen[slsaattestation.FieldBuildType]; !ok {
				selectedFields = append(selectedFields, slsaattestation.FieldBuildType)
				fieldSeen[slsaattestation.FieldBuildType] = struct{}{}
			}
		case "builtByID":
			if _, ok := fieldSeen[slsaattestation.FieldBuiltByID]; !ok {
				selectedFields = append(selectedFields, slsaattestation.FieldBuiltByID)
				fieldSeen[slsaattestation.FieldBuiltByID] = struct{}{}
			}
		case "subjectID":
			if _, ok := fieldSeen[slsaattestation.FieldSubjectID]; !ok {
				selectedFields = append(selectedFields, slsaattestation.FieldSubjectID)
				fieldSeen[slsaattestation.FieldSubjectID] = struct{}{}
			}
		case "slsaPredicate":
			if _, ok := fieldSeen[slsaattestation.FieldSlsaPredicate]; !ok {
				selectedFields = append(selectedFields, slsaattestation.FieldSlsaPredicate)
				fieldSeen[slsaattestation.FieldSlsaPredicate] = struct{}{}
			}
		case "slsaVersion":
			if _, ok := fieldSeen[slsaattestation.FieldSlsaVersion]; !ok {
				selectedFields = append(selectedFields, slsaattestation.FieldSlsaVersion)
				fieldSeen[slsaattestation.FieldSlsaVersion] = struct{}{}
			}
		case "startedOn":
			if _, ok := fieldSeen[slsaattestation.FieldStartedOn]; !ok {
				selectedFields = append(selectedFields, slsaattestation.FieldStartedOn)
				fieldSeen[slsaattestation.FieldStartedOn] = struct{}{}
			}
		case "finishedOn":
			if _, ok := fieldSeen[slsaattestation.FieldFinishedOn]; !ok {
				selectedFields = append(selectedFields, slsaattestation.FieldFinishedOn)
				fieldSeen[slsaattestation.FieldFinishedOn] = struct{}{}
			}
		case "origin":
			if _, ok := fieldSeen[slsaattestation.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, slsaattestation.FieldOrigin)
				fieldSeen[slsaattestation.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[slsaattestation.FieldCollector]; !ok {
				selectedFields = append(selectedFields, slsaattestation.FieldCollector)
				fieldSeen[slsaattestation.FieldCollector] = struct{}{}
			}
		case "builtFromHash":
			if _, ok := fieldSeen[slsaattestation.FieldBuiltFromHash]; !ok {
				selectedFields = append(selectedFields, slsaattestation.FieldBuiltFromHash)
				fieldSeen[slsaattestation.FieldBuiltFromHash] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sa.Select(selectedFields...)
	}
	return nil
}

type slsaattestationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SLSAAttestationPaginateOption
}

func newSLSAAttestationPaginateArgs(rv map[string]any) *slsaattestationPaginateArgs {
	args := &slsaattestationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *ScorecardQuery) CollectFields(ctx context.Context, satisfies ...string) (*ScorecardQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *ScorecardQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(scorecard.Columns))
		selectedFields = []string{scorecard.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "certifications":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CertifyScorecardClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.WithNamedCertifications(alias, func(wq *CertifyScorecardQuery) {
				*wq = *query
			})
		case "checks":
			if _, ok := fieldSeen[scorecard.FieldChecks]; !ok {
				selectedFields = append(selectedFields, scorecard.FieldChecks)
				fieldSeen[scorecard.FieldChecks] = struct{}{}
			}
		case "aggregateScore":
			if _, ok := fieldSeen[scorecard.FieldAggregateScore]; !ok {
				selectedFields = append(selectedFields, scorecard.FieldAggregateScore)
				fieldSeen[scorecard.FieldAggregateScore] = struct{}{}
			}
		case "timeScanned":
			if _, ok := fieldSeen[scorecard.FieldTimeScanned]; !ok {
				selectedFields = append(selectedFields, scorecard.FieldTimeScanned)
				fieldSeen[scorecard.FieldTimeScanned] = struct{}{}
			}
		case "scorecardVersion":
			if _, ok := fieldSeen[scorecard.FieldScorecardVersion]; !ok {
				selectedFields = append(selectedFields, scorecard.FieldScorecardVersion)
				fieldSeen[scorecard.FieldScorecardVersion] = struct{}{}
			}
		case "scorecardCommit":
			if _, ok := fieldSeen[scorecard.FieldScorecardCommit]; !ok {
				selectedFields = append(selectedFields, scorecard.FieldScorecardCommit)
				fieldSeen[scorecard.FieldScorecardCommit] = struct{}{}
			}
		case "origin":
			if _, ok := fieldSeen[scorecard.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, scorecard.FieldOrigin)
				fieldSeen[scorecard.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[scorecard.FieldCollector]; !ok {
				selectedFields = append(selectedFields, scorecard.FieldCollector)
				fieldSeen[scorecard.FieldCollector] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type scorecardPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ScorecardPaginateOption
}

func newScorecardPaginateArgs(rv map[string]any) *scorecardPaginateArgs {
	args := &scorecardPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sn *SourceNameQuery) CollectFields(ctx context.Context, satisfies ...string) (*SourceNameQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sn, nil
	}
	if err := sn.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sn, nil
}

func (sn *SourceNameQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(sourcename.Columns))
		selectedFields = []string{sourcename.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "namespace":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SourceNamespaceClient{config: sn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			sn.withNamespace = query
			if _, ok := fieldSeen[sourcename.FieldNamespaceID]; !ok {
				selectedFields = append(selectedFields, sourcename.FieldNamespaceID)
				fieldSeen[sourcename.FieldNamespaceID] = struct{}{}
			}
		case "occurrences":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OccurrenceClient{config: sn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			sn.WithNamedOccurrences(alias, func(wq *OccurrenceQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[sourcename.FieldName]; !ok {
				selectedFields = append(selectedFields, sourcename.FieldName)
				fieldSeen[sourcename.FieldName] = struct{}{}
			}
		case "commit":
			if _, ok := fieldSeen[sourcename.FieldCommit]; !ok {
				selectedFields = append(selectedFields, sourcename.FieldCommit)
				fieldSeen[sourcename.FieldCommit] = struct{}{}
			}
		case "tag":
			if _, ok := fieldSeen[sourcename.FieldTag]; !ok {
				selectedFields = append(selectedFields, sourcename.FieldTag)
				fieldSeen[sourcename.FieldTag] = struct{}{}
			}
		case "namespaceID":
			if _, ok := fieldSeen[sourcename.FieldNamespaceID]; !ok {
				selectedFields = append(selectedFields, sourcename.FieldNamespaceID)
				fieldSeen[sourcename.FieldNamespaceID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sn.Select(selectedFields...)
	}
	return nil
}

type sourcenamePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SourceNamePaginateOption
}

func newSourceNamePaginateArgs(rv map[string]any) *sourcenamePaginateArgs {
	args := &sourcenamePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sn *SourceNamespaceQuery) CollectFields(ctx context.Context, satisfies ...string) (*SourceNamespaceQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sn, nil
	}
	if err := sn.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sn, nil
}

func (sn *SourceNamespaceQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(sourcenamespace.Columns))
		selectedFields = []string{sourcenamespace.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "sourceType":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SourceTypeClient{config: sn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			sn.withSourceType = query
			if _, ok := fieldSeen[sourcenamespace.FieldSourceID]; !ok {
				selectedFields = append(selectedFields, sourcenamespace.FieldSourceID)
				fieldSeen[sourcenamespace.FieldSourceID] = struct{}{}
			}
		case "names":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SourceNameClient{config: sn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			sn.WithNamedNames(alias, func(wq *SourceNameQuery) {
				*wq = *query
			})
		case "namespace":
			if _, ok := fieldSeen[sourcenamespace.FieldNamespace]; !ok {
				selectedFields = append(selectedFields, sourcenamespace.FieldNamespace)
				fieldSeen[sourcenamespace.FieldNamespace] = struct{}{}
			}
		case "sourceID":
			if _, ok := fieldSeen[sourcenamespace.FieldSourceID]; !ok {
				selectedFields = append(selectedFields, sourcenamespace.FieldSourceID)
				fieldSeen[sourcenamespace.FieldSourceID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sn.Select(selectedFields...)
	}
	return nil
}

type sourcenamespacePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SourceNamespacePaginateOption
}

func newSourceNamespacePaginateArgs(rv map[string]any) *sourcenamespacePaginateArgs {
	args := &sourcenamespacePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (st *SourceTypeQuery) CollectFields(ctx context.Context, satisfies ...string) (*SourceTypeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return st, nil
	}
	if err := st.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return st, nil
}

func (st *SourceTypeQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(sourcetype.Columns))
		selectedFields = []string{sourcetype.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "namespaces":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SourceNamespaceClient{config: st.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			st.WithNamedNamespaces(alias, func(wq *SourceNamespaceQuery) {
				*wq = *query
			})
		case "type":
			if _, ok := fieldSeen[sourcetype.FieldType]; !ok {
				selectedFields = append(selectedFields, sourcetype.FieldType)
				fieldSeen[sourcetype.FieldType] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		st.Select(selectedFields...)
	}
	return nil
}

type sourcetypePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SourceTypePaginateOption
}

func newSourceTypePaginateArgs(rv map[string]any) *sourcetypePaginateArgs {
	args := &sourcetypePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ve *VulnEqualQuery) CollectFields(ctx context.Context, satisfies ...string) (*VulnEqualQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ve, nil
	}
	if err := ve.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ve, nil
}

func (ve *VulnEqualQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(vulnequal.Columns))
		selectedFields = []string{vulnequal.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "vulnerabilityIds":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&VulnerabilityIDClient{config: ve.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ve.WithNamedVulnerabilityIds(alias, func(wq *VulnerabilityIDQuery) {
				*wq = *query
			})
		case "justification":
			if _, ok := fieldSeen[vulnequal.FieldJustification]; !ok {
				selectedFields = append(selectedFields, vulnequal.FieldJustification)
				fieldSeen[vulnequal.FieldJustification] = struct{}{}
			}
		case "origin":
			if _, ok := fieldSeen[vulnequal.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, vulnequal.FieldOrigin)
				fieldSeen[vulnequal.FieldOrigin] = struct{}{}
			}
		case "collector":
			if _, ok := fieldSeen[vulnequal.FieldCollector]; !ok {
				selectedFields = append(selectedFields, vulnequal.FieldCollector)
				fieldSeen[vulnequal.FieldCollector] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ve.Select(selectedFields...)
	}
	return nil
}

type vulnequalPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []VulnEqualPaginateOption
}

func newVulnEqualPaginateArgs(rv map[string]any) *vulnequalPaginateArgs {
	args := &vulnequalPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (vi *VulnerabilityIDQuery) CollectFields(ctx context.Context, satisfies ...string) (*VulnerabilityIDQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return vi, nil
	}
	if err := vi.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return vi, nil
}

func (vi *VulnerabilityIDQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(vulnerabilityid.Columns))
		selectedFields = []string{vulnerabilityid.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "type":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&VulnerabilityTypeClient{config: vi.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			vi.withType = query
			if _, ok := fieldSeen[vulnerabilityid.FieldTypeID]; !ok {
				selectedFields = append(selectedFields, vulnerabilityid.FieldTypeID)
				fieldSeen[vulnerabilityid.FieldTypeID] = struct{}{}
			}
		case "vulnEquals":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&VulnEqualClient{config: vi.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			vi.WithNamedVulnEquals(alias, func(wq *VulnEqualQuery) {
				*wq = *query
			})
		case "vulnerabilityID":
			if _, ok := fieldSeen[vulnerabilityid.FieldVulnerabilityID]; !ok {
				selectedFields = append(selectedFields, vulnerabilityid.FieldVulnerabilityID)
				fieldSeen[vulnerabilityid.FieldVulnerabilityID] = struct{}{}
			}
		case "typeID":
			if _, ok := fieldSeen[vulnerabilityid.FieldTypeID]; !ok {
				selectedFields = append(selectedFields, vulnerabilityid.FieldTypeID)
				fieldSeen[vulnerabilityid.FieldTypeID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		vi.Select(selectedFields...)
	}
	return nil
}

type vulnerabilityidPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []VulnerabilityIDPaginateOption
}

func newVulnerabilityIDPaginateArgs(rv map[string]any) *vulnerabilityidPaginateArgs {
	args := &vulnerabilityidPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (vt *VulnerabilityTypeQuery) CollectFields(ctx context.Context, satisfies ...string) (*VulnerabilityTypeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return vt, nil
	}
	if err := vt.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return vt, nil
}

func (vt *VulnerabilityTypeQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(vulnerabilitytype.Columns))
		selectedFields = []string{vulnerabilitytype.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "vulnerabilityIds":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&VulnerabilityIDClient{config: vt.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			vt.WithNamedVulnerabilityIds(alias, func(wq *VulnerabilityIDQuery) {
				*wq = *query
			})
		case "type":
			if _, ok := fieldSeen[vulnerabilitytype.FieldType]; !ok {
				selectedFields = append(selectedFields, vulnerabilitytype.FieldType)
				fieldSeen[vulnerabilitytype.FieldType] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		vt.Select(selectedFields...)
	}
	return nil
}

type vulnerabilitytypePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []VulnerabilityTypePaginateOption
}

func newVulnerabilityTypePaginateArgs(rv map[string]any) *vulnerabilitytypePaginateArgs {
	args := &vulnerabilitytypePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

func limitRows(partitionBy string, limit int, orderBy ...sql.Querier) func(s *sql.Selector) {
	return func(s *sql.Selector) {
		d := sql.Dialect(s.Dialect())
		s.SetDistinct(false)
		with := d.With("src_query").
			As(s.Clone()).
			With("limited_query").
			As(
				d.Select("*").
					AppendSelectExprAs(
						sql.RowNumber().PartitionBy(partitionBy).OrderExpr(orderBy...),
						"row_number",
					).
					From(d.Table("src_query")),
			)
		t := d.Table("limited_query").As(s.TableName())
		*s = *d.Select(s.UnqualifiedColumns()...).
			From(t).
			Where(sql.LTE(t.C("row_number"), limit)).
			Prefix(with)
	}
}

// mayAddCondition appends another type condition to the satisfies list
// if condition is enabled (Node/Nodes) and it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond string) []string {
	if len(satisfies) == 0 {
		return satisfies
	}
	for _, s := range satisfies {
		if typeCond == s {
			return satisfies
		}
	}
	return append(satisfies, typeCond)
}
