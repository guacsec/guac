//
// Copyright 2023 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package backend

import (
	"context"
	"crypto/sha256"
	stdsql "database/sql"
	"fmt"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/predicate"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilityid"
	"github.com/guacsec/guac/pkg/assembler/backends/helper"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
	"github.com/pkg/errors"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

const (
	vulnTypeString = "vulnType"
	NoVuln         = "novuln"
)

func (b *EntBackend) IngestVulnerability(ctx context.Context, vuln model.IDorVulnerabilityInput) (*model.VulnerabilityIDs, error) {
	id, err := WithinTX(ctx, b.client, func(ctx context.Context) (*model.VulnerabilityIDs, error) {
		return upsertVulnerability(ctx, ent.TxFromContext(ctx), *vuln.VulnerabilityInput)
	})
	if err != nil {
		return nil, err
	}

	return id, nil
}

func (b *EntBackend) IngestVulnerabilities(ctx context.Context, vulns []*model.IDorVulnerabilityInput) ([]*model.VulnerabilityIDs, error) {
	funcName := "IngestVulnerabilities"
	var collectedVulnIDs []*model.VulnerabilityIDs

	ids, err := WithinTX(ctx, b.client, func(ctx context.Context) (*[]model.VulnerabilityIDs, error) {
		client := ent.TxFromContext(ctx)
		slc, err := upsertBulkVulnerability(ctx, client, vulns)
		if err != nil {
			return nil, err
		}
		return slc, nil
	})
	if err != nil {
		return nil, gqlerror.Errorf("%v :: %s", funcName, err)
	}

	for _, vulnIDs := range *ids {
		collectedVulnIDs = append(collectedVulnIDs, &vulnIDs)
	}

	return collectedVulnIDs, nil
}

func (b *EntBackend) Vulnerabilities(ctx context.Context, filter *model.VulnerabilitySpec) ([]*model.Vulnerability, error) {
	records, err := getVulnerabilities(ctx, b.client, *filter)
	if err != nil {
		return nil, err
	}
	return collect(records, toModelVulnerability), nil
}

func getVulnerabilities(ctx context.Context, client *ent.Client, filter model.VulnerabilitySpec) (ent.VulnerabilityIDs, error) {
	var where = []predicate.VulnerabilityID{
		optionalPredicate(filter.ID, IDEQ),
		optionalPredicate(filter.Type, vulnerabilityid.TypeEQ),
	}
	if filter.Type != nil && strings.ToLower(*filter.Type) != NoVuln {
		where = append(where,
			optionalPredicate(filter.VulnerabilityID, vulnerabilityid.VulnerabilityIDEqualFold),
		)
	}

	results, err := client.VulnerabilityID.Query().
		Where(where...).
		Limit(MaxPageSize).
		All(ctx)
	if err != nil {
		return nil, err
	}
	return results, nil
}

func upsertBulkVulnerability(ctx context.Context, client *ent.Tx, vulnInputs []*model.IDorVulnerabilityInput) (*[]model.VulnerabilityIDs, error) {
	batches := chunk(vulnInputs, 100)
	ids := make([]model.VulnerabilityIDs, 0)

	for _, vulns := range batches {
		creates := make([]*ent.VulnerabilityIDCreate, len(vulns))
		for i, vuln := range vulns {
			vulnIDs := helper.GuacVulnId(*vuln.VulnerabilityInput)
			vulnID := uuid.NewHash(sha256.New(), uuid.NameSpaceDNS, []byte(vulnIDs.VulnerabilityID), 5)
			creates[i] = client.VulnerabilityID.Create().
				SetID(vulnID).
				SetType(strings.ToLower(vuln.VulnerabilityInput.Type)).
				SetVulnerabilityID(strings.ToLower(vuln.VulnerabilityInput.VulnerabilityID))

			ids = append(ids, model.VulnerabilityIDs{
				VulnerabilityTypeID: fmt.Sprintf("%s:%s", vulnTypeString, vulnID.String()),
				VulnerabilityNodeID: vulnID.String()})
		}

		err := client.VulnerabilityID.CreateBulk(creates...).
			OnConflict(
				sql.ConflictColumns(vulnerabilityid.FieldType, vulnerabilityid.FieldVulnerabilityID),
			).
			DoNothing().
			Exec(ctx)
		if err != nil {
			return nil, err
		}
	}

	return &ids, nil
}

func upsertVulnerability(ctx context.Context, client *ent.Tx, spec model.VulnerabilityInputSpec) (*model.VulnerabilityIDs, error) {
	vulnIDs := helper.GuacVulnId(spec)
	vulnID := uuid.NewHash(sha256.New(), uuid.NameSpaceDNS, []byte(vulnIDs.VulnerabilityID), 5)

	_, err := client.VulnerabilityID.Create().
		SetID(vulnID).
		SetType(strings.ToLower(spec.Type)).
		SetVulnerabilityID(strings.ToLower(spec.VulnerabilityID)).
		OnConflict(sql.ConflictColumns(vulnerabilityid.FieldType, vulnerabilityid.FieldVulnerabilityID)).
		DoNothing().
		ID(ctx)

	if err != nil {
		if err != stdsql.ErrNoRows {
			return nil, errors.Wrap(err, "upsert vulnerability ID and TypeID")
		}
	}

	return &model.VulnerabilityIDs{VulnerabilityTypeID: fmt.Sprintf("%s:%s", vulnTypeString, vulnID.String()), VulnerabilityNodeID: vulnID.String()}, nil
}

func toModelVulnerability(vuln *ent.VulnerabilityID) *model.Vulnerability {
	return &model.Vulnerability{
		ID:               fmt.Sprintf("%s:%s", vulnTypeString, vuln.ID.String()),
		Type:             vuln.Type,
		VulnerabilityIDs: collect([]*ent.VulnerabilityID{}, toModelVulnerabilityID),
	}
}

func toModelVulnerabilityID(vulnID *ent.VulnerabilityID) *model.VulnerabilityID {
	return &model.VulnerabilityID{
		ID:              vulnID.ID.String(),
		VulnerabilityID: vulnID.VulnerabilityID,
	}
}
