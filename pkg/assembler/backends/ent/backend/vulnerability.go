//
// Copyright 2023 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package backend

import (
	"context"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/guacsec/guac/pkg/assembler/backends/ent"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/predicate"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilityid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilitytype"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"golang.org/x/sync/errgroup"
)

const NoVuln = "novuln"

func (b *EntBackend) IngestVulnerabilities(ctx context.Context, vulns []*model.VulnerabilityInputSpec) ([]*model.Vulnerability, error) {
	var modelVulnerabilities = make([]*model.Vulnerability, len(vulns))
	eg, ctx := errgroup.WithContext(ctx)
	for i := range vulns {
		index := i
		vuln := vulns[index]
		concurrently(eg, func() error {
			modelVuln, err := b.IngestVulnerability(ctx, *vuln)
			if err == nil {
				modelVulnerabilities[index] = modelVuln
				return err
			} else {
				return gqlerror.Errorf("IngestVulnerability failed with err: %v", err)
			}
		})
	}
	if err := eg.Wait(); err != nil {
		return nil, err
	}
	return modelVulnerabilities, nil
}

func (b *EntBackend) IngestVulnerability(ctx context.Context, vuln model.VulnerabilityInputSpec) (*model.Vulnerability, error) {
	record, err := WithinTX(ctx, b.client, func(ctx context.Context) (*int, error) {
		client := ent.TxFromContext(ctx)
		vulnerabilityID, err := upsertVulnerability(ctx, client, vuln)
		if err != nil {
			return nil, err
		}

		return vulnerabilityID, nil
	})
	if err != nil {
		return nil, err
	}

	return &model.Vulnerability{
		ID: nodeID(*record),
	}, nil
}

func (b *EntBackend) Vulnerabilities(ctx context.Context, filter *model.VulnerabilitySpec) ([]*model.Vulnerability, error) {
	records, err := getVulnerabilities(ctx, b.client, *filter)
	if err != nil {
		return nil, err
	}
	return collect(records, toModelVulnerability), nil
}

func getVulnerabilities(ctx context.Context, client *ent.Client, filter model.VulnerabilitySpec) (ent.VulnerabilityTypes, error) {
	var where = []predicate.VulnerabilityType{
		optionalPredicate(filter.ID, IDEQ),
		optionalPredicate(filter.Type, vulnerabilitytype.TypeEqualFold),
	}
	if filter.Type != nil && strings.ToLower(*filter.Type) != NoVuln {
		where = append(where, vulnerabilitytype.HasVulnerabilityIdsWith(
			optionalPredicate(filter.VulnerabilityID, vulnerabilityid.VulnerabilityIDEqualFold),
		))
	}
	results, err := client.VulnerabilityType.Query().
		Where(where...).
		WithVulnerabilityIds(func(query *ent.VulnerabilityIDQuery) {
			query.Where(optionalPredicate(filter.VulnerabilityID, vulnerabilityid.VulnerabilityIDEqualFold))
		}).
		Limit(MaxPageSize).
		All(ctx)
	if err != nil {
		return nil, err
	}
	return results, nil
}

func upsertVulnerability(ctx context.Context, client *ent.Tx, spec model.VulnerabilityInputSpec) (*int, error) {
	// Ingest the type record and ignore if it already exists
	typeId, err := client.VulnerabilityType.Create().
		SetType(strings.ToLower(spec.Type)).
		OnConflict(sql.ConflictColumns(vulnerabilitytype.FieldType)).
		Ignore().
		ID(ctx)
	if err != nil {
		return nil, err
	}

	vulnInsert := client.VulnerabilityID.Create()
	vulnID := strings.ToLower(spec.VulnerabilityID)

	vulnInsert.
		SetTypeID(typeId).
		SetVulnerabilityID(vulnID)

	err = vulnInsert.
		OnConflict(
			sql.ConflictColumns(vulnerabilityid.FieldTypeID, vulnerabilityid.FieldVulnerabilityID),
		).
		Ignore().
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &typeId, nil
}

func toModelVulnerability(vuln *ent.VulnerabilityType) *model.Vulnerability {
	return &model.Vulnerability{
		ID:               nodeID(vuln.ID),
		Type:             vuln.Type,
		VulnerabilityIDs: collect(vuln.Edges.VulnerabilityIds, toModelVulnerabilityID),
	}
}

func toModelVulnerabilityID(vulnID *ent.VulnerabilityID) *model.VulnerabilityID {
	return &model.VulnerabilityID{
		ID:              nodeID(vulnID.ID),
		VulnerabilityID: vulnID.VulnerabilityID,
	}
}
