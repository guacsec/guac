package backend

import (
	"context"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"github.com/guacsec/guac/pkg/assembler/backends/ent"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/isvulnerability"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/securityadvisory"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerability"
	"github.com/guacsec/guac/pkg/assembler/backends/helper"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

func (b *EntBackend) IsVulnerability(ctx context.Context, spec *model.IsVulnerabilitySpec) ([]*model.IsVulnerability, error) {
	if spec != nil {
		if err := helper.ValidateCveOrGhsaQueryFilter(spec.Vulnerability); err != nil {
			return nil, err
		}
	}

	query := b.client.IsVulnerability.Query().Where(
		optionalPredicate(spec.ID, IDEQ),
		optionalPredicate(spec.Collector, isvulnerability.CollectorEQ),
		optionalPredicate(spec.Justification, isvulnerability.JustificationEQ),
		optionalPredicate(spec.Origin, isvulnerability.OriginEQ),
	)

	if spec.Osv != nil {
		query.Where(isvulnerability.HasOsvWith(optionalPredicate(spec.Osv.OsvID, securityadvisory.OsvIDEqualFold)))
	}

	if spec.Vulnerability != nil {
		if spec.Vulnerability.Cve != nil {
			query.Where(isvulnerability.HasVulnerabilityWith(securityadvisory.CveIDNotNil()))
			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Cve.CveID, securityadvisory.CveIDEqualFold)))
			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Cve.Year, securityadvisory.CveYearEQ)))
		}
		if spec.Vulnerability.Ghsa != nil {
			query.Where(isvulnerability.HasVulnerabilityWith(securityadvisory.GhsaIDNotNil()))
			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Ghsa.GhsaID, securityadvisory.GhsaIDEqualFold)))
			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Ghsa.ID, IDEQ)))
		}
	}

	results, err := query.WithOsv().WithVulnerability().All(ctx)
	if err != nil {
		return nil, err
	}

	return collect(results, toModelIsVulnerability), nil
}

func (b *EntBackend) IngestVulnerability(ctx context.Context, pkg model.PkgInputSpec, spec model.VulnerabilityInput, certifyVuln model.VulnerabilityMetaDataInput) (*model.CertifyVuln, error) {
	funcName := "IngestVulnerability"
	if err := helper.ValidateVulnerabilityIngestionInput(spec, "IngestVulnerability", true); err != nil {
		return nil, Errorf("%v ::  %s", funcName, err)
	}

	record, err := WithinTX(ctx, b.client, func(context.Context) (*ent.Vulnerability, error) {
		client := ent.FromContext(ctx)
		insert := client.Vulnerability.Create()

		if spec.NoVuln != nil && *spec.NoVuln {
			// No vulnerability
		} else {
			vuln, err := getAdvisoryFromVulnerabilityInput(ctx, client, spec)
			if err != nil {
				return nil, err
			}

			insert.SetVulnerability(vuln)
		}

		pv, err := getPkgVersion(ctx, client, &pkg)
		if err != nil {
			return nil, err
		}

		insert.SetPackage(pv)

		insert.
			SetCollector(certifyVuln.Collector).
			SetDbURI(certifyVuln.DbURI).
			SetDbVersion(certifyVuln.DbVersion).
			SetOrigin(certifyVuln.Origin).
			SetScannerURI(certifyVuln.ScannerURI).
			SetScannerVersion(certifyVuln.ScannerVersion).
			SetTimeScanned(certifyVuln.TimeScanned)

		id, err := insert.
			OnConflict(
				sql.ConflictColumns(
					vulnerability.FieldVulnerabilityID,
					vulnerability.FieldPackageID,
					vulnerability.FieldCollector,
					vulnerability.FieldDbURI,
					vulnerability.FieldDbVersion,
					vulnerability.FieldOrigin,
					vulnerability.FieldScannerURI,
					vulnerability.FieldTimeScanned,
				),
				sql.ConflictWhere(sql.And(sql.NotNull(vulnerability.FieldVulnerabilityID))),
			).
			UpdateNewValues().
			ID(ctx)
		if err != nil {
			return nil, err
		}

		return client.Vulnerability.Query().Where(vulnerability.IDEQ(id)).
			WithPackage(func(q *ent.PackageVersionQuery) {
				q.WithName(func(q *ent.PackageNameQuery) {
					q.WithNamespace(func(q *ent.PackageNamespaceQuery) {
						q.WithPackage()
					})
				})
			}).
			WithVulnerability().
			Only(ctx)
	})
	if err != nil {
		return nil, err
	}

	return toModelCertifyVulnerability(record), nil
}

func getAdvisoryFromVulnerabilityInput(ctx context.Context, client *ent.Client, spec model.VulnerabilityInput) (*ent.SecurityAdvisory, error) {
	var cveOrGhsaOrOsv *ent.SecurityAdvisory
	var query *advisoryQuerySpec
	switch {
	case spec.Cve != nil:
		query = &advisoryQuerySpec{
			CveID: &spec.Cve.CveID,
			Year:  &spec.Cve.Year,
		}
	case spec.Ghsa != nil:
		query = &advisoryQuerySpec{
			GhsaID: &spec.Ghsa.GhsaID,
		}
	case spec.Osv != nil:
		query = &advisoryQuerySpec{
			OsvID: &spec.Osv.OsvID,
		}
	}
	cveOrGhsaOrOsv, err := getAdvisory(ctx, client, query)
	if err != nil {
		return nil, err
	}
	return cveOrGhsaOrOsv, nil
}

func (b *EntBackend) CertifyVuln(ctx context.Context, certifyVulnSpec *model.CertifyVulnSpec) ([]*model.CertifyVuln, error) {
	return nil, nil
}

func (b *EntBackend) IngestIsVulnerability(ctx context.Context, osv model.OSVInputSpec, vulnerability model.CveOrGhsaInput, isVulnerability model.IsVulnerabilityInputSpec) (*model.IsVulnerability, error) {
	record, err := WithinTX(ctx, b.client, func(context.Context) (*ent.IsVulnerability, error) {
		client := ent.FromContext(ctx)

		osvs, err := getAdvisories(ctx, client, &advisoryQuerySpec{
			OsvID: &osv.OsvID,
		})
		if err != nil {
			return nil, err
		}
		if len(osvs) != 1 {
			return nil, fmt.Errorf("multiple OSVs returned for osv_id %q", osv.OsvID)
		}

		vulnQuerySpec := &advisoryQuerySpec{}
		if vulnerability.Ghsa != nil {
			vulnQuerySpec.GhsaID = &vulnerability.Ghsa.GhsaID
		} else if vulnerability.Cve != nil {
			vulnQuerySpec.CveID = &vulnerability.Cve.CveID
			vulnQuerySpec.Year = &vulnerability.Cve.Year
		} else {
			return nil, fmt.Errorf("missing vulnerability input, needs GHSA or CVE")
		}

		vulns, err := getAdvisories(ctx, client, vulnQuerySpec)
		if err != nil {
			return nil, err
		}
		if len(vulns) != 1 {
			return nil, fmt.Errorf("multiple vulnerabilities returned, needs a single advisory to ingest")
		}

		id, err := client.IsVulnerability.Create().
			SetCollector(isVulnerability.Collector).
			SetJustification(isVulnerability.Justification).
			SetOrigin(isVulnerability.Origin).
			SetOsv(osvs[0]).
			SetVulnerability(vulns[0]).
			OnConflict(
				sql.ConflictColumns(
					isvulnerability.FieldOsvID,
					isvulnerability.FieldVulnerabilityID,
					isvulnerability.FieldOrigin,
					isvulnerability.FieldJustification,
				),
			).
			UpdateNewValues().
			ID(ctx)
		if err != nil {
			return nil, err
		}

		return client.IsVulnerability.Query().
			Where(isvulnerability.ID(id)).
			WithOsv(func(q *ent.SecurityAdvisoryQuery) {
				q.Select(securityadvisory.FieldID, securityadvisory.FieldOsvID)
			}).
			WithVulnerability(func(q *ent.SecurityAdvisoryQuery) {
				q.Select(securityadvisory.FieldID, securityadvisory.FieldCveID, securityadvisory.FieldGhsaID, securityadvisory.FieldCveYear)
			}).
			Only(ctx)
	})
	if err != nil {
		return nil, err
	}

	return toModelIsVulnerability(record), nil
}

func toModelCertifyVulnerability(record *ent.Vulnerability) *model.CertifyVuln {
	var vuln model.Vulnerability

	switch {
	case record.Edges.Vulnerability == nil:
		vuln = &model.NoVuln{ID: nodeID(record.ID)}
	case record.Edges.Vulnerability.CveID != nil:
		vuln = toModelCVE(record.Edges.Vulnerability)
	case record.Edges.Vulnerability.GhsaID != nil:
		vuln = toModelGHSA(record.Edges.Vulnerability)
	case record.Edges.Vulnerability.OsvID != nil:
		vuln = toModelOSV(record.Edges.Vulnerability)
	}

	return &model.CertifyVuln{
		ID:            nodeID(record.ID),
		Package:       toModelPackage(backReferencePackageVersion(record.Edges.Package)),
		Vulnerability: vuln,
		Metadata: &model.VulnerabilityMetaData{
			TimeScanned:    record.TimeScanned,
			DbURI:          record.DbURI,
			DbVersion:      record.DbVersion,
			ScannerURI:     record.ScannerURI,
			ScannerVersion: record.ScannerVersion,
			Origin:         record.Origin,
			Collector:      record.Collector,
		},
	}

}

func toModelIsVulnerability(record *ent.IsVulnerability) *model.IsVulnerability {
	return &model.IsVulnerability{
		ID:            nodeID(record.ID),
		Osv:           toModelOSV(record.Edges.Osv),
		Vulnerability: toModelGHSAOrCVE(record.Edges.Vulnerability),
		Justification: record.Justification,
		Origin:        record.Origin,
		Collector:     record.Collector,
	}
}

func toModelGHSAOrCVE(record *ent.SecurityAdvisory) model.CveOrGhsa {
	switch {
	case record == nil:
		return nil
	case record.CveID != nil:
		return toModelCVE(record)
	case record.GhsaID != nil:
		return toModelGHSA(record)
	default:
		return nil
	}
}
