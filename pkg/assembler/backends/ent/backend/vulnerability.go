package backend

import (
	"context"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"github.com/guacsec/guac/pkg/assembler/backends/ent"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/isvulnerability"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/securityadvisory"
	"github.com/guacsec/guac/pkg/assembler/backends/helper"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

func (b *EntBackend) IsVulnerability(ctx context.Context, spec *model.IsVulnerabilitySpec) ([]*model.IsVulnerability, error) {
	if spec != nil {
		if err := helper.ValidateCveOrGhsaQueryFilter(spec.Vulnerability); err != nil {
			return nil, err
		}
	}

	query := b.client.IsVulnerability.Query().Where(
		optionalPredicate(spec.ID, IDEQ),
		optionalPredicate(spec.Collector, isvulnerability.CollectorEQ),
		optionalPredicate(spec.Justification, isvulnerability.JustificationEQ),
		optionalPredicate(spec.Origin, isvulnerability.OriginEQ),
	)

	if spec.Osv != nil {
		query.Where(isvulnerability.HasOsvWith(optionalPredicate(spec.Osv.OsvID, securityadvisory.OsvIDEqualFold)))
	}

	if spec.Vulnerability != nil {
		if spec.Vulnerability.Cve != nil {
			query.Where(isvulnerability.HasVulnerabilityWith(securityadvisory.CveIDNotNil()))
			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Cve.CveID, securityadvisory.CveIDEqualFold)))
			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Cve.Year, securityadvisory.CveYearEQ)))
		}
		if spec.Vulnerability.Ghsa != nil {
			query.Where(isvulnerability.HasVulnerabilityWith(securityadvisory.GhsaIDNotNil()))
			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Ghsa.GhsaID, securityadvisory.GhsaIDEqualFold)))
			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Ghsa.ID, IDEQ)))
		}
	}

	results, err := query.WithOsv().WithVulnerability().All(ctx)
	if err != nil {
		return nil, err
	}

	return collect(results, toModelIsVulnerability), nil
}

func (b *EntBackend) IngestVulnerability(ctx context.Context, pkg model.PkgInputSpec, vulnerability model.VulnerabilityInput, certifyVuln model.VulnerabilityMetaDataInput) (*model.CertifyVuln, error) {
	return nil, nil
}

func (b *EntBackend) CertifyVuln(ctx context.Context, certifyVulnSpec *model.CertifyVulnSpec) ([]*model.CertifyVuln, error) {
	return nil, nil
}

func (b *EntBackend) IngestIsVulnerability(ctx context.Context, osv model.OSVInputSpec, vulnerability model.CveOrGhsaInput, isVulnerability model.IsVulnerabilityInputSpec) (*model.IsVulnerability, error) {
	record, err := WithinTX(ctx, b.client, func(context.Context) (*ent.IsVulnerability, error) {
		client := ent.FromContext(ctx)

		osvs, err := getAdvisories(ctx, client, &advisoryQuerySpec{
			OsvID: &osv.OsvID,
		})
		if err != nil {
			return nil, err
		}
		if len(osvs) != 1 {
			return nil, fmt.Errorf("multiple OSVs returned for osv_id %q", osv.OsvID)
		}

		vulnQuerySpec := &advisoryQuerySpec{}
		if vulnerability.Ghsa != nil {
			vulnQuerySpec.GhsaID = &vulnerability.Ghsa.GhsaID
		} else if vulnerability.Cve != nil {
			vulnQuerySpec.CveID = &vulnerability.Cve.CveID
			vulnQuerySpec.Year = &vulnerability.Cve.Year
		} else {
			return nil, fmt.Errorf("missing vulnerability input, needs GHSA or CVE")
		}

		vulns, err := getAdvisories(ctx, client, vulnQuerySpec)
		if err != nil {
			return nil, err
		}
		if len(vulns) != 1 {
			return nil, fmt.Errorf("multiple vulnerabilities returned, needs a single advisory to ingest")
		}

		id, err := client.IsVulnerability.Create().
			SetCollector(isVulnerability.Collector).
			SetJustification(isVulnerability.Justification).
			SetOrigin(isVulnerability.Origin).
			SetOsv(osvs[0]).
			SetVulnerability(vulns[0]).
			OnConflict(
				sql.ConflictColumns(
					isvulnerability.FieldOsvID,
					isvulnerability.FieldVulnerabilityID,
					isvulnerability.FieldOrigin,
					isvulnerability.FieldJustification,
				),
			).
			UpdateNewValues().
			ID(ctx)
		if err != nil {
			return nil, err
		}

		return client.IsVulnerability.Query().
			Where(isvulnerability.ID(id)).
			WithOsv().
			WithVulnerability().
			Only(ctx)
	})
	if err != nil {
		return nil, err
	}

	return toModelIsVulnerability(record), nil
}

func toModelIsVulnerability(record *ent.IsVulnerability) *model.IsVulnerability {
	return &model.IsVulnerability{
		ID:            nodeID(record.ID),
		Osv:           toModelOSV(record.Edges.Osv),
		Vulnerability: toModelGHSAOrCVE(record.Edges.Vulnerability),
		Justification: record.Justification,
		Origin:        record.Origin,
		Collector:     record.Collector,
	}
}

func toModelGHSAOrCVE(record *ent.SecurityAdvisory) model.CveOrGhsa {
	switch {
	case record == nil:
		return nil
	case record.CveID != nil:
		return toModelCVE(record)
	case record.GhsaID != nil:
		return toModelGHSA(record)
	default:
		return nil
	}
}
