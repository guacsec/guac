//
// Copyright 2023 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package backend

import (
	"context"
	stdsql "database/sql"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/guacsec/guac/pkg/assembler/backends/ent"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/predicate"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilityid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilitytype"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
	"github.com/pkg/errors"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

const NoVuln = "novuln"

func (b *EntBackend) IngestVulnerabilities(ctx context.Context, vulns []*model.VulnerabilityInputSpec) ([]*model.Vulnerability, error) {
	var modelVulnerabilities []*model.Vulnerability
	for _, vuln := range vulns {
		modelVuln, err := b.IngestVulnerability(ctx, *vuln)
		if err != nil {
			return nil, gqlerror.Errorf("IngestVulnerability failed with err: %v", err)
		}
		modelVulnerabilities = append(modelVulnerabilities, modelVuln)
	}
	return modelVulnerabilities, nil
}

func (b *EntBackend) IngestVulnerabilityID(ctx context.Context, vuln model.VulnerabilityInputSpec) (string, error) {
	id, err := WithinTX(ctx, b.client, func(ctx context.Context) (*int, error) {
		return upsertVulnerability(ctx, ent.TxFromContext(ctx), vuln)
	})
	if err != nil {
		return "", err
	}

	return strconv.Itoa(*id), nil
}

func (b *EntBackend) IngestVulnerabilityIDs(ctx context.Context, vulns []*model.VulnerabilityInputSpec) ([]string, error) {
	ids, err := WithinTX(ctx, b.client, func(ctx context.Context) (*[]string, error) {
		ids := make([]string, len(vulns))
		for i, vuln := range vulns {
			id, err := upsertVulnerability(ctx, ent.TxFromContext(ctx), *vuln)
			if err != nil {
				return nil, gqlerror.Errorf("IngestVulnerability failed with err: %v", err)
			}
			ids[i] = strconv.Itoa(*id)
		}
		return &ids, nil
	})

	if err != nil {
		return nil, err
	}
	return *ids, nil
}

func (b *EntBackend) Vulnerabilities(ctx context.Context, filter *model.VulnerabilitySpec) ([]*model.Vulnerability, error) {
	records, err := getVulnerabilities(ctx, b.client, *filter)
	if err != nil {
		return nil, err
	}
	return collect(records, toModelVulnerability), nil
}

func getVulnerabilities(ctx context.Context, client *ent.Client, filter model.VulnerabilitySpec) (ent.VulnerabilityTypes, error) {
	var where = []predicate.VulnerabilityType{
		optionalPredicate(filter.ID, IDEQ),
		optionalPredicate(filter.Type, vulnerabilitytype.TypeEqualFold),
	}
	if filter.Type != nil && strings.ToLower(*filter.Type) != NoVuln {
		where = append(where, vulnerabilitytype.HasVulnerabilityIdsWith(
			optionalPredicate(filter.VulnerabilityID, vulnerabilityid.VulnerabilityIDEqualFold),
		))
	}
	results, err := client.VulnerabilityType.Query().
		Where(where...).
		WithVulnerabilityIds(func(query *ent.VulnerabilityIDQuery) {
			query.Where(optionalPredicate(filter.VulnerabilityID, vulnerabilityid.VulnerabilityIDEqualFold))
		}).
		Limit(MaxPageSize).
		All(ctx)
	if err != nil {
		return nil, err
	}
	return results, nil
}

func upsertVulnerability(ctx context.Context, client *ent.Tx, spec model.VulnerabilityInputSpec) (*int, error) {

	typeId, err := client.VulnerabilityType.Create().
		SetType(strings.ToLower(spec.Type)).
		OnConflict(sql.ConflictColumns(vulnerabilitytype.FieldType)).
		DoNothing().
		ID(ctx)

	if err != nil {
		if err != stdsql.ErrNoRows {
			return nil, errors.Wrap(err, "upsert vulnerability")
		}
		typeId, err = client.VulnerabilityType.Query().
			Where(vulnerabilitytype.TypeEQ(strings.ToLower(spec.Type))).
			OnlyID(ctx)
		if err != nil {
			return nil, errors.Wrap(err, "get vulnerability type")
		}
	}

	_, err = client.VulnerabilityID.Create().
		SetTypeID(typeId).
		SetVulnerabilityID(strings.ToLower(spec.VulnerabilityID)).
		OnConflict(sql.ConflictColumns(vulnerabilityid.FieldTypeID, vulnerabilityid.FieldVulnerabilityID)).
		DoNothing().
		ID(ctx)

	if err != nil {
		if err != stdsql.ErrNoRows {
			return nil, errors.Wrap(err, "upsert vulnerability ID and TypeID")
		}
		_, err = client.VulnerabilityID.Query().
			Where(
				vulnerabilityid.TypeIDEQ(typeId),
			).
			OnlyID(ctx)

		if err != nil {
			return nil, errors.Wrap(err, "get vulnerability ID")
		}
	}

	return &typeId, nil
}

func toModelVulnerability(vuln *ent.VulnerabilityType) *model.Vulnerability {
	return &model.Vulnerability{
		ID:               nodeID(vuln.ID),
		Type:             vuln.Type,
		VulnerabilityIDs: collect(vuln.Edges.VulnerabilityIds, toModelVulnerabilityID),
	}
}

func toModelVulnerabilityID(vulnID *ent.VulnerabilityID) *model.VulnerabilityID {
	return &model.VulnerabilityID{
		ID:              nodeID(vulnID.ID),
		VulnerabilityID: vulnID.VulnerabilityID,
	}
}
