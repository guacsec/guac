//
// Copyright 2023 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package backend

import (
	"github.com/guacsec/guac/pkg/assembler/backends/ent"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

const NoVuln = "NoVuln"

// func (b *EntBackend) IsVulnerability(ctx context.Context, spec *model.IsVulnerabilitySpec) ([]*model.IsVulnerability, error) {
// 	if spec != nil {
// 		if err := helper.ValidateCveOrGhsaQueryFilter(spec.Vulnerability); err != nil {
// 			return nil, err
// 		}
// 	}

// 	query := b.client.IsVulnerability.Query().Where(
// 		optionalPredicate(spec.ID, IDEQ),
// 		optionalPredicate(spec.Collector, isvulnerability.CollectorEQ),
// 		optionalPredicate(spec.Justification, isvulnerability.JustificationEQ),
// 		optionalPredicate(spec.Origin, isvulnerability.OriginEQ),
// 	)

// 	if spec.Osv != nil {
// 		query.Where(isvulnerability.HasOsvWith(optionalPredicate(spec.Osv.OsvID, securityadvisory.OsvIDEqualFold)))
// 	}

// 	if spec.Vulnerability != nil {
// 		if spec.Vulnerability.Cve != nil {
// 			query.Where(isvulnerability.HasVulnerabilityWith(securityadvisory.CveIDNotNil()))
// 			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Cve.CveID, securityadvisory.CveIDEqualFold)))
// 			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Cve.Year, securityadvisory.CveYearEQ)))
// 		}
// 		if spec.Vulnerability.Ghsa != nil {
// 			query.Where(isvulnerability.HasVulnerabilityWith(securityadvisory.GhsaIDNotNil()))
// 			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Ghsa.GhsaID, securityadvisory.GhsaIDEqualFold)))
// 			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Ghsa.ID, IDEQ)))
// 		}
// 	}

// 	results, err := query.WithOsv().WithVulnerability().All(ctx)
// 	if err != nil {
// 		return nil, err
// 	}

// 	return collect(results, toModelIsVulnerability), nil
// }

// func (b *EntBackend) IngestVulnerability(ctx context.Context, vuln model.VulnerabilityInputSpec) (*model.Vulnerability, error) {
// func (b *EntBackend) IngestCertifyVuln(ctx context.Context, pkg model.PkgInputSpec, spec model.VulnerabilityInputSpec, certifyVuln model.ScanMetadataInput) (*model.CertifyVuln, error) {
// 	// funcName := "IngestVulnerability"
// 	// if err := helper.ValidateVulnerabilityIngestionInput(spec, "IngestVulnerability", true); err != nil {
// 	// 	return nil, Errorf("%v ::  %s", funcName, err)
// 	// }

// 	record, err := WithinTX(ctx, b.client, func(ctx context.Context) (*ent.CertifyVuln, error) {
// 		client := ent.TxFromContext(ctx)
// 		insert := client.CertifyVuln.Create()

// 		columns := []string{
// 			certifyvuln.FieldPackageID,
// 			certifyvuln.FieldCollector,
// 			certifyvuln.FieldScannerURI,
// 			certifyvuln.FieldScannerVersion,
// 			certifyvuln.FieldOrigin,
// 			certifyvuln.FieldDbURI,
// 			certifyvuln.FieldDbVersion,
// 		}

// 		var conflictPredicate *sql.Predicate

// 		if spec.Type == NoVuln {
// 			// No vulnerability found, so we don't have a vulnerability ID to set
// 			conflictPredicate = sql.And(sql.IsNull(certifyvuln.FieldVulnerabilityID))
// 		} else {
// 			vuln, err := getVulnerabilityFromInput(ctx, client.Client(), spec)
// 			if err != nil {
// 				return nil, err
// 			}

// 			insert.SetVulnerability(vuln)
// 			columns = append(columns, certifyvuln.FieldVulnerabilityID)
// 			conflictPredicate = sql.And(sql.NotNull(certifyvuln.FieldVulnerabilityID))
// 		}

// 		pv, err := getPkgVersion(ctx, client.Client(), pkg)
// 		if err != nil {
// 			return nil, err
// 		}

// 		insert.
// 			SetPackage(pv).
// 			SetCollector(certifyVuln.Collector).
// 			SetDbURI(certifyVuln.DbURI).
// 			SetDbVersion(certifyVuln.DbVersion).
// 			SetOrigin(certifyVuln.Origin).
// 			SetScannerURI(certifyVuln.ScannerURI).
// 			SetScannerVersion(certifyVuln.ScannerVersion).
// 			SetTimeScanned(certifyVuln.TimeScanned)

// 		id, err := insert.
// 			OnConflict(
// 				sql.ConflictColumns(columns...),
// 				sql.ConflictWhere(conflictPredicate),
// 			).
// 			UpdateNewValues().
// 			ID(ctx)
// 		if err != nil {
// 			return nil, err
// 		}

// 		return client.CertifyVuln.Query().Where(certifyvuln.IDEQ(id)).
// 			WithPackage(func(q *ent.PackageVersionQuery) {
// 				q.WithName(func(q *ent.PackageNameQuery) {
// 					q.WithNamespace(func(q *ent.PackageNamespaceQuery) {
// 						q.WithPackage()
// 					})
// 				})
// 			}).
// 			WithVulnerability().
// 			Only(ctx)
// 	})
// 	if err != nil {
// 		return nil, err
// 	}

// 	return toModelCertifyVulnerability(record), nil
// }

//func getVulnerability(ctx context.Context, client *ent.Client, query model.VulnerabilitySpec) (*ent.VulnerabilityID, error) {
//	results, err := getVulnerabilities(ctx, client, query)
//	if err != nil {
//		return nil, err
//	}
//
//	if len(results) == 0 {
//		return nil, &ent.NotFoundError{}
//	}
//
//	if len(results) > 1 {
//		return nil, &ent.NotSingularError{}
//	}
//
//	return results[0], nil
//}

//func getVulnerabilities(ctx context.Context, client *ent.Client, query model.VulnerabilitySpec) (ent.VulnerabilityIDs, error) {
//	results, err := client.VulnerabilityID.Query().
//		Where(
//			optionalPredicate(query.ID, IDEQ),
//			optionalPredicate(query.VulnerabilityID, vulnerabilityid.VulnerabilityIDEqualFold),
//			vulnerabilityid.HasTypeWith(
//				optionalPredicate(query.Type, vulnerabilitytype.TypeEqualFold),
//			),
//		).
//		WithType().
//		Limit(MaxPageSize).
//		All(ctx)
//	if err != nil {
//		return nil, err
//	}
//	return results, nil
//}

//func getVulnerabilityFromInput(ctx context.Context, client *ent.Client, spec model.VulnerabilityInputSpec) (*ent.VulnerabilityID, error) {
//	var vuln *ent.VulnerabilityID
//	vuln, err := getVulnerability(ctx, client, model.VulnerabilitySpec{
//		Type:            &spec.Type,
//		VulnerabilityID: &spec.VulnerabilityID,
//	})
//	if err != nil {
//		return nil, err
//	}
//	return vuln, nil
//}

//func upsertVulnerability(ctx context.Context, client *ent.Tx, spec model.VulnerabilityInputSpec) (*ent.VulnerabilityID, error) {
//	// Ingest the type record and ignore if it already exists
//	typeId, err := client.VulnerabilityType.Create().
//		SetType(strings.ToLower(spec.Type)).
//		OnConflict(sql.ConflictColumns(vulnerabilitytype.FieldType)).
//		Ignore().
//		ID(ctx)
//	if err != nil {
//		return nil, err
//	}
//
//	vulnInsert := client.VulnerabilityID.Create()
//	vulnID := strings.ToLower(spec.VulnerabilityID)
//
//	vulnInsert.
//		SetTypeID(typeId).
//		SetVulnerabilityID(vulnID)
//
//	err = vulnInsert.
//		OnConflict(
//			sql.ConflictColumns(vulnerabilityid.FieldTypeID, vulnerabilityid.FieldVulnerabilityID),
//		).
//		DoNothing().
//		Exec(ctx)
//	if err != nil {
//		return nil, err
//	}
//
//	return getVulnerabilityFromInput(ctx, client.Client(), spec)
//
//	// return client.Vulnerability.Get(ctx, id)
//}

// func (b *EntBackend) CertifyVuln(ctx context.Context, spec *model.CertifyVulnSpec) ([]*model.CertifyVuln, error) {
// 	predicates := []predicate.CertifyVuln{
// 		optionalPredicate(spec.ID, IDEQ),
// 		optionalPredicate(spec.Collector, certifyvuln.CollectorEQ),
// 		optionalPredicate(spec.Origin, certifyvuln.OriginEQ),
// 		optionalPredicate(spec.DbURI, certifyvuln.DbURIEQ),
// 		optionalPredicate(spec.DbVersion, certifyvuln.DbVersionEQ),
// 		optionalPredicate(spec.ScannerURI, certifyvuln.ScannerURIEQ),
// 		optionalPredicate(spec.TimeScanned, certifyvuln.TimeScannedEQ),
// 		optionalPredicate(spec.Package, func(pkg model.PkgSpec) predicate.CertifyVuln {
// 			return certifyvuln.HasPackageWith(
// 				optionalPredicate(spec.ID, IDEQ),
// 				optionalPredicate(pkg.Version, packageversion.VersionEQ),
// 				optionalPredicate(pkg.Subpath, packageversion.SubpathEQ),
// 				packageversion.QualifiersMatch(pkg.Qualifiers, ptrWithDefault(pkg.MatchOnlyEmptyQualifiers, false)),

// 				packageversion.HasNameWith(
// 					optionalPredicate(pkg.Name, packagename.Name),
// 					packagename.HasNamespaceWith(
// 						optionalPredicate(pkg.Namespace, packagenamespace.Namespace),
// 						packagenamespace.HasPackageWith(
// 							optionalPredicate(pkg.Type, packagetype.Type),
// 						),
// 					),
// 				),
// 			)
// 		}),
// 	}

// 	var vulnPreds []predicate.SecurityAdvisory
// 	if spec.Vulnerability != nil {
// 		if spec.Vulnerability.Cve != nil {
// 			vulnPreds = append(vulnPreds, optionalPredicate(spec.Vulnerability.Cve.ID, IDEQ))
// 			vulnPreds = append(vulnPreds, optionalPredicate(spec.Vulnerability.Cve.CveID, securityadvisory.CveIDEqualFold))
// 			vulnPreds = append(vulnPreds, optionalPredicate(spec.Vulnerability.Cve.Year, securityadvisory.CveYearEQ))
// 		}
// 		if spec.Vulnerability.Osv != nil {
// 			vulnPreds = append(vulnPreds, optionalPredicate(spec.Vulnerability.Osv.ID, IDEQ))
// 			vulnPreds = append(vulnPreds, optionalPredicate(spec.Vulnerability.Osv.OsvID, securityadvisory.OsvIDEqualFold))
// 		}
// 		if spec.Vulnerability.Ghsa != nil {
// 			vulnPreds = append(vulnPreds, optionalPredicate(spec.Vulnerability.Ghsa.ID, IDEQ))
// 			vulnPreds = append(vulnPreds, optionalPredicate(spec.Vulnerability.Ghsa.GhsaID, securityadvisory.GhsaIDEqualFold))
// 		}
// 		if spec.Vulnerability.NoVuln == nil {
// 			predicates = append(predicates, certifyvuln.HasVulnerabilityWith(vulnPreds...))
// 		}
// 	}

// 	records, err := b.client.CertifyVuln.Query().
// 		Where(predicates...).
// 		WithPackage(func(q *ent.PackageVersionQuery) {
// 			q.WithName(func(q *ent.PackageNameQuery) {
// 				q.WithNamespace(func(q *ent.PackageNamespaceQuery) {
// 					q.WithPackage()
// 				})
// 			})
// 		}).
// 		WithVulnerability().
// 		All(ctx)
// 	if err != nil {
// 		return nil, err
// 	}

// 	return collect(records, toModelCertifyVulnerability), nil
// }

// func (b *EntBackend) IngestIsVulnerability(ctx context.Context, osv model.OSVInputSpec, vulnerability model.CveOrGhsaInput, isVulnerability model.IsVulnerabilityInputSpec) (*model.IsVulnerability, error) {
// 	record, err := WithinTX(ctx, b.client, func(ctx context.Context) (*ent.IsVulnerability, error) {
// 		client := ent.TxFromContext(ctx)

// 		osvs, err := getAdvisories(ctx, client.Client(), &advisoryQuerySpec{
// 			OsvID: &osv.OsvID,
// 		})
// 		if err != nil {
// 			return nil, err
// 		}
// 		if len(osvs) != 1 {
// 			return nil, fmt.Errorf("multiple OSVs returned for osv_id %q", osv.OsvID)
// 		}

// 		vulnQuerySpec := &advisoryQuerySpec{}
// 		if vulnerability.Ghsa != nil {
// 			vulnQuerySpec.GhsaID = &vulnerability.Ghsa.GhsaID
// 		} else if vulnerability.Cve != nil {
// 			vulnQuerySpec.CveID = &vulnerability.Cve.CveID
// 			vulnQuerySpec.Year = &vulnerability.Cve.Year
// 		} else {
// 			return nil, fmt.Errorf("missing vulnerability input, needs GHSA or CVE")
// 		}

// 		vulns, err := getAdvisories(ctx, client.Client(), vulnQuerySpec)
// 		if err != nil {
// 			return nil, err
// 		}
// 		if len(vulns) != 1 {
// 			return nil, fmt.Errorf("multiple vulnerabilities returned, needs a single advisory to ingest")
// 		}

// 		id, err := client.IsVulnerability.Create().
// 			SetCollector(isVulnerability.Collector).
// 			SetJustification(isVulnerability.Justification).
// 			SetOrigin(isVulnerability.Origin).
// 			SetOsv(osvs[0]).
// 			SetVulnerability(vulns[0]).
// 			OnConflict(
// 				sql.ConflictColumns(
// 					isvulnerability.FieldOsvID,
// 					isvulnerability.FieldVulnerabilityID,
// 					isvulnerability.FieldOrigin,
// 					isvulnerability.FieldJustification,
// 				),
// 			).
// 			UpdateNewValues().
// 			ID(ctx)
// 		if err != nil {
// 			return nil, err
// 		}

// 		return client.IsVulnerability.Query().
// 			Where(isvulnerability.ID(id)).
// 			WithOsv(func(q *ent.SecurityAdvisoryQuery) {
// 				q.Select(securityadvisory.FieldID, securityadvisory.FieldOsvID)
// 			}).
// 			WithVulnerability(func(q *ent.SecurityAdvisoryQuery) {
// 				q.Select(securityadvisory.FieldID, securityadvisory.FieldCveID, securityadvisory.FieldGhsaID, securityadvisory.FieldCveYear)
// 			}).
// 			Only(ctx)
// 	})
// 	if err != nil {
// 		return nil, err
// 	}

// 	return toModelIsVulnerability(record), nil
// }

func toModelVulnerability(vuln *ent.VulnerabilityType) *model.Vulnerability {
	return &model.Vulnerability{
		ID:               nodeID(vuln.ID),
		Type:             vuln.Type,
		VulnerabilityIDs: collect(vuln.Edges.VulnerabilityIds, toModelVulnerabilityID),
	}
}

func toModelVulnerabilityID(vulnID *ent.VulnerabilityID) *model.VulnerabilityID {
	return &model.VulnerabilityID{
		ID:              nodeID(vulnID.ID),
		VulnerabilityID: vulnID.VulnerabilityID,
	}
}

//func toModelCertifyVulnerability(record *ent.CertifyVuln) *model.CertifyVuln {
//	// var vuln model.Vulnerability
//
//	// switch {
//	// case record.Edges.Vulnerability == nil:
//	// 	vuln = &model.NoVuln{ID: nodeID(record.ID)}
//	// case record.Edges.Vulnerability.CveID != nil:
//	// 	vuln = toModelCVE(record.Edges.Vulnerability)
//	// case record.Edges.Vulnerability.GhsaID != nil:
//	// 	vuln = toModelGHSA(record.Edges.Vulnerability)
//	// case record.Edges.Vulnerability.OsvID != nil:
//	// 	vuln = toModelOSV(record.Edges.Vulnerability)
//	// }
//
//	return &model.CertifyVuln{
//		ID:            nodeID(record.ID),
//		Package:       toModelPackage(backReferencePackageVersion(record.Edges.Package)),
//		Vulnerability: toModelVulnerability(record.Edges.Vulnerability),
//		Metadata: &model.ScanMetadata{
//			TimeScanned:    record.TimeScanned,
//			DbURI:          record.DbURI,
//			DbVersion:      record.DbVersion,
//			ScannerURI:     record.ScannerURI,
//			ScannerVersion: record.ScannerVersion,
//			Origin:         record.Origin,
//			Collector:      record.Collector,
//		},
//	}
//
//}

// func toModelIsVulnerability(record *ent.IsVulnerability) *model.IsVulnerability {
// 	return &model.IsVulnerability{
// 		ID:            nodeID(record.ID),
// 		Osv:           toModelOSV(record.Edges.Osv),
// 		Vulnerability: toModelGHSAOrCVE(record.Edges.Vulnerability),
// 		Justification: record.Justification,
// 		Origin:        record.Origin,
// 		Collector:     record.Collector,
// 	}
// }

// func toModelGHSAOrCVE(record *ent.SecurityAdvisory) model.CveOrGhsa {
// 	switch {
// 	case record == nil:
// 		return nil
// 	case record.CveID != nil:
// 		return toModelCVE(record)
// 	case record.GhsaID != nil:
// 		return toModelGHSA(record)
// 	default:
// 		return nil
// 	}
// }
