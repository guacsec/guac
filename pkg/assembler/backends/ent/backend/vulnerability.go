package backend

import (
	"context"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"github.com/guacsec/guac/pkg/assembler/backends/ent"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvuln"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/isvulnerability"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagetype"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/predicate"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/securityadvisory"
	"github.com/guacsec/guac/pkg/assembler/backends/helper"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

func (b *EntBackend) IsVulnerability(ctx context.Context, spec *model.IsVulnerabilitySpec) ([]*model.IsVulnerability, error) {
	if spec != nil {
		if err := helper.ValidateCveOrGhsaQueryFilter(spec.Vulnerability); err != nil {
			return nil, err
		}
	}

	query := b.client.IsVulnerability.Query().Where(
		optionalPredicate(spec.ID, IDEQ),
		optionalPredicate(spec.Collector, isvulnerability.CollectorEQ),
		optionalPredicate(spec.Justification, isvulnerability.JustificationEQ),
		optionalPredicate(spec.Origin, isvulnerability.OriginEQ),
	)

	if spec.Osv != nil {
		query.Where(isvulnerability.HasOsvWith(optionalPredicate(spec.Osv.OsvID, securityadvisory.OsvIDEqualFold)))
	}

	if spec.Vulnerability != nil {
		if spec.Vulnerability.Cve != nil {
			query.Where(isvulnerability.HasVulnerabilityWith(securityadvisory.CveIDNotNil()))
			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Cve.CveID, securityadvisory.CveIDEqualFold)))
			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Cve.Year, securityadvisory.CveYearEQ)))
		}
		if spec.Vulnerability.Ghsa != nil {
			query.Where(isvulnerability.HasVulnerabilityWith(securityadvisory.GhsaIDNotNil()))
			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Ghsa.GhsaID, securityadvisory.GhsaIDEqualFold)))
			query.Where(isvulnerability.HasVulnerabilityWith(optionalPredicate(spec.Vulnerability.Ghsa.ID, IDEQ)))
		}
	}

	results, err := query.WithOsv().WithVulnerability().All(ctx)
	if err != nil {
		return nil, err
	}

	return collect(results, toModelIsVulnerability), nil
}

func (b *EntBackend) IngestVulnerability(ctx context.Context, pkg model.PkgInputSpec, spec model.VulnerabilityInput, certifyVuln model.VulnerabilityMetaDataInput) (*model.CertifyVuln, error) {
	funcName := "IngestVulnerability"
	if err := helper.ValidateVulnerabilityIngestionInput(spec, "IngestVulnerability", true); err != nil {
		return nil, Errorf("%v ::  %s", funcName, err)
	}
	if b.client == nil {
		return nil, Errorf("%v ::  %s", funcName, "client is nil")
	}

	record, err := WithinTX(ctx, b.client, func(ctx context.Context) (*ent.CertifyVuln, error) {
		client := ent.TxFromContext(ctx)
		insert := client.CertifyVuln.Create()

		columns := []string{
			certifyvuln.FieldPackageID,
			certifyvuln.FieldCollector,
			certifyvuln.FieldScannerURI,
			certifyvuln.FieldScannerVersion,
			certifyvuln.FieldOrigin,
			certifyvuln.FieldDbURI,
			certifyvuln.FieldDbVersion,
		}

		var conflictPredicate *sql.Predicate

		if spec.NoVuln != nil && *spec.NoVuln {
			// No vulnerability

			conflictPredicate = sql.And(sql.IsNull(certifyvuln.FieldVulnerabilityID))
		} else {
			vuln, err := getAdvisoryFromVulnerabilityInput(ctx, client.Client(), spec)
			if err != nil {
				return nil, err
			}

			insert.SetVulnerability(vuln)
			columns = append(columns, certifyvuln.FieldVulnerabilityID)
			conflictPredicate = sql.And(sql.NotNull(certifyvuln.FieldVulnerabilityID))
		}

		pv, err := getPkgVersion(ctx, client.Client(), pkg)
		if err != nil {
			return nil, err
		}

		insert.
			SetPackage(pv).
			SetCollector(certifyVuln.Collector).
			SetDbURI(certifyVuln.DbURI).
			SetDbVersion(certifyVuln.DbVersion).
			SetOrigin(certifyVuln.Origin).
			SetScannerURI(certifyVuln.ScannerURI).
			SetScannerVersion(certifyVuln.ScannerVersion).
			SetTimeScanned(certifyVuln.TimeScanned)

		id, err := insert.
			OnConflict(
				sql.ConflictColumns(columns...),
				sql.ConflictWhere(conflictPredicate),
			).
			UpdateNewValues().
			ID(ctx)
		if err != nil {
			return nil, err
		}

		return client.CertifyVuln.Query().Where(certifyvuln.IDEQ(id)).
			WithPackage(func(q *ent.PackageVersionQuery) {
				q.WithName(func(q *ent.PackageNameQuery) {
					q.WithNamespace(func(q *ent.PackageNamespaceQuery) {
						q.WithPackage()
					})
				})
			}).
			WithVulnerability().
			Only(ctx)
	})
	if err != nil {
		return nil, err
	}

	return toModelCertifyVulnerability(record), nil
}

func getAdvisoryFromVulnerabilityInput(ctx context.Context, client *ent.Client, spec model.VulnerabilityInput) (*ent.SecurityAdvisory, error) {
	var cveOrGhsaOrOsv *ent.SecurityAdvisory
	var query *advisoryQuerySpec
	switch {
	case spec.Cve != nil:
		query = &advisoryQuerySpec{
			CveID: &spec.Cve.CveID,
			Year:  &spec.Cve.Year,
		}
	case spec.Ghsa != nil:
		query = &advisoryQuerySpec{
			GhsaID: &spec.Ghsa.GhsaID,
		}
	case spec.Osv != nil:
		query = &advisoryQuerySpec{
			OsvID: &spec.Osv.OsvID,
		}
	}
	cveOrGhsaOrOsv, err := getAdvisory(ctx, client, query)
	if err != nil {
		return nil, err
	}
	return cveOrGhsaOrOsv, nil
}

func (b *EntBackend) CertifyVuln(ctx context.Context, spec *model.CertifyVulnSpec) ([]*model.CertifyVuln, error) {
	records, err := b.client.CertifyVuln.Query().
		Where(
			optionalPredicate(spec.ID, IDEQ),
			optionalPredicate(spec.Collector, certifyvuln.CollectorEQ),
			optionalPredicate(spec.Origin, certifyvuln.OriginEQ),
			optionalPredicate(spec.DbURI, certifyvuln.DbURIEQ),
			optionalPredicate(spec.DbVersion, certifyvuln.DbVersionEQ),
			optionalPredicate(spec.ScannerURI, certifyvuln.ScannerURIEQ),
			optionalPredicate(spec.TimeScanned, certifyvuln.TimeScannedEQ),
			optionalPredicate(spec.Package, func(pkg model.PkgSpec) predicate.CertifyVuln {
				return certifyvuln.HasPackageWith(
					optionalPredicate(spec.ID, IDEQ),
					optionalPredicate(pkg.Version, packageversion.VersionEQ),
					optionalPredicate(pkg.Subpath, packageversion.SubpathEQ),
					packageversion.QualifiersMatch(pkg.Qualifiers, ptrWithDefault(pkg.MatchOnlyEmptyQualifiers, false)),

					packageversion.HasNameWith(
						optionalPredicate(pkg.Name, packagename.Name),
						packagename.HasNamespaceWith(
							optionalPredicate(pkg.Namespace, packagenamespace.Namespace),
							packagenamespace.HasPackageWith(
								optionalPredicate(pkg.Type, packagetype.Type),
							),
						),
					),
				)
			}),
		).
		WithPackage(func(q *ent.PackageVersionQuery) {
			q.WithName(func(q *ent.PackageNameQuery) {
				q.WithNamespace(func(q *ent.PackageNamespaceQuery) {
					q.WithPackage()
				})
			})
		}).
		WithVulnerability().
		All(ctx)
	if err != nil {
		return nil, err
	}

	return collect(records, toModelCertifyVulnerability), nil
}

func (b *EntBackend) IngestIsVulnerability(ctx context.Context, osv model.OSVInputSpec, vulnerability model.CveOrGhsaInput, isVulnerability model.IsVulnerabilityInputSpec) (*model.IsVulnerability, error) {
	record, err := WithinTX(ctx, b.client, func(ctx context.Context) (*ent.IsVulnerability, error) {
		client := ent.TxFromContext(ctx)

		osvs, err := getAdvisories(ctx, client.Client(), &advisoryQuerySpec{
			OsvID: &osv.OsvID,
		})
		if err != nil {
			return nil, err
		}
		if len(osvs) != 1 {
			return nil, fmt.Errorf("multiple OSVs returned for osv_id %q", osv.OsvID)
		}

		vulnQuerySpec := &advisoryQuerySpec{}
		if vulnerability.Ghsa != nil {
			vulnQuerySpec.GhsaID = &vulnerability.Ghsa.GhsaID
		} else if vulnerability.Cve != nil {
			vulnQuerySpec.CveID = &vulnerability.Cve.CveID
			vulnQuerySpec.Year = &vulnerability.Cve.Year
		} else {
			return nil, fmt.Errorf("missing vulnerability input, needs GHSA or CVE")
		}

		vulns, err := getAdvisories(ctx, client.Client(), vulnQuerySpec)
		if err != nil {
			return nil, err
		}
		if len(vulns) != 1 {
			return nil, fmt.Errorf("multiple vulnerabilities returned, needs a single advisory to ingest")
		}

		id, err := client.IsVulnerability.Create().
			SetCollector(isVulnerability.Collector).
			SetJustification(isVulnerability.Justification).
			SetOrigin(isVulnerability.Origin).
			SetOsv(osvs[0]).
			SetVulnerability(vulns[0]).
			OnConflict(
				sql.ConflictColumns(
					isvulnerability.FieldOsvID,
					isvulnerability.FieldVulnerabilityID,
					isvulnerability.FieldOrigin,
					isvulnerability.FieldJustification,
				),
			).
			UpdateNewValues().
			ID(ctx)
		if err != nil {
			return nil, err
		}

		return client.IsVulnerability.Query().
			Where(isvulnerability.ID(id)).
			WithOsv(func(q *ent.SecurityAdvisoryQuery) {
				q.Select(securityadvisory.FieldID, securityadvisory.FieldOsvID)
			}).
			WithVulnerability(func(q *ent.SecurityAdvisoryQuery) {
				q.Select(securityadvisory.FieldID, securityadvisory.FieldCveID, securityadvisory.FieldGhsaID, securityadvisory.FieldCveYear)
			}).
			Only(ctx)
	})
	if err != nil {
		return nil, err
	}

	return toModelIsVulnerability(record), nil
}

func toModelCertifyVulnerability(record *ent.CertifyVuln) *model.CertifyVuln {
	var vuln model.Vulnerability

	switch {
	case record.Edges.Vulnerability == nil:
		vuln = &model.NoVuln{ID: nodeID(record.ID)}
	case record.Edges.Vulnerability.CveID != nil:
		vuln = toModelCVE(record.Edges.Vulnerability)
	case record.Edges.Vulnerability.GhsaID != nil:
		vuln = toModelGHSA(record.Edges.Vulnerability)
	case record.Edges.Vulnerability.OsvID != nil:
		vuln = toModelOSV(record.Edges.Vulnerability)
	}

	return &model.CertifyVuln{
		ID:            nodeID(record.ID),
		Package:       toModelPackage(backReferencePackageVersion(record.Edges.Package)),
		Vulnerability: vuln,
		Metadata: &model.VulnerabilityMetaData{
			TimeScanned:    record.TimeScanned,
			DbURI:          record.DbURI,
			DbVersion:      record.DbVersion,
			ScannerURI:     record.ScannerURI,
			ScannerVersion: record.ScannerVersion,
			Origin:         record.Origin,
			Collector:      record.Collector,
		},
	}

}

func toModelIsVulnerability(record *ent.IsVulnerability) *model.IsVulnerability {
	return &model.IsVulnerability{
		ID:            nodeID(record.ID),
		Osv:           toModelOSV(record.Edges.Osv),
		Vulnerability: toModelGHSAOrCVE(record.Edges.Vulnerability),
		Justification: record.Justification,
		Origin:        record.Origin,
		Collector:     record.Collector,
	}
}

func toModelGHSAOrCVE(record *ent.SecurityAdvisory) model.CveOrGhsa {
	switch {
	case record == nil:
		return nil
	case record.CveID != nil:
		return toModelCVE(record)
	case record.GhsaID != nil:
		return toModelGHSA(record)
	default:
		return nil
	}
}
