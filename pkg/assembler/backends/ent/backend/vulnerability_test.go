package backend

import (
	"strconv"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/guacsec/guac/internal/testing/ptrfrom"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

var t1, _ = time.Parse(time.RFC3339, "2023-01-01T00:00:00Z")

var vmd1 = &model.VulnerabilityMetaData{
	Collector:      "test collector",
	Origin:         "test origin",
	ScannerVersion: "v1.0.0",
	ScannerURI:     "test scanner uri",
	DbVersion:      "2023.01.01",
	DbURI:          "test db uri",
	TimeScanned:    t1,
}

func (s *Suite) TestIngestVulnerability() {
	type call struct {
		Pkg        *model.PkgInputSpec
		Vuln       *model.VulnerabilityInput
		CerifyVuln *model.VulnerabilityMetaDataInput
	}

	tests := []struct {
		InPkg        []*model.PkgInputSpec
		Name         string
		InOsv        []*model.OSVInputSpec
		InCve        []*model.CVEInputSpec
		InGhsa       []*model.GHSAInputSpec
		Calls        []call
		ExpVuln      []*model.CertifyVuln
		Query        *model.CertifyVulnSpec
		ExpIngestErr bool
		ExpQueryErr  bool
		Only         bool
	}{
		{
			Name:  "HappyPath",
			InCve: []*model.CVEInputSpec{c1},
			InPkg: []*model.PkgInputSpec{p2},
			Calls: []call{
				{
					Pkg: p2,
					Vuln: &model.VulnerabilityInput{
						Cve: c1,
					},
					CerifyVuln: &model.VulnerabilityMetaDataInput{
						Collector:      "test collector",
						Origin:         "test origin",
						ScannerVersion: "v1.0.0",
						ScannerURI:     "test scanner uri",
						DbVersion:      "2023.01.01",
						DbURI:          "test db uri",
						TimeScanned:    t1,
					},
				},
			},
			Query: &model.CertifyVulnSpec{
				Collector: ptrfrom.String("test collector"),
			},
			ExpVuln: []*model.CertifyVuln{
				{
					ID:            "1",
					Package:       p2out,
					Vulnerability: c1out,
					Metadata:      vmd1,
				},
			},
		},
		{
			Name:  "Certify NoVuln",
			InPkg: []*model.PkgInputSpec{p2},
			Calls: []call{
				{
					Pkg: p2,
					Vuln: &model.VulnerabilityInput{
						NoVuln: ptrfrom.Bool(true),
					},
					CerifyVuln: &model.VulnerabilityMetaDataInput{
						Collector:      "test collector",
						Origin:         "test origin",
						ScannerVersion: "v1.0.0",
						ScannerURI:     "test scanner uri",
						DbVersion:      "2023.01.01",
						DbURI:          "test db uri",
						TimeScanned:    t1,
					},
				},
			},
			Query: &model.CertifyVulnSpec{
				Collector: ptrfrom.String("test collector"),
			},
			ExpVuln: []*model.CertifyVuln{
				{
					Package:       p2out,
					Vulnerability: &model.NoVuln{ID: "1"},
					Metadata:      vmd1,
				},
			},
		},
		{
			Name:  "Certify OSV",
			InOsv: []*model.OSVInputSpec{o1},
			InPkg: []*model.PkgInputSpec{p2},
			Calls: []call{
				{
					Pkg: p2,
					Vuln: &model.VulnerabilityInput{
						Osv: o1,
					},
					CerifyVuln: &model.VulnerabilityMetaDataInput{
						Collector:      "test collector",
						Origin:         "test origin",
						ScannerVersion: "v1.0.0",
						ScannerURI:     "test scanner uri",
						DbVersion:      "2023.01.01",
						DbURI:          "test db uri",
						TimeScanned:    t1,
					},
				},
			},
			Query: &model.CertifyVulnSpec{
				Collector: ptrfrom.String("test collector"),
			},
			ExpVuln: []*model.CertifyVuln{
				{
					Package:       p2out,
					Vulnerability: o1out,
					Metadata:      vmd1,
				},
			},
		},
		{
			Name:   "Certify GHSA",
			InGhsa: []*model.GHSAInputSpec{g1},
			InPkg:  []*model.PkgInputSpec{p2},
			Calls: []call{
				{
					Pkg: p2,
					Vuln: &model.VulnerabilityInput{
						Ghsa: g1,
					},
					CerifyVuln: &model.VulnerabilityMetaDataInput{
						Collector:      "test collector",
						Origin:         "test origin",
						ScannerVersion: "v1.0.0",
						ScannerURI:     "test scanner uri",
						DbVersion:      "2023.01.01",
						DbURI:          "test db uri",
						TimeScanned:    t1,
					},
				},
			},
			Query: &model.CertifyVulnSpec{
				Collector: ptrfrom.String("test collector"),
			},
			ExpVuln: []*model.CertifyVuln{
				{
					Package:       p2out,
					Vulnerability: g1out,
					Metadata:      vmd1,
				},
			},
		},
		{
			Name:   "Query on GHSA",
			InGhsa: []*model.GHSAInputSpec{g1},
			InPkg:  []*model.PkgInputSpec{p2},
			Calls: []call{
				{
					Pkg: p2,
					Vuln: &model.VulnerabilityInput{
						Ghsa: g1,
					},
					CerifyVuln: &model.VulnerabilityMetaDataInput{
						Collector:      "test collector",
						Origin:         "test origin",
						ScannerVersion: "v1.0.0",
						ScannerURI:     "test scanner uri",
						DbVersion:      "2023.01.01",
						DbURI:          "test db uri",
						TimeScanned:    t1,
					},
				},
			},
			Query: &model.CertifyVulnSpec{
				Vulnerability: &model.VulnerabilitySpec{
					Ghsa: &model.GHSASpec{
						GhsaID: &g1.GhsaID,
					},
				},
			},
			ExpVuln: []*model.CertifyVuln{
				{
					Package:       p2out,
					Vulnerability: g1out,
					Metadata:      vmd1,
				},
			},
		},
		{
			Name:   "Query on Package",
			InGhsa: []*model.GHSAInputSpec{g1},
			InPkg:  []*model.PkgInputSpec{p2},
			Calls: []call{
				{
					Pkg: p2,
					Vuln: &model.VulnerabilityInput{
						Ghsa: g1,
					},
					CerifyVuln: &model.VulnerabilityMetaDataInput{
						Collector:      "test collector",
						Origin:         "test origin",
						ScannerVersion: "v1.0.0",
						ScannerURI:     "test scanner uri",
						DbVersion:      "2023.01.01",
						DbURI:          "test db uri",
						TimeScanned:    t1,
					},
				},
			},
			Query: &model.CertifyVulnSpec{
				Package: &model.PkgSpec{
					Name: ptrfrom.String(p2.Name),
				},
			},
			ExpVuln: []*model.CertifyVuln{
				{
					Package:       p2out,
					Vulnerability: g1out,
					Metadata:      vmd1,
				},
			},
		},
		{
			Name:   "Query No Vuln",
			InGhsa: []*model.GHSAInputSpec{g1},
			InPkg:  []*model.PkgInputSpec{p2},
			Calls: []call{
				{
					Pkg: p2,
					Vuln: &model.VulnerabilityInput{
						NoVuln: ptrfrom.Bool(true),
					},
					CerifyVuln: &model.VulnerabilityMetaDataInput{
						Collector:      "test collector",
						Origin:         "test origin",
						ScannerVersion: "v1.0.0",
						ScannerURI:     "test scanner uri",
						DbVersion:      "2023.01.01",
						DbURI:          "test db uri",
						TimeScanned:    t1,
					},
				},
			},
			Query: &model.CertifyVulnSpec{
				Vulnerability: &model.VulnerabilitySpec{
					NoVuln: ptrfrom.Bool(true),
				},
			},
			ExpVuln: []*model.CertifyVuln{
				{
					Package:       p2out,
					Vulnerability: &model.NoVuln{ID: "any"},
					Metadata:      vmd1,
				},
			},
		},
		{
			Name:  "Ingest without vuln",
			InPkg: []*model.PkgInputSpec{p2},
			Calls: []call{
				{
					Pkg:        p2,
					Vuln:       &model.VulnerabilityInput{},
					CerifyVuln: &model.VulnerabilityMetaDataInput{},
				},
			},
			Query:        &model.CertifyVulnSpec{},
			ExpIngestErr: true,
		},
		{
			Name:  "Ingest missing pkg",
			InPkg: []*model.PkgInputSpec{},
			Calls: []call{
				{
					Pkg:        p2,
					Vuln:       &model.VulnerabilityInput{},
					CerifyVuln: &model.VulnerabilityMetaDataInput{},
				},
			},
			Query:        &model.CertifyVulnSpec{},
			ExpIngestErr: true,
		},
	}

	ctx := s.Ctx
	hasOnly := false
	for _, t := range tests {
		if t.Only {
			hasOnly = true
			break
		}
	}

	for _, test := range tests {
		if hasOnly && !test.Only {
			continue
		}

		s.Run(test.Name, func() {
			t := s.T()
			b, err := GetBackend(s.Client)
			if err != nil {
				t.Fatalf("Could not instantiate testing backend: %v", err)
			}
			for _, o := range test.InOsv {
				if _, err := b.IngestOsv(ctx, o); err != nil {
					t.Fatalf("Could not ingest osv: %v", err)
				}
			}
			for _, c := range test.InCve {
				if _, err := b.IngestCve(ctx, c); err != nil {
					t.Fatalf("Could not ingest cve: %v", err)
				}
			}
			for _, g := range test.InGhsa {
				if _, err := b.IngestGhsa(ctx, g); err != nil {
					t.Fatalf("Could not ingest ghsa: %a", err)
				}
			}
			if _, err := b.IngestPackages(ctx, test.InPkg); err != nil {
				t.Fatalf("Could not ingest packages: %v", err)
			}

			ids := make([]string, len(test.Calls))
			for i, o := range test.Calls {
				record, err := b.IngestVulnerability(ctx, *o.Pkg, *o.Vuln, *o.CerifyVuln)
				if (err != nil) != test.ExpIngestErr {
					t.Fatalf("did not get expected ingest error, want: %v, got: %v", test.ExpIngestErr, err)
				}
				if err != nil {
					return
				}
				ids[i] = record.ID
			}
			if test.Query != nil {
				if test.Query.ID != nil {
					idIndex, err := strconv.Atoi(*test.Query.ID)
					if err == nil && idIndex > -1 && idIndex < len(ids) {
						test.Query.ID = ptrfrom.String(ids[idIndex])
					}
				}
			}

			got, err := b.CertifyVuln(ctx, test.Query)
			if (err != nil) != test.ExpQueryErr {
				t.Fatalf("did not get expected query error, want: %v, got: %v", test.ExpQueryErr, err)
			}
			if err != nil {
				return
			}
			if diff := cmp.Diff(test.ExpVuln, got, ignoreID); diff != "" {
				t.Errorf("Unexpected results. (-want +got):\n%s", diff)
			}
		})
	}
}

func (s *Suite) TestIsVulnerability() {
	type call struct {
		Osv  *model.OSVInputSpec
		Vuln model.CveOrGhsaInput
		In   *model.IsVulnerabilityInputSpec
	}
	tests := []struct {
		Name         string
		InOsv        []*model.OSVInputSpec
		InCve        []*model.CVEInputSpec
		InGhsa       []*model.GHSAInputSpec
		Calls        []call
		Query        *model.IsVulnerabilitySpec
		ExpOcc       []*model.IsVulnerability
		ExpIngestErr bool
		ExpQueryErr  bool
		Only         bool
	}{
		{
			Name:  "HappyPath",
			InOsv: []*model.OSVInputSpec{o1},
			InCve: []*model.CVEInputSpec{c1},
			Calls: []call{
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
			},
			Query: &model.IsVulnerabilitySpec{
				Justification: ptrfrom.String("test justification"),
			},
			ExpOcc: []*model.IsVulnerability{
				{
					Osv:           o1out,
					Vulnerability: c1out,
					Justification: "test justification",
				},
			},
		},
		{
			Name:  "Igest same twice",
			InOsv: []*model.OSVInputSpec{o1},
			InCve: []*model.CVEInputSpec{c1},
			Calls: []call{
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
			},
			Query: &model.IsVulnerabilitySpec{
				Justification: ptrfrom.String("test justification"),
			},
			ExpOcc: []*model.IsVulnerability{
				{
					Osv:           o1out,
					Vulnerability: c1out,
					Justification: "test justification",
				},
			},
		},
		{
			Name:  "Query on Justification",
			InOsv: []*model.OSVInputSpec{o1},
			InCve: []*model.CVEInputSpec{c1},
			Calls: []call{
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification one",
					},
				},
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification two",
					},
				},
			},
			Query: &model.IsVulnerabilitySpec{
				Justification: ptrfrom.String("test justification one"),
			},
			ExpOcc: []*model.IsVulnerability{
				{
					Osv:           o1out,
					Vulnerability: c1out,
					Justification: "test justification one",
				},
			},
		},
		{
			Name:  "Query on OSV",
			InOsv: []*model.OSVInputSpec{o1, o2},
			InCve: []*model.CVEInputSpec{c1},
			Calls: []call{
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
				{
					Osv: o2,
					Vuln: model.CveOrGhsaInput{
						Cve: c1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
			},
			Query: &model.IsVulnerabilitySpec{
				Osv: &model.OSVSpec{
					OsvID: ptrfrom.String("CVE-2022-26499"),
				},
			},
			ExpOcc: []*model.IsVulnerability{
				{
					Osv:           o2out,
					Vulnerability: c1out,
					Justification: "test justification",
				},
			},
		},
		{
			Name:   "Query on GHSA",
			InOsv:  []*model.OSVInputSpec{o1},
			InCve:  []*model.CVEInputSpec{c1, c2},
			InGhsa: []*model.GHSAInputSpec{g1},
			Calls: []call{
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c2,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Ghsa: g1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
			},
			Query: &model.IsVulnerabilitySpec{
				Vulnerability: &model.CveOrGhsaSpec{
					Ghsa: &model.GHSASpec{},
				},
			},
			ExpOcc: []*model.IsVulnerability{
				{
					Osv:           o1out,
					Vulnerability: g1out,
					Justification: "test justification",
				},
			},
		},
		{
			Name:   "Query none",
			InOsv:  []*model.OSVInputSpec{o1},
			InCve:  []*model.CVEInputSpec{c1, c2},
			InGhsa: []*model.GHSAInputSpec{g1},
			Calls: []call{
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c2,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Ghsa: g1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
			},
			Query: &model.IsVulnerabilitySpec{
				Vulnerability: &model.CveOrGhsaSpec{
					Ghsa: &model.GHSASpec{
						GhsaID: ptrfrom.String("asdf"),
					},
				},
			},
			ExpOcc: nil,
		},
		{
			Name:   "Query multiple",
			InOsv:  []*model.OSVInputSpec{o1},
			InCve:  []*model.CVEInputSpec{c1, c2},
			InGhsa: []*model.GHSAInputSpec{g1},
			Calls: []call{
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c2,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Ghsa: g1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
			},
			Query: &model.IsVulnerabilitySpec{
				Vulnerability: &model.CveOrGhsaSpec{
					Cve: &model.CVESpec{},
				},
			},
			ExpOcc: []*model.IsVulnerability{
				{
					Osv:           o1out,
					Vulnerability: c1out,
					Justification: "test justification",
				},
				{
					Osv:           o1out,
					Vulnerability: c2out,
					Justification: "test justification",
				},
			},
		},
		{
			Name:   "Query ID",
			InOsv:  []*model.OSVInputSpec{o1},
			InCve:  []*model.CVEInputSpec{c1, c2},
			InGhsa: []*model.GHSAInputSpec{g1},
			Calls: []call{
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c2,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Ghsa: g1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
			},
			Query: &model.IsVulnerabilitySpec{
				ID: ptrfrom.String("0"),
			},
			ExpOcc: []*model.IsVulnerability{
				{
					Osv:           o1out,
					Vulnerability: c1out,
					Justification: "test justification",
				},
			},
		},
		{
			Name:   "Query ID not found",
			InOsv:  []*model.OSVInputSpec{o1},
			InCve:  []*model.CVEInputSpec{c1, c2},
			InGhsa: []*model.GHSAInputSpec{g1},
			Calls: []call{
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c2,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Ghsa: g1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
			},
			Query: &model.IsVulnerabilitySpec{
				ID: ptrfrom.String("123456"),
			},
			ExpOcc: nil,
		},
		{
			Name:  "Ingest without Osv",
			InCve: []*model.CVEInputSpec{c1},
			Calls: []call{
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Cve: c1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
			},
			ExpIngestErr: true,
		},
		{
			Name:  "Ingest without GHSA",
			InOsv: []*model.OSVInputSpec{o1},
			Calls: []call{
				{
					Osv: o1,
					Vuln: model.CveOrGhsaInput{
						Ghsa: g1,
					},
					In: &model.IsVulnerabilityInputSpec{
						Justification: "test justification",
					},
				},
			},
			ExpIngestErr: true,
		},
		{
			Name: "Query Error",
			Query: &model.IsVulnerabilitySpec{
				Vulnerability: &model.CveOrGhsaSpec{
					Cve:  &model.CVESpec{},
					Ghsa: &model.GHSASpec{},
				},
			},
			ExpQueryErr: true,
		},
	}
	ctx := s.Ctx
	hasOnly := false
	for _, t := range tests {
		if t.Only {
			hasOnly = true
			break
		}
	}

	for _, test := range tests {
		if hasOnly && !test.Only {
			continue
		}

		s.Run(test.Name, func() {
			t := s.T()
			b, err := GetBackend(s.Client)
			if err != nil {
				t.Fatalf("Could not instantiate testing backend: %v", err)
			}
			for _, o := range test.InOsv {
				if _, err := b.IngestOsv(ctx, o); err != nil {
					t.Fatalf("Could not ingest osv: %v", err)
				}
			}
			for _, c := range test.InCve {
				if _, err := b.IngestCve(ctx, c); err != nil {
					t.Fatalf("Could not ingest cve: %v", err)
				}
			}
			for _, g := range test.InGhsa {
				if _, err := b.IngestGhsa(ctx, g); err != nil {
					t.Fatalf("Could not ingest ghsa: %a", err)
				}
			}
			ids := make([]string, len(test.Calls))
			for i, o := range test.Calls {
				record, err := b.IngestIsVulnerability(ctx, *o.Osv, o.Vuln, *o.In)
				if (err != nil) != test.ExpIngestErr {
					t.Fatalf("did not get expected ingest error, want: %v, got: %v", test.ExpIngestErr, err)
				}
				if err != nil {
					return
				}
				ids[i] = record.ID
			}
			if test.Query.ID != nil {
				idIndex, err := strconv.Atoi(*test.Query.ID)
				if err == nil && idIndex > -1 && idIndex < len(ids) {
					test.Query.ID = ptrfrom.String(ids[idIndex])
				}
			}

			got, err := b.IsVulnerability(ctx, test.Query)
			if (err != nil) != test.ExpQueryErr {
				t.Fatalf("did not get expected query error, want: %v, got: %v", test.ExpQueryErr, err)
			}
			if err != nil {
				return
			}
			if diff := cmp.Diff(test.ExpOcc, got, ignoreID); diff != "" {
				t.Errorf("Unexpected results. (-want +got):\n%s", diff)
			}
		})
	}
}

// func TestVulnerabilityNeighbors(t *testing.T) {
// 	type call struct {
// 		Osv  *model.OSVInputSpec
// 		Vuln model.CveOrGhsaInput
// 		In   *model.IsVulnerabilityInputSpec
// 	}
// 	tests := []struct {
// 		Name         string
// 		InOsv        []*model.OSVInputSpec
// 		InCve        []*model.CVEInputSpec
// 		InGhsa       []*model.GHSAInputSpec
// 		Calls        []call
// 		ExpNeighbors map[string][]string
// 	}{
// 		{
// 			Name:  "HappyPath",
// 			InOsv: []*model.OSVInputSpec{o1},
// 			InCve: []*model.CVEInputSpec{c1},
// 			Calls: []call{
// 				call{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			ExpNeighbors: map[string][]string{
// 				"2": []string{"4"},      // osv to isVuln
// 				"3": []string{"4"},      // cve to isVuln
// 				"4": []string{"2", "3"}, // isVuln to osv and cve
// 			},
// 		},
// 		{
// 			Name:   "Two IsVuln",
// 			InOsv:  []*model.OSVInputSpec{o1},
// 			InCve:  []*model.CVEInputSpec{c1},
// 			InGhsa: []*model.GHSAInputSpec{g1},
// 			Calls: []call{
// 				call{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				call{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Ghsa: g1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			ExpNeighbors: map[string][]string{
// 				"2": []string{"5", "6"}, // osv to both isVuln
// 				"3": []string{"5"},
// 				"4": []string{"6"},
// 				"5": []string{"2", "3"},
// 				"6": []string{"2", "4"},
// 			},
// 		},
// 	}
// 	ctx := context.Background()
// 	for _, test := range tests {
// 		t.Run(test.Name, func(t *testing.T) {
// 			b, err := inmem.GetBackend(nil)
// 			if err != nil {
// 				t.Fatalf("Could not instantiate testing backend: %v", err)
// 			}
// 			for _, o := range test.InOsv {
// 				if _, err := b.IngestOsv(ctx, o); err != nil {
// 					t.Fatalf("Could not ingest osv: %v", err)
// 				}
// 			}
// 			for _, c := range test.InCve {
// 				if _, err := b.IngestCve(ctx, c); err != nil {
// 					t.Fatalf("Could not ingest cve: %v", err)
// 				}
// 			}
// 			for _, g := range test.InGhsa {
// 				if _, err := b.IngestGhsa(ctx, g); err != nil {
// 					t.Fatalf("Could not ingest ghsa: %s", err)
// 				}
// 			}
// 			for _, o := range test.Calls {
// 				if _, err := b.IngestIsVulnerability(ctx, *o.Osv, o.Vuln, *o.In); err != nil {
// 					t.Fatalf("Could not ingest isVulnerability: %s", err)
// 				}
// 			}
// 			for q, r := range test.ExpNeighbors {
// 				got, err := b.Neighbors(ctx, q, nil)
// 				if err != nil {
// 					t.Fatalf("Could not query neighbors: %s", err)
// 				}
// 				gotIDs := convNodes(got)
// 				slices.Sort(r)
// 				slices.Sort(gotIDs)
// 				if diff := cmp.Diff(r, gotIDs); diff != "" {
// 					t.Errorf("Unexpected results. (-want +got):\n%s", diff)
// 				}
// 			}
// 		})
// 	}
// }
