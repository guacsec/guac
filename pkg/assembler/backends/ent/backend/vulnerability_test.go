//
// Copyright 2023 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package backend

//var c1 = &model.VulnerabilityInputSpec{
//	Type:            "cve",
//	VulnerabilityID: "CVE-2019-13110",
//}
//var c1out = &model.VulnerabilityID{
//	VulnerabilityID: "cve-2019-13110",
//}
//
//var c2 = &model.VulnerabilityInputSpec{
//	Type:            "cve",
//	VulnerabilityID: "CVE-2014-8139",
//}
//var c2out = &model.VulnerabilityID{
//	VulnerabilityID: "cve-2014-8139",
//}
//
//var c3 = &model.VulnerabilityInputSpec{
//	Type:            "CVE",
//	VulnerabilityID: "cVe-2014-8140",
//}
//var c3out = &model.VulnerabilityID{
//	VulnerabilityID: "cve-2014-8140",
//}
//
//var g1 = &model.VulnerabilityInputSpec{
//	Type:            "GHSA",
//	VulnerabilityID: "GHSA-h45f-rjvw-2rv2",
//}
//
////var g1out = &model.VulnerabilityID{
////	VulnerabilityID: "ghsa-h45f-rjvw-2rv2",
////}
//
//var g2 = &model.VulnerabilityInputSpec{
//	Type:            "ghsa",
//	VulnerabilityID: "GHSA-xrw3-wqph-3fxg",
//}
//var g2out = &model.VulnerabilityID{
//	VulnerabilityID: "ghsa-xrw3-wqph-3fxg",
//}
//
//var g3 = &model.VulnerabilityInputSpec{
//	Type:            "ghsa",
//	VulnerabilityID: "GHSA-8v4j-7jgf-5rg9",
//}
//var g3out = &model.VulnerabilityID{
//	VulnerabilityID: "ghsa-8v4j-7jgf-5rg9",
//}
//
//var o1 = &model.VulnerabilityInputSpec{
//	Type:            "OSV",
//	VulnerabilityID: "CVE-2014-8140",
//}
//var o1out = &model.VulnerabilityID{
//	VulnerabilityID: "cve-2014-8140",
//}
//
//var o2 = &model.VulnerabilityInputSpec{
//	Type:            "osv",
//	VulnerabilityID: "CVE-2022-26499",
//}
//var o2out = &model.VulnerabilityID{
//	VulnerabilityID: "cve-2022-26499",
//}
//
//var o3 = &model.VulnerabilityInputSpec{
//	Type:            "osv",
//	VulnerabilityID: "GHSA-h45f-rjvw-2rv2",
//}
//var o3out = &model.VulnerabilityID{
//	VulnerabilityID: "ghsa-h45f-rjvw-2rv2",
//}
//
//var noVulnInput = &model.VulnerabilityInputSpec{
//	Type:            "noVuln",
//	VulnerabilityID: "",
//}
//var noVulnOut = &model.VulnerabilityID{
//	VulnerabilityID: "",
//}
//
//func lessCve(a, b *model.Vulnerability) bool {
//	return a.VulnerabilityIDs[0].VulnerabilityID < b.VulnerabilityIDs[0].VulnerabilityID
//}

//func (s *Suite) TestVulnerability() {
//	tests := []struct {
//		Name         string
//		Ingests      []*model.VulnerabilityInputSpec
//		ExpIngestErr bool
//		Query        *model.VulnerabilitySpec
//		Exp          []*model.Vulnerability
//		ExpQueryErr  bool
//	}{
//		{
//			Name:    "HappyPath",
//			Ingests: []*model.VulnerabilityInputSpec{c1},
//			Query:   &model.VulnerabilitySpec{},
//			Exp: []*model.Vulnerability{
//				&model.Vulnerability{
//					Type:             "cve",
//					VulnerabilityIDs: []*model.VulnerabilityID{c1out},
//				},
//			},
//		},
//		{
//			Name:    "Multiple",
//			Ingests: []*model.VulnerabilityInputSpec{c1, c2},
//			Query:   &model.VulnerabilitySpec{},
//			Exp: []*model.Vulnerability{
//				&model.Vulnerability{
//					Type:             "cve",
//					VulnerabilityIDs: []*model.VulnerabilityID{c1out, c2out},
//				},
//			},
//		},
//		{
//			Name:    "Duplicates",
//			Ingests: []*model.VulnerabilityInputSpec{c1, c1, c1},
//			Query:   &model.VulnerabilitySpec{},
//			Exp: []*model.Vulnerability{
//				&model.Vulnerability{
//					Type:             "cve",
//					VulnerabilityIDs: []*model.VulnerabilityID{c1out},
//				},
//			},
//		},
//		{
//			Name:    "Query by type - cve",
//			Ingests: []*model.VulnerabilityInputSpec{c1, c2, c3, g1, o1},
//			Query: &model.VulnerabilitySpec{
//				Type: ptrfrom.String("cve"),
//			},
//			Exp: []*model.Vulnerability{
//				&model.Vulnerability{
//					Type:             "cve",
//					VulnerabilityIDs: []*model.VulnerabilityID{c1out, c2out, c3out},
//				},
//			},
//		},
//		{
//			Name:    "Query by type - ghsa",
//			Ingests: []*model.VulnerabilityInputSpec{c1, c2, c3, g2, g3, o1},
//			Query: &model.VulnerabilitySpec{
//				Type: ptrfrom.String("ghsa"),
//			},
//			Exp: []*model.Vulnerability{
//				&model.Vulnerability{
//					Type:             "ghsa",
//					VulnerabilityIDs: []*model.VulnerabilityID{g2out, g3out},
//				},
//			},
//		},
//		{
//			Name:    "Query by type - osv",
//			Ingests: []*model.VulnerabilityInputSpec{c1, c2, c3, g3, o1, o2, o3},
//			Query: &model.VulnerabilitySpec{
//				Type: ptrfrom.String("osv"),
//			},
//			Exp: []*model.Vulnerability{
//				&model.Vulnerability{
//					Type:             "osv",
//					VulnerabilityIDs: []*model.VulnerabilityID{o1out, o2out, o3out},
//				},
//			},
//		},
//		{
//			Name:    "Query by type - noVuln",
//			Ingests: []*model.VulnerabilityInputSpec{noVulnInput},
//			Query: &model.VulnerabilitySpec{
//				Type: ptrfrom.String("noVuln"),
//			},
//			Exp: []*model.Vulnerability{
//				&model.Vulnerability{
//					Type:             "novuln",
//					VulnerabilityIDs: []*model.VulnerabilityID{noVulnOut},
//				},
//			},
//		},
//		{
//			Name:    "Query by vulnID",
//			Ingests: []*model.VulnerabilityInputSpec{c1, c2, c3},
//			Query: &model.VulnerabilitySpec{
//				VulnerabilityID: ptrfrom.String("CVE-2014-8140"),
//			},
//			Exp: []*model.Vulnerability{
//				&model.Vulnerability{
//					Type:             "cve",
//					VulnerabilityIDs: []*model.VulnerabilityID{c3out},
//				},
//			},
//		},
//		{
//			Name:    "Query by vulnID - noVuln",
//			Ingests: []*model.VulnerabilityInputSpec{c1, c2, c3, noVulnInput},
//			Query: &model.VulnerabilitySpec{
//				Type: ptrfrom.String("noVuln"),
//			},
//			Exp: []*model.Vulnerability{
//				&model.Vulnerability{
//					Type:             "novuln",
//					VulnerabilityIDs: []*model.VulnerabilityID{noVulnOut},
//				},
//			},
//		},
//		{
//			Name:    "Query by ID",
//			Ingests: []*model.VulnerabilityInputSpec{c1},
//			Query: &model.VulnerabilitySpec{
//				ID: ptrfrom.String("2"),
//			},
//			Exp: []*model.Vulnerability{
//				&model.Vulnerability{
//					Type:             "cve",
//					VulnerabilityIDs: []*model.VulnerabilityID{c1out},
//				},
//			},
//		},
//		{
//			Name:    "Query none",
//			Ingests: []*model.VulnerabilityInputSpec{c1, c2, c3},
//			Query: &model.VulnerabilitySpec{
//				Type: ptrfrom.String("ghsa"),
//			},
//			Exp: []*model.Vulnerability{},
//		},
//		{
//			Name:    "Query none ID",
//			Ingests: []*model.VulnerabilityInputSpec{c1, c2, c3},
//			Query: &model.VulnerabilitySpec{
//				ID: ptrfrom.String("12345"),
//			},
//			Exp: nil,
//		},
//		{
//			Name:    "Query invalid ID",
//			Ingests: []*model.VulnerabilityInputSpec{c1, c2, c3},
//			Query: &model.VulnerabilitySpec{
//				ID: ptrfrom.String("asdf"),
//			},
//			ExpQueryErr: true,
//		},
//	}
//
//	for _, test := range tests {
//		s.Run(test.Name, func() {
//			ctx := s.Ctx
//			t := s.T()
//			b, err := GetBackend(s.Client)
//			if err != nil {
//				t.Fatalf("Could not instantiate testing backend: %v", err)
//			}
//			for _, i := range test.Ingests {
//				_, err := b.IngestVulnerability(ctx, *i)
//				if (err != nil) != test.ExpIngestErr {
//					t.Fatalf("did not get expected ingest error, want: %v, got: %v", test.ExpIngestErr, err)
//				}
//				if err != nil {
//					return
//				}
//			}
//			got, err := b.Vulnerabilities(ctx, test.Query)
//			if (err != nil) != test.ExpQueryErr {
//				t.Fatalf("did not get expected query error, want: %v, got: %v", test.ExpQueryErr, err)
//			}
//			if err != nil {
//				return
//			}
//			slices.SortFunc(got, lessCve)
//			if diff := cmp.Diff(test.Exp, got, ignoreID, ignoreEmptySlices); diff != "" {
//				t.Errorf("Unexpected results. (-want +got):\n%s", diff)
//			}
//		})
//	}
//}

// var t1, _ = time.Parse(time.RFC3339, "2023-01-01T00:00:00Z")

// var vmd1 = &model.VulnerabilityMetaData{
// 	Collector:      "test collector",
// 	Origin:         "test origin",
// 	ScannerVersion: "v1.0.0",
// 	ScannerURI:     "test scanner uri",
// 	DbVersion:      "2023.01.01",
// 	DbURI:          "test db uri",
// 	TimeScanned:    t1,
// }

// func (s *Suite) TestIngestVulnerability() {
// 	type call struct {
// 		Pkg        *model.PkgInputSpec
// 		Vuln       *model.VulnerabilityInput
// 		CerifyVuln *model.VulnerabilityMetaDataInput
// 	}

// 	tests := []struct {
// 		InPkg        []*model.PkgInputSpec
// 		Name         string
// 		InOsv        []*model.OSVInputSpec
// 		InCve        []*model.CVEInputSpec
// 		InGhsa       []*model.GHSAInputSpec
// 		Calls        []call
// 		ExpVuln      []*model.CertifyVuln
// 		Query        *model.CertifyVulnSpec
// 		ExpIngestErr bool
// 		ExpQueryErr  bool
// 		Only         bool
// 	}{
// 		{
// 			Name:  "HappyPath",
// 			InCve: []*model.CVEInputSpec{c1},
// 			InPkg: []*model.PkgInputSpec{p2},
// 			Calls: []call{
// 				{
// 					Pkg: p2,
// 					Vuln: &model.VulnerabilityInput{
// 						Cve: c1,
// 					},
// 					CerifyVuln: &model.VulnerabilityMetaDataInput{
// 						Collector:      "test collector",
// 						Origin:         "test origin",
// 						ScannerVersion: "v1.0.0",
// 						ScannerURI:     "test scanner uri",
// 						DbVersion:      "2023.01.01",
// 						DbURI:          "test db uri",
// 						TimeScanned:    t1,
// 					},
// 				},
// 			},
// 			Query: &model.CertifyVulnSpec{
// 				Collector: ptrfrom.String("test collector"),
// 			},
// 			ExpVuln: []*model.CertifyVuln{
// 				{
// 					ID:            "1",
// 					Package:       p2out,
// 					Vulnerability: c1out,
// 					Metadata:      vmd1,
// 				},
// 			},
// 		},
// 		{
// 			Name:  "Certify NoVuln",
// 			InPkg: []*model.PkgInputSpec{p2},
// 			Calls: []call{
// 				{
// 					Pkg: p2,
// 					Vuln: &model.VulnerabilityInput{
// 						NoVuln: ptrfrom.Bool(true),
// 					},
// 					CerifyVuln: &model.VulnerabilityMetaDataInput{
// 						Collector:      "test collector",
// 						Origin:         "test origin",
// 						ScannerVersion: "v1.0.0",
// 						ScannerURI:     "test scanner uri",
// 						DbVersion:      "2023.01.01",
// 						DbURI:          "test db uri",
// 						TimeScanned:    t1,
// 					},
// 				},
// 			},
// 			Query: &model.CertifyVulnSpec{
// 				Collector: ptrfrom.String("test collector"),
// 			},
// 			ExpVuln: []*model.CertifyVuln{
// 				{
// 					Package:       p2out,
// 					Vulnerability: &model.NoVuln{ID: "1"},
// 					Metadata:      vmd1,
// 				},
// 			},
// 		},
// 		{
// 			Name:  "Certify OSV",
// 			InOsv: []*model.OSVInputSpec{o1},
// 			InPkg: []*model.PkgInputSpec{p2},
// 			Calls: []call{
// 				{
// 					Pkg: p2,
// 					Vuln: &model.VulnerabilityInput{
// 						Osv: o1,
// 					},
// 					CerifyVuln: &model.VulnerabilityMetaDataInput{
// 						Collector:      "test collector",
// 						Origin:         "test origin",
// 						ScannerVersion: "v1.0.0",
// 						ScannerURI:     "test scanner uri",
// 						DbVersion:      "2023.01.01",
// 						DbURI:          "test db uri",
// 						TimeScanned:    t1,
// 					},
// 				},
// 			},
// 			Query: &model.CertifyVulnSpec{
// 				Collector: ptrfrom.String("test collector"),
// 			},
// 			ExpVuln: []*model.CertifyVuln{
// 				{
// 					Package:       p2out,
// 					Vulnerability: o1out,
// 					Metadata:      vmd1,
// 				},
// 			},
// 		},
// 		{
// 			Name:   "Certify GHSA",
// 			InGhsa: []*model.GHSAInputSpec{g1},
// 			InPkg:  []*model.PkgInputSpec{p2},
// 			Calls: []call{
// 				{
// 					Pkg: p2,
// 					Vuln: &model.VulnerabilityInput{
// 						Ghsa: g1,
// 					},
// 					CerifyVuln: &model.VulnerabilityMetaDataInput{
// 						Collector:      "test collector",
// 						Origin:         "test origin",
// 						ScannerVersion: "v1.0.0",
// 						ScannerURI:     "test scanner uri",
// 						DbVersion:      "2023.01.01",
// 						DbURI:          "test db uri",
// 						TimeScanned:    t1,
// 					},
// 				},
// 			},
// 			Query: &model.CertifyVulnSpec{
// 				Collector: ptrfrom.String("test collector"),
// 			},
// 			ExpVuln: []*model.CertifyVuln{
// 				{
// 					Package:       p2out,
// 					Vulnerability: g1out,
// 					Metadata:      vmd1,
// 				},
// 			},
// 		},
// 		{
// 			Name:   "Query on GHSA",
// 			InGhsa: []*model.GHSAInputSpec{g1},
// 			InPkg:  []*model.PkgInputSpec{p2},
// 			Calls: []call{
// 				{
// 					Pkg: p2,
// 					Vuln: &model.VulnerabilityInput{
// 						Ghsa: g1,
// 					},
// 					CerifyVuln: &model.VulnerabilityMetaDataInput{
// 						Collector:      "test collector",
// 						Origin:         "test origin",
// 						ScannerVersion: "v1.0.0",
// 						ScannerURI:     "test scanner uri",
// 						DbVersion:      "2023.01.01",
// 						DbURI:          "test db uri",
// 						TimeScanned:    t1,
// 					},
// 				},
// 			},
// 			Query: &model.CertifyVulnSpec{
// 				Vulnerability: &model.VulnerabilitySpec{
// 					Ghsa: &model.GHSASpec{
// 						GhsaID: &g1.GhsaID,
// 					},
// 				},
// 			},
// 			ExpVuln: []*model.CertifyVuln{
// 				{
// 					Package:       p2out,
// 					Vulnerability: g1out,
// 					Metadata:      vmd1,
// 				},
// 			},
// 		},
// 		{
// 			Name:   "Query on Package",
// 			InGhsa: []*model.GHSAInputSpec{g1},
// 			InPkg:  []*model.PkgInputSpec{p2},
// 			Calls: []call{
// 				{
// 					Pkg: p2,
// 					Vuln: &model.VulnerabilityInput{
// 						Ghsa: g1,
// 					},
// 					CerifyVuln: &model.VulnerabilityMetaDataInput{
// 						Collector:      "test collector",
// 						Origin:         "test origin",
// 						ScannerVersion: "v1.0.0",
// 						ScannerURI:     "test scanner uri",
// 						DbVersion:      "2023.01.01",
// 						DbURI:          "test db uri",
// 						TimeScanned:    t1,
// 					},
// 				},
// 			},
// 			Query: &model.CertifyVulnSpec{
// 				Package: &model.PkgSpec{
// 					Name: ptrfrom.String(p2.Name),
// 				},
// 			},
// 			ExpVuln: []*model.CertifyVuln{
// 				{
// 					Package:       p2out,
// 					Vulnerability: g1out,
// 					Metadata:      vmd1,
// 				},
// 			},
// 		},
// 		{
// 			Name:   "Query No Vuln",
// 			InGhsa: []*model.GHSAInputSpec{g1},
// 			InPkg:  []*model.PkgInputSpec{p2},
// 			Calls: []call{
// 				{
// 					Pkg: p2,
// 					Vuln: &model.VulnerabilityInput{
// 						NoVuln: ptrfrom.Bool(true),
// 					},
// 					CerifyVuln: &model.VulnerabilityMetaDataInput{
// 						Collector:      "test collector",
// 						Origin:         "test origin",
// 						ScannerVersion: "v1.0.0",
// 						ScannerURI:     "test scanner uri",
// 						DbVersion:      "2023.01.01",
// 						DbURI:          "test db uri",
// 						TimeScanned:    t1,
// 					},
// 				},
// 			},
// 			Query: &model.CertifyVulnSpec{
// 				Vulnerability: &model.VulnerabilitySpec{
// 					NoVuln: ptrfrom.Bool(true),
// 				},
// 			},
// 			ExpVuln: []*model.CertifyVuln{
// 				{
// 					Package:       p2out,
// 					Vulnerability: &model.NoVuln{ID: "any"},
// 					Metadata:      vmd1,
// 				},
// 			},
// 		},
// 		{
// 			Name:  "Ingest without vuln",
// 			InPkg: []*model.PkgInputSpec{p2},
// 			Calls: []call{
// 				{
// 					Pkg:        p2,
// 					Vuln:       &model.VulnerabilityInput{},
// 					CerifyVuln: &model.VulnerabilityMetaDataInput{},
// 				},
// 			},
// 			Query:        &model.CertifyVulnSpec{},
// 			ExpIngestErr: true,
// 		},
// 		{
// 			Name:  "Ingest missing pkg",
// 			InPkg: []*model.PkgInputSpec{},
// 			Calls: []call{
// 				{
// 					Pkg:        p2,
// 					Vuln:       &model.VulnerabilityInput{},
// 					CerifyVuln: &model.VulnerabilityMetaDataInput{},
// 				},
// 			},
// 			Query:        &model.CertifyVulnSpec{},
// 			ExpIngestErr: true,
// 		},
// 	}

// 	ctx := s.Ctx
// 	hasOnly := false
// 	for _, t := range tests {
// 		if t.Only {
// 			hasOnly = true
// 			break
// 		}
// 	}

// 	for _, test := range tests {
// 		if hasOnly && !test.Only {
// 			continue
// 		}

// 		s.Run(test.Name, func() {
// 			t := s.T()
// 			b, err := GetBackend(s.Client)
// 			if err != nil {
// 				t.Fatalf("Could not instantiate testing backend: %v", err)
// 			}
// 			for _, o := range test.InOsv {
// 				if _, err := b.IngestOsv(ctx, o); err != nil {
// 					t.Fatalf("Could not ingest osv: %v", err)
// 				}
// 			}
// 			for _, c := range test.InCve {
// 				if _, err := b.IngestCve(ctx, c); err != nil {
// 					t.Fatalf("Could not ingest cve: %v", err)
// 				}
// 			}
// 			for _, g := range test.InGhsa {
// 				if _, err := b.IngestGhsa(ctx, g); err != nil {
// 					t.Fatalf("Could not ingest ghsa: %a", err)
// 				}
// 			}
// 			if _, err := b.IngestPackages(ctx, test.InPkg); err != nil {
// 				t.Fatalf("Could not ingest packages: %v", err)
// 			}

// 			ids := make([]string, len(test.Calls))
// 			for i, o := range test.Calls {
// 				record, err := b.IngestVulnerability(ctx, *o.Pkg, *o.Vuln, *o.CerifyVuln)
// 				if (err != nil) != test.ExpIngestErr {
// 					t.Fatalf("did not get expected ingest error, want: %v, got: %v", test.ExpIngestErr, err)
// 				}
// 				if err != nil {
// 					return
// 				}
// 				ids[i] = record.ID
// 			}
// 			if test.Query != nil {
// 				if test.Query.ID != nil {
// 					idIndex, err := strconv.Atoi(*test.Query.ID)
// 					if err == nil && idIndex > -1 && idIndex < len(ids) {
// 						test.Query.ID = ptrfrom.String(ids[idIndex])
// 					}
// 				}
// 			}

// 			got, err := b.CertifyVuln(ctx, test.Query)
// 			if (err != nil) != test.ExpQueryErr {
// 				t.Fatalf("did not get expected query error, want: %v, got: %v", test.ExpQueryErr, err)
// 			}
// 			if err != nil {
// 				return
// 			}
// 			if diff := cmp.Diff(test.ExpVuln, got, ignoreID); diff != "" {
// 				t.Errorf("Unexpected results. (-want +got):\n%s", diff)
// 			}
// 		})
// 	}
// }

// func (s *Suite) TestIsVulnerability() {
// 	type call struct {
// 		Osv  *model.OSVInputSpec
// 		Vuln model.CveOrGhsaInput
// 		In   *model.IsVulnerabilityInputSpec
// 	}
// 	tests := []struct {
// 		Name         string
// 		InOsv        []*model.OSVInputSpec
// 		InCve        []*model.CVEInputSpec
// 		InGhsa       []*model.GHSAInputSpec
// 		Calls        []call
// 		Query        *model.IsVulnerabilitySpec
// 		ExpOcc       []*model.IsVulnerability
// 		ExpIngestErr bool
// 		ExpQueryErr  bool
// 		Only         bool
// 	}{
// 		{
// 			Name:  "HappyPath",
// 			InOsv: []*model.OSVInputSpec{o1},
// 			InCve: []*model.CVEInputSpec{c1},
// 			Calls: []call{
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			Query: &model.IsVulnerabilitySpec{
// 				Justification: ptrfrom.String("test justification"),
// 			},
// 			ExpOcc: []*model.IsVulnerability{
// 				{
// 					Osv:           o1out,
// 					Vulnerability: c1out,
// 					Justification: "test justification",
// 				},
// 			},
// 		},
// 		{
// 			Name:  "Igest same twice",
// 			InOsv: []*model.OSVInputSpec{o1},
// 			InCve: []*model.CVEInputSpec{c1},
// 			Calls: []call{
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			Query: &model.IsVulnerabilitySpec{
// 				Justification: ptrfrom.String("test justification"),
// 			},
// 			ExpOcc: []*model.IsVulnerability{
// 				{
// 					Osv:           o1out,
// 					Vulnerability: c1out,
// 					Justification: "test justification",
// 				},
// 			},
// 		},
// 		{
// 			Name:  "Query on Justification",
// 			InOsv: []*model.OSVInputSpec{o1},
// 			InCve: []*model.CVEInputSpec{c1},
// 			Calls: []call{
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification one",
// 					},
// 				},
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification two",
// 					},
// 				},
// 			},
// 			Query: &model.IsVulnerabilitySpec{
// 				Justification: ptrfrom.String("test justification one"),
// 			},
// 			ExpOcc: []*model.IsVulnerability{
// 				{
// 					Osv:           o1out,
// 					Vulnerability: c1out,
// 					Justification: "test justification one",
// 				},
// 			},
// 		},
// 		{
// 			Name:  "Query on OSV",
// 			InOsv: []*model.OSVInputSpec{o1, o2},
// 			InCve: []*model.CVEInputSpec{c1},
// 			Calls: []call{
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				{
// 					Osv: o2,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			Query: &model.IsVulnerabilitySpec{
// 				Osv: &model.OSVSpec{
// 					OsvID: ptrfrom.String("CVE-2022-26499"),
// 				},
// 			},
// 			ExpOcc: []*model.IsVulnerability{
// 				{
// 					Osv:           o2out,
// 					Vulnerability: c1out,
// 					Justification: "test justification",
// 				},
// 			},
// 		},
// 		{
// 			Name:   "Query on GHSA",
// 			InOsv:  []*model.OSVInputSpec{o1},
// 			InCve:  []*model.CVEInputSpec{c1, c2},
// 			InGhsa: []*model.GHSAInputSpec{g1},
// 			Calls: []call{
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c2,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Ghsa: g1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			Query: &model.IsVulnerabilitySpec{
// 				Vulnerability: &model.CveOrGhsaSpec{
// 					Ghsa: &model.GHSASpec{},
// 				},
// 			},
// 			ExpOcc: []*model.IsVulnerability{
// 				{
// 					Osv:           o1out,
// 					Vulnerability: g1out,
// 					Justification: "test justification",
// 				},
// 			},
// 		},
// 		{
// 			Name:   "Query none",
// 			InOsv:  []*model.OSVInputSpec{o1},
// 			InCve:  []*model.CVEInputSpec{c1, c2},
// 			InGhsa: []*model.GHSAInputSpec{g1},
// 			Calls: []call{
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c2,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Ghsa: g1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			Query: &model.IsVulnerabilitySpec{
// 				Vulnerability: &model.CveOrGhsaSpec{
// 					Ghsa: &model.GHSASpec{
// 						GhsaID: ptrfrom.String("asdf"),
// 					},
// 				},
// 			},
// 			ExpOcc: nil,
// 		},
// 		{
// 			Name:   "Query multiple",
// 			InOsv:  []*model.OSVInputSpec{o1},
// 			InCve:  []*model.CVEInputSpec{c1, c2},
// 			InGhsa: []*model.GHSAInputSpec{g1},
// 			Calls: []call{
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c2,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Ghsa: g1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			Query: &model.IsVulnerabilitySpec{
// 				Vulnerability: &model.CveOrGhsaSpec{
// 					Cve: &model.CVESpec{},
// 				},
// 			},
// 			ExpOcc: []*model.IsVulnerability{
// 				{
// 					Osv:           o1out,
// 					Vulnerability: c1out,
// 					Justification: "test justification",
// 				},
// 				{
// 					Osv:           o1out,
// 					Vulnerability: c2out,
// 					Justification: "test justification",
// 				},
// 			},
// 		},
// 		{
// 			Name:   "Query ID",
// 			InOsv:  []*model.OSVInputSpec{o1},
// 			InCve:  []*model.CVEInputSpec{c1, c2},
// 			InGhsa: []*model.GHSAInputSpec{g1},
// 			Calls: []call{
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c2,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Ghsa: g1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			Query: &model.IsVulnerabilitySpec{
// 				ID: ptrfrom.String("0"),
// 			},
// 			ExpOcc: []*model.IsVulnerability{
// 				{
// 					Osv:           o1out,
// 					Vulnerability: c1out,
// 					Justification: "test justification",
// 				},
// 			},
// 		},
// 		{
// 			Name:   "Query ID not found",
// 			InOsv:  []*model.OSVInputSpec{o1},
// 			InCve:  []*model.CVEInputSpec{c1, c2},
// 			InGhsa: []*model.GHSAInputSpec{g1},
// 			Calls: []call{
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c2,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Ghsa: g1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			Query: &model.IsVulnerabilitySpec{
// 				ID: ptrfrom.String("123456"),
// 			},
// 			ExpOcc: nil,
// 		},
// 		{
// 			Name:  "Ingest without Osv",
// 			InCve: []*model.CVEInputSpec{c1},
// 			Calls: []call{
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			ExpIngestErr: true,
// 		},
// 		{
// 			Name:  "Ingest without GHSA",
// 			InOsv: []*model.OSVInputSpec{o1},
// 			Calls: []call{
// 				{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Ghsa: g1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			ExpIngestErr: true,
// 		},
// 		{
// 			Name: "Query Error",
// 			Query: &model.IsVulnerabilitySpec{
// 				Vulnerability: &model.CveOrGhsaSpec{
// 					Cve:  &model.CVESpec{},
// 					Ghsa: &model.GHSASpec{},
// 				},
// 			},
// 			ExpQueryErr: true,
// 		},
// 	}
// 	ctx := s.Ctx
// 	hasOnly := false
// 	for _, t := range tests {
// 		if t.Only {
// 			hasOnly = true
// 			break
// 		}
// 	}

// 	for _, test := range tests {
// 		if hasOnly && !test.Only {
// 			continue
// 		}

// 		s.Run(test.Name, func() {
// 			t := s.T()
// 			b, err := GetBackend(s.Client)
// 			if err != nil {
// 				t.Fatalf("Could not instantiate testing backend: %v", err)
// 			}
// 			for _, o := range test.InOsv {
// 				if _, err := b.IngestOsv(ctx, o); err != nil {
// 					t.Fatalf("Could not ingest osv: %v", err)
// 				}
// 			}
// 			for _, c := range test.InCve {
// 				if _, err := b.IngestCve(ctx, c); err != nil {
// 					t.Fatalf("Could not ingest cve: %v", err)
// 				}
// 			}
// 			for _, g := range test.InGhsa {
// 				if _, err := b.IngestGhsa(ctx, g); err != nil {
// 					t.Fatalf("Could not ingest ghsa: %a", err)
// 				}
// 			}
// 			ids := make([]string, len(test.Calls))
// 			for i, o := range test.Calls {
// 				record, err := b.IngestIsVulnerability(ctx, *o.Osv, o.Vuln, *o.In)
// 				if (err != nil) != test.ExpIngestErr {
// 					t.Fatalf("did not get expected ingest error, want: %v, got: %v", test.ExpIngestErr, err)
// 				}
// 				if err != nil {
// 					return
// 				}
// 				ids[i] = record.ID
// 			}
// 			if test.Query.ID != nil {
// 				idIndex, err := strconv.Atoi(*test.Query.ID)
// 				if err == nil && idIndex > -1 && idIndex < len(ids) {
// 					test.Query.ID = ptrfrom.String(ids[idIndex])
// 				}
// 			}

// 			got, err := b.IsVulnerability(ctx, test.Query)
// 			if (err != nil) != test.ExpQueryErr {
// 				t.Fatalf("did not get expected query error, want: %v, got: %v", test.ExpQueryErr, err)
// 			}
// 			if err != nil {
// 				return
// 			}
// 			if diff := cmp.Diff(test.ExpOcc, got, ignoreID); diff != "" {
// 				t.Errorf("Unexpected results. (-want +got):\n%s", diff)
// 			}
// 		})
// 	}
// }

// func TestVulnerabilityNeighbors(t *testing.T) {
// 	type call struct {
// 		Osv  *model.OSVInputSpec
// 		Vuln model.CveOrGhsaInput
// 		In   *model.IsVulnerabilityInputSpec
// 	}
// 	tests := []struct {
// 		Name         string
// 		InOsv        []*model.OSVInputSpec
// 		InCve        []*model.CVEInputSpec
// 		InGhsa       []*model.GHSAInputSpec
// 		Calls        []call
// 		ExpNeighbors map[string][]string
// 	}{
// 		{
// 			Name:  "HappyPath",
// 			InOsv: []*model.OSVInputSpec{o1},
// 			InCve: []*model.CVEInputSpec{c1},
// 			Calls: []call{
// 				call{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			ExpNeighbors: map[string][]string{
// 				"2": []string{"4"},      // osv to isVuln
// 				"3": []string{"4"},      // cve to isVuln
// 				"4": []string{"2", "3"}, // isVuln to osv and cve
// 			},
// 		},
// 		{
// 			Name:   "Two IsVuln",
// 			InOsv:  []*model.OSVInputSpec{o1},
// 			InCve:  []*model.CVEInputSpec{c1},
// 			InGhsa: []*model.GHSAInputSpec{g1},
// 			Calls: []call{
// 				call{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Cve: c1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 				call{
// 					Osv: o1,
// 					Vuln: model.CveOrGhsaInput{
// 						Ghsa: g1,
// 					},
// 					In: &model.IsVulnerabilityInputSpec{
// 						Justification: "test justification",
// 					},
// 				},
// 			},
// 			ExpNeighbors: map[string][]string{
// 				"2": []string{"5", "6"}, // osv to both isVuln
// 				"3": []string{"5"},
// 				"4": []string{"6"},
// 				"5": []string{"2", "3"},
// 				"6": []string{"2", "4"},
// 			},
// 		},
// 	}
// 	ctx := context.Background()
// 	for _, test := range tests {
// 		t.Run(test.Name, func(t *testing.T) {
// 			b, err := inmem.GetBackend(nil)
// 			if err != nil {
// 				t.Fatalf("Could not instantiate testing backend: %v", err)
// 			}
// 			for _, o := range test.InOsv {
// 				if _, err := b.IngestOsv(ctx, o); err != nil {
// 					t.Fatalf("Could not ingest osv: %v", err)
// 				}
// 			}
// 			for _, c := range test.InCve {
// 				if _, err := b.IngestCve(ctx, c); err != nil {
// 					t.Fatalf("Could not ingest cve: %v", err)
// 				}
// 			}
// 			for _, g := range test.InGhsa {
// 				if _, err := b.IngestGhsa(ctx, g); err != nil {
// 					t.Fatalf("Could not ingest ghsa: %s", err)
// 				}
// 			}
// 			for _, o := range test.Calls {
// 				if _, err := b.IngestIsVulnerability(ctx, *o.Osv, o.Vuln, *o.In); err != nil {
// 					t.Fatalf("Could not ingest isVulnerability: %s", err)
// 				}
// 			}
// 			for q, r := range test.ExpNeighbors {
// 				got, err := b.Neighbors(ctx, q, nil)
// 				if err != nil {
// 					t.Fatalf("Could not query neighbors: %s", err)
// 				}
// 				gotIDs := convNodes(got)
// 				slices.Sort(r)
// 				slices.Sort(gotIDs)
// 				if diff := cmp.Diff(r, gotIDs); diff != "" {
// 					t.Errorf("Unexpected results. (-want +got):\n%s", diff)
// 				}
// 			}
// 		})
// 	}
// }
