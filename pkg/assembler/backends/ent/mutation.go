// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/artifact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/billofmaterials"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/builder"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certification"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifylegal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyscorecard"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvex"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvuln"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/dependency"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hashequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hasmetadata"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hassourceat"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/license"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/occurrence"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pkgequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pointofcontact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/predicate"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/slsaattestation"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilityid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilitymetadata"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArtifact              = "Artifact"
	TypeBillOfMaterials       = "BillOfMaterials"
	TypeBuilder               = "Builder"
	TypeCertification         = "Certification"
	TypeCertifyLegal          = "CertifyLegal"
	TypeCertifyScorecard      = "CertifyScorecard"
	TypeCertifyVex            = "CertifyVex"
	TypeCertifyVuln           = "CertifyVuln"
	TypeDependency            = "Dependency"
	TypeHasMetadata           = "HasMetadata"
	TypeHasSourceAt           = "HasSourceAt"
	TypeHashEqual             = "HashEqual"
	TypeLicense               = "License"
	TypeOccurrence            = "Occurrence"
	TypePackageName           = "PackageName"
	TypePackageVersion        = "PackageVersion"
	TypePkgEqual              = "PkgEqual"
	TypePointOfContact        = "PointOfContact"
	TypeSLSAAttestation       = "SLSAAttestation"
	TypeSourceName            = "SourceName"
	TypeVulnEqual             = "VulnEqual"
	TypeVulnerabilityID       = "VulnerabilityID"
	TypeVulnerabilityMetadata = "VulnerabilityMetadata"
)

// ArtifactMutation represents an operation that mutates the Artifact nodes in the graph.
type ArtifactMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	algorithm                   *string
	digest                      *string
	clearedFields               map[string]struct{}
	occurrences                 map[uuid.UUID]struct{}
	removedoccurrences          map[uuid.UUID]struct{}
	clearedoccurrences          bool
	sbom                        map[uuid.UUID]struct{}
	removedsbom                 map[uuid.UUID]struct{}
	clearedsbom                 bool
	attestations                map[uuid.UUID]struct{}
	removedattestations         map[uuid.UUID]struct{}
	clearedattestations         bool
	attestations_subject        map[uuid.UUID]struct{}
	removedattestations_subject map[uuid.UUID]struct{}
	clearedattestations_subject bool
	hash_equal_art_a            map[uuid.UUID]struct{}
	removedhash_equal_art_a     map[uuid.UUID]struct{}
	clearedhash_equal_art_a     bool
	hash_equal_art_b            map[uuid.UUID]struct{}
	removedhash_equal_art_b     map[uuid.UUID]struct{}
	clearedhash_equal_art_b     bool
	vex                         map[uuid.UUID]struct{}
	removedvex                  map[uuid.UUID]struct{}
	clearedvex                  bool
	certification               map[uuid.UUID]struct{}
	removedcertification        map[uuid.UUID]struct{}
	clearedcertification        bool
	metadata                    map[uuid.UUID]struct{}
	removedmetadata             map[uuid.UUID]struct{}
	clearedmetadata             bool
	poc                         map[uuid.UUID]struct{}
	removedpoc                  map[uuid.UUID]struct{}
	clearedpoc                  bool
	included_in_sboms           map[uuid.UUID]struct{}
	removedincluded_in_sboms    map[uuid.UUID]struct{}
	clearedincluded_in_sboms    bool
	done                        bool
	oldValue                    func(context.Context) (*Artifact, error)
	predicates                  []predicate.Artifact
}

var _ ent.Mutation = (*ArtifactMutation)(nil)

// artifactOption allows management of the mutation configuration using functional options.
type artifactOption func(*ArtifactMutation)

// newArtifactMutation creates new mutation for the Artifact entity.
func newArtifactMutation(c config, op Op, opts ...artifactOption) *ArtifactMutation {
	m := &ArtifactMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactID sets the ID field of the mutation.
func withArtifactID(id uuid.UUID) artifactOption {
	return func(m *ArtifactMutation) {
		var (
			err   error
			once  sync.Once
			value *Artifact
		)
		m.oldValue = func(ctx context.Context) (*Artifact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artifact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifact sets the old Artifact of the mutation.
func withArtifact(node *Artifact) artifactOption {
	return func(m *ArtifactMutation) {
		m.oldValue = func(context.Context) (*Artifact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Artifact entities.
func (m *ArtifactMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtifactMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artifact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlgorithm sets the "algorithm" field.
func (m *ArtifactMutation) SetAlgorithm(s string) {
	m.algorithm = &s
}

// Algorithm returns the value of the "algorithm" field in the mutation.
func (m *ArtifactMutation) Algorithm() (r string, exists bool) {
	v := m.algorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgorithm returns the old "algorithm" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldAlgorithm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgorithm: %w", err)
	}
	return oldValue.Algorithm, nil
}

// ResetAlgorithm resets all changes to the "algorithm" field.
func (m *ArtifactMutation) ResetAlgorithm() {
	m.algorithm = nil
}

// SetDigest sets the "digest" field.
func (m *ArtifactMutation) SetDigest(s string) {
	m.digest = &s
}

// Digest returns the value of the "digest" field in the mutation.
func (m *ArtifactMutation) Digest() (r string, exists bool) {
	v := m.digest
	if v == nil {
		return
	}
	return *v, true
}

// OldDigest returns the old "digest" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDigest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigest: %w", err)
	}
	return oldValue.Digest, nil
}

// ResetDigest resets all changes to the "digest" field.
func (m *ArtifactMutation) ResetDigest() {
	m.digest = nil
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by ids.
func (m *ArtifactMutation) AddOccurrenceIDs(ids ...uuid.UUID) {
	if m.occurrences == nil {
		m.occurrences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.occurrences[ids[i]] = struct{}{}
	}
}

// ClearOccurrences clears the "occurrences" edge to the Occurrence entity.
func (m *ArtifactMutation) ClearOccurrences() {
	m.clearedoccurrences = true
}

// OccurrencesCleared reports if the "occurrences" edge to the Occurrence entity was cleared.
func (m *ArtifactMutation) OccurrencesCleared() bool {
	return m.clearedoccurrences
}

// RemoveOccurrenceIDs removes the "occurrences" edge to the Occurrence entity by IDs.
func (m *ArtifactMutation) RemoveOccurrenceIDs(ids ...uuid.UUID) {
	if m.removedoccurrences == nil {
		m.removedoccurrences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.occurrences, ids[i])
		m.removedoccurrences[ids[i]] = struct{}{}
	}
}

// RemovedOccurrences returns the removed IDs of the "occurrences" edge to the Occurrence entity.
func (m *ArtifactMutation) RemovedOccurrencesIDs() (ids []uuid.UUID) {
	for id := range m.removedoccurrences {
		ids = append(ids, id)
	}
	return
}

// OccurrencesIDs returns the "occurrences" edge IDs in the mutation.
func (m *ArtifactMutation) OccurrencesIDs() (ids []uuid.UUID) {
	for id := range m.occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetOccurrences resets all changes to the "occurrences" edge.
func (m *ArtifactMutation) ResetOccurrences() {
	m.occurrences = nil
	m.clearedoccurrences = false
	m.removedoccurrences = nil
}

// AddSbomIDs adds the "sbom" edge to the BillOfMaterials entity by ids.
func (m *ArtifactMutation) AddSbomIDs(ids ...uuid.UUID) {
	if m.sbom == nil {
		m.sbom = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sbom[ids[i]] = struct{}{}
	}
}

// ClearSbom clears the "sbom" edge to the BillOfMaterials entity.
func (m *ArtifactMutation) ClearSbom() {
	m.clearedsbom = true
}

// SbomCleared reports if the "sbom" edge to the BillOfMaterials entity was cleared.
func (m *ArtifactMutation) SbomCleared() bool {
	return m.clearedsbom
}

// RemoveSbomIDs removes the "sbom" edge to the BillOfMaterials entity by IDs.
func (m *ArtifactMutation) RemoveSbomIDs(ids ...uuid.UUID) {
	if m.removedsbom == nil {
		m.removedsbom = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.sbom, ids[i])
		m.removedsbom[ids[i]] = struct{}{}
	}
}

// RemovedSbom returns the removed IDs of the "sbom" edge to the BillOfMaterials entity.
func (m *ArtifactMutation) RemovedSbomIDs() (ids []uuid.UUID) {
	for id := range m.removedsbom {
		ids = append(ids, id)
	}
	return
}

// SbomIDs returns the "sbom" edge IDs in the mutation.
func (m *ArtifactMutation) SbomIDs() (ids []uuid.UUID) {
	for id := range m.sbom {
		ids = append(ids, id)
	}
	return
}

// ResetSbom resets all changes to the "sbom" edge.
func (m *ArtifactMutation) ResetSbom() {
	m.sbom = nil
	m.clearedsbom = false
	m.removedsbom = nil
}

// AddAttestationIDs adds the "attestations" edge to the SLSAAttestation entity by ids.
func (m *ArtifactMutation) AddAttestationIDs(ids ...uuid.UUID) {
	if m.attestations == nil {
		m.attestations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attestations[ids[i]] = struct{}{}
	}
}

// ClearAttestations clears the "attestations" edge to the SLSAAttestation entity.
func (m *ArtifactMutation) ClearAttestations() {
	m.clearedattestations = true
}

// AttestationsCleared reports if the "attestations" edge to the SLSAAttestation entity was cleared.
func (m *ArtifactMutation) AttestationsCleared() bool {
	return m.clearedattestations
}

// RemoveAttestationIDs removes the "attestations" edge to the SLSAAttestation entity by IDs.
func (m *ArtifactMutation) RemoveAttestationIDs(ids ...uuid.UUID) {
	if m.removedattestations == nil {
		m.removedattestations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attestations, ids[i])
		m.removedattestations[ids[i]] = struct{}{}
	}
}

// RemovedAttestations returns the removed IDs of the "attestations" edge to the SLSAAttestation entity.
func (m *ArtifactMutation) RemovedAttestationsIDs() (ids []uuid.UUID) {
	for id := range m.removedattestations {
		ids = append(ids, id)
	}
	return
}

// AttestationsIDs returns the "attestations" edge IDs in the mutation.
func (m *ArtifactMutation) AttestationsIDs() (ids []uuid.UUID) {
	for id := range m.attestations {
		ids = append(ids, id)
	}
	return
}

// ResetAttestations resets all changes to the "attestations" edge.
func (m *ArtifactMutation) ResetAttestations() {
	m.attestations = nil
	m.clearedattestations = false
	m.removedattestations = nil
}

// AddAttestationsSubjectIDs adds the "attestations_subject" edge to the SLSAAttestation entity by ids.
func (m *ArtifactMutation) AddAttestationsSubjectIDs(ids ...uuid.UUID) {
	if m.attestations_subject == nil {
		m.attestations_subject = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attestations_subject[ids[i]] = struct{}{}
	}
}

// ClearAttestationsSubject clears the "attestations_subject" edge to the SLSAAttestation entity.
func (m *ArtifactMutation) ClearAttestationsSubject() {
	m.clearedattestations_subject = true
}

// AttestationsSubjectCleared reports if the "attestations_subject" edge to the SLSAAttestation entity was cleared.
func (m *ArtifactMutation) AttestationsSubjectCleared() bool {
	return m.clearedattestations_subject
}

// RemoveAttestationsSubjectIDs removes the "attestations_subject" edge to the SLSAAttestation entity by IDs.
func (m *ArtifactMutation) RemoveAttestationsSubjectIDs(ids ...uuid.UUID) {
	if m.removedattestations_subject == nil {
		m.removedattestations_subject = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attestations_subject, ids[i])
		m.removedattestations_subject[ids[i]] = struct{}{}
	}
}

// RemovedAttestationsSubject returns the removed IDs of the "attestations_subject" edge to the SLSAAttestation entity.
func (m *ArtifactMutation) RemovedAttestationsSubjectIDs() (ids []uuid.UUID) {
	for id := range m.removedattestations_subject {
		ids = append(ids, id)
	}
	return
}

// AttestationsSubjectIDs returns the "attestations_subject" edge IDs in the mutation.
func (m *ArtifactMutation) AttestationsSubjectIDs() (ids []uuid.UUID) {
	for id := range m.attestations_subject {
		ids = append(ids, id)
	}
	return
}

// ResetAttestationsSubject resets all changes to the "attestations_subject" edge.
func (m *ArtifactMutation) ResetAttestationsSubject() {
	m.attestations_subject = nil
	m.clearedattestations_subject = false
	m.removedattestations_subject = nil
}

// AddHashEqualArtAIDs adds the "hash_equal_art_a" edge to the HashEqual entity by ids.
func (m *ArtifactMutation) AddHashEqualArtAIDs(ids ...uuid.UUID) {
	if m.hash_equal_art_a == nil {
		m.hash_equal_art_a = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hash_equal_art_a[ids[i]] = struct{}{}
	}
}

// ClearHashEqualArtA clears the "hash_equal_art_a" edge to the HashEqual entity.
func (m *ArtifactMutation) ClearHashEqualArtA() {
	m.clearedhash_equal_art_a = true
}

// HashEqualArtACleared reports if the "hash_equal_art_a" edge to the HashEqual entity was cleared.
func (m *ArtifactMutation) HashEqualArtACleared() bool {
	return m.clearedhash_equal_art_a
}

// RemoveHashEqualArtAIDs removes the "hash_equal_art_a" edge to the HashEqual entity by IDs.
func (m *ArtifactMutation) RemoveHashEqualArtAIDs(ids ...uuid.UUID) {
	if m.removedhash_equal_art_a == nil {
		m.removedhash_equal_art_a = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hash_equal_art_a, ids[i])
		m.removedhash_equal_art_a[ids[i]] = struct{}{}
	}
}

// RemovedHashEqualArtA returns the removed IDs of the "hash_equal_art_a" edge to the HashEqual entity.
func (m *ArtifactMutation) RemovedHashEqualArtAIDs() (ids []uuid.UUID) {
	for id := range m.removedhash_equal_art_a {
		ids = append(ids, id)
	}
	return
}

// HashEqualArtAIDs returns the "hash_equal_art_a" edge IDs in the mutation.
func (m *ArtifactMutation) HashEqualArtAIDs() (ids []uuid.UUID) {
	for id := range m.hash_equal_art_a {
		ids = append(ids, id)
	}
	return
}

// ResetHashEqualArtA resets all changes to the "hash_equal_art_a" edge.
func (m *ArtifactMutation) ResetHashEqualArtA() {
	m.hash_equal_art_a = nil
	m.clearedhash_equal_art_a = false
	m.removedhash_equal_art_a = nil
}

// AddHashEqualArtBIDs adds the "hash_equal_art_b" edge to the HashEqual entity by ids.
func (m *ArtifactMutation) AddHashEqualArtBIDs(ids ...uuid.UUID) {
	if m.hash_equal_art_b == nil {
		m.hash_equal_art_b = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hash_equal_art_b[ids[i]] = struct{}{}
	}
}

// ClearHashEqualArtB clears the "hash_equal_art_b" edge to the HashEqual entity.
func (m *ArtifactMutation) ClearHashEqualArtB() {
	m.clearedhash_equal_art_b = true
}

// HashEqualArtBCleared reports if the "hash_equal_art_b" edge to the HashEqual entity was cleared.
func (m *ArtifactMutation) HashEqualArtBCleared() bool {
	return m.clearedhash_equal_art_b
}

// RemoveHashEqualArtBIDs removes the "hash_equal_art_b" edge to the HashEqual entity by IDs.
func (m *ArtifactMutation) RemoveHashEqualArtBIDs(ids ...uuid.UUID) {
	if m.removedhash_equal_art_b == nil {
		m.removedhash_equal_art_b = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hash_equal_art_b, ids[i])
		m.removedhash_equal_art_b[ids[i]] = struct{}{}
	}
}

// RemovedHashEqualArtB returns the removed IDs of the "hash_equal_art_b" edge to the HashEqual entity.
func (m *ArtifactMutation) RemovedHashEqualArtBIDs() (ids []uuid.UUID) {
	for id := range m.removedhash_equal_art_b {
		ids = append(ids, id)
	}
	return
}

// HashEqualArtBIDs returns the "hash_equal_art_b" edge IDs in the mutation.
func (m *ArtifactMutation) HashEqualArtBIDs() (ids []uuid.UUID) {
	for id := range m.hash_equal_art_b {
		ids = append(ids, id)
	}
	return
}

// ResetHashEqualArtB resets all changes to the "hash_equal_art_b" edge.
func (m *ArtifactMutation) ResetHashEqualArtB() {
	m.hash_equal_art_b = nil
	m.clearedhash_equal_art_b = false
	m.removedhash_equal_art_b = nil
}

// AddVexIDs adds the "vex" edge to the CertifyVex entity by ids.
func (m *ArtifactMutation) AddVexIDs(ids ...uuid.UUID) {
	if m.vex == nil {
		m.vex = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vex[ids[i]] = struct{}{}
	}
}

// ClearVex clears the "vex" edge to the CertifyVex entity.
func (m *ArtifactMutation) ClearVex() {
	m.clearedvex = true
}

// VexCleared reports if the "vex" edge to the CertifyVex entity was cleared.
func (m *ArtifactMutation) VexCleared() bool {
	return m.clearedvex
}

// RemoveVexIDs removes the "vex" edge to the CertifyVex entity by IDs.
func (m *ArtifactMutation) RemoveVexIDs(ids ...uuid.UUID) {
	if m.removedvex == nil {
		m.removedvex = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vex, ids[i])
		m.removedvex[ids[i]] = struct{}{}
	}
}

// RemovedVex returns the removed IDs of the "vex" edge to the CertifyVex entity.
func (m *ArtifactMutation) RemovedVexIDs() (ids []uuid.UUID) {
	for id := range m.removedvex {
		ids = append(ids, id)
	}
	return
}

// VexIDs returns the "vex" edge IDs in the mutation.
func (m *ArtifactMutation) VexIDs() (ids []uuid.UUID) {
	for id := range m.vex {
		ids = append(ids, id)
	}
	return
}

// ResetVex resets all changes to the "vex" edge.
func (m *ArtifactMutation) ResetVex() {
	m.vex = nil
	m.clearedvex = false
	m.removedvex = nil
}

// AddCertificationIDs adds the "certification" edge to the Certification entity by ids.
func (m *ArtifactMutation) AddCertificationIDs(ids ...uuid.UUID) {
	if m.certification == nil {
		m.certification = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.certification[ids[i]] = struct{}{}
	}
}

// ClearCertification clears the "certification" edge to the Certification entity.
func (m *ArtifactMutation) ClearCertification() {
	m.clearedcertification = true
}

// CertificationCleared reports if the "certification" edge to the Certification entity was cleared.
func (m *ArtifactMutation) CertificationCleared() bool {
	return m.clearedcertification
}

// RemoveCertificationIDs removes the "certification" edge to the Certification entity by IDs.
func (m *ArtifactMutation) RemoveCertificationIDs(ids ...uuid.UUID) {
	if m.removedcertification == nil {
		m.removedcertification = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.certification, ids[i])
		m.removedcertification[ids[i]] = struct{}{}
	}
}

// RemovedCertification returns the removed IDs of the "certification" edge to the Certification entity.
func (m *ArtifactMutation) RemovedCertificationIDs() (ids []uuid.UUID) {
	for id := range m.removedcertification {
		ids = append(ids, id)
	}
	return
}

// CertificationIDs returns the "certification" edge IDs in the mutation.
func (m *ArtifactMutation) CertificationIDs() (ids []uuid.UUID) {
	for id := range m.certification {
		ids = append(ids, id)
	}
	return
}

// ResetCertification resets all changes to the "certification" edge.
func (m *ArtifactMutation) ResetCertification() {
	m.certification = nil
	m.clearedcertification = false
	m.removedcertification = nil
}

// AddMetadatumIDs adds the "metadata" edge to the HasMetadata entity by ids.
func (m *ArtifactMutation) AddMetadatumIDs(ids ...uuid.UUID) {
	if m.metadata == nil {
		m.metadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the HasMetadata entity.
func (m *ArtifactMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the HasMetadata entity was cleared.
func (m *ArtifactMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the HasMetadata entity by IDs.
func (m *ArtifactMutation) RemoveMetadatumIDs(ids ...uuid.UUID) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the HasMetadata entity.
func (m *ArtifactMutation) RemovedMetadataIDs() (ids []uuid.UUID) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *ArtifactMutation) MetadataIDs() (ids []uuid.UUID) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *ArtifactMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// AddPocIDs adds the "poc" edge to the PointOfContact entity by ids.
func (m *ArtifactMutation) AddPocIDs(ids ...uuid.UUID) {
	if m.poc == nil {
		m.poc = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.poc[ids[i]] = struct{}{}
	}
}

// ClearPoc clears the "poc" edge to the PointOfContact entity.
func (m *ArtifactMutation) ClearPoc() {
	m.clearedpoc = true
}

// PocCleared reports if the "poc" edge to the PointOfContact entity was cleared.
func (m *ArtifactMutation) PocCleared() bool {
	return m.clearedpoc
}

// RemovePocIDs removes the "poc" edge to the PointOfContact entity by IDs.
func (m *ArtifactMutation) RemovePocIDs(ids ...uuid.UUID) {
	if m.removedpoc == nil {
		m.removedpoc = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.poc, ids[i])
		m.removedpoc[ids[i]] = struct{}{}
	}
}

// RemovedPoc returns the removed IDs of the "poc" edge to the PointOfContact entity.
func (m *ArtifactMutation) RemovedPocIDs() (ids []uuid.UUID) {
	for id := range m.removedpoc {
		ids = append(ids, id)
	}
	return
}

// PocIDs returns the "poc" edge IDs in the mutation.
func (m *ArtifactMutation) PocIDs() (ids []uuid.UUID) {
	for id := range m.poc {
		ids = append(ids, id)
	}
	return
}

// ResetPoc resets all changes to the "poc" edge.
func (m *ArtifactMutation) ResetPoc() {
	m.poc = nil
	m.clearedpoc = false
	m.removedpoc = nil
}

// AddIncludedInSbomIDs adds the "included_in_sboms" edge to the BillOfMaterials entity by ids.
func (m *ArtifactMutation) AddIncludedInSbomIDs(ids ...uuid.UUID) {
	if m.included_in_sboms == nil {
		m.included_in_sboms = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.included_in_sboms[ids[i]] = struct{}{}
	}
}

// ClearIncludedInSboms clears the "included_in_sboms" edge to the BillOfMaterials entity.
func (m *ArtifactMutation) ClearIncludedInSboms() {
	m.clearedincluded_in_sboms = true
}

// IncludedInSbomsCleared reports if the "included_in_sboms" edge to the BillOfMaterials entity was cleared.
func (m *ArtifactMutation) IncludedInSbomsCleared() bool {
	return m.clearedincluded_in_sboms
}

// RemoveIncludedInSbomIDs removes the "included_in_sboms" edge to the BillOfMaterials entity by IDs.
func (m *ArtifactMutation) RemoveIncludedInSbomIDs(ids ...uuid.UUID) {
	if m.removedincluded_in_sboms == nil {
		m.removedincluded_in_sboms = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.included_in_sboms, ids[i])
		m.removedincluded_in_sboms[ids[i]] = struct{}{}
	}
}

// RemovedIncludedInSboms returns the removed IDs of the "included_in_sboms" edge to the BillOfMaterials entity.
func (m *ArtifactMutation) RemovedIncludedInSbomsIDs() (ids []uuid.UUID) {
	for id := range m.removedincluded_in_sboms {
		ids = append(ids, id)
	}
	return
}

// IncludedInSbomsIDs returns the "included_in_sboms" edge IDs in the mutation.
func (m *ArtifactMutation) IncludedInSbomsIDs() (ids []uuid.UUID) {
	for id := range m.included_in_sboms {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedInSboms resets all changes to the "included_in_sboms" edge.
func (m *ArtifactMutation) ResetIncludedInSboms() {
	m.included_in_sboms = nil
	m.clearedincluded_in_sboms = false
	m.removedincluded_in_sboms = nil
}

// Where appends a list predicates to the ArtifactMutation builder.
func (m *ArtifactMutation) Where(ps ...predicate.Artifact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtifactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtifactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Artifact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtifactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtifactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Artifact).
func (m *ArtifactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.algorithm != nil {
		fields = append(fields, artifact.FieldAlgorithm)
	}
	if m.digest != nil {
		fields = append(fields, artifact.FieldDigest)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifact.FieldAlgorithm:
		return m.Algorithm()
	case artifact.FieldDigest:
		return m.Digest()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifact.FieldAlgorithm:
		return m.OldAlgorithm(ctx)
	case artifact.FieldDigest:
		return m.OldDigest(ctx)
	}
	return nil, fmt.Errorf("unknown Artifact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifact.FieldAlgorithm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgorithm(v)
		return nil
	case artifact.FieldDigest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigest(v)
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Artifact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactMutation) ResetField(name string) error {
	switch name {
	case artifact.FieldAlgorithm:
		m.ResetAlgorithm()
		return nil
	case artifact.FieldDigest:
		m.ResetDigest()
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.occurrences != nil {
		edges = append(edges, artifact.EdgeOccurrences)
	}
	if m.sbom != nil {
		edges = append(edges, artifact.EdgeSbom)
	}
	if m.attestations != nil {
		edges = append(edges, artifact.EdgeAttestations)
	}
	if m.attestations_subject != nil {
		edges = append(edges, artifact.EdgeAttestationsSubject)
	}
	if m.hash_equal_art_a != nil {
		edges = append(edges, artifact.EdgeHashEqualArtA)
	}
	if m.hash_equal_art_b != nil {
		edges = append(edges, artifact.EdgeHashEqualArtB)
	}
	if m.vex != nil {
		edges = append(edges, artifact.EdgeVex)
	}
	if m.certification != nil {
		edges = append(edges, artifact.EdgeCertification)
	}
	if m.metadata != nil {
		edges = append(edges, artifact.EdgeMetadata)
	}
	if m.poc != nil {
		edges = append(edges, artifact.EdgePoc)
	}
	if m.included_in_sboms != nil {
		edges = append(edges, artifact.EdgeIncludedInSboms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.occurrences))
		for id := range m.occurrences {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeSbom:
		ids := make([]ent.Value, 0, len(m.sbom))
		for id := range m.sbom {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeAttestations:
		ids := make([]ent.Value, 0, len(m.attestations))
		for id := range m.attestations {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeAttestationsSubject:
		ids := make([]ent.Value, 0, len(m.attestations_subject))
		for id := range m.attestations_subject {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeHashEqualArtA:
		ids := make([]ent.Value, 0, len(m.hash_equal_art_a))
		for id := range m.hash_equal_art_a {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeHashEqualArtB:
		ids := make([]ent.Value, 0, len(m.hash_equal_art_b))
		for id := range m.hash_equal_art_b {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeVex:
		ids := make([]ent.Value, 0, len(m.vex))
		for id := range m.vex {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeCertification:
		ids := make([]ent.Value, 0, len(m.certification))
		for id := range m.certification {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgePoc:
		ids := make([]ent.Value, 0, len(m.poc))
		for id := range m.poc {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeIncludedInSboms:
		ids := make([]ent.Value, 0, len(m.included_in_sboms))
		for id := range m.included_in_sboms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedoccurrences != nil {
		edges = append(edges, artifact.EdgeOccurrences)
	}
	if m.removedsbom != nil {
		edges = append(edges, artifact.EdgeSbom)
	}
	if m.removedattestations != nil {
		edges = append(edges, artifact.EdgeAttestations)
	}
	if m.removedattestations_subject != nil {
		edges = append(edges, artifact.EdgeAttestationsSubject)
	}
	if m.removedhash_equal_art_a != nil {
		edges = append(edges, artifact.EdgeHashEqualArtA)
	}
	if m.removedhash_equal_art_b != nil {
		edges = append(edges, artifact.EdgeHashEqualArtB)
	}
	if m.removedvex != nil {
		edges = append(edges, artifact.EdgeVex)
	}
	if m.removedcertification != nil {
		edges = append(edges, artifact.EdgeCertification)
	}
	if m.removedmetadata != nil {
		edges = append(edges, artifact.EdgeMetadata)
	}
	if m.removedpoc != nil {
		edges = append(edges, artifact.EdgePoc)
	}
	if m.removedincluded_in_sboms != nil {
		edges = append(edges, artifact.EdgeIncludedInSboms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.removedoccurrences))
		for id := range m.removedoccurrences {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeSbom:
		ids := make([]ent.Value, 0, len(m.removedsbom))
		for id := range m.removedsbom {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeAttestations:
		ids := make([]ent.Value, 0, len(m.removedattestations))
		for id := range m.removedattestations {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeAttestationsSubject:
		ids := make([]ent.Value, 0, len(m.removedattestations_subject))
		for id := range m.removedattestations_subject {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeHashEqualArtA:
		ids := make([]ent.Value, 0, len(m.removedhash_equal_art_a))
		for id := range m.removedhash_equal_art_a {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeHashEqualArtB:
		ids := make([]ent.Value, 0, len(m.removedhash_equal_art_b))
		for id := range m.removedhash_equal_art_b {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeVex:
		ids := make([]ent.Value, 0, len(m.removedvex))
		for id := range m.removedvex {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeCertification:
		ids := make([]ent.Value, 0, len(m.removedcertification))
		for id := range m.removedcertification {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgePoc:
		ids := make([]ent.Value, 0, len(m.removedpoc))
		for id := range m.removedpoc {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeIncludedInSboms:
		ids := make([]ent.Value, 0, len(m.removedincluded_in_sboms))
		for id := range m.removedincluded_in_sboms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedoccurrences {
		edges = append(edges, artifact.EdgeOccurrences)
	}
	if m.clearedsbom {
		edges = append(edges, artifact.EdgeSbom)
	}
	if m.clearedattestations {
		edges = append(edges, artifact.EdgeAttestations)
	}
	if m.clearedattestations_subject {
		edges = append(edges, artifact.EdgeAttestationsSubject)
	}
	if m.clearedhash_equal_art_a {
		edges = append(edges, artifact.EdgeHashEqualArtA)
	}
	if m.clearedhash_equal_art_b {
		edges = append(edges, artifact.EdgeHashEqualArtB)
	}
	if m.clearedvex {
		edges = append(edges, artifact.EdgeVex)
	}
	if m.clearedcertification {
		edges = append(edges, artifact.EdgeCertification)
	}
	if m.clearedmetadata {
		edges = append(edges, artifact.EdgeMetadata)
	}
	if m.clearedpoc {
		edges = append(edges, artifact.EdgePoc)
	}
	if m.clearedincluded_in_sboms {
		edges = append(edges, artifact.EdgeIncludedInSboms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactMutation) EdgeCleared(name string) bool {
	switch name {
	case artifact.EdgeOccurrences:
		return m.clearedoccurrences
	case artifact.EdgeSbom:
		return m.clearedsbom
	case artifact.EdgeAttestations:
		return m.clearedattestations
	case artifact.EdgeAttestationsSubject:
		return m.clearedattestations_subject
	case artifact.EdgeHashEqualArtA:
		return m.clearedhash_equal_art_a
	case artifact.EdgeHashEqualArtB:
		return m.clearedhash_equal_art_b
	case artifact.EdgeVex:
		return m.clearedvex
	case artifact.EdgeCertification:
		return m.clearedcertification
	case artifact.EdgeMetadata:
		return m.clearedmetadata
	case artifact.EdgePoc:
		return m.clearedpoc
	case artifact.EdgeIncludedInSboms:
		return m.clearedincluded_in_sboms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactMutation) ResetEdge(name string) error {
	switch name {
	case artifact.EdgeOccurrences:
		m.ResetOccurrences()
		return nil
	case artifact.EdgeSbom:
		m.ResetSbom()
		return nil
	case artifact.EdgeAttestations:
		m.ResetAttestations()
		return nil
	case artifact.EdgeAttestationsSubject:
		m.ResetAttestationsSubject()
		return nil
	case artifact.EdgeHashEqualArtA:
		m.ResetHashEqualArtA()
		return nil
	case artifact.EdgeHashEqualArtB:
		m.ResetHashEqualArtB()
		return nil
	case artifact.EdgeVex:
		m.ResetVex()
		return nil
	case artifact.EdgeCertification:
		m.ResetCertification()
		return nil
	case artifact.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case artifact.EdgePoc:
		m.ResetPoc()
		return nil
	case artifact.EdgeIncludedInSboms:
		m.ResetIncludedInSboms()
		return nil
	}
	return fmt.Errorf("unknown Artifact edge %s", name)
}

// BillOfMaterialsMutation represents an operation that mutates the BillOfMaterials nodes in the graph.
type BillOfMaterialsMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *uuid.UUID
	uri                                *string
	algorithm                          *string
	digest                             *string
	download_location                  *string
	origin                             *string
	collector                          *string
	document_ref                       *string
	known_since                        *time.Time
	included_packages_hash             *string
	included_artifacts_hash            *string
	included_dependencies_hash         *string
	included_occurrences_hash          *string
	clearedFields                      map[string]struct{}
	_package                           *uuid.UUID
	cleared_package                    bool
	artifact                           *uuid.UUID
	clearedartifact                    bool
	included_software_packages         map[uuid.UUID]struct{}
	removedincluded_software_packages  map[uuid.UUID]struct{}
	clearedincluded_software_packages  bool
	included_software_artifacts        map[uuid.UUID]struct{}
	removedincluded_software_artifacts map[uuid.UUID]struct{}
	clearedincluded_software_artifacts bool
	included_dependencies              map[uuid.UUID]struct{}
	removedincluded_dependencies       map[uuid.UUID]struct{}
	clearedincluded_dependencies       bool
	included_occurrences               map[uuid.UUID]struct{}
	removedincluded_occurrences        map[uuid.UUID]struct{}
	clearedincluded_occurrences        bool
	done                               bool
	oldValue                           func(context.Context) (*BillOfMaterials, error)
	predicates                         []predicate.BillOfMaterials
}

var _ ent.Mutation = (*BillOfMaterialsMutation)(nil)

// billofmaterialsOption allows management of the mutation configuration using functional options.
type billofmaterialsOption func(*BillOfMaterialsMutation)

// newBillOfMaterialsMutation creates new mutation for the BillOfMaterials entity.
func newBillOfMaterialsMutation(c config, op Op, opts ...billofmaterialsOption) *BillOfMaterialsMutation {
	m := &BillOfMaterialsMutation{
		config:        c,
		op:            op,
		typ:           TypeBillOfMaterials,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillOfMaterialsID sets the ID field of the mutation.
func withBillOfMaterialsID(id uuid.UUID) billofmaterialsOption {
	return func(m *BillOfMaterialsMutation) {
		var (
			err   error
			once  sync.Once
			value *BillOfMaterials
		)
		m.oldValue = func(ctx context.Context) (*BillOfMaterials, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillOfMaterials.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillOfMaterials sets the old BillOfMaterials of the mutation.
func withBillOfMaterials(node *BillOfMaterials) billofmaterialsOption {
	return func(m *BillOfMaterialsMutation) {
		m.oldValue = func(context.Context) (*BillOfMaterials, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillOfMaterialsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillOfMaterialsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillOfMaterials entities.
func (m *BillOfMaterialsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillOfMaterialsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillOfMaterialsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillOfMaterials.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *BillOfMaterialsMutation) SetPackageID(u uuid.UUID) {
	m._package = &u
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *BillOfMaterialsMutation) PackageID() (r uuid.UUID, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldPackageID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *BillOfMaterialsMutation) ClearPackageID() {
	m._package = nil
	m.clearedFields[billofmaterials.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *BillOfMaterialsMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[billofmaterials.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *BillOfMaterialsMutation) ResetPackageID() {
	m._package = nil
	delete(m.clearedFields, billofmaterials.FieldPackageID)
}

// SetArtifactID sets the "artifact_id" field.
func (m *BillOfMaterialsMutation) SetArtifactID(u uuid.UUID) {
	m.artifact = &u
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *BillOfMaterialsMutation) ArtifactID() (r uuid.UUID, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldArtifactID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ClearArtifactID clears the value of the "artifact_id" field.
func (m *BillOfMaterialsMutation) ClearArtifactID() {
	m.artifact = nil
	m.clearedFields[billofmaterials.FieldArtifactID] = struct{}{}
}

// ArtifactIDCleared returns if the "artifact_id" field was cleared in this mutation.
func (m *BillOfMaterialsMutation) ArtifactIDCleared() bool {
	_, ok := m.clearedFields[billofmaterials.FieldArtifactID]
	return ok
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *BillOfMaterialsMutation) ResetArtifactID() {
	m.artifact = nil
	delete(m.clearedFields, billofmaterials.FieldArtifactID)
}

// SetURI sets the "uri" field.
func (m *BillOfMaterialsMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *BillOfMaterialsMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *BillOfMaterialsMutation) ResetURI() {
	m.uri = nil
}

// SetAlgorithm sets the "algorithm" field.
func (m *BillOfMaterialsMutation) SetAlgorithm(s string) {
	m.algorithm = &s
}

// Algorithm returns the value of the "algorithm" field in the mutation.
func (m *BillOfMaterialsMutation) Algorithm() (r string, exists bool) {
	v := m.algorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgorithm returns the old "algorithm" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldAlgorithm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgorithm: %w", err)
	}
	return oldValue.Algorithm, nil
}

// ResetAlgorithm resets all changes to the "algorithm" field.
func (m *BillOfMaterialsMutation) ResetAlgorithm() {
	m.algorithm = nil
}

// SetDigest sets the "digest" field.
func (m *BillOfMaterialsMutation) SetDigest(s string) {
	m.digest = &s
}

// Digest returns the value of the "digest" field in the mutation.
func (m *BillOfMaterialsMutation) Digest() (r string, exists bool) {
	v := m.digest
	if v == nil {
		return
	}
	return *v, true
}

// OldDigest returns the old "digest" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldDigest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigest: %w", err)
	}
	return oldValue.Digest, nil
}

// ResetDigest resets all changes to the "digest" field.
func (m *BillOfMaterialsMutation) ResetDigest() {
	m.digest = nil
}

// SetDownloadLocation sets the "download_location" field.
func (m *BillOfMaterialsMutation) SetDownloadLocation(s string) {
	m.download_location = &s
}

// DownloadLocation returns the value of the "download_location" field in the mutation.
func (m *BillOfMaterialsMutation) DownloadLocation() (r string, exists bool) {
	v := m.download_location
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadLocation returns the old "download_location" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldDownloadLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadLocation: %w", err)
	}
	return oldValue.DownloadLocation, nil
}

// ResetDownloadLocation resets all changes to the "download_location" field.
func (m *BillOfMaterialsMutation) ResetDownloadLocation() {
	m.download_location = nil
}

// SetOrigin sets the "origin" field.
func (m *BillOfMaterialsMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *BillOfMaterialsMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *BillOfMaterialsMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *BillOfMaterialsMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *BillOfMaterialsMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *BillOfMaterialsMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *BillOfMaterialsMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *BillOfMaterialsMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *BillOfMaterialsMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// SetKnownSince sets the "known_since" field.
func (m *BillOfMaterialsMutation) SetKnownSince(t time.Time) {
	m.known_since = &t
}

// KnownSince returns the value of the "known_since" field in the mutation.
func (m *BillOfMaterialsMutation) KnownSince() (r time.Time, exists bool) {
	v := m.known_since
	if v == nil {
		return
	}
	return *v, true
}

// OldKnownSince returns the old "known_since" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldKnownSince(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnownSince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnownSince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnownSince: %w", err)
	}
	return oldValue.KnownSince, nil
}

// ResetKnownSince resets all changes to the "known_since" field.
func (m *BillOfMaterialsMutation) ResetKnownSince() {
	m.known_since = nil
}

// SetIncludedPackagesHash sets the "included_packages_hash" field.
func (m *BillOfMaterialsMutation) SetIncludedPackagesHash(s string) {
	m.included_packages_hash = &s
}

// IncludedPackagesHash returns the value of the "included_packages_hash" field in the mutation.
func (m *BillOfMaterialsMutation) IncludedPackagesHash() (r string, exists bool) {
	v := m.included_packages_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludedPackagesHash returns the old "included_packages_hash" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldIncludedPackagesHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncludedPackagesHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncludedPackagesHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludedPackagesHash: %w", err)
	}
	return oldValue.IncludedPackagesHash, nil
}

// ResetIncludedPackagesHash resets all changes to the "included_packages_hash" field.
func (m *BillOfMaterialsMutation) ResetIncludedPackagesHash() {
	m.included_packages_hash = nil
}

// SetIncludedArtifactsHash sets the "included_artifacts_hash" field.
func (m *BillOfMaterialsMutation) SetIncludedArtifactsHash(s string) {
	m.included_artifacts_hash = &s
}

// IncludedArtifactsHash returns the value of the "included_artifacts_hash" field in the mutation.
func (m *BillOfMaterialsMutation) IncludedArtifactsHash() (r string, exists bool) {
	v := m.included_artifacts_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludedArtifactsHash returns the old "included_artifacts_hash" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldIncludedArtifactsHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncludedArtifactsHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncludedArtifactsHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludedArtifactsHash: %w", err)
	}
	return oldValue.IncludedArtifactsHash, nil
}

// ResetIncludedArtifactsHash resets all changes to the "included_artifacts_hash" field.
func (m *BillOfMaterialsMutation) ResetIncludedArtifactsHash() {
	m.included_artifacts_hash = nil
}

// SetIncludedDependenciesHash sets the "included_dependencies_hash" field.
func (m *BillOfMaterialsMutation) SetIncludedDependenciesHash(s string) {
	m.included_dependencies_hash = &s
}

// IncludedDependenciesHash returns the value of the "included_dependencies_hash" field in the mutation.
func (m *BillOfMaterialsMutation) IncludedDependenciesHash() (r string, exists bool) {
	v := m.included_dependencies_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludedDependenciesHash returns the old "included_dependencies_hash" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldIncludedDependenciesHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncludedDependenciesHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncludedDependenciesHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludedDependenciesHash: %w", err)
	}
	return oldValue.IncludedDependenciesHash, nil
}

// ResetIncludedDependenciesHash resets all changes to the "included_dependencies_hash" field.
func (m *BillOfMaterialsMutation) ResetIncludedDependenciesHash() {
	m.included_dependencies_hash = nil
}

// SetIncludedOccurrencesHash sets the "included_occurrences_hash" field.
func (m *BillOfMaterialsMutation) SetIncludedOccurrencesHash(s string) {
	m.included_occurrences_hash = &s
}

// IncludedOccurrencesHash returns the value of the "included_occurrences_hash" field in the mutation.
func (m *BillOfMaterialsMutation) IncludedOccurrencesHash() (r string, exists bool) {
	v := m.included_occurrences_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludedOccurrencesHash returns the old "included_occurrences_hash" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldIncludedOccurrencesHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncludedOccurrencesHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncludedOccurrencesHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludedOccurrencesHash: %w", err)
	}
	return oldValue.IncludedOccurrencesHash, nil
}

// ResetIncludedOccurrencesHash resets all changes to the "included_occurrences_hash" field.
func (m *BillOfMaterialsMutation) ResetIncludedOccurrencesHash() {
	m.included_occurrences_hash = nil
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *BillOfMaterialsMutation) ClearPackage() {
	m.cleared_package = true
	m.clearedFields[billofmaterials.FieldPackageID] = struct{}{}
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *BillOfMaterialsMutation) PackageCleared() bool {
	return m.PackageIDCleared() || m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *BillOfMaterialsMutation) PackageIDs() (ids []uuid.UUID) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *BillOfMaterialsMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *BillOfMaterialsMutation) ClearArtifact() {
	m.clearedartifact = true
	m.clearedFields[billofmaterials.FieldArtifactID] = struct{}{}
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *BillOfMaterialsMutation) ArtifactCleared() bool {
	return m.ArtifactIDCleared() || m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *BillOfMaterialsMutation) ArtifactIDs() (ids []uuid.UUID) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *BillOfMaterialsMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// AddIncludedSoftwarePackageIDs adds the "included_software_packages" edge to the PackageVersion entity by ids.
func (m *BillOfMaterialsMutation) AddIncludedSoftwarePackageIDs(ids ...uuid.UUID) {
	if m.included_software_packages == nil {
		m.included_software_packages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.included_software_packages[ids[i]] = struct{}{}
	}
}

// ClearIncludedSoftwarePackages clears the "included_software_packages" edge to the PackageVersion entity.
func (m *BillOfMaterialsMutation) ClearIncludedSoftwarePackages() {
	m.clearedincluded_software_packages = true
}

// IncludedSoftwarePackagesCleared reports if the "included_software_packages" edge to the PackageVersion entity was cleared.
func (m *BillOfMaterialsMutation) IncludedSoftwarePackagesCleared() bool {
	return m.clearedincluded_software_packages
}

// RemoveIncludedSoftwarePackageIDs removes the "included_software_packages" edge to the PackageVersion entity by IDs.
func (m *BillOfMaterialsMutation) RemoveIncludedSoftwarePackageIDs(ids ...uuid.UUID) {
	if m.removedincluded_software_packages == nil {
		m.removedincluded_software_packages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.included_software_packages, ids[i])
		m.removedincluded_software_packages[ids[i]] = struct{}{}
	}
}

// RemovedIncludedSoftwarePackages returns the removed IDs of the "included_software_packages" edge to the PackageVersion entity.
func (m *BillOfMaterialsMutation) RemovedIncludedSoftwarePackagesIDs() (ids []uuid.UUID) {
	for id := range m.removedincluded_software_packages {
		ids = append(ids, id)
	}
	return
}

// IncludedSoftwarePackagesIDs returns the "included_software_packages" edge IDs in the mutation.
func (m *BillOfMaterialsMutation) IncludedSoftwarePackagesIDs() (ids []uuid.UUID) {
	for id := range m.included_software_packages {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedSoftwarePackages resets all changes to the "included_software_packages" edge.
func (m *BillOfMaterialsMutation) ResetIncludedSoftwarePackages() {
	m.included_software_packages = nil
	m.clearedincluded_software_packages = false
	m.removedincluded_software_packages = nil
}

// AddIncludedSoftwareArtifactIDs adds the "included_software_artifacts" edge to the Artifact entity by ids.
func (m *BillOfMaterialsMutation) AddIncludedSoftwareArtifactIDs(ids ...uuid.UUID) {
	if m.included_software_artifacts == nil {
		m.included_software_artifacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.included_software_artifacts[ids[i]] = struct{}{}
	}
}

// ClearIncludedSoftwareArtifacts clears the "included_software_artifacts" edge to the Artifact entity.
func (m *BillOfMaterialsMutation) ClearIncludedSoftwareArtifacts() {
	m.clearedincluded_software_artifacts = true
}

// IncludedSoftwareArtifactsCleared reports if the "included_software_artifacts" edge to the Artifact entity was cleared.
func (m *BillOfMaterialsMutation) IncludedSoftwareArtifactsCleared() bool {
	return m.clearedincluded_software_artifacts
}

// RemoveIncludedSoftwareArtifactIDs removes the "included_software_artifacts" edge to the Artifact entity by IDs.
func (m *BillOfMaterialsMutation) RemoveIncludedSoftwareArtifactIDs(ids ...uuid.UUID) {
	if m.removedincluded_software_artifacts == nil {
		m.removedincluded_software_artifacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.included_software_artifacts, ids[i])
		m.removedincluded_software_artifacts[ids[i]] = struct{}{}
	}
}

// RemovedIncludedSoftwareArtifacts returns the removed IDs of the "included_software_artifacts" edge to the Artifact entity.
func (m *BillOfMaterialsMutation) RemovedIncludedSoftwareArtifactsIDs() (ids []uuid.UUID) {
	for id := range m.removedincluded_software_artifacts {
		ids = append(ids, id)
	}
	return
}

// IncludedSoftwareArtifactsIDs returns the "included_software_artifacts" edge IDs in the mutation.
func (m *BillOfMaterialsMutation) IncludedSoftwareArtifactsIDs() (ids []uuid.UUID) {
	for id := range m.included_software_artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedSoftwareArtifacts resets all changes to the "included_software_artifacts" edge.
func (m *BillOfMaterialsMutation) ResetIncludedSoftwareArtifacts() {
	m.included_software_artifacts = nil
	m.clearedincluded_software_artifacts = false
	m.removedincluded_software_artifacts = nil
}

// AddIncludedDependencyIDs adds the "included_dependencies" edge to the Dependency entity by ids.
func (m *BillOfMaterialsMutation) AddIncludedDependencyIDs(ids ...uuid.UUID) {
	if m.included_dependencies == nil {
		m.included_dependencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.included_dependencies[ids[i]] = struct{}{}
	}
}

// ClearIncludedDependencies clears the "included_dependencies" edge to the Dependency entity.
func (m *BillOfMaterialsMutation) ClearIncludedDependencies() {
	m.clearedincluded_dependencies = true
}

// IncludedDependenciesCleared reports if the "included_dependencies" edge to the Dependency entity was cleared.
func (m *BillOfMaterialsMutation) IncludedDependenciesCleared() bool {
	return m.clearedincluded_dependencies
}

// RemoveIncludedDependencyIDs removes the "included_dependencies" edge to the Dependency entity by IDs.
func (m *BillOfMaterialsMutation) RemoveIncludedDependencyIDs(ids ...uuid.UUID) {
	if m.removedincluded_dependencies == nil {
		m.removedincluded_dependencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.included_dependencies, ids[i])
		m.removedincluded_dependencies[ids[i]] = struct{}{}
	}
}

// RemovedIncludedDependencies returns the removed IDs of the "included_dependencies" edge to the Dependency entity.
func (m *BillOfMaterialsMutation) RemovedIncludedDependenciesIDs() (ids []uuid.UUID) {
	for id := range m.removedincluded_dependencies {
		ids = append(ids, id)
	}
	return
}

// IncludedDependenciesIDs returns the "included_dependencies" edge IDs in the mutation.
func (m *BillOfMaterialsMutation) IncludedDependenciesIDs() (ids []uuid.UUID) {
	for id := range m.included_dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedDependencies resets all changes to the "included_dependencies" edge.
func (m *BillOfMaterialsMutation) ResetIncludedDependencies() {
	m.included_dependencies = nil
	m.clearedincluded_dependencies = false
	m.removedincluded_dependencies = nil
}

// AddIncludedOccurrenceIDs adds the "included_occurrences" edge to the Occurrence entity by ids.
func (m *BillOfMaterialsMutation) AddIncludedOccurrenceIDs(ids ...uuid.UUID) {
	if m.included_occurrences == nil {
		m.included_occurrences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.included_occurrences[ids[i]] = struct{}{}
	}
}

// ClearIncludedOccurrences clears the "included_occurrences" edge to the Occurrence entity.
func (m *BillOfMaterialsMutation) ClearIncludedOccurrences() {
	m.clearedincluded_occurrences = true
}

// IncludedOccurrencesCleared reports if the "included_occurrences" edge to the Occurrence entity was cleared.
func (m *BillOfMaterialsMutation) IncludedOccurrencesCleared() bool {
	return m.clearedincluded_occurrences
}

// RemoveIncludedOccurrenceIDs removes the "included_occurrences" edge to the Occurrence entity by IDs.
func (m *BillOfMaterialsMutation) RemoveIncludedOccurrenceIDs(ids ...uuid.UUID) {
	if m.removedincluded_occurrences == nil {
		m.removedincluded_occurrences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.included_occurrences, ids[i])
		m.removedincluded_occurrences[ids[i]] = struct{}{}
	}
}

// RemovedIncludedOccurrences returns the removed IDs of the "included_occurrences" edge to the Occurrence entity.
func (m *BillOfMaterialsMutation) RemovedIncludedOccurrencesIDs() (ids []uuid.UUID) {
	for id := range m.removedincluded_occurrences {
		ids = append(ids, id)
	}
	return
}

// IncludedOccurrencesIDs returns the "included_occurrences" edge IDs in the mutation.
func (m *BillOfMaterialsMutation) IncludedOccurrencesIDs() (ids []uuid.UUID) {
	for id := range m.included_occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedOccurrences resets all changes to the "included_occurrences" edge.
func (m *BillOfMaterialsMutation) ResetIncludedOccurrences() {
	m.included_occurrences = nil
	m.clearedincluded_occurrences = false
	m.removedincluded_occurrences = nil
}

// Where appends a list predicates to the BillOfMaterialsMutation builder.
func (m *BillOfMaterialsMutation) Where(ps ...predicate.BillOfMaterials) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillOfMaterialsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillOfMaterialsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillOfMaterials, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillOfMaterialsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillOfMaterialsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillOfMaterials).
func (m *BillOfMaterialsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillOfMaterialsMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m._package != nil {
		fields = append(fields, billofmaterials.FieldPackageID)
	}
	if m.artifact != nil {
		fields = append(fields, billofmaterials.FieldArtifactID)
	}
	if m.uri != nil {
		fields = append(fields, billofmaterials.FieldURI)
	}
	if m.algorithm != nil {
		fields = append(fields, billofmaterials.FieldAlgorithm)
	}
	if m.digest != nil {
		fields = append(fields, billofmaterials.FieldDigest)
	}
	if m.download_location != nil {
		fields = append(fields, billofmaterials.FieldDownloadLocation)
	}
	if m.origin != nil {
		fields = append(fields, billofmaterials.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, billofmaterials.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, billofmaterials.FieldDocumentRef)
	}
	if m.known_since != nil {
		fields = append(fields, billofmaterials.FieldKnownSince)
	}
	if m.included_packages_hash != nil {
		fields = append(fields, billofmaterials.FieldIncludedPackagesHash)
	}
	if m.included_artifacts_hash != nil {
		fields = append(fields, billofmaterials.FieldIncludedArtifactsHash)
	}
	if m.included_dependencies_hash != nil {
		fields = append(fields, billofmaterials.FieldIncludedDependenciesHash)
	}
	if m.included_occurrences_hash != nil {
		fields = append(fields, billofmaterials.FieldIncludedOccurrencesHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillOfMaterialsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billofmaterials.FieldPackageID:
		return m.PackageID()
	case billofmaterials.FieldArtifactID:
		return m.ArtifactID()
	case billofmaterials.FieldURI:
		return m.URI()
	case billofmaterials.FieldAlgorithm:
		return m.Algorithm()
	case billofmaterials.FieldDigest:
		return m.Digest()
	case billofmaterials.FieldDownloadLocation:
		return m.DownloadLocation()
	case billofmaterials.FieldOrigin:
		return m.Origin()
	case billofmaterials.FieldCollector:
		return m.Collector()
	case billofmaterials.FieldDocumentRef:
		return m.DocumentRef()
	case billofmaterials.FieldKnownSince:
		return m.KnownSince()
	case billofmaterials.FieldIncludedPackagesHash:
		return m.IncludedPackagesHash()
	case billofmaterials.FieldIncludedArtifactsHash:
		return m.IncludedArtifactsHash()
	case billofmaterials.FieldIncludedDependenciesHash:
		return m.IncludedDependenciesHash()
	case billofmaterials.FieldIncludedOccurrencesHash:
		return m.IncludedOccurrencesHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillOfMaterialsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billofmaterials.FieldPackageID:
		return m.OldPackageID(ctx)
	case billofmaterials.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case billofmaterials.FieldURI:
		return m.OldURI(ctx)
	case billofmaterials.FieldAlgorithm:
		return m.OldAlgorithm(ctx)
	case billofmaterials.FieldDigest:
		return m.OldDigest(ctx)
	case billofmaterials.FieldDownloadLocation:
		return m.OldDownloadLocation(ctx)
	case billofmaterials.FieldOrigin:
		return m.OldOrigin(ctx)
	case billofmaterials.FieldCollector:
		return m.OldCollector(ctx)
	case billofmaterials.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	case billofmaterials.FieldKnownSince:
		return m.OldKnownSince(ctx)
	case billofmaterials.FieldIncludedPackagesHash:
		return m.OldIncludedPackagesHash(ctx)
	case billofmaterials.FieldIncludedArtifactsHash:
		return m.OldIncludedArtifactsHash(ctx)
	case billofmaterials.FieldIncludedDependenciesHash:
		return m.OldIncludedDependenciesHash(ctx)
	case billofmaterials.FieldIncludedOccurrencesHash:
		return m.OldIncludedOccurrencesHash(ctx)
	}
	return nil, fmt.Errorf("unknown BillOfMaterials field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillOfMaterialsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billofmaterials.FieldPackageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case billofmaterials.FieldArtifactID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case billofmaterials.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case billofmaterials.FieldAlgorithm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgorithm(v)
		return nil
	case billofmaterials.FieldDigest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigest(v)
		return nil
	case billofmaterials.FieldDownloadLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadLocation(v)
		return nil
	case billofmaterials.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case billofmaterials.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case billofmaterials.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	case billofmaterials.FieldKnownSince:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnownSince(v)
		return nil
	case billofmaterials.FieldIncludedPackagesHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludedPackagesHash(v)
		return nil
	case billofmaterials.FieldIncludedArtifactsHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludedArtifactsHash(v)
		return nil
	case billofmaterials.FieldIncludedDependenciesHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludedDependenciesHash(v)
		return nil
	case billofmaterials.FieldIncludedOccurrencesHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludedOccurrencesHash(v)
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillOfMaterialsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillOfMaterialsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillOfMaterialsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillOfMaterials numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillOfMaterialsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billofmaterials.FieldPackageID) {
		fields = append(fields, billofmaterials.FieldPackageID)
	}
	if m.FieldCleared(billofmaterials.FieldArtifactID) {
		fields = append(fields, billofmaterials.FieldArtifactID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillOfMaterialsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillOfMaterialsMutation) ClearField(name string) error {
	switch name {
	case billofmaterials.FieldPackageID:
		m.ClearPackageID()
		return nil
	case billofmaterials.FieldArtifactID:
		m.ClearArtifactID()
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillOfMaterialsMutation) ResetField(name string) error {
	switch name {
	case billofmaterials.FieldPackageID:
		m.ResetPackageID()
		return nil
	case billofmaterials.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case billofmaterials.FieldURI:
		m.ResetURI()
		return nil
	case billofmaterials.FieldAlgorithm:
		m.ResetAlgorithm()
		return nil
	case billofmaterials.FieldDigest:
		m.ResetDigest()
		return nil
	case billofmaterials.FieldDownloadLocation:
		m.ResetDownloadLocation()
		return nil
	case billofmaterials.FieldOrigin:
		m.ResetOrigin()
		return nil
	case billofmaterials.FieldCollector:
		m.ResetCollector()
		return nil
	case billofmaterials.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	case billofmaterials.FieldKnownSince:
		m.ResetKnownSince()
		return nil
	case billofmaterials.FieldIncludedPackagesHash:
		m.ResetIncludedPackagesHash()
		return nil
	case billofmaterials.FieldIncludedArtifactsHash:
		m.ResetIncludedArtifactsHash()
		return nil
	case billofmaterials.FieldIncludedDependenciesHash:
		m.ResetIncludedDependenciesHash()
		return nil
	case billofmaterials.FieldIncludedOccurrencesHash:
		m.ResetIncludedOccurrencesHash()
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillOfMaterialsMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._package != nil {
		edges = append(edges, billofmaterials.EdgePackage)
	}
	if m.artifact != nil {
		edges = append(edges, billofmaterials.EdgeArtifact)
	}
	if m.included_software_packages != nil {
		edges = append(edges, billofmaterials.EdgeIncludedSoftwarePackages)
	}
	if m.included_software_artifacts != nil {
		edges = append(edges, billofmaterials.EdgeIncludedSoftwareArtifacts)
	}
	if m.included_dependencies != nil {
		edges = append(edges, billofmaterials.EdgeIncludedDependencies)
	}
	if m.included_occurrences != nil {
		edges = append(edges, billofmaterials.EdgeIncludedOccurrences)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillOfMaterialsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billofmaterials.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case billofmaterials.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	case billofmaterials.EdgeIncludedSoftwarePackages:
		ids := make([]ent.Value, 0, len(m.included_software_packages))
		for id := range m.included_software_packages {
			ids = append(ids, id)
		}
		return ids
	case billofmaterials.EdgeIncludedSoftwareArtifacts:
		ids := make([]ent.Value, 0, len(m.included_software_artifacts))
		for id := range m.included_software_artifacts {
			ids = append(ids, id)
		}
		return ids
	case billofmaterials.EdgeIncludedDependencies:
		ids := make([]ent.Value, 0, len(m.included_dependencies))
		for id := range m.included_dependencies {
			ids = append(ids, id)
		}
		return ids
	case billofmaterials.EdgeIncludedOccurrences:
		ids := make([]ent.Value, 0, len(m.included_occurrences))
		for id := range m.included_occurrences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillOfMaterialsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedincluded_software_packages != nil {
		edges = append(edges, billofmaterials.EdgeIncludedSoftwarePackages)
	}
	if m.removedincluded_software_artifacts != nil {
		edges = append(edges, billofmaterials.EdgeIncludedSoftwareArtifacts)
	}
	if m.removedincluded_dependencies != nil {
		edges = append(edges, billofmaterials.EdgeIncludedDependencies)
	}
	if m.removedincluded_occurrences != nil {
		edges = append(edges, billofmaterials.EdgeIncludedOccurrences)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillOfMaterialsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case billofmaterials.EdgeIncludedSoftwarePackages:
		ids := make([]ent.Value, 0, len(m.removedincluded_software_packages))
		for id := range m.removedincluded_software_packages {
			ids = append(ids, id)
		}
		return ids
	case billofmaterials.EdgeIncludedSoftwareArtifacts:
		ids := make([]ent.Value, 0, len(m.removedincluded_software_artifacts))
		for id := range m.removedincluded_software_artifacts {
			ids = append(ids, id)
		}
		return ids
	case billofmaterials.EdgeIncludedDependencies:
		ids := make([]ent.Value, 0, len(m.removedincluded_dependencies))
		for id := range m.removedincluded_dependencies {
			ids = append(ids, id)
		}
		return ids
	case billofmaterials.EdgeIncludedOccurrences:
		ids := make([]ent.Value, 0, len(m.removedincluded_occurrences))
		for id := range m.removedincluded_occurrences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillOfMaterialsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_package {
		edges = append(edges, billofmaterials.EdgePackage)
	}
	if m.clearedartifact {
		edges = append(edges, billofmaterials.EdgeArtifact)
	}
	if m.clearedincluded_software_packages {
		edges = append(edges, billofmaterials.EdgeIncludedSoftwarePackages)
	}
	if m.clearedincluded_software_artifacts {
		edges = append(edges, billofmaterials.EdgeIncludedSoftwareArtifacts)
	}
	if m.clearedincluded_dependencies {
		edges = append(edges, billofmaterials.EdgeIncludedDependencies)
	}
	if m.clearedincluded_occurrences {
		edges = append(edges, billofmaterials.EdgeIncludedOccurrences)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillOfMaterialsMutation) EdgeCleared(name string) bool {
	switch name {
	case billofmaterials.EdgePackage:
		return m.cleared_package
	case billofmaterials.EdgeArtifact:
		return m.clearedartifact
	case billofmaterials.EdgeIncludedSoftwarePackages:
		return m.clearedincluded_software_packages
	case billofmaterials.EdgeIncludedSoftwareArtifacts:
		return m.clearedincluded_software_artifacts
	case billofmaterials.EdgeIncludedDependencies:
		return m.clearedincluded_dependencies
	case billofmaterials.EdgeIncludedOccurrences:
		return m.clearedincluded_occurrences
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillOfMaterialsMutation) ClearEdge(name string) error {
	switch name {
	case billofmaterials.EdgePackage:
		m.ClearPackage()
		return nil
	case billofmaterials.EdgeArtifact:
		m.ClearArtifact()
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillOfMaterialsMutation) ResetEdge(name string) error {
	switch name {
	case billofmaterials.EdgePackage:
		m.ResetPackage()
		return nil
	case billofmaterials.EdgeArtifact:
		m.ResetArtifact()
		return nil
	case billofmaterials.EdgeIncludedSoftwarePackages:
		m.ResetIncludedSoftwarePackages()
		return nil
	case billofmaterials.EdgeIncludedSoftwareArtifacts:
		m.ResetIncludedSoftwareArtifacts()
		return nil
	case billofmaterials.EdgeIncludedDependencies:
		m.ResetIncludedDependencies()
		return nil
	case billofmaterials.EdgeIncludedOccurrences:
		m.ResetIncludedOccurrences()
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials edge %s", name)
}

// BuilderMutation represents an operation that mutates the Builder nodes in the graph.
type BuilderMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	uri                      *string
	clearedFields            map[string]struct{}
	slsa_attestations        map[uuid.UUID]struct{}
	removedslsa_attestations map[uuid.UUID]struct{}
	clearedslsa_attestations bool
	done                     bool
	oldValue                 func(context.Context) (*Builder, error)
	predicates               []predicate.Builder
}

var _ ent.Mutation = (*BuilderMutation)(nil)

// builderOption allows management of the mutation configuration using functional options.
type builderOption func(*BuilderMutation)

// newBuilderMutation creates new mutation for the Builder entity.
func newBuilderMutation(c config, op Op, opts ...builderOption) *BuilderMutation {
	m := &BuilderMutation{
		config:        c,
		op:            op,
		typ:           TypeBuilder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuilderID sets the ID field of the mutation.
func withBuilderID(id uuid.UUID) builderOption {
	return func(m *BuilderMutation) {
		var (
			err   error
			once  sync.Once
			value *Builder
		)
		m.oldValue = func(ctx context.Context) (*Builder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Builder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuilder sets the old Builder of the mutation.
func withBuilder(node *Builder) builderOption {
	return func(m *BuilderMutation) {
		m.oldValue = func(context.Context) (*Builder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuilderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuilderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Builder entities.
func (m *BuilderMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuilderMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuilderMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Builder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURI sets the "uri" field.
func (m *BuilderMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *BuilderMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the Builder entity.
// If the Builder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuilderMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *BuilderMutation) ResetURI() {
	m.uri = nil
}

// AddSlsaAttestationIDs adds the "slsa_attestations" edge to the SLSAAttestation entity by ids.
func (m *BuilderMutation) AddSlsaAttestationIDs(ids ...uuid.UUID) {
	if m.slsa_attestations == nil {
		m.slsa_attestations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.slsa_attestations[ids[i]] = struct{}{}
	}
}

// ClearSlsaAttestations clears the "slsa_attestations" edge to the SLSAAttestation entity.
func (m *BuilderMutation) ClearSlsaAttestations() {
	m.clearedslsa_attestations = true
}

// SlsaAttestationsCleared reports if the "slsa_attestations" edge to the SLSAAttestation entity was cleared.
func (m *BuilderMutation) SlsaAttestationsCleared() bool {
	return m.clearedslsa_attestations
}

// RemoveSlsaAttestationIDs removes the "slsa_attestations" edge to the SLSAAttestation entity by IDs.
func (m *BuilderMutation) RemoveSlsaAttestationIDs(ids ...uuid.UUID) {
	if m.removedslsa_attestations == nil {
		m.removedslsa_attestations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.slsa_attestations, ids[i])
		m.removedslsa_attestations[ids[i]] = struct{}{}
	}
}

// RemovedSlsaAttestations returns the removed IDs of the "slsa_attestations" edge to the SLSAAttestation entity.
func (m *BuilderMutation) RemovedSlsaAttestationsIDs() (ids []uuid.UUID) {
	for id := range m.removedslsa_attestations {
		ids = append(ids, id)
	}
	return
}

// SlsaAttestationsIDs returns the "slsa_attestations" edge IDs in the mutation.
func (m *BuilderMutation) SlsaAttestationsIDs() (ids []uuid.UUID) {
	for id := range m.slsa_attestations {
		ids = append(ids, id)
	}
	return
}

// ResetSlsaAttestations resets all changes to the "slsa_attestations" edge.
func (m *BuilderMutation) ResetSlsaAttestations() {
	m.slsa_attestations = nil
	m.clearedslsa_attestations = false
	m.removedslsa_attestations = nil
}

// Where appends a list predicates to the BuilderMutation builder.
func (m *BuilderMutation) Where(ps ...predicate.Builder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BuilderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BuilderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Builder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BuilderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BuilderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Builder).
func (m *BuilderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuilderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.uri != nil {
		fields = append(fields, builder.FieldURI)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuilderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case builder.FieldURI:
		return m.URI()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuilderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case builder.FieldURI:
		return m.OldURI(ctx)
	}
	return nil, fmt.Errorf("unknown Builder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuilderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case builder.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	}
	return fmt.Errorf("unknown Builder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuilderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuilderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuilderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Builder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuilderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuilderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuilderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Builder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuilderMutation) ResetField(name string) error {
	switch name {
	case builder.FieldURI:
		m.ResetURI()
		return nil
	}
	return fmt.Errorf("unknown Builder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuilderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.slsa_attestations != nil {
		edges = append(edges, builder.EdgeSlsaAttestations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuilderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case builder.EdgeSlsaAttestations:
		ids := make([]ent.Value, 0, len(m.slsa_attestations))
		for id := range m.slsa_attestations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuilderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedslsa_attestations != nil {
		edges = append(edges, builder.EdgeSlsaAttestations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuilderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case builder.EdgeSlsaAttestations:
		ids := make([]ent.Value, 0, len(m.removedslsa_attestations))
		for id := range m.removedslsa_attestations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuilderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedslsa_attestations {
		edges = append(edges, builder.EdgeSlsaAttestations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuilderMutation) EdgeCleared(name string) bool {
	switch name {
	case builder.EdgeSlsaAttestations:
		return m.clearedslsa_attestations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuilderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Builder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuilderMutation) ResetEdge(name string) error {
	switch name {
	case builder.EdgeSlsaAttestations:
		m.ResetSlsaAttestations()
		return nil
	}
	return fmt.Errorf("unknown Builder edge %s", name)
}

// CertificationMutation represents an operation that mutates the Certification nodes in the graph.
type CertificationMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	_type                  *certification.Type
	justification          *string
	known_since            *time.Time
	origin                 *string
	collector              *string
	document_ref           *string
	clearedFields          map[string]struct{}
	source                 *uuid.UUID
	clearedsource          bool
	package_version        *uuid.UUID
	clearedpackage_version bool
	all_versions           *uuid.UUID
	clearedall_versions    bool
	artifact               *uuid.UUID
	clearedartifact        bool
	done                   bool
	oldValue               func(context.Context) (*Certification, error)
	predicates             []predicate.Certification
}

var _ ent.Mutation = (*CertificationMutation)(nil)

// certificationOption allows management of the mutation configuration using functional options.
type certificationOption func(*CertificationMutation)

// newCertificationMutation creates new mutation for the Certification entity.
func newCertificationMutation(c config, op Op, opts ...certificationOption) *CertificationMutation {
	m := &CertificationMutation{
		config:        c,
		op:            op,
		typ:           TypeCertification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificationID sets the ID field of the mutation.
func withCertificationID(id uuid.UUID) certificationOption {
	return func(m *CertificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Certification
		)
		m.oldValue = func(ctx context.Context) (*Certification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Certification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertification sets the old Certification of the mutation.
func withCertification(node *Certification) certificationOption {
	return func(m *CertificationMutation) {
		m.oldValue = func(context.Context) (*Certification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Certification entities.
func (m *CertificationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertificationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertificationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Certification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceID sets the "source_id" field.
func (m *CertificationMutation) SetSourceID(u uuid.UUID) {
	m.source = &u
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *CertificationMutation) SourceID() (r uuid.UUID, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldSourceID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *CertificationMutation) ClearSourceID() {
	m.source = nil
	m.clearedFields[certification.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *CertificationMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[certification.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *CertificationMutation) ResetSourceID() {
	m.source = nil
	delete(m.clearedFields, certification.FieldSourceID)
}

// SetPackageVersionID sets the "package_version_id" field.
func (m *CertificationMutation) SetPackageVersionID(u uuid.UUID) {
	m.package_version = &u
}

// PackageVersionID returns the value of the "package_version_id" field in the mutation.
func (m *CertificationMutation) PackageVersionID() (r uuid.UUID, exists bool) {
	v := m.package_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageVersionID returns the old "package_version_id" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldPackageVersionID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageVersionID: %w", err)
	}
	return oldValue.PackageVersionID, nil
}

// ClearPackageVersionID clears the value of the "package_version_id" field.
func (m *CertificationMutation) ClearPackageVersionID() {
	m.package_version = nil
	m.clearedFields[certification.FieldPackageVersionID] = struct{}{}
}

// PackageVersionIDCleared returns if the "package_version_id" field was cleared in this mutation.
func (m *CertificationMutation) PackageVersionIDCleared() bool {
	_, ok := m.clearedFields[certification.FieldPackageVersionID]
	return ok
}

// ResetPackageVersionID resets all changes to the "package_version_id" field.
func (m *CertificationMutation) ResetPackageVersionID() {
	m.package_version = nil
	delete(m.clearedFields, certification.FieldPackageVersionID)
}

// SetPackageNameID sets the "package_name_id" field.
func (m *CertificationMutation) SetPackageNameID(u uuid.UUID) {
	m.all_versions = &u
}

// PackageNameID returns the value of the "package_name_id" field in the mutation.
func (m *CertificationMutation) PackageNameID() (r uuid.UUID, exists bool) {
	v := m.all_versions
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageNameID returns the old "package_name_id" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldPackageNameID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageNameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageNameID: %w", err)
	}
	return oldValue.PackageNameID, nil
}

// ClearPackageNameID clears the value of the "package_name_id" field.
func (m *CertificationMutation) ClearPackageNameID() {
	m.all_versions = nil
	m.clearedFields[certification.FieldPackageNameID] = struct{}{}
}

// PackageNameIDCleared returns if the "package_name_id" field was cleared in this mutation.
func (m *CertificationMutation) PackageNameIDCleared() bool {
	_, ok := m.clearedFields[certification.FieldPackageNameID]
	return ok
}

// ResetPackageNameID resets all changes to the "package_name_id" field.
func (m *CertificationMutation) ResetPackageNameID() {
	m.all_versions = nil
	delete(m.clearedFields, certification.FieldPackageNameID)
}

// SetArtifactID sets the "artifact_id" field.
func (m *CertificationMutation) SetArtifactID(u uuid.UUID) {
	m.artifact = &u
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *CertificationMutation) ArtifactID() (r uuid.UUID, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldArtifactID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ClearArtifactID clears the value of the "artifact_id" field.
func (m *CertificationMutation) ClearArtifactID() {
	m.artifact = nil
	m.clearedFields[certification.FieldArtifactID] = struct{}{}
}

// ArtifactIDCleared returns if the "artifact_id" field was cleared in this mutation.
func (m *CertificationMutation) ArtifactIDCleared() bool {
	_, ok := m.clearedFields[certification.FieldArtifactID]
	return ok
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *CertificationMutation) ResetArtifactID() {
	m.artifact = nil
	delete(m.clearedFields, certification.FieldArtifactID)
}

// SetType sets the "type" field.
func (m *CertificationMutation) SetType(c certification.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CertificationMutation) GetType() (r certification.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldType(ctx context.Context) (v certification.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CertificationMutation) ResetType() {
	m._type = nil
}

// SetJustification sets the "justification" field.
func (m *CertificationMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *CertificationMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *CertificationMutation) ResetJustification() {
	m.justification = nil
}

// SetKnownSince sets the "known_since" field.
func (m *CertificationMutation) SetKnownSince(t time.Time) {
	m.known_since = &t
}

// KnownSince returns the value of the "known_since" field in the mutation.
func (m *CertificationMutation) KnownSince() (r time.Time, exists bool) {
	v := m.known_since
	if v == nil {
		return
	}
	return *v, true
}

// OldKnownSince returns the old "known_since" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldKnownSince(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnownSince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnownSince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnownSince: %w", err)
	}
	return oldValue.KnownSince, nil
}

// ResetKnownSince resets all changes to the "known_since" field.
func (m *CertificationMutation) ResetKnownSince() {
	m.known_since = nil
}

// SetOrigin sets the "origin" field.
func (m *CertificationMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *CertificationMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *CertificationMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *CertificationMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *CertificationMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *CertificationMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *CertificationMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *CertificationMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *CertificationMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *CertificationMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[certification.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *CertificationMutation) SourceCleared() bool {
	return m.SourceIDCleared() || m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *CertificationMutation) SourceIDs() (ids []uuid.UUID) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *CertificationMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// ClearPackageVersion clears the "package_version" edge to the PackageVersion entity.
func (m *CertificationMutation) ClearPackageVersion() {
	m.clearedpackage_version = true
	m.clearedFields[certification.FieldPackageVersionID] = struct{}{}
}

// PackageVersionCleared reports if the "package_version" edge to the PackageVersion entity was cleared.
func (m *CertificationMutation) PackageVersionCleared() bool {
	return m.PackageVersionIDCleared() || m.clearedpackage_version
}

// PackageVersionIDs returns the "package_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageVersionID instead. It exists only for internal usage by the builders.
func (m *CertificationMutation) PackageVersionIDs() (ids []uuid.UUID) {
	if id := m.package_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackageVersion resets all changes to the "package_version" edge.
func (m *CertificationMutation) ResetPackageVersion() {
	m.package_version = nil
	m.clearedpackage_version = false
}

// SetAllVersionsID sets the "all_versions" edge to the PackageName entity by id.
func (m *CertificationMutation) SetAllVersionsID(id uuid.UUID) {
	m.all_versions = &id
}

// ClearAllVersions clears the "all_versions" edge to the PackageName entity.
func (m *CertificationMutation) ClearAllVersions() {
	m.clearedall_versions = true
	m.clearedFields[certification.FieldPackageNameID] = struct{}{}
}

// AllVersionsCleared reports if the "all_versions" edge to the PackageName entity was cleared.
func (m *CertificationMutation) AllVersionsCleared() bool {
	return m.PackageNameIDCleared() || m.clearedall_versions
}

// AllVersionsID returns the "all_versions" edge ID in the mutation.
func (m *CertificationMutation) AllVersionsID() (id uuid.UUID, exists bool) {
	if m.all_versions != nil {
		return *m.all_versions, true
	}
	return
}

// AllVersionsIDs returns the "all_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AllVersionsID instead. It exists only for internal usage by the builders.
func (m *CertificationMutation) AllVersionsIDs() (ids []uuid.UUID) {
	if id := m.all_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAllVersions resets all changes to the "all_versions" edge.
func (m *CertificationMutation) ResetAllVersions() {
	m.all_versions = nil
	m.clearedall_versions = false
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *CertificationMutation) ClearArtifact() {
	m.clearedartifact = true
	m.clearedFields[certification.FieldArtifactID] = struct{}{}
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *CertificationMutation) ArtifactCleared() bool {
	return m.ArtifactIDCleared() || m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *CertificationMutation) ArtifactIDs() (ids []uuid.UUID) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *CertificationMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// Where appends a list predicates to the CertificationMutation builder.
func (m *CertificationMutation) Where(ps ...predicate.Certification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Certification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Certification).
func (m *CertificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertificationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.source != nil {
		fields = append(fields, certification.FieldSourceID)
	}
	if m.package_version != nil {
		fields = append(fields, certification.FieldPackageVersionID)
	}
	if m.all_versions != nil {
		fields = append(fields, certification.FieldPackageNameID)
	}
	if m.artifact != nil {
		fields = append(fields, certification.FieldArtifactID)
	}
	if m._type != nil {
		fields = append(fields, certification.FieldType)
	}
	if m.justification != nil {
		fields = append(fields, certification.FieldJustification)
	}
	if m.known_since != nil {
		fields = append(fields, certification.FieldKnownSince)
	}
	if m.origin != nil {
		fields = append(fields, certification.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, certification.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, certification.FieldDocumentRef)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certification.FieldSourceID:
		return m.SourceID()
	case certification.FieldPackageVersionID:
		return m.PackageVersionID()
	case certification.FieldPackageNameID:
		return m.PackageNameID()
	case certification.FieldArtifactID:
		return m.ArtifactID()
	case certification.FieldType:
		return m.GetType()
	case certification.FieldJustification:
		return m.Justification()
	case certification.FieldKnownSince:
		return m.KnownSince()
	case certification.FieldOrigin:
		return m.Origin()
	case certification.FieldCollector:
		return m.Collector()
	case certification.FieldDocumentRef:
		return m.DocumentRef()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certification.FieldSourceID:
		return m.OldSourceID(ctx)
	case certification.FieldPackageVersionID:
		return m.OldPackageVersionID(ctx)
	case certification.FieldPackageNameID:
		return m.OldPackageNameID(ctx)
	case certification.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case certification.FieldType:
		return m.OldType(ctx)
	case certification.FieldJustification:
		return m.OldJustification(ctx)
	case certification.FieldKnownSince:
		return m.OldKnownSince(ctx)
	case certification.FieldOrigin:
		return m.OldOrigin(ctx)
	case certification.FieldCollector:
		return m.OldCollector(ctx)
	case certification.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	}
	return nil, fmt.Errorf("unknown Certification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certification.FieldSourceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case certification.FieldPackageVersionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageVersionID(v)
		return nil
	case certification.FieldPackageNameID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageNameID(v)
		return nil
	case certification.FieldArtifactID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case certification.FieldType:
		v, ok := value.(certification.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case certification.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case certification.FieldKnownSince:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnownSince(v)
		return nil
	case certification.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case certification.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case certification.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	}
	return fmt.Errorf("unknown Certification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Certification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certification.FieldSourceID) {
		fields = append(fields, certification.FieldSourceID)
	}
	if m.FieldCleared(certification.FieldPackageVersionID) {
		fields = append(fields, certification.FieldPackageVersionID)
	}
	if m.FieldCleared(certification.FieldPackageNameID) {
		fields = append(fields, certification.FieldPackageNameID)
	}
	if m.FieldCleared(certification.FieldArtifactID) {
		fields = append(fields, certification.FieldArtifactID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificationMutation) ClearField(name string) error {
	switch name {
	case certification.FieldSourceID:
		m.ClearSourceID()
		return nil
	case certification.FieldPackageVersionID:
		m.ClearPackageVersionID()
		return nil
	case certification.FieldPackageNameID:
		m.ClearPackageNameID()
		return nil
	case certification.FieldArtifactID:
		m.ClearArtifactID()
		return nil
	}
	return fmt.Errorf("unknown Certification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertificationMutation) ResetField(name string) error {
	switch name {
	case certification.FieldSourceID:
		m.ResetSourceID()
		return nil
	case certification.FieldPackageVersionID:
		m.ResetPackageVersionID()
		return nil
	case certification.FieldPackageNameID:
		m.ResetPackageNameID()
		return nil
	case certification.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case certification.FieldType:
		m.ResetType()
		return nil
	case certification.FieldJustification:
		m.ResetJustification()
		return nil
	case certification.FieldKnownSince:
		m.ResetKnownSince()
		return nil
	case certification.FieldOrigin:
		m.ResetOrigin()
		return nil
	case certification.FieldCollector:
		m.ResetCollector()
		return nil
	case certification.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	}
	return fmt.Errorf("unknown Certification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.source != nil {
		edges = append(edges, certification.EdgeSource)
	}
	if m.package_version != nil {
		edges = append(edges, certification.EdgePackageVersion)
	}
	if m.all_versions != nil {
		edges = append(edges, certification.EdgeAllVersions)
	}
	if m.artifact != nil {
		edges = append(edges, certification.EdgeArtifact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certification.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	case certification.EdgePackageVersion:
		if id := m.package_version; id != nil {
			return []ent.Value{*id}
		}
	case certification.EdgeAllVersions:
		if id := m.all_versions; id != nil {
			return []ent.Value{*id}
		}
	case certification.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsource {
		edges = append(edges, certification.EdgeSource)
	}
	if m.clearedpackage_version {
		edges = append(edges, certification.EdgePackageVersion)
	}
	if m.clearedall_versions {
		edges = append(edges, certification.EdgeAllVersions)
	}
	if m.clearedartifact {
		edges = append(edges, certification.EdgeArtifact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertificationMutation) EdgeCleared(name string) bool {
	switch name {
	case certification.EdgeSource:
		return m.clearedsource
	case certification.EdgePackageVersion:
		return m.clearedpackage_version
	case certification.EdgeAllVersions:
		return m.clearedall_versions
	case certification.EdgeArtifact:
		return m.clearedartifact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertificationMutation) ClearEdge(name string) error {
	switch name {
	case certification.EdgeSource:
		m.ClearSource()
		return nil
	case certification.EdgePackageVersion:
		m.ClearPackageVersion()
		return nil
	case certification.EdgeAllVersions:
		m.ClearAllVersions()
		return nil
	case certification.EdgeArtifact:
		m.ClearArtifact()
		return nil
	}
	return fmt.Errorf("unknown Certification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertificationMutation) ResetEdge(name string) error {
	switch name {
	case certification.EdgeSource:
		m.ResetSource()
		return nil
	case certification.EdgePackageVersion:
		m.ResetPackageVersion()
		return nil
	case certification.EdgeAllVersions:
		m.ResetAllVersions()
		return nil
	case certification.EdgeArtifact:
		m.ResetArtifact()
		return nil
	}
	return fmt.Errorf("unknown Certification edge %s", name)
}

// CertifyLegalMutation represents an operation that mutates the CertifyLegal nodes in the graph.
type CertifyLegalMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	declared_license           *string
	discovered_license         *string
	attribution                *string
	justification              *string
	time_scanned               *time.Time
	origin                     *string
	collector                  *string
	document_ref               *string
	declared_licenses_hash     *string
	discovered_licenses_hash   *string
	clearedFields              map[string]struct{}
	_package                   *uuid.UUID
	cleared_package            bool
	source                     *uuid.UUID
	clearedsource              bool
	declared_licenses          map[uuid.UUID]struct{}
	removeddeclared_licenses   map[uuid.UUID]struct{}
	cleareddeclared_licenses   bool
	discovered_licenses        map[uuid.UUID]struct{}
	removeddiscovered_licenses map[uuid.UUID]struct{}
	cleareddiscovered_licenses bool
	done                       bool
	oldValue                   func(context.Context) (*CertifyLegal, error)
	predicates                 []predicate.CertifyLegal
}

var _ ent.Mutation = (*CertifyLegalMutation)(nil)

// certifylegalOption allows management of the mutation configuration using functional options.
type certifylegalOption func(*CertifyLegalMutation)

// newCertifyLegalMutation creates new mutation for the CertifyLegal entity.
func newCertifyLegalMutation(c config, op Op, opts ...certifylegalOption) *CertifyLegalMutation {
	m := &CertifyLegalMutation{
		config:        c,
		op:            op,
		typ:           TypeCertifyLegal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertifyLegalID sets the ID field of the mutation.
func withCertifyLegalID(id uuid.UUID) certifylegalOption {
	return func(m *CertifyLegalMutation) {
		var (
			err   error
			once  sync.Once
			value *CertifyLegal
		)
		m.oldValue = func(ctx context.Context) (*CertifyLegal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertifyLegal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertifyLegal sets the old CertifyLegal of the mutation.
func withCertifyLegal(node *CertifyLegal) certifylegalOption {
	return func(m *CertifyLegalMutation) {
		m.oldValue = func(context.Context) (*CertifyLegal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertifyLegalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertifyLegalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CertifyLegal entities.
func (m *CertifyLegalMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertifyLegalMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertifyLegalMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertifyLegal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *CertifyLegalMutation) SetPackageID(u uuid.UUID) {
	m._package = &u
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *CertifyLegalMutation) PackageID() (r uuid.UUID, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldPackageID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *CertifyLegalMutation) ClearPackageID() {
	m._package = nil
	m.clearedFields[certifylegal.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *CertifyLegalMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[certifylegal.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *CertifyLegalMutation) ResetPackageID() {
	m._package = nil
	delete(m.clearedFields, certifylegal.FieldPackageID)
}

// SetSourceID sets the "source_id" field.
func (m *CertifyLegalMutation) SetSourceID(u uuid.UUID) {
	m.source = &u
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *CertifyLegalMutation) SourceID() (r uuid.UUID, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldSourceID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *CertifyLegalMutation) ClearSourceID() {
	m.source = nil
	m.clearedFields[certifylegal.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *CertifyLegalMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[certifylegal.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *CertifyLegalMutation) ResetSourceID() {
	m.source = nil
	delete(m.clearedFields, certifylegal.FieldSourceID)
}

// SetDeclaredLicense sets the "declared_license" field.
func (m *CertifyLegalMutation) SetDeclaredLicense(s string) {
	m.declared_license = &s
}

// DeclaredLicense returns the value of the "declared_license" field in the mutation.
func (m *CertifyLegalMutation) DeclaredLicense() (r string, exists bool) {
	v := m.declared_license
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredLicense returns the old "declared_license" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldDeclaredLicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredLicense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredLicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredLicense: %w", err)
	}
	return oldValue.DeclaredLicense, nil
}

// ResetDeclaredLicense resets all changes to the "declared_license" field.
func (m *CertifyLegalMutation) ResetDeclaredLicense() {
	m.declared_license = nil
}

// SetDiscoveredLicense sets the "discovered_license" field.
func (m *CertifyLegalMutation) SetDiscoveredLicense(s string) {
	m.discovered_license = &s
}

// DiscoveredLicense returns the value of the "discovered_license" field in the mutation.
func (m *CertifyLegalMutation) DiscoveredLicense() (r string, exists bool) {
	v := m.discovered_license
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveredLicense returns the old "discovered_license" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldDiscoveredLicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveredLicense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveredLicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveredLicense: %w", err)
	}
	return oldValue.DiscoveredLicense, nil
}

// ResetDiscoveredLicense resets all changes to the "discovered_license" field.
func (m *CertifyLegalMutation) ResetDiscoveredLicense() {
	m.discovered_license = nil
}

// SetAttribution sets the "attribution" field.
func (m *CertifyLegalMutation) SetAttribution(s string) {
	m.attribution = &s
}

// Attribution returns the value of the "attribution" field in the mutation.
func (m *CertifyLegalMutation) Attribution() (r string, exists bool) {
	v := m.attribution
	if v == nil {
		return
	}
	return *v, true
}

// OldAttribution returns the old "attribution" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldAttribution(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttribution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttribution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttribution: %w", err)
	}
	return oldValue.Attribution, nil
}

// ResetAttribution resets all changes to the "attribution" field.
func (m *CertifyLegalMutation) ResetAttribution() {
	m.attribution = nil
}

// SetJustification sets the "justification" field.
func (m *CertifyLegalMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *CertifyLegalMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *CertifyLegalMutation) ResetJustification() {
	m.justification = nil
}

// SetTimeScanned sets the "time_scanned" field.
func (m *CertifyLegalMutation) SetTimeScanned(t time.Time) {
	m.time_scanned = &t
}

// TimeScanned returns the value of the "time_scanned" field in the mutation.
func (m *CertifyLegalMutation) TimeScanned() (r time.Time, exists bool) {
	v := m.time_scanned
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeScanned returns the old "time_scanned" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldTimeScanned(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeScanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeScanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeScanned: %w", err)
	}
	return oldValue.TimeScanned, nil
}

// ResetTimeScanned resets all changes to the "time_scanned" field.
func (m *CertifyLegalMutation) ResetTimeScanned() {
	m.time_scanned = nil
}

// SetOrigin sets the "origin" field.
func (m *CertifyLegalMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *CertifyLegalMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *CertifyLegalMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *CertifyLegalMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *CertifyLegalMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *CertifyLegalMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *CertifyLegalMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *CertifyLegalMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *CertifyLegalMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// SetDeclaredLicensesHash sets the "declared_licenses_hash" field.
func (m *CertifyLegalMutation) SetDeclaredLicensesHash(s string) {
	m.declared_licenses_hash = &s
}

// DeclaredLicensesHash returns the value of the "declared_licenses_hash" field in the mutation.
func (m *CertifyLegalMutation) DeclaredLicensesHash() (r string, exists bool) {
	v := m.declared_licenses_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredLicensesHash returns the old "declared_licenses_hash" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldDeclaredLicensesHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredLicensesHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredLicensesHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredLicensesHash: %w", err)
	}
	return oldValue.DeclaredLicensesHash, nil
}

// ResetDeclaredLicensesHash resets all changes to the "declared_licenses_hash" field.
func (m *CertifyLegalMutation) ResetDeclaredLicensesHash() {
	m.declared_licenses_hash = nil
}

// SetDiscoveredLicensesHash sets the "discovered_licenses_hash" field.
func (m *CertifyLegalMutation) SetDiscoveredLicensesHash(s string) {
	m.discovered_licenses_hash = &s
}

// DiscoveredLicensesHash returns the value of the "discovered_licenses_hash" field in the mutation.
func (m *CertifyLegalMutation) DiscoveredLicensesHash() (r string, exists bool) {
	v := m.discovered_licenses_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveredLicensesHash returns the old "discovered_licenses_hash" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldDiscoveredLicensesHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveredLicensesHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveredLicensesHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveredLicensesHash: %w", err)
	}
	return oldValue.DiscoveredLicensesHash, nil
}

// ResetDiscoveredLicensesHash resets all changes to the "discovered_licenses_hash" field.
func (m *CertifyLegalMutation) ResetDiscoveredLicensesHash() {
	m.discovered_licenses_hash = nil
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *CertifyLegalMutation) ClearPackage() {
	m.cleared_package = true
	m.clearedFields[certifylegal.FieldPackageID] = struct{}{}
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *CertifyLegalMutation) PackageCleared() bool {
	return m.PackageIDCleared() || m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *CertifyLegalMutation) PackageIDs() (ids []uuid.UUID) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *CertifyLegalMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *CertifyLegalMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[certifylegal.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *CertifyLegalMutation) SourceCleared() bool {
	return m.SourceIDCleared() || m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *CertifyLegalMutation) SourceIDs() (ids []uuid.UUID) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *CertifyLegalMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// AddDeclaredLicenseIDs adds the "declared_licenses" edge to the License entity by ids.
func (m *CertifyLegalMutation) AddDeclaredLicenseIDs(ids ...uuid.UUID) {
	if m.declared_licenses == nil {
		m.declared_licenses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.declared_licenses[ids[i]] = struct{}{}
	}
}

// ClearDeclaredLicenses clears the "declared_licenses" edge to the License entity.
func (m *CertifyLegalMutation) ClearDeclaredLicenses() {
	m.cleareddeclared_licenses = true
}

// DeclaredLicensesCleared reports if the "declared_licenses" edge to the License entity was cleared.
func (m *CertifyLegalMutation) DeclaredLicensesCleared() bool {
	return m.cleareddeclared_licenses
}

// RemoveDeclaredLicenseIDs removes the "declared_licenses" edge to the License entity by IDs.
func (m *CertifyLegalMutation) RemoveDeclaredLicenseIDs(ids ...uuid.UUID) {
	if m.removeddeclared_licenses == nil {
		m.removeddeclared_licenses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.declared_licenses, ids[i])
		m.removeddeclared_licenses[ids[i]] = struct{}{}
	}
}

// RemovedDeclaredLicenses returns the removed IDs of the "declared_licenses" edge to the License entity.
func (m *CertifyLegalMutation) RemovedDeclaredLicensesIDs() (ids []uuid.UUID) {
	for id := range m.removeddeclared_licenses {
		ids = append(ids, id)
	}
	return
}

// DeclaredLicensesIDs returns the "declared_licenses" edge IDs in the mutation.
func (m *CertifyLegalMutation) DeclaredLicensesIDs() (ids []uuid.UUID) {
	for id := range m.declared_licenses {
		ids = append(ids, id)
	}
	return
}

// ResetDeclaredLicenses resets all changes to the "declared_licenses" edge.
func (m *CertifyLegalMutation) ResetDeclaredLicenses() {
	m.declared_licenses = nil
	m.cleareddeclared_licenses = false
	m.removeddeclared_licenses = nil
}

// AddDiscoveredLicenseIDs adds the "discovered_licenses" edge to the License entity by ids.
func (m *CertifyLegalMutation) AddDiscoveredLicenseIDs(ids ...uuid.UUID) {
	if m.discovered_licenses == nil {
		m.discovered_licenses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.discovered_licenses[ids[i]] = struct{}{}
	}
}

// ClearDiscoveredLicenses clears the "discovered_licenses" edge to the License entity.
func (m *CertifyLegalMutation) ClearDiscoveredLicenses() {
	m.cleareddiscovered_licenses = true
}

// DiscoveredLicensesCleared reports if the "discovered_licenses" edge to the License entity was cleared.
func (m *CertifyLegalMutation) DiscoveredLicensesCleared() bool {
	return m.cleareddiscovered_licenses
}

// RemoveDiscoveredLicenseIDs removes the "discovered_licenses" edge to the License entity by IDs.
func (m *CertifyLegalMutation) RemoveDiscoveredLicenseIDs(ids ...uuid.UUID) {
	if m.removeddiscovered_licenses == nil {
		m.removeddiscovered_licenses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.discovered_licenses, ids[i])
		m.removeddiscovered_licenses[ids[i]] = struct{}{}
	}
}

// RemovedDiscoveredLicenses returns the removed IDs of the "discovered_licenses" edge to the License entity.
func (m *CertifyLegalMutation) RemovedDiscoveredLicensesIDs() (ids []uuid.UUID) {
	for id := range m.removeddiscovered_licenses {
		ids = append(ids, id)
	}
	return
}

// DiscoveredLicensesIDs returns the "discovered_licenses" edge IDs in the mutation.
func (m *CertifyLegalMutation) DiscoveredLicensesIDs() (ids []uuid.UUID) {
	for id := range m.discovered_licenses {
		ids = append(ids, id)
	}
	return
}

// ResetDiscoveredLicenses resets all changes to the "discovered_licenses" edge.
func (m *CertifyLegalMutation) ResetDiscoveredLicenses() {
	m.discovered_licenses = nil
	m.cleareddiscovered_licenses = false
	m.removeddiscovered_licenses = nil
}

// Where appends a list predicates to the CertifyLegalMutation builder.
func (m *CertifyLegalMutation) Where(ps ...predicate.CertifyLegal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertifyLegalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertifyLegalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CertifyLegal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertifyLegalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertifyLegalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CertifyLegal).
func (m *CertifyLegalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertifyLegalMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m._package != nil {
		fields = append(fields, certifylegal.FieldPackageID)
	}
	if m.source != nil {
		fields = append(fields, certifylegal.FieldSourceID)
	}
	if m.declared_license != nil {
		fields = append(fields, certifylegal.FieldDeclaredLicense)
	}
	if m.discovered_license != nil {
		fields = append(fields, certifylegal.FieldDiscoveredLicense)
	}
	if m.attribution != nil {
		fields = append(fields, certifylegal.FieldAttribution)
	}
	if m.justification != nil {
		fields = append(fields, certifylegal.FieldJustification)
	}
	if m.time_scanned != nil {
		fields = append(fields, certifylegal.FieldTimeScanned)
	}
	if m.origin != nil {
		fields = append(fields, certifylegal.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, certifylegal.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, certifylegal.FieldDocumentRef)
	}
	if m.declared_licenses_hash != nil {
		fields = append(fields, certifylegal.FieldDeclaredLicensesHash)
	}
	if m.discovered_licenses_hash != nil {
		fields = append(fields, certifylegal.FieldDiscoveredLicensesHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertifyLegalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certifylegal.FieldPackageID:
		return m.PackageID()
	case certifylegal.FieldSourceID:
		return m.SourceID()
	case certifylegal.FieldDeclaredLicense:
		return m.DeclaredLicense()
	case certifylegal.FieldDiscoveredLicense:
		return m.DiscoveredLicense()
	case certifylegal.FieldAttribution:
		return m.Attribution()
	case certifylegal.FieldJustification:
		return m.Justification()
	case certifylegal.FieldTimeScanned:
		return m.TimeScanned()
	case certifylegal.FieldOrigin:
		return m.Origin()
	case certifylegal.FieldCollector:
		return m.Collector()
	case certifylegal.FieldDocumentRef:
		return m.DocumentRef()
	case certifylegal.FieldDeclaredLicensesHash:
		return m.DeclaredLicensesHash()
	case certifylegal.FieldDiscoveredLicensesHash:
		return m.DiscoveredLicensesHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertifyLegalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certifylegal.FieldPackageID:
		return m.OldPackageID(ctx)
	case certifylegal.FieldSourceID:
		return m.OldSourceID(ctx)
	case certifylegal.FieldDeclaredLicense:
		return m.OldDeclaredLicense(ctx)
	case certifylegal.FieldDiscoveredLicense:
		return m.OldDiscoveredLicense(ctx)
	case certifylegal.FieldAttribution:
		return m.OldAttribution(ctx)
	case certifylegal.FieldJustification:
		return m.OldJustification(ctx)
	case certifylegal.FieldTimeScanned:
		return m.OldTimeScanned(ctx)
	case certifylegal.FieldOrigin:
		return m.OldOrigin(ctx)
	case certifylegal.FieldCollector:
		return m.OldCollector(ctx)
	case certifylegal.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	case certifylegal.FieldDeclaredLicensesHash:
		return m.OldDeclaredLicensesHash(ctx)
	case certifylegal.FieldDiscoveredLicensesHash:
		return m.OldDiscoveredLicensesHash(ctx)
	}
	return nil, fmt.Errorf("unknown CertifyLegal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyLegalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certifylegal.FieldPackageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case certifylegal.FieldSourceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case certifylegal.FieldDeclaredLicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredLicense(v)
		return nil
	case certifylegal.FieldDiscoveredLicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveredLicense(v)
		return nil
	case certifylegal.FieldAttribution:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttribution(v)
		return nil
	case certifylegal.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case certifylegal.FieldTimeScanned:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeScanned(v)
		return nil
	case certifylegal.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case certifylegal.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case certifylegal.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	case certifylegal.FieldDeclaredLicensesHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredLicensesHash(v)
		return nil
	case certifylegal.FieldDiscoveredLicensesHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveredLicensesHash(v)
		return nil
	}
	return fmt.Errorf("unknown CertifyLegal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertifyLegalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertifyLegalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyLegalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CertifyLegal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertifyLegalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certifylegal.FieldPackageID) {
		fields = append(fields, certifylegal.FieldPackageID)
	}
	if m.FieldCleared(certifylegal.FieldSourceID) {
		fields = append(fields, certifylegal.FieldSourceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertifyLegalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertifyLegalMutation) ClearField(name string) error {
	switch name {
	case certifylegal.FieldPackageID:
		m.ClearPackageID()
		return nil
	case certifylegal.FieldSourceID:
		m.ClearSourceID()
		return nil
	}
	return fmt.Errorf("unknown CertifyLegal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertifyLegalMutation) ResetField(name string) error {
	switch name {
	case certifylegal.FieldPackageID:
		m.ResetPackageID()
		return nil
	case certifylegal.FieldSourceID:
		m.ResetSourceID()
		return nil
	case certifylegal.FieldDeclaredLicense:
		m.ResetDeclaredLicense()
		return nil
	case certifylegal.FieldDiscoveredLicense:
		m.ResetDiscoveredLicense()
		return nil
	case certifylegal.FieldAttribution:
		m.ResetAttribution()
		return nil
	case certifylegal.FieldJustification:
		m.ResetJustification()
		return nil
	case certifylegal.FieldTimeScanned:
		m.ResetTimeScanned()
		return nil
	case certifylegal.FieldOrigin:
		m.ResetOrigin()
		return nil
	case certifylegal.FieldCollector:
		m.ResetCollector()
		return nil
	case certifylegal.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	case certifylegal.FieldDeclaredLicensesHash:
		m.ResetDeclaredLicensesHash()
		return nil
	case certifylegal.FieldDiscoveredLicensesHash:
		m.ResetDiscoveredLicensesHash()
		return nil
	}
	return fmt.Errorf("unknown CertifyLegal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertifyLegalMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._package != nil {
		edges = append(edges, certifylegal.EdgePackage)
	}
	if m.source != nil {
		edges = append(edges, certifylegal.EdgeSource)
	}
	if m.declared_licenses != nil {
		edges = append(edges, certifylegal.EdgeDeclaredLicenses)
	}
	if m.discovered_licenses != nil {
		edges = append(edges, certifylegal.EdgeDiscoveredLicenses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertifyLegalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certifylegal.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case certifylegal.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	case certifylegal.EdgeDeclaredLicenses:
		ids := make([]ent.Value, 0, len(m.declared_licenses))
		for id := range m.declared_licenses {
			ids = append(ids, id)
		}
		return ids
	case certifylegal.EdgeDiscoveredLicenses:
		ids := make([]ent.Value, 0, len(m.discovered_licenses))
		for id := range m.discovered_licenses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertifyLegalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddeclared_licenses != nil {
		edges = append(edges, certifylegal.EdgeDeclaredLicenses)
	}
	if m.removeddiscovered_licenses != nil {
		edges = append(edges, certifylegal.EdgeDiscoveredLicenses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertifyLegalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case certifylegal.EdgeDeclaredLicenses:
		ids := make([]ent.Value, 0, len(m.removeddeclared_licenses))
		for id := range m.removeddeclared_licenses {
			ids = append(ids, id)
		}
		return ids
	case certifylegal.EdgeDiscoveredLicenses:
		ids := make([]ent.Value, 0, len(m.removeddiscovered_licenses))
		for id := range m.removeddiscovered_licenses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertifyLegalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_package {
		edges = append(edges, certifylegal.EdgePackage)
	}
	if m.clearedsource {
		edges = append(edges, certifylegal.EdgeSource)
	}
	if m.cleareddeclared_licenses {
		edges = append(edges, certifylegal.EdgeDeclaredLicenses)
	}
	if m.cleareddiscovered_licenses {
		edges = append(edges, certifylegal.EdgeDiscoveredLicenses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertifyLegalMutation) EdgeCleared(name string) bool {
	switch name {
	case certifylegal.EdgePackage:
		return m.cleared_package
	case certifylegal.EdgeSource:
		return m.clearedsource
	case certifylegal.EdgeDeclaredLicenses:
		return m.cleareddeclared_licenses
	case certifylegal.EdgeDiscoveredLicenses:
		return m.cleareddiscovered_licenses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertifyLegalMutation) ClearEdge(name string) error {
	switch name {
	case certifylegal.EdgePackage:
		m.ClearPackage()
		return nil
	case certifylegal.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown CertifyLegal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertifyLegalMutation) ResetEdge(name string) error {
	switch name {
	case certifylegal.EdgePackage:
		m.ResetPackage()
		return nil
	case certifylegal.EdgeSource:
		m.ResetSource()
		return nil
	case certifylegal.EdgeDeclaredLicenses:
		m.ResetDeclaredLicenses()
		return nil
	case certifylegal.EdgeDiscoveredLicenses:
		m.ResetDiscoveredLicenses()
		return nil
	}
	return fmt.Errorf("unknown CertifyLegal edge %s", name)
}

// CertifyScorecardMutation represents an operation that mutates the CertifyScorecard nodes in the graph.
type CertifyScorecardMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	checks             *[]*model.ScorecardCheck
	appendchecks       []*model.ScorecardCheck
	aggregate_score    *float64
	addaggregate_score *float64
	time_scanned       *time.Time
	scorecard_version  *string
	scorecard_commit   *string
	origin             *string
	collector          *string
	document_ref       *string
	checks_hash        *string
	clearedFields      map[string]struct{}
	source             *uuid.UUID
	clearedsource      bool
	done               bool
	oldValue           func(context.Context) (*CertifyScorecard, error)
	predicates         []predicate.CertifyScorecard
}

var _ ent.Mutation = (*CertifyScorecardMutation)(nil)

// certifyscorecardOption allows management of the mutation configuration using functional options.
type certifyscorecardOption func(*CertifyScorecardMutation)

// newCertifyScorecardMutation creates new mutation for the CertifyScorecard entity.
func newCertifyScorecardMutation(c config, op Op, opts ...certifyscorecardOption) *CertifyScorecardMutation {
	m := &CertifyScorecardMutation{
		config:        c,
		op:            op,
		typ:           TypeCertifyScorecard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertifyScorecardID sets the ID field of the mutation.
func withCertifyScorecardID(id uuid.UUID) certifyscorecardOption {
	return func(m *CertifyScorecardMutation) {
		var (
			err   error
			once  sync.Once
			value *CertifyScorecard
		)
		m.oldValue = func(ctx context.Context) (*CertifyScorecard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertifyScorecard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertifyScorecard sets the old CertifyScorecard of the mutation.
func withCertifyScorecard(node *CertifyScorecard) certifyscorecardOption {
	return func(m *CertifyScorecardMutation) {
		m.oldValue = func(context.Context) (*CertifyScorecard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertifyScorecardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertifyScorecardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CertifyScorecard entities.
func (m *CertifyScorecardMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertifyScorecardMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertifyScorecardMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertifyScorecard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceID sets the "source_id" field.
func (m *CertifyScorecardMutation) SetSourceID(u uuid.UUID) {
	m.source = &u
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *CertifyScorecardMutation) SourceID() (r uuid.UUID, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the CertifyScorecard entity.
// If the CertifyScorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyScorecardMutation) OldSourceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *CertifyScorecardMutation) ResetSourceID() {
	m.source = nil
}

// SetChecks sets the "checks" field.
func (m *CertifyScorecardMutation) SetChecks(mc []*model.ScorecardCheck) {
	m.checks = &mc
	m.appendchecks = nil
}

// Checks returns the value of the "checks" field in the mutation.
func (m *CertifyScorecardMutation) Checks() (r []*model.ScorecardCheck, exists bool) {
	v := m.checks
	if v == nil {
		return
	}
	return *v, true
}

// OldChecks returns the old "checks" field's value of the CertifyScorecard entity.
// If the CertifyScorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyScorecardMutation) OldChecks(ctx context.Context) (v []*model.ScorecardCheck, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecks: %w", err)
	}
	return oldValue.Checks, nil
}

// AppendChecks adds mc to the "checks" field.
func (m *CertifyScorecardMutation) AppendChecks(mc []*model.ScorecardCheck) {
	m.appendchecks = append(m.appendchecks, mc...)
}

// AppendedChecks returns the list of values that were appended to the "checks" field in this mutation.
func (m *CertifyScorecardMutation) AppendedChecks() ([]*model.ScorecardCheck, bool) {
	if len(m.appendchecks) == 0 {
		return nil, false
	}
	return m.appendchecks, true
}

// ResetChecks resets all changes to the "checks" field.
func (m *CertifyScorecardMutation) ResetChecks() {
	m.checks = nil
	m.appendchecks = nil
}

// SetAggregateScore sets the "aggregate_score" field.
func (m *CertifyScorecardMutation) SetAggregateScore(f float64) {
	m.aggregate_score = &f
	m.addaggregate_score = nil
}

// AggregateScore returns the value of the "aggregate_score" field in the mutation.
func (m *CertifyScorecardMutation) AggregateScore() (r float64, exists bool) {
	v := m.aggregate_score
	if v == nil {
		return
	}
	return *v, true
}

// OldAggregateScore returns the old "aggregate_score" field's value of the CertifyScorecard entity.
// If the CertifyScorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyScorecardMutation) OldAggregateScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAggregateScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAggregateScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAggregateScore: %w", err)
	}
	return oldValue.AggregateScore, nil
}

// AddAggregateScore adds f to the "aggregate_score" field.
func (m *CertifyScorecardMutation) AddAggregateScore(f float64) {
	if m.addaggregate_score != nil {
		*m.addaggregate_score += f
	} else {
		m.addaggregate_score = &f
	}
}

// AddedAggregateScore returns the value that was added to the "aggregate_score" field in this mutation.
func (m *CertifyScorecardMutation) AddedAggregateScore() (r float64, exists bool) {
	v := m.addaggregate_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetAggregateScore resets all changes to the "aggregate_score" field.
func (m *CertifyScorecardMutation) ResetAggregateScore() {
	m.aggregate_score = nil
	m.addaggregate_score = nil
}

// SetTimeScanned sets the "time_scanned" field.
func (m *CertifyScorecardMutation) SetTimeScanned(t time.Time) {
	m.time_scanned = &t
}

// TimeScanned returns the value of the "time_scanned" field in the mutation.
func (m *CertifyScorecardMutation) TimeScanned() (r time.Time, exists bool) {
	v := m.time_scanned
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeScanned returns the old "time_scanned" field's value of the CertifyScorecard entity.
// If the CertifyScorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyScorecardMutation) OldTimeScanned(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeScanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeScanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeScanned: %w", err)
	}
	return oldValue.TimeScanned, nil
}

// ResetTimeScanned resets all changes to the "time_scanned" field.
func (m *CertifyScorecardMutation) ResetTimeScanned() {
	m.time_scanned = nil
}

// SetScorecardVersion sets the "scorecard_version" field.
func (m *CertifyScorecardMutation) SetScorecardVersion(s string) {
	m.scorecard_version = &s
}

// ScorecardVersion returns the value of the "scorecard_version" field in the mutation.
func (m *CertifyScorecardMutation) ScorecardVersion() (r string, exists bool) {
	v := m.scorecard_version
	if v == nil {
		return
	}
	return *v, true
}

// OldScorecardVersion returns the old "scorecard_version" field's value of the CertifyScorecard entity.
// If the CertifyScorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyScorecardMutation) OldScorecardVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScorecardVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScorecardVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScorecardVersion: %w", err)
	}
	return oldValue.ScorecardVersion, nil
}

// ResetScorecardVersion resets all changes to the "scorecard_version" field.
func (m *CertifyScorecardMutation) ResetScorecardVersion() {
	m.scorecard_version = nil
}

// SetScorecardCommit sets the "scorecard_commit" field.
func (m *CertifyScorecardMutation) SetScorecardCommit(s string) {
	m.scorecard_commit = &s
}

// ScorecardCommit returns the value of the "scorecard_commit" field in the mutation.
func (m *CertifyScorecardMutation) ScorecardCommit() (r string, exists bool) {
	v := m.scorecard_commit
	if v == nil {
		return
	}
	return *v, true
}

// OldScorecardCommit returns the old "scorecard_commit" field's value of the CertifyScorecard entity.
// If the CertifyScorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyScorecardMutation) OldScorecardCommit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScorecardCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScorecardCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScorecardCommit: %w", err)
	}
	return oldValue.ScorecardCommit, nil
}

// ResetScorecardCommit resets all changes to the "scorecard_commit" field.
func (m *CertifyScorecardMutation) ResetScorecardCommit() {
	m.scorecard_commit = nil
}

// SetOrigin sets the "origin" field.
func (m *CertifyScorecardMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *CertifyScorecardMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the CertifyScorecard entity.
// If the CertifyScorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyScorecardMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *CertifyScorecardMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *CertifyScorecardMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *CertifyScorecardMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the CertifyScorecard entity.
// If the CertifyScorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyScorecardMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *CertifyScorecardMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *CertifyScorecardMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *CertifyScorecardMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the CertifyScorecard entity.
// If the CertifyScorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyScorecardMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *CertifyScorecardMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// SetChecksHash sets the "checks_hash" field.
func (m *CertifyScorecardMutation) SetChecksHash(s string) {
	m.checks_hash = &s
}

// ChecksHash returns the value of the "checks_hash" field in the mutation.
func (m *CertifyScorecardMutation) ChecksHash() (r string, exists bool) {
	v := m.checks_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksHash returns the old "checks_hash" field's value of the CertifyScorecard entity.
// If the CertifyScorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyScorecardMutation) OldChecksHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksHash: %w", err)
	}
	return oldValue.ChecksHash, nil
}

// ResetChecksHash resets all changes to the "checks_hash" field.
func (m *CertifyScorecardMutation) ResetChecksHash() {
	m.checks_hash = nil
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *CertifyScorecardMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[certifyscorecard.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *CertifyScorecardMutation) SourceCleared() bool {
	return m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *CertifyScorecardMutation) SourceIDs() (ids []uuid.UUID) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *CertifyScorecardMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Where appends a list predicates to the CertifyScorecardMutation builder.
func (m *CertifyScorecardMutation) Where(ps ...predicate.CertifyScorecard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertifyScorecardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertifyScorecardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CertifyScorecard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertifyScorecardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertifyScorecardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CertifyScorecard).
func (m *CertifyScorecardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertifyScorecardMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.source != nil {
		fields = append(fields, certifyscorecard.FieldSourceID)
	}
	if m.checks != nil {
		fields = append(fields, certifyscorecard.FieldChecks)
	}
	if m.aggregate_score != nil {
		fields = append(fields, certifyscorecard.FieldAggregateScore)
	}
	if m.time_scanned != nil {
		fields = append(fields, certifyscorecard.FieldTimeScanned)
	}
	if m.scorecard_version != nil {
		fields = append(fields, certifyscorecard.FieldScorecardVersion)
	}
	if m.scorecard_commit != nil {
		fields = append(fields, certifyscorecard.FieldScorecardCommit)
	}
	if m.origin != nil {
		fields = append(fields, certifyscorecard.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, certifyscorecard.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, certifyscorecard.FieldDocumentRef)
	}
	if m.checks_hash != nil {
		fields = append(fields, certifyscorecard.FieldChecksHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertifyScorecardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certifyscorecard.FieldSourceID:
		return m.SourceID()
	case certifyscorecard.FieldChecks:
		return m.Checks()
	case certifyscorecard.FieldAggregateScore:
		return m.AggregateScore()
	case certifyscorecard.FieldTimeScanned:
		return m.TimeScanned()
	case certifyscorecard.FieldScorecardVersion:
		return m.ScorecardVersion()
	case certifyscorecard.FieldScorecardCommit:
		return m.ScorecardCommit()
	case certifyscorecard.FieldOrigin:
		return m.Origin()
	case certifyscorecard.FieldCollector:
		return m.Collector()
	case certifyscorecard.FieldDocumentRef:
		return m.DocumentRef()
	case certifyscorecard.FieldChecksHash:
		return m.ChecksHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertifyScorecardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certifyscorecard.FieldSourceID:
		return m.OldSourceID(ctx)
	case certifyscorecard.FieldChecks:
		return m.OldChecks(ctx)
	case certifyscorecard.FieldAggregateScore:
		return m.OldAggregateScore(ctx)
	case certifyscorecard.FieldTimeScanned:
		return m.OldTimeScanned(ctx)
	case certifyscorecard.FieldScorecardVersion:
		return m.OldScorecardVersion(ctx)
	case certifyscorecard.FieldScorecardCommit:
		return m.OldScorecardCommit(ctx)
	case certifyscorecard.FieldOrigin:
		return m.OldOrigin(ctx)
	case certifyscorecard.FieldCollector:
		return m.OldCollector(ctx)
	case certifyscorecard.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	case certifyscorecard.FieldChecksHash:
		return m.OldChecksHash(ctx)
	}
	return nil, fmt.Errorf("unknown CertifyScorecard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyScorecardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certifyscorecard.FieldSourceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case certifyscorecard.FieldChecks:
		v, ok := value.([]*model.ScorecardCheck)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecks(v)
		return nil
	case certifyscorecard.FieldAggregateScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAggregateScore(v)
		return nil
	case certifyscorecard.FieldTimeScanned:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeScanned(v)
		return nil
	case certifyscorecard.FieldScorecardVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScorecardVersion(v)
		return nil
	case certifyscorecard.FieldScorecardCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScorecardCommit(v)
		return nil
	case certifyscorecard.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case certifyscorecard.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case certifyscorecard.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	case certifyscorecard.FieldChecksHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksHash(v)
		return nil
	}
	return fmt.Errorf("unknown CertifyScorecard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertifyScorecardMutation) AddedFields() []string {
	var fields []string
	if m.addaggregate_score != nil {
		fields = append(fields, certifyscorecard.FieldAggregateScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertifyScorecardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case certifyscorecard.FieldAggregateScore:
		return m.AddedAggregateScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyScorecardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case certifyscorecard.FieldAggregateScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAggregateScore(v)
		return nil
	}
	return fmt.Errorf("unknown CertifyScorecard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertifyScorecardMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertifyScorecardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertifyScorecardMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CertifyScorecard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertifyScorecardMutation) ResetField(name string) error {
	switch name {
	case certifyscorecard.FieldSourceID:
		m.ResetSourceID()
		return nil
	case certifyscorecard.FieldChecks:
		m.ResetChecks()
		return nil
	case certifyscorecard.FieldAggregateScore:
		m.ResetAggregateScore()
		return nil
	case certifyscorecard.FieldTimeScanned:
		m.ResetTimeScanned()
		return nil
	case certifyscorecard.FieldScorecardVersion:
		m.ResetScorecardVersion()
		return nil
	case certifyscorecard.FieldScorecardCommit:
		m.ResetScorecardCommit()
		return nil
	case certifyscorecard.FieldOrigin:
		m.ResetOrigin()
		return nil
	case certifyscorecard.FieldCollector:
		m.ResetCollector()
		return nil
	case certifyscorecard.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	case certifyscorecard.FieldChecksHash:
		m.ResetChecksHash()
		return nil
	}
	return fmt.Errorf("unknown CertifyScorecard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertifyScorecardMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.source != nil {
		edges = append(edges, certifyscorecard.EdgeSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertifyScorecardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certifyscorecard.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertifyScorecardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertifyScorecardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertifyScorecardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsource {
		edges = append(edges, certifyscorecard.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertifyScorecardMutation) EdgeCleared(name string) bool {
	switch name {
	case certifyscorecard.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertifyScorecardMutation) ClearEdge(name string) error {
	switch name {
	case certifyscorecard.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown CertifyScorecard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertifyScorecardMutation) ResetEdge(name string) error {
	switch name {
	case certifyscorecard.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown CertifyScorecard edge %s", name)
}

// CertifyVexMutation represents an operation that mutates the CertifyVex nodes in the graph.
type CertifyVexMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	known_since          *time.Time
	status               *string
	statement            *string
	status_notes         *string
	justification        *string
	origin               *string
	collector            *string
	document_ref         *string
	clearedFields        map[string]struct{}
	_package             *uuid.UUID
	cleared_package      bool
	artifact             *uuid.UUID
	clearedartifact      bool
	vulnerability        *uuid.UUID
	clearedvulnerability bool
	done                 bool
	oldValue             func(context.Context) (*CertifyVex, error)
	predicates           []predicate.CertifyVex
}

var _ ent.Mutation = (*CertifyVexMutation)(nil)

// certifyvexOption allows management of the mutation configuration using functional options.
type certifyvexOption func(*CertifyVexMutation)

// newCertifyVexMutation creates new mutation for the CertifyVex entity.
func newCertifyVexMutation(c config, op Op, opts ...certifyvexOption) *CertifyVexMutation {
	m := &CertifyVexMutation{
		config:        c,
		op:            op,
		typ:           TypeCertifyVex,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertifyVexID sets the ID field of the mutation.
func withCertifyVexID(id uuid.UUID) certifyvexOption {
	return func(m *CertifyVexMutation) {
		var (
			err   error
			once  sync.Once
			value *CertifyVex
		)
		m.oldValue = func(ctx context.Context) (*CertifyVex, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertifyVex.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertifyVex sets the old CertifyVex of the mutation.
func withCertifyVex(node *CertifyVex) certifyvexOption {
	return func(m *CertifyVexMutation) {
		m.oldValue = func(context.Context) (*CertifyVex, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertifyVexMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertifyVexMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CertifyVex entities.
func (m *CertifyVexMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertifyVexMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertifyVexMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertifyVex.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *CertifyVexMutation) SetPackageID(u uuid.UUID) {
	m._package = &u
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *CertifyVexMutation) PackageID() (r uuid.UUID, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldPackageID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *CertifyVexMutation) ClearPackageID() {
	m._package = nil
	m.clearedFields[certifyvex.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *CertifyVexMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[certifyvex.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *CertifyVexMutation) ResetPackageID() {
	m._package = nil
	delete(m.clearedFields, certifyvex.FieldPackageID)
}

// SetArtifactID sets the "artifact_id" field.
func (m *CertifyVexMutation) SetArtifactID(u uuid.UUID) {
	m.artifact = &u
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *CertifyVexMutation) ArtifactID() (r uuid.UUID, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldArtifactID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ClearArtifactID clears the value of the "artifact_id" field.
func (m *CertifyVexMutation) ClearArtifactID() {
	m.artifact = nil
	m.clearedFields[certifyvex.FieldArtifactID] = struct{}{}
}

// ArtifactIDCleared returns if the "artifact_id" field was cleared in this mutation.
func (m *CertifyVexMutation) ArtifactIDCleared() bool {
	_, ok := m.clearedFields[certifyvex.FieldArtifactID]
	return ok
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *CertifyVexMutation) ResetArtifactID() {
	m.artifact = nil
	delete(m.clearedFields, certifyvex.FieldArtifactID)
}

// SetVulnerabilityID sets the "vulnerability_id" field.
func (m *CertifyVexMutation) SetVulnerabilityID(u uuid.UUID) {
	m.vulnerability = &u
}

// VulnerabilityID returns the value of the "vulnerability_id" field in the mutation.
func (m *CertifyVexMutation) VulnerabilityID() (r uuid.UUID, exists bool) {
	v := m.vulnerability
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnerabilityID returns the old "vulnerability_id" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldVulnerabilityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVulnerabilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVulnerabilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnerabilityID: %w", err)
	}
	return oldValue.VulnerabilityID, nil
}

// ResetVulnerabilityID resets all changes to the "vulnerability_id" field.
func (m *CertifyVexMutation) ResetVulnerabilityID() {
	m.vulnerability = nil
}

// SetKnownSince sets the "known_since" field.
func (m *CertifyVexMutation) SetKnownSince(t time.Time) {
	m.known_since = &t
}

// KnownSince returns the value of the "known_since" field in the mutation.
func (m *CertifyVexMutation) KnownSince() (r time.Time, exists bool) {
	v := m.known_since
	if v == nil {
		return
	}
	return *v, true
}

// OldKnownSince returns the old "known_since" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldKnownSince(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnownSince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnownSince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnownSince: %w", err)
	}
	return oldValue.KnownSince, nil
}

// ResetKnownSince resets all changes to the "known_since" field.
func (m *CertifyVexMutation) ResetKnownSince() {
	m.known_since = nil
}

// SetStatus sets the "status" field.
func (m *CertifyVexMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CertifyVexMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CertifyVexMutation) ResetStatus() {
	m.status = nil
}

// SetStatement sets the "statement" field.
func (m *CertifyVexMutation) SetStatement(s string) {
	m.statement = &s
}

// Statement returns the value of the "statement" field in the mutation.
func (m *CertifyVexMutation) Statement() (r string, exists bool) {
	v := m.statement
	if v == nil {
		return
	}
	return *v, true
}

// OldStatement returns the old "statement" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldStatement(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatement: %w", err)
	}
	return oldValue.Statement, nil
}

// ResetStatement resets all changes to the "statement" field.
func (m *CertifyVexMutation) ResetStatement() {
	m.statement = nil
}

// SetStatusNotes sets the "status_notes" field.
func (m *CertifyVexMutation) SetStatusNotes(s string) {
	m.status_notes = &s
}

// StatusNotes returns the value of the "status_notes" field in the mutation.
func (m *CertifyVexMutation) StatusNotes() (r string, exists bool) {
	v := m.status_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusNotes returns the old "status_notes" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldStatusNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusNotes: %w", err)
	}
	return oldValue.StatusNotes, nil
}

// ResetStatusNotes resets all changes to the "status_notes" field.
func (m *CertifyVexMutation) ResetStatusNotes() {
	m.status_notes = nil
}

// SetJustification sets the "justification" field.
func (m *CertifyVexMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *CertifyVexMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *CertifyVexMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *CertifyVexMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *CertifyVexMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *CertifyVexMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *CertifyVexMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *CertifyVexMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *CertifyVexMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *CertifyVexMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *CertifyVexMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *CertifyVexMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *CertifyVexMutation) ClearPackage() {
	m.cleared_package = true
	m.clearedFields[certifyvex.FieldPackageID] = struct{}{}
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *CertifyVexMutation) PackageCleared() bool {
	return m.PackageIDCleared() || m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *CertifyVexMutation) PackageIDs() (ids []uuid.UUID) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *CertifyVexMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *CertifyVexMutation) ClearArtifact() {
	m.clearedartifact = true
	m.clearedFields[certifyvex.FieldArtifactID] = struct{}{}
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *CertifyVexMutation) ArtifactCleared() bool {
	return m.ArtifactIDCleared() || m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *CertifyVexMutation) ArtifactIDs() (ids []uuid.UUID) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *CertifyVexMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// ClearVulnerability clears the "vulnerability" edge to the VulnerabilityID entity.
func (m *CertifyVexMutation) ClearVulnerability() {
	m.clearedvulnerability = true
	m.clearedFields[certifyvex.FieldVulnerabilityID] = struct{}{}
}

// VulnerabilityCleared reports if the "vulnerability" edge to the VulnerabilityID entity was cleared.
func (m *CertifyVexMutation) VulnerabilityCleared() bool {
	return m.clearedvulnerability
}

// VulnerabilityIDs returns the "vulnerability" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityID instead. It exists only for internal usage by the builders.
func (m *CertifyVexMutation) VulnerabilityIDs() (ids []uuid.UUID) {
	if id := m.vulnerability; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerability resets all changes to the "vulnerability" edge.
func (m *CertifyVexMutation) ResetVulnerability() {
	m.vulnerability = nil
	m.clearedvulnerability = false
}

// Where appends a list predicates to the CertifyVexMutation builder.
func (m *CertifyVexMutation) Where(ps ...predicate.CertifyVex) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertifyVexMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertifyVexMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CertifyVex, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertifyVexMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertifyVexMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CertifyVex).
func (m *CertifyVexMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertifyVexMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m._package != nil {
		fields = append(fields, certifyvex.FieldPackageID)
	}
	if m.artifact != nil {
		fields = append(fields, certifyvex.FieldArtifactID)
	}
	if m.vulnerability != nil {
		fields = append(fields, certifyvex.FieldVulnerabilityID)
	}
	if m.known_since != nil {
		fields = append(fields, certifyvex.FieldKnownSince)
	}
	if m.status != nil {
		fields = append(fields, certifyvex.FieldStatus)
	}
	if m.statement != nil {
		fields = append(fields, certifyvex.FieldStatement)
	}
	if m.status_notes != nil {
		fields = append(fields, certifyvex.FieldStatusNotes)
	}
	if m.justification != nil {
		fields = append(fields, certifyvex.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, certifyvex.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, certifyvex.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, certifyvex.FieldDocumentRef)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertifyVexMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certifyvex.FieldPackageID:
		return m.PackageID()
	case certifyvex.FieldArtifactID:
		return m.ArtifactID()
	case certifyvex.FieldVulnerabilityID:
		return m.VulnerabilityID()
	case certifyvex.FieldKnownSince:
		return m.KnownSince()
	case certifyvex.FieldStatus:
		return m.Status()
	case certifyvex.FieldStatement:
		return m.Statement()
	case certifyvex.FieldStatusNotes:
		return m.StatusNotes()
	case certifyvex.FieldJustification:
		return m.Justification()
	case certifyvex.FieldOrigin:
		return m.Origin()
	case certifyvex.FieldCollector:
		return m.Collector()
	case certifyvex.FieldDocumentRef:
		return m.DocumentRef()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertifyVexMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certifyvex.FieldPackageID:
		return m.OldPackageID(ctx)
	case certifyvex.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case certifyvex.FieldVulnerabilityID:
		return m.OldVulnerabilityID(ctx)
	case certifyvex.FieldKnownSince:
		return m.OldKnownSince(ctx)
	case certifyvex.FieldStatus:
		return m.OldStatus(ctx)
	case certifyvex.FieldStatement:
		return m.OldStatement(ctx)
	case certifyvex.FieldStatusNotes:
		return m.OldStatusNotes(ctx)
	case certifyvex.FieldJustification:
		return m.OldJustification(ctx)
	case certifyvex.FieldOrigin:
		return m.OldOrigin(ctx)
	case certifyvex.FieldCollector:
		return m.OldCollector(ctx)
	case certifyvex.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	}
	return nil, fmt.Errorf("unknown CertifyVex field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyVexMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certifyvex.FieldPackageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case certifyvex.FieldArtifactID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case certifyvex.FieldVulnerabilityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnerabilityID(v)
		return nil
	case certifyvex.FieldKnownSince:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnownSince(v)
		return nil
	case certifyvex.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case certifyvex.FieldStatement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatement(v)
		return nil
	case certifyvex.FieldStatusNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusNotes(v)
		return nil
	case certifyvex.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case certifyvex.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case certifyvex.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case certifyvex.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	}
	return fmt.Errorf("unknown CertifyVex field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertifyVexMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertifyVexMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyVexMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CertifyVex numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertifyVexMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certifyvex.FieldPackageID) {
		fields = append(fields, certifyvex.FieldPackageID)
	}
	if m.FieldCleared(certifyvex.FieldArtifactID) {
		fields = append(fields, certifyvex.FieldArtifactID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertifyVexMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertifyVexMutation) ClearField(name string) error {
	switch name {
	case certifyvex.FieldPackageID:
		m.ClearPackageID()
		return nil
	case certifyvex.FieldArtifactID:
		m.ClearArtifactID()
		return nil
	}
	return fmt.Errorf("unknown CertifyVex nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertifyVexMutation) ResetField(name string) error {
	switch name {
	case certifyvex.FieldPackageID:
		m.ResetPackageID()
		return nil
	case certifyvex.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case certifyvex.FieldVulnerabilityID:
		m.ResetVulnerabilityID()
		return nil
	case certifyvex.FieldKnownSince:
		m.ResetKnownSince()
		return nil
	case certifyvex.FieldStatus:
		m.ResetStatus()
		return nil
	case certifyvex.FieldStatement:
		m.ResetStatement()
		return nil
	case certifyvex.FieldStatusNotes:
		m.ResetStatusNotes()
		return nil
	case certifyvex.FieldJustification:
		m.ResetJustification()
		return nil
	case certifyvex.FieldOrigin:
		m.ResetOrigin()
		return nil
	case certifyvex.FieldCollector:
		m.ResetCollector()
		return nil
	case certifyvex.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	}
	return fmt.Errorf("unknown CertifyVex field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertifyVexMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._package != nil {
		edges = append(edges, certifyvex.EdgePackage)
	}
	if m.artifact != nil {
		edges = append(edges, certifyvex.EdgeArtifact)
	}
	if m.vulnerability != nil {
		edges = append(edges, certifyvex.EdgeVulnerability)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertifyVexMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certifyvex.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case certifyvex.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	case certifyvex.EdgeVulnerability:
		if id := m.vulnerability; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertifyVexMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertifyVexMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertifyVexMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_package {
		edges = append(edges, certifyvex.EdgePackage)
	}
	if m.clearedartifact {
		edges = append(edges, certifyvex.EdgeArtifact)
	}
	if m.clearedvulnerability {
		edges = append(edges, certifyvex.EdgeVulnerability)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertifyVexMutation) EdgeCleared(name string) bool {
	switch name {
	case certifyvex.EdgePackage:
		return m.cleared_package
	case certifyvex.EdgeArtifact:
		return m.clearedartifact
	case certifyvex.EdgeVulnerability:
		return m.clearedvulnerability
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertifyVexMutation) ClearEdge(name string) error {
	switch name {
	case certifyvex.EdgePackage:
		m.ClearPackage()
		return nil
	case certifyvex.EdgeArtifact:
		m.ClearArtifact()
		return nil
	case certifyvex.EdgeVulnerability:
		m.ClearVulnerability()
		return nil
	}
	return fmt.Errorf("unknown CertifyVex unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertifyVexMutation) ResetEdge(name string) error {
	switch name {
	case certifyvex.EdgePackage:
		m.ResetPackage()
		return nil
	case certifyvex.EdgeArtifact:
		m.ResetArtifact()
		return nil
	case certifyvex.EdgeVulnerability:
		m.ResetVulnerability()
		return nil
	}
	return fmt.Errorf("unknown CertifyVex edge %s", name)
}

// CertifyVulnMutation represents an operation that mutates the CertifyVuln nodes in the graph.
type CertifyVulnMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	time_scanned         *time.Time
	db_uri               *string
	db_version           *string
	scanner_uri          *string
	scanner_version      *string
	origin               *string
	collector            *string
	document_ref         *string
	clearedFields        map[string]struct{}
	vulnerability        *uuid.UUID
	clearedvulnerability bool
	_package             *uuid.UUID
	cleared_package      bool
	done                 bool
	oldValue             func(context.Context) (*CertifyVuln, error)
	predicates           []predicate.CertifyVuln
}

var _ ent.Mutation = (*CertifyVulnMutation)(nil)

// certifyvulnOption allows management of the mutation configuration using functional options.
type certifyvulnOption func(*CertifyVulnMutation)

// newCertifyVulnMutation creates new mutation for the CertifyVuln entity.
func newCertifyVulnMutation(c config, op Op, opts ...certifyvulnOption) *CertifyVulnMutation {
	m := &CertifyVulnMutation{
		config:        c,
		op:            op,
		typ:           TypeCertifyVuln,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertifyVulnID sets the ID field of the mutation.
func withCertifyVulnID(id uuid.UUID) certifyvulnOption {
	return func(m *CertifyVulnMutation) {
		var (
			err   error
			once  sync.Once
			value *CertifyVuln
		)
		m.oldValue = func(ctx context.Context) (*CertifyVuln, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertifyVuln.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertifyVuln sets the old CertifyVuln of the mutation.
func withCertifyVuln(node *CertifyVuln) certifyvulnOption {
	return func(m *CertifyVulnMutation) {
		m.oldValue = func(context.Context) (*CertifyVuln, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertifyVulnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertifyVulnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CertifyVuln entities.
func (m *CertifyVulnMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertifyVulnMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertifyVulnMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertifyVuln.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVulnerabilityID sets the "vulnerability_id" field.
func (m *CertifyVulnMutation) SetVulnerabilityID(u uuid.UUID) {
	m.vulnerability = &u
}

// VulnerabilityID returns the value of the "vulnerability_id" field in the mutation.
func (m *CertifyVulnMutation) VulnerabilityID() (r uuid.UUID, exists bool) {
	v := m.vulnerability
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnerabilityID returns the old "vulnerability_id" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldVulnerabilityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVulnerabilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVulnerabilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnerabilityID: %w", err)
	}
	return oldValue.VulnerabilityID, nil
}

// ResetVulnerabilityID resets all changes to the "vulnerability_id" field.
func (m *CertifyVulnMutation) ResetVulnerabilityID() {
	m.vulnerability = nil
}

// SetPackageID sets the "package_id" field.
func (m *CertifyVulnMutation) SetPackageID(u uuid.UUID) {
	m._package = &u
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *CertifyVulnMutation) PackageID() (r uuid.UUID, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldPackageID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *CertifyVulnMutation) ResetPackageID() {
	m._package = nil
}

// SetTimeScanned sets the "time_scanned" field.
func (m *CertifyVulnMutation) SetTimeScanned(t time.Time) {
	m.time_scanned = &t
}

// TimeScanned returns the value of the "time_scanned" field in the mutation.
func (m *CertifyVulnMutation) TimeScanned() (r time.Time, exists bool) {
	v := m.time_scanned
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeScanned returns the old "time_scanned" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldTimeScanned(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeScanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeScanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeScanned: %w", err)
	}
	return oldValue.TimeScanned, nil
}

// ResetTimeScanned resets all changes to the "time_scanned" field.
func (m *CertifyVulnMutation) ResetTimeScanned() {
	m.time_scanned = nil
}

// SetDbURI sets the "db_uri" field.
func (m *CertifyVulnMutation) SetDbURI(s string) {
	m.db_uri = &s
}

// DbURI returns the value of the "db_uri" field in the mutation.
func (m *CertifyVulnMutation) DbURI() (r string, exists bool) {
	v := m.db_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldDbURI returns the old "db_uri" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldDbURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDbURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDbURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDbURI: %w", err)
	}
	return oldValue.DbURI, nil
}

// ResetDbURI resets all changes to the "db_uri" field.
func (m *CertifyVulnMutation) ResetDbURI() {
	m.db_uri = nil
}

// SetDbVersion sets the "db_version" field.
func (m *CertifyVulnMutation) SetDbVersion(s string) {
	m.db_version = &s
}

// DbVersion returns the value of the "db_version" field in the mutation.
func (m *CertifyVulnMutation) DbVersion() (r string, exists bool) {
	v := m.db_version
	if v == nil {
		return
	}
	return *v, true
}

// OldDbVersion returns the old "db_version" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldDbVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDbVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDbVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDbVersion: %w", err)
	}
	return oldValue.DbVersion, nil
}

// ResetDbVersion resets all changes to the "db_version" field.
func (m *CertifyVulnMutation) ResetDbVersion() {
	m.db_version = nil
}

// SetScannerURI sets the "scanner_uri" field.
func (m *CertifyVulnMutation) SetScannerURI(s string) {
	m.scanner_uri = &s
}

// ScannerURI returns the value of the "scanner_uri" field in the mutation.
func (m *CertifyVulnMutation) ScannerURI() (r string, exists bool) {
	v := m.scanner_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldScannerURI returns the old "scanner_uri" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldScannerURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScannerURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScannerURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScannerURI: %w", err)
	}
	return oldValue.ScannerURI, nil
}

// ResetScannerURI resets all changes to the "scanner_uri" field.
func (m *CertifyVulnMutation) ResetScannerURI() {
	m.scanner_uri = nil
}

// SetScannerVersion sets the "scanner_version" field.
func (m *CertifyVulnMutation) SetScannerVersion(s string) {
	m.scanner_version = &s
}

// ScannerVersion returns the value of the "scanner_version" field in the mutation.
func (m *CertifyVulnMutation) ScannerVersion() (r string, exists bool) {
	v := m.scanner_version
	if v == nil {
		return
	}
	return *v, true
}

// OldScannerVersion returns the old "scanner_version" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldScannerVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScannerVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScannerVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScannerVersion: %w", err)
	}
	return oldValue.ScannerVersion, nil
}

// ResetScannerVersion resets all changes to the "scanner_version" field.
func (m *CertifyVulnMutation) ResetScannerVersion() {
	m.scanner_version = nil
}

// SetOrigin sets the "origin" field.
func (m *CertifyVulnMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *CertifyVulnMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *CertifyVulnMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *CertifyVulnMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *CertifyVulnMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *CertifyVulnMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *CertifyVulnMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *CertifyVulnMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *CertifyVulnMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// ClearVulnerability clears the "vulnerability" edge to the VulnerabilityID entity.
func (m *CertifyVulnMutation) ClearVulnerability() {
	m.clearedvulnerability = true
	m.clearedFields[certifyvuln.FieldVulnerabilityID] = struct{}{}
}

// VulnerabilityCleared reports if the "vulnerability" edge to the VulnerabilityID entity was cleared.
func (m *CertifyVulnMutation) VulnerabilityCleared() bool {
	return m.clearedvulnerability
}

// VulnerabilityIDs returns the "vulnerability" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityID instead. It exists only for internal usage by the builders.
func (m *CertifyVulnMutation) VulnerabilityIDs() (ids []uuid.UUID) {
	if id := m.vulnerability; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerability resets all changes to the "vulnerability" edge.
func (m *CertifyVulnMutation) ResetVulnerability() {
	m.vulnerability = nil
	m.clearedvulnerability = false
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *CertifyVulnMutation) ClearPackage() {
	m.cleared_package = true
	m.clearedFields[certifyvuln.FieldPackageID] = struct{}{}
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *CertifyVulnMutation) PackageCleared() bool {
	return m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *CertifyVulnMutation) PackageIDs() (ids []uuid.UUID) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *CertifyVulnMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// Where appends a list predicates to the CertifyVulnMutation builder.
func (m *CertifyVulnMutation) Where(ps ...predicate.CertifyVuln) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertifyVulnMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertifyVulnMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CertifyVuln, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertifyVulnMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertifyVulnMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CertifyVuln).
func (m *CertifyVulnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertifyVulnMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.vulnerability != nil {
		fields = append(fields, certifyvuln.FieldVulnerabilityID)
	}
	if m._package != nil {
		fields = append(fields, certifyvuln.FieldPackageID)
	}
	if m.time_scanned != nil {
		fields = append(fields, certifyvuln.FieldTimeScanned)
	}
	if m.db_uri != nil {
		fields = append(fields, certifyvuln.FieldDbURI)
	}
	if m.db_version != nil {
		fields = append(fields, certifyvuln.FieldDbVersion)
	}
	if m.scanner_uri != nil {
		fields = append(fields, certifyvuln.FieldScannerURI)
	}
	if m.scanner_version != nil {
		fields = append(fields, certifyvuln.FieldScannerVersion)
	}
	if m.origin != nil {
		fields = append(fields, certifyvuln.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, certifyvuln.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, certifyvuln.FieldDocumentRef)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertifyVulnMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certifyvuln.FieldVulnerabilityID:
		return m.VulnerabilityID()
	case certifyvuln.FieldPackageID:
		return m.PackageID()
	case certifyvuln.FieldTimeScanned:
		return m.TimeScanned()
	case certifyvuln.FieldDbURI:
		return m.DbURI()
	case certifyvuln.FieldDbVersion:
		return m.DbVersion()
	case certifyvuln.FieldScannerURI:
		return m.ScannerURI()
	case certifyvuln.FieldScannerVersion:
		return m.ScannerVersion()
	case certifyvuln.FieldOrigin:
		return m.Origin()
	case certifyvuln.FieldCollector:
		return m.Collector()
	case certifyvuln.FieldDocumentRef:
		return m.DocumentRef()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertifyVulnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certifyvuln.FieldVulnerabilityID:
		return m.OldVulnerabilityID(ctx)
	case certifyvuln.FieldPackageID:
		return m.OldPackageID(ctx)
	case certifyvuln.FieldTimeScanned:
		return m.OldTimeScanned(ctx)
	case certifyvuln.FieldDbURI:
		return m.OldDbURI(ctx)
	case certifyvuln.FieldDbVersion:
		return m.OldDbVersion(ctx)
	case certifyvuln.FieldScannerURI:
		return m.OldScannerURI(ctx)
	case certifyvuln.FieldScannerVersion:
		return m.OldScannerVersion(ctx)
	case certifyvuln.FieldOrigin:
		return m.OldOrigin(ctx)
	case certifyvuln.FieldCollector:
		return m.OldCollector(ctx)
	case certifyvuln.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	}
	return nil, fmt.Errorf("unknown CertifyVuln field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyVulnMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certifyvuln.FieldVulnerabilityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnerabilityID(v)
		return nil
	case certifyvuln.FieldPackageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case certifyvuln.FieldTimeScanned:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeScanned(v)
		return nil
	case certifyvuln.FieldDbURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDbURI(v)
		return nil
	case certifyvuln.FieldDbVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDbVersion(v)
		return nil
	case certifyvuln.FieldScannerURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScannerURI(v)
		return nil
	case certifyvuln.FieldScannerVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScannerVersion(v)
		return nil
	case certifyvuln.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case certifyvuln.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case certifyvuln.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	}
	return fmt.Errorf("unknown CertifyVuln field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertifyVulnMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertifyVulnMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyVulnMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CertifyVuln numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertifyVulnMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertifyVulnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertifyVulnMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CertifyVuln nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertifyVulnMutation) ResetField(name string) error {
	switch name {
	case certifyvuln.FieldVulnerabilityID:
		m.ResetVulnerabilityID()
		return nil
	case certifyvuln.FieldPackageID:
		m.ResetPackageID()
		return nil
	case certifyvuln.FieldTimeScanned:
		m.ResetTimeScanned()
		return nil
	case certifyvuln.FieldDbURI:
		m.ResetDbURI()
		return nil
	case certifyvuln.FieldDbVersion:
		m.ResetDbVersion()
		return nil
	case certifyvuln.FieldScannerURI:
		m.ResetScannerURI()
		return nil
	case certifyvuln.FieldScannerVersion:
		m.ResetScannerVersion()
		return nil
	case certifyvuln.FieldOrigin:
		m.ResetOrigin()
		return nil
	case certifyvuln.FieldCollector:
		m.ResetCollector()
		return nil
	case certifyvuln.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	}
	return fmt.Errorf("unknown CertifyVuln field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertifyVulnMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.vulnerability != nil {
		edges = append(edges, certifyvuln.EdgeVulnerability)
	}
	if m._package != nil {
		edges = append(edges, certifyvuln.EdgePackage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertifyVulnMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certifyvuln.EdgeVulnerability:
		if id := m.vulnerability; id != nil {
			return []ent.Value{*id}
		}
	case certifyvuln.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertifyVulnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertifyVulnMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertifyVulnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvulnerability {
		edges = append(edges, certifyvuln.EdgeVulnerability)
	}
	if m.cleared_package {
		edges = append(edges, certifyvuln.EdgePackage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertifyVulnMutation) EdgeCleared(name string) bool {
	switch name {
	case certifyvuln.EdgeVulnerability:
		return m.clearedvulnerability
	case certifyvuln.EdgePackage:
		return m.cleared_package
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertifyVulnMutation) ClearEdge(name string) error {
	switch name {
	case certifyvuln.EdgeVulnerability:
		m.ClearVulnerability()
		return nil
	case certifyvuln.EdgePackage:
		m.ClearPackage()
		return nil
	}
	return fmt.Errorf("unknown CertifyVuln unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertifyVulnMutation) ResetEdge(name string) error {
	switch name {
	case certifyvuln.EdgeVulnerability:
		m.ResetVulnerability()
		return nil
	case certifyvuln.EdgePackage:
		m.ResetPackage()
		return nil
	}
	return fmt.Errorf("unknown CertifyVuln edge %s", name)
}

// DependencyMutation represents an operation that mutates the Dependency nodes in the graph.
type DependencyMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	dependency_type                  *dependency.DependencyType
	justification                    *string
	origin                           *string
	collector                        *string
	document_ref                     *string
	clearedFields                    map[string]struct{}
	_package                         *uuid.UUID
	cleared_package                  bool
	dependent_package_version        *uuid.UUID
	cleareddependent_package_version bool
	included_in_sboms                map[uuid.UUID]struct{}
	removedincluded_in_sboms         map[uuid.UUID]struct{}
	clearedincluded_in_sboms         bool
	done                             bool
	oldValue                         func(context.Context) (*Dependency, error)
	predicates                       []predicate.Dependency
}

var _ ent.Mutation = (*DependencyMutation)(nil)

// dependencyOption allows management of the mutation configuration using functional options.
type dependencyOption func(*DependencyMutation)

// newDependencyMutation creates new mutation for the Dependency entity.
func newDependencyMutation(c config, op Op, opts ...dependencyOption) *DependencyMutation {
	m := &DependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDependencyID sets the ID field of the mutation.
func withDependencyID(id uuid.UUID) dependencyOption {
	return func(m *DependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Dependency
		)
		m.oldValue = func(ctx context.Context) (*Dependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDependency sets the old Dependency of the mutation.
func withDependency(node *Dependency) dependencyOption {
	return func(m *DependencyMutation) {
		m.oldValue = func(context.Context) (*Dependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dependency entities.
func (m *DependencyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DependencyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DependencyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *DependencyMutation) SetPackageID(u uuid.UUID) {
	m._package = &u
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *DependencyMutation) PackageID() (r uuid.UUID, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldPackageID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *DependencyMutation) ResetPackageID() {
	m._package = nil
}

// SetDependentPackageVersionID sets the "dependent_package_version_id" field.
func (m *DependencyMutation) SetDependentPackageVersionID(u uuid.UUID) {
	m.dependent_package_version = &u
}

// DependentPackageVersionID returns the value of the "dependent_package_version_id" field in the mutation.
func (m *DependencyMutation) DependentPackageVersionID() (r uuid.UUID, exists bool) {
	v := m.dependent_package_version
	if v == nil {
		return
	}
	return *v, true
}

// OldDependentPackageVersionID returns the old "dependent_package_version_id" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldDependentPackageVersionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependentPackageVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependentPackageVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependentPackageVersionID: %w", err)
	}
	return oldValue.DependentPackageVersionID, nil
}

// ResetDependentPackageVersionID resets all changes to the "dependent_package_version_id" field.
func (m *DependencyMutation) ResetDependentPackageVersionID() {
	m.dependent_package_version = nil
}

// SetDependencyType sets the "dependency_type" field.
func (m *DependencyMutation) SetDependencyType(dt dependency.DependencyType) {
	m.dependency_type = &dt
}

// DependencyType returns the value of the "dependency_type" field in the mutation.
func (m *DependencyMutation) DependencyType() (r dependency.DependencyType, exists bool) {
	v := m.dependency_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyType returns the old "dependency_type" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldDependencyType(ctx context.Context) (v dependency.DependencyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyType: %w", err)
	}
	return oldValue.DependencyType, nil
}

// ResetDependencyType resets all changes to the "dependency_type" field.
func (m *DependencyMutation) ResetDependencyType() {
	m.dependency_type = nil
}

// SetJustification sets the "justification" field.
func (m *DependencyMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *DependencyMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *DependencyMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *DependencyMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *DependencyMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *DependencyMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *DependencyMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *DependencyMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *DependencyMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *DependencyMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *DependencyMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *DependencyMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *DependencyMutation) ClearPackage() {
	m.cleared_package = true
	m.clearedFields[dependency.FieldPackageID] = struct{}{}
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *DependencyMutation) PackageCleared() bool {
	return m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *DependencyMutation) PackageIDs() (ids []uuid.UUID) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *DependencyMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearDependentPackageVersion clears the "dependent_package_version" edge to the PackageVersion entity.
func (m *DependencyMutation) ClearDependentPackageVersion() {
	m.cleareddependent_package_version = true
	m.clearedFields[dependency.FieldDependentPackageVersionID] = struct{}{}
}

// DependentPackageVersionCleared reports if the "dependent_package_version" edge to the PackageVersion entity was cleared.
func (m *DependencyMutation) DependentPackageVersionCleared() bool {
	return m.cleareddependent_package_version
}

// DependentPackageVersionIDs returns the "dependent_package_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DependentPackageVersionID instead. It exists only for internal usage by the builders.
func (m *DependencyMutation) DependentPackageVersionIDs() (ids []uuid.UUID) {
	if id := m.dependent_package_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDependentPackageVersion resets all changes to the "dependent_package_version" edge.
func (m *DependencyMutation) ResetDependentPackageVersion() {
	m.dependent_package_version = nil
	m.cleareddependent_package_version = false
}

// AddIncludedInSbomIDs adds the "included_in_sboms" edge to the BillOfMaterials entity by ids.
func (m *DependencyMutation) AddIncludedInSbomIDs(ids ...uuid.UUID) {
	if m.included_in_sboms == nil {
		m.included_in_sboms = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.included_in_sboms[ids[i]] = struct{}{}
	}
}

// ClearIncludedInSboms clears the "included_in_sboms" edge to the BillOfMaterials entity.
func (m *DependencyMutation) ClearIncludedInSboms() {
	m.clearedincluded_in_sboms = true
}

// IncludedInSbomsCleared reports if the "included_in_sboms" edge to the BillOfMaterials entity was cleared.
func (m *DependencyMutation) IncludedInSbomsCleared() bool {
	return m.clearedincluded_in_sboms
}

// RemoveIncludedInSbomIDs removes the "included_in_sboms" edge to the BillOfMaterials entity by IDs.
func (m *DependencyMutation) RemoveIncludedInSbomIDs(ids ...uuid.UUID) {
	if m.removedincluded_in_sboms == nil {
		m.removedincluded_in_sboms = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.included_in_sboms, ids[i])
		m.removedincluded_in_sboms[ids[i]] = struct{}{}
	}
}

// RemovedIncludedInSboms returns the removed IDs of the "included_in_sboms" edge to the BillOfMaterials entity.
func (m *DependencyMutation) RemovedIncludedInSbomsIDs() (ids []uuid.UUID) {
	for id := range m.removedincluded_in_sboms {
		ids = append(ids, id)
	}
	return
}

// IncludedInSbomsIDs returns the "included_in_sboms" edge IDs in the mutation.
func (m *DependencyMutation) IncludedInSbomsIDs() (ids []uuid.UUID) {
	for id := range m.included_in_sboms {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedInSboms resets all changes to the "included_in_sboms" edge.
func (m *DependencyMutation) ResetIncludedInSboms() {
	m.included_in_sboms = nil
	m.clearedincluded_in_sboms = false
	m.removedincluded_in_sboms = nil
}

// Where appends a list predicates to the DependencyMutation builder.
func (m *DependencyMutation) Where(ps ...predicate.Dependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dependency).
func (m *DependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DependencyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._package != nil {
		fields = append(fields, dependency.FieldPackageID)
	}
	if m.dependent_package_version != nil {
		fields = append(fields, dependency.FieldDependentPackageVersionID)
	}
	if m.dependency_type != nil {
		fields = append(fields, dependency.FieldDependencyType)
	}
	if m.justification != nil {
		fields = append(fields, dependency.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, dependency.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, dependency.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, dependency.FieldDocumentRef)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dependency.FieldPackageID:
		return m.PackageID()
	case dependency.FieldDependentPackageVersionID:
		return m.DependentPackageVersionID()
	case dependency.FieldDependencyType:
		return m.DependencyType()
	case dependency.FieldJustification:
		return m.Justification()
	case dependency.FieldOrigin:
		return m.Origin()
	case dependency.FieldCollector:
		return m.Collector()
	case dependency.FieldDocumentRef:
		return m.DocumentRef()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dependency.FieldPackageID:
		return m.OldPackageID(ctx)
	case dependency.FieldDependentPackageVersionID:
		return m.OldDependentPackageVersionID(ctx)
	case dependency.FieldDependencyType:
		return m.OldDependencyType(ctx)
	case dependency.FieldJustification:
		return m.OldJustification(ctx)
	case dependency.FieldOrigin:
		return m.OldOrigin(ctx)
	case dependency.FieldCollector:
		return m.OldCollector(ctx)
	case dependency.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	}
	return nil, fmt.Errorf("unknown Dependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dependency.FieldPackageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case dependency.FieldDependentPackageVersionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependentPackageVersionID(v)
		return nil
	case dependency.FieldDependencyType:
		v, ok := value.(dependency.DependencyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyType(v)
		return nil
	case dependency.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case dependency.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case dependency.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case dependency.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	}
	return fmt.Errorf("unknown Dependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DependencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DependencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Dependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DependencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DependencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Dependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DependencyMutation) ResetField(name string) error {
	switch name {
	case dependency.FieldPackageID:
		m.ResetPackageID()
		return nil
	case dependency.FieldDependentPackageVersionID:
		m.ResetDependentPackageVersionID()
		return nil
	case dependency.FieldDependencyType:
		m.ResetDependencyType()
		return nil
	case dependency.FieldJustification:
		m.ResetJustification()
		return nil
	case dependency.FieldOrigin:
		m.ResetOrigin()
		return nil
	case dependency.FieldCollector:
		m.ResetCollector()
		return nil
	case dependency.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	}
	return fmt.Errorf("unknown Dependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._package != nil {
		edges = append(edges, dependency.EdgePackage)
	}
	if m.dependent_package_version != nil {
		edges = append(edges, dependency.EdgeDependentPackageVersion)
	}
	if m.included_in_sboms != nil {
		edges = append(edges, dependency.EdgeIncludedInSboms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dependency.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case dependency.EdgeDependentPackageVersion:
		if id := m.dependent_package_version; id != nil {
			return []ent.Value{*id}
		}
	case dependency.EdgeIncludedInSboms:
		ids := make([]ent.Value, 0, len(m.included_in_sboms))
		for id := range m.included_in_sboms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedincluded_in_sboms != nil {
		edges = append(edges, dependency.EdgeIncludedInSboms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DependencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dependency.EdgeIncludedInSboms:
		ids := make([]ent.Value, 0, len(m.removedincluded_in_sboms))
		for id := range m.removedincluded_in_sboms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_package {
		edges = append(edges, dependency.EdgePackage)
	}
	if m.cleareddependent_package_version {
		edges = append(edges, dependency.EdgeDependentPackageVersion)
	}
	if m.clearedincluded_in_sboms {
		edges = append(edges, dependency.EdgeIncludedInSboms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case dependency.EdgePackage:
		return m.cleared_package
	case dependency.EdgeDependentPackageVersion:
		return m.cleareddependent_package_version
	case dependency.EdgeIncludedInSboms:
		return m.clearedincluded_in_sboms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DependencyMutation) ClearEdge(name string) error {
	switch name {
	case dependency.EdgePackage:
		m.ClearPackage()
		return nil
	case dependency.EdgeDependentPackageVersion:
		m.ClearDependentPackageVersion()
		return nil
	}
	return fmt.Errorf("unknown Dependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DependencyMutation) ResetEdge(name string) error {
	switch name {
	case dependency.EdgePackage:
		m.ResetPackage()
		return nil
	case dependency.EdgeDependentPackageVersion:
		m.ResetDependentPackageVersion()
		return nil
	case dependency.EdgeIncludedInSboms:
		m.ResetIncludedInSboms()
		return nil
	}
	return fmt.Errorf("unknown Dependency edge %s", name)
}

// HasMetadataMutation represents an operation that mutates the HasMetadata nodes in the graph.
type HasMetadataMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	timestamp              *time.Time
	key                    *string
	value                  *string
	justification          *string
	origin                 *string
	collector              *string
	document_ref           *string
	clearedFields          map[string]struct{}
	source                 *uuid.UUID
	clearedsource          bool
	package_version        *uuid.UUID
	clearedpackage_version bool
	all_versions           *uuid.UUID
	clearedall_versions    bool
	artifact               *uuid.UUID
	clearedartifact        bool
	done                   bool
	oldValue               func(context.Context) (*HasMetadata, error)
	predicates             []predicate.HasMetadata
}

var _ ent.Mutation = (*HasMetadataMutation)(nil)

// hasmetadataOption allows management of the mutation configuration using functional options.
type hasmetadataOption func(*HasMetadataMutation)

// newHasMetadataMutation creates new mutation for the HasMetadata entity.
func newHasMetadataMutation(c config, op Op, opts ...hasmetadataOption) *HasMetadataMutation {
	m := &HasMetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeHasMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHasMetadataID sets the ID field of the mutation.
func withHasMetadataID(id uuid.UUID) hasmetadataOption {
	return func(m *HasMetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *HasMetadata
		)
		m.oldValue = func(ctx context.Context) (*HasMetadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HasMetadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHasMetadata sets the old HasMetadata of the mutation.
func withHasMetadata(node *HasMetadata) hasmetadataOption {
	return func(m *HasMetadataMutation) {
		m.oldValue = func(context.Context) (*HasMetadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HasMetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HasMetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HasMetadata entities.
func (m *HasMetadataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HasMetadataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HasMetadataMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HasMetadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceID sets the "source_id" field.
func (m *HasMetadataMutation) SetSourceID(u uuid.UUID) {
	m.source = &u
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *HasMetadataMutation) SourceID() (r uuid.UUID, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the HasMetadata entity.
// If the HasMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasMetadataMutation) OldSourceID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *HasMetadataMutation) ClearSourceID() {
	m.source = nil
	m.clearedFields[hasmetadata.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *HasMetadataMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[hasmetadata.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *HasMetadataMutation) ResetSourceID() {
	m.source = nil
	delete(m.clearedFields, hasmetadata.FieldSourceID)
}

// SetPackageVersionID sets the "package_version_id" field.
func (m *HasMetadataMutation) SetPackageVersionID(u uuid.UUID) {
	m.package_version = &u
}

// PackageVersionID returns the value of the "package_version_id" field in the mutation.
func (m *HasMetadataMutation) PackageVersionID() (r uuid.UUID, exists bool) {
	v := m.package_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageVersionID returns the old "package_version_id" field's value of the HasMetadata entity.
// If the HasMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasMetadataMutation) OldPackageVersionID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageVersionID: %w", err)
	}
	return oldValue.PackageVersionID, nil
}

// ClearPackageVersionID clears the value of the "package_version_id" field.
func (m *HasMetadataMutation) ClearPackageVersionID() {
	m.package_version = nil
	m.clearedFields[hasmetadata.FieldPackageVersionID] = struct{}{}
}

// PackageVersionIDCleared returns if the "package_version_id" field was cleared in this mutation.
func (m *HasMetadataMutation) PackageVersionIDCleared() bool {
	_, ok := m.clearedFields[hasmetadata.FieldPackageVersionID]
	return ok
}

// ResetPackageVersionID resets all changes to the "package_version_id" field.
func (m *HasMetadataMutation) ResetPackageVersionID() {
	m.package_version = nil
	delete(m.clearedFields, hasmetadata.FieldPackageVersionID)
}

// SetPackageNameID sets the "package_name_id" field.
func (m *HasMetadataMutation) SetPackageNameID(u uuid.UUID) {
	m.all_versions = &u
}

// PackageNameID returns the value of the "package_name_id" field in the mutation.
func (m *HasMetadataMutation) PackageNameID() (r uuid.UUID, exists bool) {
	v := m.all_versions
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageNameID returns the old "package_name_id" field's value of the HasMetadata entity.
// If the HasMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasMetadataMutation) OldPackageNameID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageNameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageNameID: %w", err)
	}
	return oldValue.PackageNameID, nil
}

// ClearPackageNameID clears the value of the "package_name_id" field.
func (m *HasMetadataMutation) ClearPackageNameID() {
	m.all_versions = nil
	m.clearedFields[hasmetadata.FieldPackageNameID] = struct{}{}
}

// PackageNameIDCleared returns if the "package_name_id" field was cleared in this mutation.
func (m *HasMetadataMutation) PackageNameIDCleared() bool {
	_, ok := m.clearedFields[hasmetadata.FieldPackageNameID]
	return ok
}

// ResetPackageNameID resets all changes to the "package_name_id" field.
func (m *HasMetadataMutation) ResetPackageNameID() {
	m.all_versions = nil
	delete(m.clearedFields, hasmetadata.FieldPackageNameID)
}

// SetArtifactID sets the "artifact_id" field.
func (m *HasMetadataMutation) SetArtifactID(u uuid.UUID) {
	m.artifact = &u
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *HasMetadataMutation) ArtifactID() (r uuid.UUID, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the HasMetadata entity.
// If the HasMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasMetadataMutation) OldArtifactID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ClearArtifactID clears the value of the "artifact_id" field.
func (m *HasMetadataMutation) ClearArtifactID() {
	m.artifact = nil
	m.clearedFields[hasmetadata.FieldArtifactID] = struct{}{}
}

// ArtifactIDCleared returns if the "artifact_id" field was cleared in this mutation.
func (m *HasMetadataMutation) ArtifactIDCleared() bool {
	_, ok := m.clearedFields[hasmetadata.FieldArtifactID]
	return ok
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *HasMetadataMutation) ResetArtifactID() {
	m.artifact = nil
	delete(m.clearedFields, hasmetadata.FieldArtifactID)
}

// SetTimestamp sets the "timestamp" field.
func (m *HasMetadataMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *HasMetadataMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the HasMetadata entity.
// If the HasMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasMetadataMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *HasMetadataMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetKey sets the "key" field.
func (m *HasMetadataMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *HasMetadataMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the HasMetadata entity.
// If the HasMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasMetadataMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *HasMetadataMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *HasMetadataMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *HasMetadataMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the HasMetadata entity.
// If the HasMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasMetadataMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *HasMetadataMutation) ResetValue() {
	m.value = nil
}

// SetJustification sets the "justification" field.
func (m *HasMetadataMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *HasMetadataMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the HasMetadata entity.
// If the HasMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasMetadataMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *HasMetadataMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *HasMetadataMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *HasMetadataMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the HasMetadata entity.
// If the HasMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasMetadataMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *HasMetadataMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *HasMetadataMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *HasMetadataMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the HasMetadata entity.
// If the HasMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasMetadataMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *HasMetadataMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *HasMetadataMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *HasMetadataMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the HasMetadata entity.
// If the HasMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasMetadataMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *HasMetadataMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *HasMetadataMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[hasmetadata.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *HasMetadataMutation) SourceCleared() bool {
	return m.SourceIDCleared() || m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *HasMetadataMutation) SourceIDs() (ids []uuid.UUID) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *HasMetadataMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// ClearPackageVersion clears the "package_version" edge to the PackageVersion entity.
func (m *HasMetadataMutation) ClearPackageVersion() {
	m.clearedpackage_version = true
	m.clearedFields[hasmetadata.FieldPackageVersionID] = struct{}{}
}

// PackageVersionCleared reports if the "package_version" edge to the PackageVersion entity was cleared.
func (m *HasMetadataMutation) PackageVersionCleared() bool {
	return m.PackageVersionIDCleared() || m.clearedpackage_version
}

// PackageVersionIDs returns the "package_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageVersionID instead. It exists only for internal usage by the builders.
func (m *HasMetadataMutation) PackageVersionIDs() (ids []uuid.UUID) {
	if id := m.package_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackageVersion resets all changes to the "package_version" edge.
func (m *HasMetadataMutation) ResetPackageVersion() {
	m.package_version = nil
	m.clearedpackage_version = false
}

// SetAllVersionsID sets the "all_versions" edge to the PackageName entity by id.
func (m *HasMetadataMutation) SetAllVersionsID(id uuid.UUID) {
	m.all_versions = &id
}

// ClearAllVersions clears the "all_versions" edge to the PackageName entity.
func (m *HasMetadataMutation) ClearAllVersions() {
	m.clearedall_versions = true
	m.clearedFields[hasmetadata.FieldPackageNameID] = struct{}{}
}

// AllVersionsCleared reports if the "all_versions" edge to the PackageName entity was cleared.
func (m *HasMetadataMutation) AllVersionsCleared() bool {
	return m.PackageNameIDCleared() || m.clearedall_versions
}

// AllVersionsID returns the "all_versions" edge ID in the mutation.
func (m *HasMetadataMutation) AllVersionsID() (id uuid.UUID, exists bool) {
	if m.all_versions != nil {
		return *m.all_versions, true
	}
	return
}

// AllVersionsIDs returns the "all_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AllVersionsID instead. It exists only for internal usage by the builders.
func (m *HasMetadataMutation) AllVersionsIDs() (ids []uuid.UUID) {
	if id := m.all_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAllVersions resets all changes to the "all_versions" edge.
func (m *HasMetadataMutation) ResetAllVersions() {
	m.all_versions = nil
	m.clearedall_versions = false
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *HasMetadataMutation) ClearArtifact() {
	m.clearedartifact = true
	m.clearedFields[hasmetadata.FieldArtifactID] = struct{}{}
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *HasMetadataMutation) ArtifactCleared() bool {
	return m.ArtifactIDCleared() || m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *HasMetadataMutation) ArtifactIDs() (ids []uuid.UUID) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *HasMetadataMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// Where appends a list predicates to the HasMetadataMutation builder.
func (m *HasMetadataMutation) Where(ps ...predicate.HasMetadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HasMetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HasMetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HasMetadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HasMetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HasMetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HasMetadata).
func (m *HasMetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HasMetadataMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.source != nil {
		fields = append(fields, hasmetadata.FieldSourceID)
	}
	if m.package_version != nil {
		fields = append(fields, hasmetadata.FieldPackageVersionID)
	}
	if m.all_versions != nil {
		fields = append(fields, hasmetadata.FieldPackageNameID)
	}
	if m.artifact != nil {
		fields = append(fields, hasmetadata.FieldArtifactID)
	}
	if m.timestamp != nil {
		fields = append(fields, hasmetadata.FieldTimestamp)
	}
	if m.key != nil {
		fields = append(fields, hasmetadata.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, hasmetadata.FieldValue)
	}
	if m.justification != nil {
		fields = append(fields, hasmetadata.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, hasmetadata.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, hasmetadata.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, hasmetadata.FieldDocumentRef)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HasMetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hasmetadata.FieldSourceID:
		return m.SourceID()
	case hasmetadata.FieldPackageVersionID:
		return m.PackageVersionID()
	case hasmetadata.FieldPackageNameID:
		return m.PackageNameID()
	case hasmetadata.FieldArtifactID:
		return m.ArtifactID()
	case hasmetadata.FieldTimestamp:
		return m.Timestamp()
	case hasmetadata.FieldKey:
		return m.Key()
	case hasmetadata.FieldValue:
		return m.Value()
	case hasmetadata.FieldJustification:
		return m.Justification()
	case hasmetadata.FieldOrigin:
		return m.Origin()
	case hasmetadata.FieldCollector:
		return m.Collector()
	case hasmetadata.FieldDocumentRef:
		return m.DocumentRef()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HasMetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hasmetadata.FieldSourceID:
		return m.OldSourceID(ctx)
	case hasmetadata.FieldPackageVersionID:
		return m.OldPackageVersionID(ctx)
	case hasmetadata.FieldPackageNameID:
		return m.OldPackageNameID(ctx)
	case hasmetadata.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case hasmetadata.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case hasmetadata.FieldKey:
		return m.OldKey(ctx)
	case hasmetadata.FieldValue:
		return m.OldValue(ctx)
	case hasmetadata.FieldJustification:
		return m.OldJustification(ctx)
	case hasmetadata.FieldOrigin:
		return m.OldOrigin(ctx)
	case hasmetadata.FieldCollector:
		return m.OldCollector(ctx)
	case hasmetadata.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	}
	return nil, fmt.Errorf("unknown HasMetadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HasMetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hasmetadata.FieldSourceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case hasmetadata.FieldPackageVersionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageVersionID(v)
		return nil
	case hasmetadata.FieldPackageNameID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageNameID(v)
		return nil
	case hasmetadata.FieldArtifactID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case hasmetadata.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case hasmetadata.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case hasmetadata.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case hasmetadata.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case hasmetadata.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case hasmetadata.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case hasmetadata.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	}
	return fmt.Errorf("unknown HasMetadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HasMetadataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HasMetadataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HasMetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HasMetadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HasMetadataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hasmetadata.FieldSourceID) {
		fields = append(fields, hasmetadata.FieldSourceID)
	}
	if m.FieldCleared(hasmetadata.FieldPackageVersionID) {
		fields = append(fields, hasmetadata.FieldPackageVersionID)
	}
	if m.FieldCleared(hasmetadata.FieldPackageNameID) {
		fields = append(fields, hasmetadata.FieldPackageNameID)
	}
	if m.FieldCleared(hasmetadata.FieldArtifactID) {
		fields = append(fields, hasmetadata.FieldArtifactID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HasMetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HasMetadataMutation) ClearField(name string) error {
	switch name {
	case hasmetadata.FieldSourceID:
		m.ClearSourceID()
		return nil
	case hasmetadata.FieldPackageVersionID:
		m.ClearPackageVersionID()
		return nil
	case hasmetadata.FieldPackageNameID:
		m.ClearPackageNameID()
		return nil
	case hasmetadata.FieldArtifactID:
		m.ClearArtifactID()
		return nil
	}
	return fmt.Errorf("unknown HasMetadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HasMetadataMutation) ResetField(name string) error {
	switch name {
	case hasmetadata.FieldSourceID:
		m.ResetSourceID()
		return nil
	case hasmetadata.FieldPackageVersionID:
		m.ResetPackageVersionID()
		return nil
	case hasmetadata.FieldPackageNameID:
		m.ResetPackageNameID()
		return nil
	case hasmetadata.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case hasmetadata.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case hasmetadata.FieldKey:
		m.ResetKey()
		return nil
	case hasmetadata.FieldValue:
		m.ResetValue()
		return nil
	case hasmetadata.FieldJustification:
		m.ResetJustification()
		return nil
	case hasmetadata.FieldOrigin:
		m.ResetOrigin()
		return nil
	case hasmetadata.FieldCollector:
		m.ResetCollector()
		return nil
	case hasmetadata.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	}
	return fmt.Errorf("unknown HasMetadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HasMetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.source != nil {
		edges = append(edges, hasmetadata.EdgeSource)
	}
	if m.package_version != nil {
		edges = append(edges, hasmetadata.EdgePackageVersion)
	}
	if m.all_versions != nil {
		edges = append(edges, hasmetadata.EdgeAllVersions)
	}
	if m.artifact != nil {
		edges = append(edges, hasmetadata.EdgeArtifact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HasMetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hasmetadata.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	case hasmetadata.EdgePackageVersion:
		if id := m.package_version; id != nil {
			return []ent.Value{*id}
		}
	case hasmetadata.EdgeAllVersions:
		if id := m.all_versions; id != nil {
			return []ent.Value{*id}
		}
	case hasmetadata.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HasMetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HasMetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HasMetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsource {
		edges = append(edges, hasmetadata.EdgeSource)
	}
	if m.clearedpackage_version {
		edges = append(edges, hasmetadata.EdgePackageVersion)
	}
	if m.clearedall_versions {
		edges = append(edges, hasmetadata.EdgeAllVersions)
	}
	if m.clearedartifact {
		edges = append(edges, hasmetadata.EdgeArtifact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HasMetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case hasmetadata.EdgeSource:
		return m.clearedsource
	case hasmetadata.EdgePackageVersion:
		return m.clearedpackage_version
	case hasmetadata.EdgeAllVersions:
		return m.clearedall_versions
	case hasmetadata.EdgeArtifact:
		return m.clearedartifact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HasMetadataMutation) ClearEdge(name string) error {
	switch name {
	case hasmetadata.EdgeSource:
		m.ClearSource()
		return nil
	case hasmetadata.EdgePackageVersion:
		m.ClearPackageVersion()
		return nil
	case hasmetadata.EdgeAllVersions:
		m.ClearAllVersions()
		return nil
	case hasmetadata.EdgeArtifact:
		m.ClearArtifact()
		return nil
	}
	return fmt.Errorf("unknown HasMetadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HasMetadataMutation) ResetEdge(name string) error {
	switch name {
	case hasmetadata.EdgeSource:
		m.ResetSource()
		return nil
	case hasmetadata.EdgePackageVersion:
		m.ResetPackageVersion()
		return nil
	case hasmetadata.EdgeAllVersions:
		m.ResetAllVersions()
		return nil
	case hasmetadata.EdgeArtifact:
		m.ResetArtifact()
		return nil
	}
	return fmt.Errorf("unknown HasMetadata edge %s", name)
}

// HasSourceAtMutation represents an operation that mutates the HasSourceAt nodes in the graph.
type HasSourceAtMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	known_since            *time.Time
	justification          *string
	origin                 *string
	collector              *string
	document_ref           *string
	clearedFields          map[string]struct{}
	package_version        *uuid.UUID
	clearedpackage_version bool
	all_versions           *uuid.UUID
	clearedall_versions    bool
	source                 *uuid.UUID
	clearedsource          bool
	done                   bool
	oldValue               func(context.Context) (*HasSourceAt, error)
	predicates             []predicate.HasSourceAt
}

var _ ent.Mutation = (*HasSourceAtMutation)(nil)

// hassourceatOption allows management of the mutation configuration using functional options.
type hassourceatOption func(*HasSourceAtMutation)

// newHasSourceAtMutation creates new mutation for the HasSourceAt entity.
func newHasSourceAtMutation(c config, op Op, opts ...hassourceatOption) *HasSourceAtMutation {
	m := &HasSourceAtMutation{
		config:        c,
		op:            op,
		typ:           TypeHasSourceAt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHasSourceAtID sets the ID field of the mutation.
func withHasSourceAtID(id uuid.UUID) hassourceatOption {
	return func(m *HasSourceAtMutation) {
		var (
			err   error
			once  sync.Once
			value *HasSourceAt
		)
		m.oldValue = func(ctx context.Context) (*HasSourceAt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HasSourceAt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHasSourceAt sets the old HasSourceAt of the mutation.
func withHasSourceAt(node *HasSourceAt) hassourceatOption {
	return func(m *HasSourceAtMutation) {
		m.oldValue = func(context.Context) (*HasSourceAt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HasSourceAtMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HasSourceAtMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HasSourceAt entities.
func (m *HasSourceAtMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HasSourceAtMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HasSourceAtMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HasSourceAt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageVersionID sets the "package_version_id" field.
func (m *HasSourceAtMutation) SetPackageVersionID(u uuid.UUID) {
	m.package_version = &u
}

// PackageVersionID returns the value of the "package_version_id" field in the mutation.
func (m *HasSourceAtMutation) PackageVersionID() (r uuid.UUID, exists bool) {
	v := m.package_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageVersionID returns the old "package_version_id" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldPackageVersionID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageVersionID: %w", err)
	}
	return oldValue.PackageVersionID, nil
}

// ClearPackageVersionID clears the value of the "package_version_id" field.
func (m *HasSourceAtMutation) ClearPackageVersionID() {
	m.package_version = nil
	m.clearedFields[hassourceat.FieldPackageVersionID] = struct{}{}
}

// PackageVersionIDCleared returns if the "package_version_id" field was cleared in this mutation.
func (m *HasSourceAtMutation) PackageVersionIDCleared() bool {
	_, ok := m.clearedFields[hassourceat.FieldPackageVersionID]
	return ok
}

// ResetPackageVersionID resets all changes to the "package_version_id" field.
func (m *HasSourceAtMutation) ResetPackageVersionID() {
	m.package_version = nil
	delete(m.clearedFields, hassourceat.FieldPackageVersionID)
}

// SetPackageNameID sets the "package_name_id" field.
func (m *HasSourceAtMutation) SetPackageNameID(u uuid.UUID) {
	m.all_versions = &u
}

// PackageNameID returns the value of the "package_name_id" field in the mutation.
func (m *HasSourceAtMutation) PackageNameID() (r uuid.UUID, exists bool) {
	v := m.all_versions
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageNameID returns the old "package_name_id" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldPackageNameID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageNameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageNameID: %w", err)
	}
	return oldValue.PackageNameID, nil
}

// ClearPackageNameID clears the value of the "package_name_id" field.
func (m *HasSourceAtMutation) ClearPackageNameID() {
	m.all_versions = nil
	m.clearedFields[hassourceat.FieldPackageNameID] = struct{}{}
}

// PackageNameIDCleared returns if the "package_name_id" field was cleared in this mutation.
func (m *HasSourceAtMutation) PackageNameIDCleared() bool {
	_, ok := m.clearedFields[hassourceat.FieldPackageNameID]
	return ok
}

// ResetPackageNameID resets all changes to the "package_name_id" field.
func (m *HasSourceAtMutation) ResetPackageNameID() {
	m.all_versions = nil
	delete(m.clearedFields, hassourceat.FieldPackageNameID)
}

// SetSourceID sets the "source_id" field.
func (m *HasSourceAtMutation) SetSourceID(u uuid.UUID) {
	m.source = &u
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *HasSourceAtMutation) SourceID() (r uuid.UUID, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldSourceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *HasSourceAtMutation) ResetSourceID() {
	m.source = nil
}

// SetKnownSince sets the "known_since" field.
func (m *HasSourceAtMutation) SetKnownSince(t time.Time) {
	m.known_since = &t
}

// KnownSince returns the value of the "known_since" field in the mutation.
func (m *HasSourceAtMutation) KnownSince() (r time.Time, exists bool) {
	v := m.known_since
	if v == nil {
		return
	}
	return *v, true
}

// OldKnownSince returns the old "known_since" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldKnownSince(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnownSince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnownSince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnownSince: %w", err)
	}
	return oldValue.KnownSince, nil
}

// ResetKnownSince resets all changes to the "known_since" field.
func (m *HasSourceAtMutation) ResetKnownSince() {
	m.known_since = nil
}

// SetJustification sets the "justification" field.
func (m *HasSourceAtMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *HasSourceAtMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *HasSourceAtMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *HasSourceAtMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *HasSourceAtMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *HasSourceAtMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *HasSourceAtMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *HasSourceAtMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *HasSourceAtMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *HasSourceAtMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *HasSourceAtMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *HasSourceAtMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// ClearPackageVersion clears the "package_version" edge to the PackageVersion entity.
func (m *HasSourceAtMutation) ClearPackageVersion() {
	m.clearedpackage_version = true
	m.clearedFields[hassourceat.FieldPackageVersionID] = struct{}{}
}

// PackageVersionCleared reports if the "package_version" edge to the PackageVersion entity was cleared.
func (m *HasSourceAtMutation) PackageVersionCleared() bool {
	return m.PackageVersionIDCleared() || m.clearedpackage_version
}

// PackageVersionIDs returns the "package_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageVersionID instead. It exists only for internal usage by the builders.
func (m *HasSourceAtMutation) PackageVersionIDs() (ids []uuid.UUID) {
	if id := m.package_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackageVersion resets all changes to the "package_version" edge.
func (m *HasSourceAtMutation) ResetPackageVersion() {
	m.package_version = nil
	m.clearedpackage_version = false
}

// SetAllVersionsID sets the "all_versions" edge to the PackageName entity by id.
func (m *HasSourceAtMutation) SetAllVersionsID(id uuid.UUID) {
	m.all_versions = &id
}

// ClearAllVersions clears the "all_versions" edge to the PackageName entity.
func (m *HasSourceAtMutation) ClearAllVersions() {
	m.clearedall_versions = true
	m.clearedFields[hassourceat.FieldPackageNameID] = struct{}{}
}

// AllVersionsCleared reports if the "all_versions" edge to the PackageName entity was cleared.
func (m *HasSourceAtMutation) AllVersionsCleared() bool {
	return m.PackageNameIDCleared() || m.clearedall_versions
}

// AllVersionsID returns the "all_versions" edge ID in the mutation.
func (m *HasSourceAtMutation) AllVersionsID() (id uuid.UUID, exists bool) {
	if m.all_versions != nil {
		return *m.all_versions, true
	}
	return
}

// AllVersionsIDs returns the "all_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AllVersionsID instead. It exists only for internal usage by the builders.
func (m *HasSourceAtMutation) AllVersionsIDs() (ids []uuid.UUID) {
	if id := m.all_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAllVersions resets all changes to the "all_versions" edge.
func (m *HasSourceAtMutation) ResetAllVersions() {
	m.all_versions = nil
	m.clearedall_versions = false
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *HasSourceAtMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[hassourceat.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *HasSourceAtMutation) SourceCleared() bool {
	return m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *HasSourceAtMutation) SourceIDs() (ids []uuid.UUID) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *HasSourceAtMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Where appends a list predicates to the HasSourceAtMutation builder.
func (m *HasSourceAtMutation) Where(ps ...predicate.HasSourceAt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HasSourceAtMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HasSourceAtMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HasSourceAt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HasSourceAtMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HasSourceAtMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HasSourceAt).
func (m *HasSourceAtMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HasSourceAtMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.package_version != nil {
		fields = append(fields, hassourceat.FieldPackageVersionID)
	}
	if m.all_versions != nil {
		fields = append(fields, hassourceat.FieldPackageNameID)
	}
	if m.source != nil {
		fields = append(fields, hassourceat.FieldSourceID)
	}
	if m.known_since != nil {
		fields = append(fields, hassourceat.FieldKnownSince)
	}
	if m.justification != nil {
		fields = append(fields, hassourceat.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, hassourceat.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, hassourceat.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, hassourceat.FieldDocumentRef)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HasSourceAtMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hassourceat.FieldPackageVersionID:
		return m.PackageVersionID()
	case hassourceat.FieldPackageNameID:
		return m.PackageNameID()
	case hassourceat.FieldSourceID:
		return m.SourceID()
	case hassourceat.FieldKnownSince:
		return m.KnownSince()
	case hassourceat.FieldJustification:
		return m.Justification()
	case hassourceat.FieldOrigin:
		return m.Origin()
	case hassourceat.FieldCollector:
		return m.Collector()
	case hassourceat.FieldDocumentRef:
		return m.DocumentRef()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HasSourceAtMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hassourceat.FieldPackageVersionID:
		return m.OldPackageVersionID(ctx)
	case hassourceat.FieldPackageNameID:
		return m.OldPackageNameID(ctx)
	case hassourceat.FieldSourceID:
		return m.OldSourceID(ctx)
	case hassourceat.FieldKnownSince:
		return m.OldKnownSince(ctx)
	case hassourceat.FieldJustification:
		return m.OldJustification(ctx)
	case hassourceat.FieldOrigin:
		return m.OldOrigin(ctx)
	case hassourceat.FieldCollector:
		return m.OldCollector(ctx)
	case hassourceat.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	}
	return nil, fmt.Errorf("unknown HasSourceAt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HasSourceAtMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hassourceat.FieldPackageVersionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageVersionID(v)
		return nil
	case hassourceat.FieldPackageNameID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageNameID(v)
		return nil
	case hassourceat.FieldSourceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case hassourceat.FieldKnownSince:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnownSince(v)
		return nil
	case hassourceat.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case hassourceat.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case hassourceat.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case hassourceat.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HasSourceAtMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HasSourceAtMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HasSourceAtMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HasSourceAt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HasSourceAtMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hassourceat.FieldPackageVersionID) {
		fields = append(fields, hassourceat.FieldPackageVersionID)
	}
	if m.FieldCleared(hassourceat.FieldPackageNameID) {
		fields = append(fields, hassourceat.FieldPackageNameID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HasSourceAtMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HasSourceAtMutation) ClearField(name string) error {
	switch name {
	case hassourceat.FieldPackageVersionID:
		m.ClearPackageVersionID()
		return nil
	case hassourceat.FieldPackageNameID:
		m.ClearPackageNameID()
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HasSourceAtMutation) ResetField(name string) error {
	switch name {
	case hassourceat.FieldPackageVersionID:
		m.ResetPackageVersionID()
		return nil
	case hassourceat.FieldPackageNameID:
		m.ResetPackageNameID()
		return nil
	case hassourceat.FieldSourceID:
		m.ResetSourceID()
		return nil
	case hassourceat.FieldKnownSince:
		m.ResetKnownSince()
		return nil
	case hassourceat.FieldJustification:
		m.ResetJustification()
		return nil
	case hassourceat.FieldOrigin:
		m.ResetOrigin()
		return nil
	case hassourceat.FieldCollector:
		m.ResetCollector()
		return nil
	case hassourceat.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HasSourceAtMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.package_version != nil {
		edges = append(edges, hassourceat.EdgePackageVersion)
	}
	if m.all_versions != nil {
		edges = append(edges, hassourceat.EdgeAllVersions)
	}
	if m.source != nil {
		edges = append(edges, hassourceat.EdgeSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HasSourceAtMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hassourceat.EdgePackageVersion:
		if id := m.package_version; id != nil {
			return []ent.Value{*id}
		}
	case hassourceat.EdgeAllVersions:
		if id := m.all_versions; id != nil {
			return []ent.Value{*id}
		}
	case hassourceat.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HasSourceAtMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HasSourceAtMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HasSourceAtMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpackage_version {
		edges = append(edges, hassourceat.EdgePackageVersion)
	}
	if m.clearedall_versions {
		edges = append(edges, hassourceat.EdgeAllVersions)
	}
	if m.clearedsource {
		edges = append(edges, hassourceat.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HasSourceAtMutation) EdgeCleared(name string) bool {
	switch name {
	case hassourceat.EdgePackageVersion:
		return m.clearedpackage_version
	case hassourceat.EdgeAllVersions:
		return m.clearedall_versions
	case hassourceat.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HasSourceAtMutation) ClearEdge(name string) error {
	switch name {
	case hassourceat.EdgePackageVersion:
		m.ClearPackageVersion()
		return nil
	case hassourceat.EdgeAllVersions:
		m.ClearAllVersions()
		return nil
	case hassourceat.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HasSourceAtMutation) ResetEdge(name string) error {
	switch name {
	case hassourceat.EdgePackageVersion:
		m.ResetPackageVersion()
		return nil
	case hassourceat.EdgeAllVersions:
		m.ResetAllVersions()
		return nil
	case hassourceat.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt edge %s", name)
}

// HashEqualMutation represents an operation that mutates the HashEqual nodes in the graph.
type HashEqualMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	origin            *string
	collector         *string
	justification     *string
	document_ref      *string
	artifacts_hash    *string
	clearedFields     map[string]struct{}
	artifact_a        *uuid.UUID
	clearedartifact_a bool
	artifact_b        *uuid.UUID
	clearedartifact_b bool
	done              bool
	oldValue          func(context.Context) (*HashEqual, error)
	predicates        []predicate.HashEqual
}

var _ ent.Mutation = (*HashEqualMutation)(nil)

// hashequalOption allows management of the mutation configuration using functional options.
type hashequalOption func(*HashEqualMutation)

// newHashEqualMutation creates new mutation for the HashEqual entity.
func newHashEqualMutation(c config, op Op, opts ...hashequalOption) *HashEqualMutation {
	m := &HashEqualMutation{
		config:        c,
		op:            op,
		typ:           TypeHashEqual,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHashEqualID sets the ID field of the mutation.
func withHashEqualID(id uuid.UUID) hashequalOption {
	return func(m *HashEqualMutation) {
		var (
			err   error
			once  sync.Once
			value *HashEqual
		)
		m.oldValue = func(ctx context.Context) (*HashEqual, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HashEqual.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHashEqual sets the old HashEqual of the mutation.
func withHashEqual(node *HashEqual) hashequalOption {
	return func(m *HashEqualMutation) {
		m.oldValue = func(context.Context) (*HashEqual, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HashEqualMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HashEqualMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HashEqual entities.
func (m *HashEqualMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HashEqualMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HashEqualMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HashEqual.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArtID sets the "art_id" field.
func (m *HashEqualMutation) SetArtID(u uuid.UUID) {
	m.artifact_a = &u
}

// ArtID returns the value of the "art_id" field in the mutation.
func (m *HashEqualMutation) ArtID() (r uuid.UUID, exists bool) {
	v := m.artifact_a
	if v == nil {
		return
	}
	return *v, true
}

// OldArtID returns the old "art_id" field's value of the HashEqual entity.
// If the HashEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashEqualMutation) OldArtID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtID: %w", err)
	}
	return oldValue.ArtID, nil
}

// ResetArtID resets all changes to the "art_id" field.
func (m *HashEqualMutation) ResetArtID() {
	m.artifact_a = nil
}

// SetEqualArtID sets the "equal_art_id" field.
func (m *HashEqualMutation) SetEqualArtID(u uuid.UUID) {
	m.artifact_b = &u
}

// EqualArtID returns the value of the "equal_art_id" field in the mutation.
func (m *HashEqualMutation) EqualArtID() (r uuid.UUID, exists bool) {
	v := m.artifact_b
	if v == nil {
		return
	}
	return *v, true
}

// OldEqualArtID returns the old "equal_art_id" field's value of the HashEqual entity.
// If the HashEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashEqualMutation) OldEqualArtID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEqualArtID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEqualArtID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEqualArtID: %w", err)
	}
	return oldValue.EqualArtID, nil
}

// ResetEqualArtID resets all changes to the "equal_art_id" field.
func (m *HashEqualMutation) ResetEqualArtID() {
	m.artifact_b = nil
}

// SetOrigin sets the "origin" field.
func (m *HashEqualMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *HashEqualMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the HashEqual entity.
// If the HashEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashEqualMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *HashEqualMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *HashEqualMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *HashEqualMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the HashEqual entity.
// If the HashEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashEqualMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *HashEqualMutation) ResetCollector() {
	m.collector = nil
}

// SetJustification sets the "justification" field.
func (m *HashEqualMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *HashEqualMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the HashEqual entity.
// If the HashEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashEqualMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *HashEqualMutation) ResetJustification() {
	m.justification = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *HashEqualMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *HashEqualMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the HashEqual entity.
// If the HashEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashEqualMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *HashEqualMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// SetArtifactsHash sets the "artifacts_hash" field.
func (m *HashEqualMutation) SetArtifactsHash(s string) {
	m.artifacts_hash = &s
}

// ArtifactsHash returns the value of the "artifacts_hash" field in the mutation.
func (m *HashEqualMutation) ArtifactsHash() (r string, exists bool) {
	v := m.artifacts_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactsHash returns the old "artifacts_hash" field's value of the HashEqual entity.
// If the HashEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashEqualMutation) OldArtifactsHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactsHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactsHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactsHash: %w", err)
	}
	return oldValue.ArtifactsHash, nil
}

// ResetArtifactsHash resets all changes to the "artifacts_hash" field.
func (m *HashEqualMutation) ResetArtifactsHash() {
	m.artifacts_hash = nil
}

// SetArtifactAID sets the "artifact_a" edge to the Artifact entity by id.
func (m *HashEqualMutation) SetArtifactAID(id uuid.UUID) {
	m.artifact_a = &id
}

// ClearArtifactA clears the "artifact_a" edge to the Artifact entity.
func (m *HashEqualMutation) ClearArtifactA() {
	m.clearedartifact_a = true
	m.clearedFields[hashequal.FieldArtID] = struct{}{}
}

// ArtifactACleared reports if the "artifact_a" edge to the Artifact entity was cleared.
func (m *HashEqualMutation) ArtifactACleared() bool {
	return m.clearedartifact_a
}

// ArtifactAID returns the "artifact_a" edge ID in the mutation.
func (m *HashEqualMutation) ArtifactAID() (id uuid.UUID, exists bool) {
	if m.artifact_a != nil {
		return *m.artifact_a, true
	}
	return
}

// ArtifactAIDs returns the "artifact_a" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactAID instead. It exists only for internal usage by the builders.
func (m *HashEqualMutation) ArtifactAIDs() (ids []uuid.UUID) {
	if id := m.artifact_a; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifactA resets all changes to the "artifact_a" edge.
func (m *HashEqualMutation) ResetArtifactA() {
	m.artifact_a = nil
	m.clearedartifact_a = false
}

// SetArtifactBID sets the "artifact_b" edge to the Artifact entity by id.
func (m *HashEqualMutation) SetArtifactBID(id uuid.UUID) {
	m.artifact_b = &id
}

// ClearArtifactB clears the "artifact_b" edge to the Artifact entity.
func (m *HashEqualMutation) ClearArtifactB() {
	m.clearedartifact_b = true
	m.clearedFields[hashequal.FieldEqualArtID] = struct{}{}
}

// ArtifactBCleared reports if the "artifact_b" edge to the Artifact entity was cleared.
func (m *HashEqualMutation) ArtifactBCleared() bool {
	return m.clearedartifact_b
}

// ArtifactBID returns the "artifact_b" edge ID in the mutation.
func (m *HashEqualMutation) ArtifactBID() (id uuid.UUID, exists bool) {
	if m.artifact_b != nil {
		return *m.artifact_b, true
	}
	return
}

// ArtifactBIDs returns the "artifact_b" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactBID instead. It exists only for internal usage by the builders.
func (m *HashEqualMutation) ArtifactBIDs() (ids []uuid.UUID) {
	if id := m.artifact_b; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifactB resets all changes to the "artifact_b" edge.
func (m *HashEqualMutation) ResetArtifactB() {
	m.artifact_b = nil
	m.clearedartifact_b = false
}

// Where appends a list predicates to the HashEqualMutation builder.
func (m *HashEqualMutation) Where(ps ...predicate.HashEqual) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HashEqualMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HashEqualMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HashEqual, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HashEqualMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HashEqualMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HashEqual).
func (m *HashEqualMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HashEqualMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.artifact_a != nil {
		fields = append(fields, hashequal.FieldArtID)
	}
	if m.artifact_b != nil {
		fields = append(fields, hashequal.FieldEqualArtID)
	}
	if m.origin != nil {
		fields = append(fields, hashequal.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, hashequal.FieldCollector)
	}
	if m.justification != nil {
		fields = append(fields, hashequal.FieldJustification)
	}
	if m.document_ref != nil {
		fields = append(fields, hashequal.FieldDocumentRef)
	}
	if m.artifacts_hash != nil {
		fields = append(fields, hashequal.FieldArtifactsHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HashEqualMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hashequal.FieldArtID:
		return m.ArtID()
	case hashequal.FieldEqualArtID:
		return m.EqualArtID()
	case hashequal.FieldOrigin:
		return m.Origin()
	case hashequal.FieldCollector:
		return m.Collector()
	case hashequal.FieldJustification:
		return m.Justification()
	case hashequal.FieldDocumentRef:
		return m.DocumentRef()
	case hashequal.FieldArtifactsHash:
		return m.ArtifactsHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HashEqualMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hashequal.FieldArtID:
		return m.OldArtID(ctx)
	case hashequal.FieldEqualArtID:
		return m.OldEqualArtID(ctx)
	case hashequal.FieldOrigin:
		return m.OldOrigin(ctx)
	case hashequal.FieldCollector:
		return m.OldCollector(ctx)
	case hashequal.FieldJustification:
		return m.OldJustification(ctx)
	case hashequal.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	case hashequal.FieldArtifactsHash:
		return m.OldArtifactsHash(ctx)
	}
	return nil, fmt.Errorf("unknown HashEqual field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HashEqualMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hashequal.FieldArtID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtID(v)
		return nil
	case hashequal.FieldEqualArtID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEqualArtID(v)
		return nil
	case hashequal.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case hashequal.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case hashequal.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case hashequal.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	case hashequal.FieldArtifactsHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactsHash(v)
		return nil
	}
	return fmt.Errorf("unknown HashEqual field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HashEqualMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HashEqualMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HashEqualMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HashEqual numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HashEqualMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HashEqualMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HashEqualMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HashEqual nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HashEqualMutation) ResetField(name string) error {
	switch name {
	case hashequal.FieldArtID:
		m.ResetArtID()
		return nil
	case hashequal.FieldEqualArtID:
		m.ResetEqualArtID()
		return nil
	case hashequal.FieldOrigin:
		m.ResetOrigin()
		return nil
	case hashequal.FieldCollector:
		m.ResetCollector()
		return nil
	case hashequal.FieldJustification:
		m.ResetJustification()
		return nil
	case hashequal.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	case hashequal.FieldArtifactsHash:
		m.ResetArtifactsHash()
		return nil
	}
	return fmt.Errorf("unknown HashEqual field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HashEqualMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.artifact_a != nil {
		edges = append(edges, hashequal.EdgeArtifactA)
	}
	if m.artifact_b != nil {
		edges = append(edges, hashequal.EdgeArtifactB)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HashEqualMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hashequal.EdgeArtifactA:
		if id := m.artifact_a; id != nil {
			return []ent.Value{*id}
		}
	case hashequal.EdgeArtifactB:
		if id := m.artifact_b; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HashEqualMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HashEqualMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HashEqualMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedartifact_a {
		edges = append(edges, hashequal.EdgeArtifactA)
	}
	if m.clearedartifact_b {
		edges = append(edges, hashequal.EdgeArtifactB)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HashEqualMutation) EdgeCleared(name string) bool {
	switch name {
	case hashequal.EdgeArtifactA:
		return m.clearedartifact_a
	case hashequal.EdgeArtifactB:
		return m.clearedartifact_b
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HashEqualMutation) ClearEdge(name string) error {
	switch name {
	case hashequal.EdgeArtifactA:
		m.ClearArtifactA()
		return nil
	case hashequal.EdgeArtifactB:
		m.ClearArtifactB()
		return nil
	}
	return fmt.Errorf("unknown HashEqual unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HashEqualMutation) ResetEdge(name string) error {
	switch name {
	case hashequal.EdgeArtifactA:
		m.ResetArtifactA()
		return nil
	case hashequal.EdgeArtifactB:
		m.ResetArtifactB()
		return nil
	}
	return fmt.Errorf("unknown HashEqual edge %s", name)
}

// LicenseMutation represents an operation that mutates the License nodes in the graph.
type LicenseMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *uuid.UUID
	name                                *string
	inline                              *string
	list_version                        *string
	clearedFields                       map[string]struct{}
	declared_in_certify_legals          map[uuid.UUID]struct{}
	removeddeclared_in_certify_legals   map[uuid.UUID]struct{}
	cleareddeclared_in_certify_legals   bool
	discovered_in_certify_legals        map[uuid.UUID]struct{}
	removeddiscovered_in_certify_legals map[uuid.UUID]struct{}
	cleareddiscovered_in_certify_legals bool
	done                                bool
	oldValue                            func(context.Context) (*License, error)
	predicates                          []predicate.License
}

var _ ent.Mutation = (*LicenseMutation)(nil)

// licenseOption allows management of the mutation configuration using functional options.
type licenseOption func(*LicenseMutation)

// newLicenseMutation creates new mutation for the License entity.
func newLicenseMutation(c config, op Op, opts ...licenseOption) *LicenseMutation {
	m := &LicenseMutation{
		config:        c,
		op:            op,
		typ:           TypeLicense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLicenseID sets the ID field of the mutation.
func withLicenseID(id uuid.UUID) licenseOption {
	return func(m *LicenseMutation) {
		var (
			err   error
			once  sync.Once
			value *License
		)
		m.oldValue = func(ctx context.Context) (*License, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().License.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLicense sets the old License of the mutation.
func withLicense(node *License) licenseOption {
	return func(m *LicenseMutation) {
		m.oldValue = func(context.Context) (*License, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LicenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LicenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of License entities.
func (m *LicenseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LicenseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LicenseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().License.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LicenseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LicenseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LicenseMutation) ResetName() {
	m.name = nil
}

// SetInline sets the "inline" field.
func (m *LicenseMutation) SetInline(s string) {
	m.inline = &s
}

// Inline returns the value of the "inline" field in the mutation.
func (m *LicenseMutation) Inline() (r string, exists bool) {
	v := m.inline
	if v == nil {
		return
	}
	return *v, true
}

// OldInline returns the old "inline" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldInline(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInline: %w", err)
	}
	return oldValue.Inline, nil
}

// ClearInline clears the value of the "inline" field.
func (m *LicenseMutation) ClearInline() {
	m.inline = nil
	m.clearedFields[license.FieldInline] = struct{}{}
}

// InlineCleared returns if the "inline" field was cleared in this mutation.
func (m *LicenseMutation) InlineCleared() bool {
	_, ok := m.clearedFields[license.FieldInline]
	return ok
}

// ResetInline resets all changes to the "inline" field.
func (m *LicenseMutation) ResetInline() {
	m.inline = nil
	delete(m.clearedFields, license.FieldInline)
}

// SetListVersion sets the "list_version" field.
func (m *LicenseMutation) SetListVersion(s string) {
	m.list_version = &s
}

// ListVersion returns the value of the "list_version" field in the mutation.
func (m *LicenseMutation) ListVersion() (r string, exists bool) {
	v := m.list_version
	if v == nil {
		return
	}
	return *v, true
}

// OldListVersion returns the old "list_version" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldListVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListVersion: %w", err)
	}
	return oldValue.ListVersion, nil
}

// ClearListVersion clears the value of the "list_version" field.
func (m *LicenseMutation) ClearListVersion() {
	m.list_version = nil
	m.clearedFields[license.FieldListVersion] = struct{}{}
}

// ListVersionCleared returns if the "list_version" field was cleared in this mutation.
func (m *LicenseMutation) ListVersionCleared() bool {
	_, ok := m.clearedFields[license.FieldListVersion]
	return ok
}

// ResetListVersion resets all changes to the "list_version" field.
func (m *LicenseMutation) ResetListVersion() {
	m.list_version = nil
	delete(m.clearedFields, license.FieldListVersion)
}

// AddDeclaredInCertifyLegalIDs adds the "declared_in_certify_legals" edge to the CertifyLegal entity by ids.
func (m *LicenseMutation) AddDeclaredInCertifyLegalIDs(ids ...uuid.UUID) {
	if m.declared_in_certify_legals == nil {
		m.declared_in_certify_legals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.declared_in_certify_legals[ids[i]] = struct{}{}
	}
}

// ClearDeclaredInCertifyLegals clears the "declared_in_certify_legals" edge to the CertifyLegal entity.
func (m *LicenseMutation) ClearDeclaredInCertifyLegals() {
	m.cleareddeclared_in_certify_legals = true
}

// DeclaredInCertifyLegalsCleared reports if the "declared_in_certify_legals" edge to the CertifyLegal entity was cleared.
func (m *LicenseMutation) DeclaredInCertifyLegalsCleared() bool {
	return m.cleareddeclared_in_certify_legals
}

// RemoveDeclaredInCertifyLegalIDs removes the "declared_in_certify_legals" edge to the CertifyLegal entity by IDs.
func (m *LicenseMutation) RemoveDeclaredInCertifyLegalIDs(ids ...uuid.UUID) {
	if m.removeddeclared_in_certify_legals == nil {
		m.removeddeclared_in_certify_legals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.declared_in_certify_legals, ids[i])
		m.removeddeclared_in_certify_legals[ids[i]] = struct{}{}
	}
}

// RemovedDeclaredInCertifyLegals returns the removed IDs of the "declared_in_certify_legals" edge to the CertifyLegal entity.
func (m *LicenseMutation) RemovedDeclaredInCertifyLegalsIDs() (ids []uuid.UUID) {
	for id := range m.removeddeclared_in_certify_legals {
		ids = append(ids, id)
	}
	return
}

// DeclaredInCertifyLegalsIDs returns the "declared_in_certify_legals" edge IDs in the mutation.
func (m *LicenseMutation) DeclaredInCertifyLegalsIDs() (ids []uuid.UUID) {
	for id := range m.declared_in_certify_legals {
		ids = append(ids, id)
	}
	return
}

// ResetDeclaredInCertifyLegals resets all changes to the "declared_in_certify_legals" edge.
func (m *LicenseMutation) ResetDeclaredInCertifyLegals() {
	m.declared_in_certify_legals = nil
	m.cleareddeclared_in_certify_legals = false
	m.removeddeclared_in_certify_legals = nil
}

// AddDiscoveredInCertifyLegalIDs adds the "discovered_in_certify_legals" edge to the CertifyLegal entity by ids.
func (m *LicenseMutation) AddDiscoveredInCertifyLegalIDs(ids ...uuid.UUID) {
	if m.discovered_in_certify_legals == nil {
		m.discovered_in_certify_legals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.discovered_in_certify_legals[ids[i]] = struct{}{}
	}
}

// ClearDiscoveredInCertifyLegals clears the "discovered_in_certify_legals" edge to the CertifyLegal entity.
func (m *LicenseMutation) ClearDiscoveredInCertifyLegals() {
	m.cleareddiscovered_in_certify_legals = true
}

// DiscoveredInCertifyLegalsCleared reports if the "discovered_in_certify_legals" edge to the CertifyLegal entity was cleared.
func (m *LicenseMutation) DiscoveredInCertifyLegalsCleared() bool {
	return m.cleareddiscovered_in_certify_legals
}

// RemoveDiscoveredInCertifyLegalIDs removes the "discovered_in_certify_legals" edge to the CertifyLegal entity by IDs.
func (m *LicenseMutation) RemoveDiscoveredInCertifyLegalIDs(ids ...uuid.UUID) {
	if m.removeddiscovered_in_certify_legals == nil {
		m.removeddiscovered_in_certify_legals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.discovered_in_certify_legals, ids[i])
		m.removeddiscovered_in_certify_legals[ids[i]] = struct{}{}
	}
}

// RemovedDiscoveredInCertifyLegals returns the removed IDs of the "discovered_in_certify_legals" edge to the CertifyLegal entity.
func (m *LicenseMutation) RemovedDiscoveredInCertifyLegalsIDs() (ids []uuid.UUID) {
	for id := range m.removeddiscovered_in_certify_legals {
		ids = append(ids, id)
	}
	return
}

// DiscoveredInCertifyLegalsIDs returns the "discovered_in_certify_legals" edge IDs in the mutation.
func (m *LicenseMutation) DiscoveredInCertifyLegalsIDs() (ids []uuid.UUID) {
	for id := range m.discovered_in_certify_legals {
		ids = append(ids, id)
	}
	return
}

// ResetDiscoveredInCertifyLegals resets all changes to the "discovered_in_certify_legals" edge.
func (m *LicenseMutation) ResetDiscoveredInCertifyLegals() {
	m.discovered_in_certify_legals = nil
	m.cleareddiscovered_in_certify_legals = false
	m.removeddiscovered_in_certify_legals = nil
}

// Where appends a list predicates to the LicenseMutation builder.
func (m *LicenseMutation) Where(ps ...predicate.License) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LicenseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LicenseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.License, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LicenseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LicenseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (License).
func (m *LicenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LicenseMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, license.FieldName)
	}
	if m.inline != nil {
		fields = append(fields, license.FieldInline)
	}
	if m.list_version != nil {
		fields = append(fields, license.FieldListVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LicenseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case license.FieldName:
		return m.Name()
	case license.FieldInline:
		return m.Inline()
	case license.FieldListVersion:
		return m.ListVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LicenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case license.FieldName:
		return m.OldName(ctx)
	case license.FieldInline:
		return m.OldInline(ctx)
	case license.FieldListVersion:
		return m.OldListVersion(ctx)
	}
	return nil, fmt.Errorf("unknown License field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case license.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case license.FieldInline:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInline(v)
		return nil
	case license.FieldListVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListVersion(v)
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LicenseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LicenseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown License numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LicenseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(license.FieldInline) {
		fields = append(fields, license.FieldInline)
	}
	if m.FieldCleared(license.FieldListVersion) {
		fields = append(fields, license.FieldListVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LicenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LicenseMutation) ClearField(name string) error {
	switch name {
	case license.FieldInline:
		m.ClearInline()
		return nil
	case license.FieldListVersion:
		m.ClearListVersion()
		return nil
	}
	return fmt.Errorf("unknown License nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LicenseMutation) ResetField(name string) error {
	switch name {
	case license.FieldName:
		m.ResetName()
		return nil
	case license.FieldInline:
		m.ResetInline()
		return nil
	case license.FieldListVersion:
		m.ResetListVersion()
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LicenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.declared_in_certify_legals != nil {
		edges = append(edges, license.EdgeDeclaredInCertifyLegals)
	}
	if m.discovered_in_certify_legals != nil {
		edges = append(edges, license.EdgeDiscoveredInCertifyLegals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LicenseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeDeclaredInCertifyLegals:
		ids := make([]ent.Value, 0, len(m.declared_in_certify_legals))
		for id := range m.declared_in_certify_legals {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeDiscoveredInCertifyLegals:
		ids := make([]ent.Value, 0, len(m.discovered_in_certify_legals))
		for id := range m.discovered_in_certify_legals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LicenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddeclared_in_certify_legals != nil {
		edges = append(edges, license.EdgeDeclaredInCertifyLegals)
	}
	if m.removeddiscovered_in_certify_legals != nil {
		edges = append(edges, license.EdgeDiscoveredInCertifyLegals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LicenseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeDeclaredInCertifyLegals:
		ids := make([]ent.Value, 0, len(m.removeddeclared_in_certify_legals))
		for id := range m.removeddeclared_in_certify_legals {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeDiscoveredInCertifyLegals:
		ids := make([]ent.Value, 0, len(m.removeddiscovered_in_certify_legals))
		for id := range m.removeddiscovered_in_certify_legals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LicenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddeclared_in_certify_legals {
		edges = append(edges, license.EdgeDeclaredInCertifyLegals)
	}
	if m.cleareddiscovered_in_certify_legals {
		edges = append(edges, license.EdgeDiscoveredInCertifyLegals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LicenseMutation) EdgeCleared(name string) bool {
	switch name {
	case license.EdgeDeclaredInCertifyLegals:
		return m.cleareddeclared_in_certify_legals
	case license.EdgeDiscoveredInCertifyLegals:
		return m.cleareddiscovered_in_certify_legals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LicenseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown License unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LicenseMutation) ResetEdge(name string) error {
	switch name {
	case license.EdgeDeclaredInCertifyLegals:
		m.ResetDeclaredInCertifyLegals()
		return nil
	case license.EdgeDiscoveredInCertifyLegals:
		m.ResetDiscoveredInCertifyLegals()
		return nil
	}
	return fmt.Errorf("unknown License edge %s", name)
}

// OccurrenceMutation represents an operation that mutates the Occurrence nodes in the graph.
type OccurrenceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	justification            *string
	origin                   *string
	collector                *string
	document_ref             *string
	clearedFields            map[string]struct{}
	artifact                 *uuid.UUID
	clearedartifact          bool
	_package                 *uuid.UUID
	cleared_package          bool
	source                   *uuid.UUID
	clearedsource            bool
	included_in_sboms        map[uuid.UUID]struct{}
	removedincluded_in_sboms map[uuid.UUID]struct{}
	clearedincluded_in_sboms bool
	done                     bool
	oldValue                 func(context.Context) (*Occurrence, error)
	predicates               []predicate.Occurrence
}

var _ ent.Mutation = (*OccurrenceMutation)(nil)

// occurrenceOption allows management of the mutation configuration using functional options.
type occurrenceOption func(*OccurrenceMutation)

// newOccurrenceMutation creates new mutation for the Occurrence entity.
func newOccurrenceMutation(c config, op Op, opts ...occurrenceOption) *OccurrenceMutation {
	m := &OccurrenceMutation{
		config:        c,
		op:            op,
		typ:           TypeOccurrence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOccurrenceID sets the ID field of the mutation.
func withOccurrenceID(id uuid.UUID) occurrenceOption {
	return func(m *OccurrenceMutation) {
		var (
			err   error
			once  sync.Once
			value *Occurrence
		)
		m.oldValue = func(ctx context.Context) (*Occurrence, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Occurrence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOccurrence sets the old Occurrence of the mutation.
func withOccurrence(node *Occurrence) occurrenceOption {
	return func(m *OccurrenceMutation) {
		m.oldValue = func(context.Context) (*Occurrence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OccurrenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OccurrenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Occurrence entities.
func (m *OccurrenceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OccurrenceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OccurrenceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Occurrence.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArtifactID sets the "artifact_id" field.
func (m *OccurrenceMutation) SetArtifactID(u uuid.UUID) {
	m.artifact = &u
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *OccurrenceMutation) ArtifactID() (r uuid.UUID, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldArtifactID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *OccurrenceMutation) ResetArtifactID() {
	m.artifact = nil
}

// SetJustification sets the "justification" field.
func (m *OccurrenceMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *OccurrenceMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *OccurrenceMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *OccurrenceMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *OccurrenceMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *OccurrenceMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *OccurrenceMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *OccurrenceMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *OccurrenceMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *OccurrenceMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *OccurrenceMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *OccurrenceMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// SetSourceID sets the "source_id" field.
func (m *OccurrenceMutation) SetSourceID(u uuid.UUID) {
	m.source = &u
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *OccurrenceMutation) SourceID() (r uuid.UUID, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldSourceID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *OccurrenceMutation) ClearSourceID() {
	m.source = nil
	m.clearedFields[occurrence.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *OccurrenceMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *OccurrenceMutation) ResetSourceID() {
	m.source = nil
	delete(m.clearedFields, occurrence.FieldSourceID)
}

// SetPackageID sets the "package_id" field.
func (m *OccurrenceMutation) SetPackageID(u uuid.UUID) {
	m._package = &u
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *OccurrenceMutation) PackageID() (r uuid.UUID, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldPackageID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *OccurrenceMutation) ClearPackageID() {
	m._package = nil
	m.clearedFields[occurrence.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *OccurrenceMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *OccurrenceMutation) ResetPackageID() {
	m._package = nil
	delete(m.clearedFields, occurrence.FieldPackageID)
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *OccurrenceMutation) ClearArtifact() {
	m.clearedartifact = true
	m.clearedFields[occurrence.FieldArtifactID] = struct{}{}
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *OccurrenceMutation) ArtifactCleared() bool {
	return m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *OccurrenceMutation) ArtifactIDs() (ids []uuid.UUID) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *OccurrenceMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *OccurrenceMutation) ClearPackage() {
	m.cleared_package = true
	m.clearedFields[occurrence.FieldPackageID] = struct{}{}
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *OccurrenceMutation) PackageCleared() bool {
	return m.PackageIDCleared() || m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *OccurrenceMutation) PackageIDs() (ids []uuid.UUID) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *OccurrenceMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *OccurrenceMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[occurrence.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *OccurrenceMutation) SourceCleared() bool {
	return m.SourceIDCleared() || m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *OccurrenceMutation) SourceIDs() (ids []uuid.UUID) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *OccurrenceMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// AddIncludedInSbomIDs adds the "included_in_sboms" edge to the BillOfMaterials entity by ids.
func (m *OccurrenceMutation) AddIncludedInSbomIDs(ids ...uuid.UUID) {
	if m.included_in_sboms == nil {
		m.included_in_sboms = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.included_in_sboms[ids[i]] = struct{}{}
	}
}

// ClearIncludedInSboms clears the "included_in_sboms" edge to the BillOfMaterials entity.
func (m *OccurrenceMutation) ClearIncludedInSboms() {
	m.clearedincluded_in_sboms = true
}

// IncludedInSbomsCleared reports if the "included_in_sboms" edge to the BillOfMaterials entity was cleared.
func (m *OccurrenceMutation) IncludedInSbomsCleared() bool {
	return m.clearedincluded_in_sboms
}

// RemoveIncludedInSbomIDs removes the "included_in_sboms" edge to the BillOfMaterials entity by IDs.
func (m *OccurrenceMutation) RemoveIncludedInSbomIDs(ids ...uuid.UUID) {
	if m.removedincluded_in_sboms == nil {
		m.removedincluded_in_sboms = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.included_in_sboms, ids[i])
		m.removedincluded_in_sboms[ids[i]] = struct{}{}
	}
}

// RemovedIncludedInSboms returns the removed IDs of the "included_in_sboms" edge to the BillOfMaterials entity.
func (m *OccurrenceMutation) RemovedIncludedInSbomsIDs() (ids []uuid.UUID) {
	for id := range m.removedincluded_in_sboms {
		ids = append(ids, id)
	}
	return
}

// IncludedInSbomsIDs returns the "included_in_sboms" edge IDs in the mutation.
func (m *OccurrenceMutation) IncludedInSbomsIDs() (ids []uuid.UUID) {
	for id := range m.included_in_sboms {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedInSboms resets all changes to the "included_in_sboms" edge.
func (m *OccurrenceMutation) ResetIncludedInSboms() {
	m.included_in_sboms = nil
	m.clearedincluded_in_sboms = false
	m.removedincluded_in_sboms = nil
}

// Where appends a list predicates to the OccurrenceMutation builder.
func (m *OccurrenceMutation) Where(ps ...predicate.Occurrence) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OccurrenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OccurrenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Occurrence, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OccurrenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OccurrenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Occurrence).
func (m *OccurrenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OccurrenceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.artifact != nil {
		fields = append(fields, occurrence.FieldArtifactID)
	}
	if m.justification != nil {
		fields = append(fields, occurrence.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, occurrence.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, occurrence.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, occurrence.FieldDocumentRef)
	}
	if m.source != nil {
		fields = append(fields, occurrence.FieldSourceID)
	}
	if m._package != nil {
		fields = append(fields, occurrence.FieldPackageID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OccurrenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case occurrence.FieldArtifactID:
		return m.ArtifactID()
	case occurrence.FieldJustification:
		return m.Justification()
	case occurrence.FieldOrigin:
		return m.Origin()
	case occurrence.FieldCollector:
		return m.Collector()
	case occurrence.FieldDocumentRef:
		return m.DocumentRef()
	case occurrence.FieldSourceID:
		return m.SourceID()
	case occurrence.FieldPackageID:
		return m.PackageID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OccurrenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case occurrence.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case occurrence.FieldJustification:
		return m.OldJustification(ctx)
	case occurrence.FieldOrigin:
		return m.OldOrigin(ctx)
	case occurrence.FieldCollector:
		return m.OldCollector(ctx)
	case occurrence.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	case occurrence.FieldSourceID:
		return m.OldSourceID(ctx)
	case occurrence.FieldPackageID:
		return m.OldPackageID(ctx)
	}
	return nil, fmt.Errorf("unknown Occurrence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurrenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case occurrence.FieldArtifactID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case occurrence.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case occurrence.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case occurrence.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case occurrence.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	case occurrence.FieldSourceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case occurrence.FieldPackageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	}
	return fmt.Errorf("unknown Occurrence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OccurrenceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OccurrenceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurrenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Occurrence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OccurrenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(occurrence.FieldSourceID) {
		fields = append(fields, occurrence.FieldSourceID)
	}
	if m.FieldCleared(occurrence.FieldPackageID) {
		fields = append(fields, occurrence.FieldPackageID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OccurrenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OccurrenceMutation) ClearField(name string) error {
	switch name {
	case occurrence.FieldSourceID:
		m.ClearSourceID()
		return nil
	case occurrence.FieldPackageID:
		m.ClearPackageID()
		return nil
	}
	return fmt.Errorf("unknown Occurrence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OccurrenceMutation) ResetField(name string) error {
	switch name {
	case occurrence.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case occurrence.FieldJustification:
		m.ResetJustification()
		return nil
	case occurrence.FieldOrigin:
		m.ResetOrigin()
		return nil
	case occurrence.FieldCollector:
		m.ResetCollector()
		return nil
	case occurrence.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	case occurrence.FieldSourceID:
		m.ResetSourceID()
		return nil
	case occurrence.FieldPackageID:
		m.ResetPackageID()
		return nil
	}
	return fmt.Errorf("unknown Occurrence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OccurrenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.artifact != nil {
		edges = append(edges, occurrence.EdgeArtifact)
	}
	if m._package != nil {
		edges = append(edges, occurrence.EdgePackage)
	}
	if m.source != nil {
		edges = append(edges, occurrence.EdgeSource)
	}
	if m.included_in_sboms != nil {
		edges = append(edges, occurrence.EdgeIncludedInSboms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OccurrenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case occurrence.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	case occurrence.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case occurrence.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	case occurrence.EdgeIncludedInSboms:
		ids := make([]ent.Value, 0, len(m.included_in_sboms))
		for id := range m.included_in_sboms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OccurrenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedincluded_in_sboms != nil {
		edges = append(edges, occurrence.EdgeIncludedInSboms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OccurrenceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case occurrence.EdgeIncludedInSboms:
		ids := make([]ent.Value, 0, len(m.removedincluded_in_sboms))
		for id := range m.removedincluded_in_sboms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OccurrenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedartifact {
		edges = append(edges, occurrence.EdgeArtifact)
	}
	if m.cleared_package {
		edges = append(edges, occurrence.EdgePackage)
	}
	if m.clearedsource {
		edges = append(edges, occurrence.EdgeSource)
	}
	if m.clearedincluded_in_sboms {
		edges = append(edges, occurrence.EdgeIncludedInSboms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OccurrenceMutation) EdgeCleared(name string) bool {
	switch name {
	case occurrence.EdgeArtifact:
		return m.clearedartifact
	case occurrence.EdgePackage:
		return m.cleared_package
	case occurrence.EdgeSource:
		return m.clearedsource
	case occurrence.EdgeIncludedInSboms:
		return m.clearedincluded_in_sboms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OccurrenceMutation) ClearEdge(name string) error {
	switch name {
	case occurrence.EdgeArtifact:
		m.ClearArtifact()
		return nil
	case occurrence.EdgePackage:
		m.ClearPackage()
		return nil
	case occurrence.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown Occurrence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OccurrenceMutation) ResetEdge(name string) error {
	switch name {
	case occurrence.EdgeArtifact:
		m.ResetArtifact()
		return nil
	case occurrence.EdgePackage:
		m.ResetPackage()
		return nil
	case occurrence.EdgeSource:
		m.ResetSource()
		return nil
	case occurrence.EdgeIncludedInSboms:
		m.ResetIncludedInSboms()
		return nil
	}
	return fmt.Errorf("unknown Occurrence edge %s", name)
}

// PackageNameMutation represents an operation that mutates the PackageName nodes in the graph.
type PackageNameMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	_type                *string
	namespace            *string
	name                 *string
	clearedFields        map[string]struct{}
	versions             map[uuid.UUID]struct{}
	removedversions      map[uuid.UUID]struct{}
	clearedversions      bool
	has_source_at        map[uuid.UUID]struct{}
	removedhas_source_at map[uuid.UUID]struct{}
	clearedhas_source_at bool
	certification        map[uuid.UUID]struct{}
	removedcertification map[uuid.UUID]struct{}
	clearedcertification bool
	metadata             map[uuid.UUID]struct{}
	removedmetadata      map[uuid.UUID]struct{}
	clearedmetadata      bool
	poc                  map[uuid.UUID]struct{}
	removedpoc           map[uuid.UUID]struct{}
	clearedpoc           bool
	done                 bool
	oldValue             func(context.Context) (*PackageName, error)
	predicates           []predicate.PackageName
}

var _ ent.Mutation = (*PackageNameMutation)(nil)

// packagenameOption allows management of the mutation configuration using functional options.
type packagenameOption func(*PackageNameMutation)

// newPackageNameMutation creates new mutation for the PackageName entity.
func newPackageNameMutation(c config, op Op, opts ...packagenameOption) *PackageNameMutation {
	m := &PackageNameMutation{
		config:        c,
		op:            op,
		typ:           TypePackageName,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageNameID sets the ID field of the mutation.
func withPackageNameID(id uuid.UUID) packagenameOption {
	return func(m *PackageNameMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageName
		)
		m.oldValue = func(ctx context.Context) (*PackageName, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageName.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageName sets the old PackageName of the mutation.
func withPackageName(node *PackageName) packagenameOption {
	return func(m *PackageNameMutation) {
		m.oldValue = func(context.Context) (*PackageName, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageNameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageNameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PackageName entities.
func (m *PackageNameMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageNameMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageNameMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageName.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *PackageNameMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PackageNameMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PackageName entity.
// If the PackageName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNameMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PackageNameMutation) ResetType() {
	m._type = nil
}

// SetNamespace sets the "namespace" field.
func (m *PackageNameMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PackageNameMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the PackageName entity.
// If the PackageName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNameMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PackageNameMutation) ResetNamespace() {
	m.namespace = nil
}

// SetName sets the "name" field.
func (m *PackageNameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PackageNameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PackageName entity.
// If the PackageName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PackageNameMutation) ResetName() {
	m.name = nil
}

// AddVersionIDs adds the "versions" edge to the PackageVersion entity by ids.
func (m *PackageNameMutation) AddVersionIDs(ids ...uuid.UUID) {
	if m.versions == nil {
		m.versions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the PackageVersion entity.
func (m *PackageNameMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the PackageVersion entity was cleared.
func (m *PackageNameMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the PackageVersion entity by IDs.
func (m *PackageNameMutation) RemoveVersionIDs(ids ...uuid.UUID) {
	if m.removedversions == nil {
		m.removedversions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the PackageVersion entity.
func (m *PackageNameMutation) RemovedVersionsIDs() (ids []uuid.UUID) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *PackageNameMutation) VersionsIDs() (ids []uuid.UUID) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *PackageNameMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// AddHasSourceAtIDs adds the "has_source_at" edge to the HasSourceAt entity by ids.
func (m *PackageNameMutation) AddHasSourceAtIDs(ids ...uuid.UUID) {
	if m.has_source_at == nil {
		m.has_source_at = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.has_source_at[ids[i]] = struct{}{}
	}
}

// ClearHasSourceAt clears the "has_source_at" edge to the HasSourceAt entity.
func (m *PackageNameMutation) ClearHasSourceAt() {
	m.clearedhas_source_at = true
}

// HasSourceAtCleared reports if the "has_source_at" edge to the HasSourceAt entity was cleared.
func (m *PackageNameMutation) HasSourceAtCleared() bool {
	return m.clearedhas_source_at
}

// RemoveHasSourceAtIDs removes the "has_source_at" edge to the HasSourceAt entity by IDs.
func (m *PackageNameMutation) RemoveHasSourceAtIDs(ids ...uuid.UUID) {
	if m.removedhas_source_at == nil {
		m.removedhas_source_at = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.has_source_at, ids[i])
		m.removedhas_source_at[ids[i]] = struct{}{}
	}
}

// RemovedHasSourceAt returns the removed IDs of the "has_source_at" edge to the HasSourceAt entity.
func (m *PackageNameMutation) RemovedHasSourceAtIDs() (ids []uuid.UUID) {
	for id := range m.removedhas_source_at {
		ids = append(ids, id)
	}
	return
}

// HasSourceAtIDs returns the "has_source_at" edge IDs in the mutation.
func (m *PackageNameMutation) HasSourceAtIDs() (ids []uuid.UUID) {
	for id := range m.has_source_at {
		ids = append(ids, id)
	}
	return
}

// ResetHasSourceAt resets all changes to the "has_source_at" edge.
func (m *PackageNameMutation) ResetHasSourceAt() {
	m.has_source_at = nil
	m.clearedhas_source_at = false
	m.removedhas_source_at = nil
}

// AddCertificationIDs adds the "certification" edge to the Certification entity by ids.
func (m *PackageNameMutation) AddCertificationIDs(ids ...uuid.UUID) {
	if m.certification == nil {
		m.certification = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.certification[ids[i]] = struct{}{}
	}
}

// ClearCertification clears the "certification" edge to the Certification entity.
func (m *PackageNameMutation) ClearCertification() {
	m.clearedcertification = true
}

// CertificationCleared reports if the "certification" edge to the Certification entity was cleared.
func (m *PackageNameMutation) CertificationCleared() bool {
	return m.clearedcertification
}

// RemoveCertificationIDs removes the "certification" edge to the Certification entity by IDs.
func (m *PackageNameMutation) RemoveCertificationIDs(ids ...uuid.UUID) {
	if m.removedcertification == nil {
		m.removedcertification = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.certification, ids[i])
		m.removedcertification[ids[i]] = struct{}{}
	}
}

// RemovedCertification returns the removed IDs of the "certification" edge to the Certification entity.
func (m *PackageNameMutation) RemovedCertificationIDs() (ids []uuid.UUID) {
	for id := range m.removedcertification {
		ids = append(ids, id)
	}
	return
}

// CertificationIDs returns the "certification" edge IDs in the mutation.
func (m *PackageNameMutation) CertificationIDs() (ids []uuid.UUID) {
	for id := range m.certification {
		ids = append(ids, id)
	}
	return
}

// ResetCertification resets all changes to the "certification" edge.
func (m *PackageNameMutation) ResetCertification() {
	m.certification = nil
	m.clearedcertification = false
	m.removedcertification = nil
}

// AddMetadatumIDs adds the "metadata" edge to the HasMetadata entity by ids.
func (m *PackageNameMutation) AddMetadatumIDs(ids ...uuid.UUID) {
	if m.metadata == nil {
		m.metadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the HasMetadata entity.
func (m *PackageNameMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the HasMetadata entity was cleared.
func (m *PackageNameMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the HasMetadata entity by IDs.
func (m *PackageNameMutation) RemoveMetadatumIDs(ids ...uuid.UUID) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the HasMetadata entity.
func (m *PackageNameMutation) RemovedMetadataIDs() (ids []uuid.UUID) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *PackageNameMutation) MetadataIDs() (ids []uuid.UUID) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *PackageNameMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// AddPocIDs adds the "poc" edge to the PointOfContact entity by ids.
func (m *PackageNameMutation) AddPocIDs(ids ...uuid.UUID) {
	if m.poc == nil {
		m.poc = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.poc[ids[i]] = struct{}{}
	}
}

// ClearPoc clears the "poc" edge to the PointOfContact entity.
func (m *PackageNameMutation) ClearPoc() {
	m.clearedpoc = true
}

// PocCleared reports if the "poc" edge to the PointOfContact entity was cleared.
func (m *PackageNameMutation) PocCleared() bool {
	return m.clearedpoc
}

// RemovePocIDs removes the "poc" edge to the PointOfContact entity by IDs.
func (m *PackageNameMutation) RemovePocIDs(ids ...uuid.UUID) {
	if m.removedpoc == nil {
		m.removedpoc = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.poc, ids[i])
		m.removedpoc[ids[i]] = struct{}{}
	}
}

// RemovedPoc returns the removed IDs of the "poc" edge to the PointOfContact entity.
func (m *PackageNameMutation) RemovedPocIDs() (ids []uuid.UUID) {
	for id := range m.removedpoc {
		ids = append(ids, id)
	}
	return
}

// PocIDs returns the "poc" edge IDs in the mutation.
func (m *PackageNameMutation) PocIDs() (ids []uuid.UUID) {
	for id := range m.poc {
		ids = append(ids, id)
	}
	return
}

// ResetPoc resets all changes to the "poc" edge.
func (m *PackageNameMutation) ResetPoc() {
	m.poc = nil
	m.clearedpoc = false
	m.removedpoc = nil
}

// Where appends a list predicates to the PackageNameMutation builder.
func (m *PackageNameMutation) Where(ps ...predicate.PackageName) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageNameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageNameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageName, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageNameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageNameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageName).
func (m *PackageNameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageNameMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._type != nil {
		fields = append(fields, packagename.FieldType)
	}
	if m.namespace != nil {
		fields = append(fields, packagename.FieldNamespace)
	}
	if m.name != nil {
		fields = append(fields, packagename.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageNameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagename.FieldType:
		return m.GetType()
	case packagename.FieldNamespace:
		return m.Namespace()
	case packagename.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageNameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagename.FieldType:
		return m.OldType(ctx)
	case packagename.FieldNamespace:
		return m.OldNamespace(ctx)
	case packagename.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown PackageName field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagename.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case packagename.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case packagename.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown PackageName field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageNameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageNameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageName numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageNameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageNameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageNameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackageName nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageNameMutation) ResetField(name string) error {
	switch name {
	case packagename.FieldType:
		m.ResetType()
		return nil
	case packagename.FieldNamespace:
		m.ResetNamespace()
		return nil
	case packagename.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PackageName field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageNameMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.versions != nil {
		edges = append(edges, packagename.EdgeVersions)
	}
	if m.has_source_at != nil {
		edges = append(edges, packagename.EdgeHasSourceAt)
	}
	if m.certification != nil {
		edges = append(edges, packagename.EdgeCertification)
	}
	if m.metadata != nil {
		edges = append(edges, packagename.EdgeMetadata)
	}
	if m.poc != nil {
		edges = append(edges, packagename.EdgePoc)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageNameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagename.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case packagename.EdgeHasSourceAt:
		ids := make([]ent.Value, 0, len(m.has_source_at))
		for id := range m.has_source_at {
			ids = append(ids, id)
		}
		return ids
	case packagename.EdgeCertification:
		ids := make([]ent.Value, 0, len(m.certification))
		for id := range m.certification {
			ids = append(ids, id)
		}
		return ids
	case packagename.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case packagename.EdgePoc:
		ids := make([]ent.Value, 0, len(m.poc))
		for id := range m.poc {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageNameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedversions != nil {
		edges = append(edges, packagename.EdgeVersions)
	}
	if m.removedhas_source_at != nil {
		edges = append(edges, packagename.EdgeHasSourceAt)
	}
	if m.removedcertification != nil {
		edges = append(edges, packagename.EdgeCertification)
	}
	if m.removedmetadata != nil {
		edges = append(edges, packagename.EdgeMetadata)
	}
	if m.removedpoc != nil {
		edges = append(edges, packagename.EdgePoc)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageNameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packagename.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	case packagename.EdgeHasSourceAt:
		ids := make([]ent.Value, 0, len(m.removedhas_source_at))
		for id := range m.removedhas_source_at {
			ids = append(ids, id)
		}
		return ids
	case packagename.EdgeCertification:
		ids := make([]ent.Value, 0, len(m.removedcertification))
		for id := range m.removedcertification {
			ids = append(ids, id)
		}
		return ids
	case packagename.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	case packagename.EdgePoc:
		ids := make([]ent.Value, 0, len(m.removedpoc))
		for id := range m.removedpoc {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageNameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedversions {
		edges = append(edges, packagename.EdgeVersions)
	}
	if m.clearedhas_source_at {
		edges = append(edges, packagename.EdgeHasSourceAt)
	}
	if m.clearedcertification {
		edges = append(edges, packagename.EdgeCertification)
	}
	if m.clearedmetadata {
		edges = append(edges, packagename.EdgeMetadata)
	}
	if m.clearedpoc {
		edges = append(edges, packagename.EdgePoc)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageNameMutation) EdgeCleared(name string) bool {
	switch name {
	case packagename.EdgeVersions:
		return m.clearedversions
	case packagename.EdgeHasSourceAt:
		return m.clearedhas_source_at
	case packagename.EdgeCertification:
		return m.clearedcertification
	case packagename.EdgeMetadata:
		return m.clearedmetadata
	case packagename.EdgePoc:
		return m.clearedpoc
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageNameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageName unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageNameMutation) ResetEdge(name string) error {
	switch name {
	case packagename.EdgeVersions:
		m.ResetVersions()
		return nil
	case packagename.EdgeHasSourceAt:
		m.ResetHasSourceAt()
		return nil
	case packagename.EdgeCertification:
		m.ResetCertification()
		return nil
	case packagename.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case packagename.EdgePoc:
		m.ResetPoc()
		return nil
	}
	return fmt.Errorf("unknown PackageName edge %s", name)
}

// PackageVersionMutation represents an operation that mutates the PackageVersion nodes in the graph.
type PackageVersionMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	version                   *string
	subpath                   *string
	qualifiers                *[]model.PackageQualifier
	appendqualifiers          []model.PackageQualifier
	hash                      *string
	clearedFields             map[string]struct{}
	name                      *uuid.UUID
	clearedname               bool
	occurrences               map[uuid.UUID]struct{}
	removedoccurrences        map[uuid.UUID]struct{}
	clearedoccurrences        bool
	sbom                      map[uuid.UUID]struct{}
	removedsbom               map[uuid.UUID]struct{}
	clearedsbom               bool
	vuln                      map[uuid.UUID]struct{}
	removedvuln               map[uuid.UUID]struct{}
	clearedvuln               bool
	vex                       map[uuid.UUID]struct{}
	removedvex                map[uuid.UUID]struct{}
	clearedvex                bool
	has_source_at             map[uuid.UUID]struct{}
	removedhas_source_at      map[uuid.UUID]struct{}
	clearedhas_source_at      bool
	certification             map[uuid.UUID]struct{}
	removedcertification      map[uuid.UUID]struct{}
	clearedcertification      bool
	metadata                  map[uuid.UUID]struct{}
	removedmetadata           map[uuid.UUID]struct{}
	clearedmetadata           bool
	dependency                map[uuid.UUID]struct{}
	removeddependency         map[uuid.UUID]struct{}
	cleareddependency         bool
	dependency_subject        map[uuid.UUID]struct{}
	removeddependency_subject map[uuid.UUID]struct{}
	cleareddependency_subject bool
	included_in_sboms         map[uuid.UUID]struct{}
	removedincluded_in_sboms  map[uuid.UUID]struct{}
	clearedincluded_in_sboms  bool
	pkg_equal_pkg_a           map[uuid.UUID]struct{}
	removedpkg_equal_pkg_a    map[uuid.UUID]struct{}
	clearedpkg_equal_pkg_a    bool
	pkg_equal_pkg_b           map[uuid.UUID]struct{}
	removedpkg_equal_pkg_b    map[uuid.UUID]struct{}
	clearedpkg_equal_pkg_b    bool
	poc                       map[uuid.UUID]struct{}
	removedpoc                map[uuid.UUID]struct{}
	clearedpoc                bool
	certify_legal             map[uuid.UUID]struct{}
	removedcertify_legal      map[uuid.UUID]struct{}
	clearedcertify_legal      bool
	done                      bool
	oldValue                  func(context.Context) (*PackageVersion, error)
	predicates                []predicate.PackageVersion
}

var _ ent.Mutation = (*PackageVersionMutation)(nil)

// packageversionOption allows management of the mutation configuration using functional options.
type packageversionOption func(*PackageVersionMutation)

// newPackageVersionMutation creates new mutation for the PackageVersion entity.
func newPackageVersionMutation(c config, op Op, opts ...packageversionOption) *PackageVersionMutation {
	m := &PackageVersionMutation{
		config:        c,
		op:            op,
		typ:           TypePackageVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageVersionID sets the ID field of the mutation.
func withPackageVersionID(id uuid.UUID) packageversionOption {
	return func(m *PackageVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageVersion
		)
		m.oldValue = func(ctx context.Context) (*PackageVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageVersion sets the old PackageVersion of the mutation.
func withPackageVersion(node *PackageVersion) packageversionOption {
	return func(m *PackageVersionMutation) {
		m.oldValue = func(context.Context) (*PackageVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PackageVersion entities.
func (m *PackageVersionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageVersionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageVersionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameID sets the "name_id" field.
func (m *PackageVersionMutation) SetNameID(u uuid.UUID) {
	m.name = &u
}

// NameID returns the value of the "name_id" field in the mutation.
func (m *PackageVersionMutation) NameID() (r uuid.UUID, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldNameID returns the old "name_id" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldNameID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameID: %w", err)
	}
	return oldValue.NameID, nil
}

// ResetNameID resets all changes to the "name_id" field.
func (m *PackageVersionMutation) ResetNameID() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *PackageVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PackageVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PackageVersionMutation) ResetVersion() {
	m.version = nil
}

// SetSubpath sets the "subpath" field.
func (m *PackageVersionMutation) SetSubpath(s string) {
	m.subpath = &s
}

// Subpath returns the value of the "subpath" field in the mutation.
func (m *PackageVersionMutation) Subpath() (r string, exists bool) {
	v := m.subpath
	if v == nil {
		return
	}
	return *v, true
}

// OldSubpath returns the old "subpath" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldSubpath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubpath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubpath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubpath: %w", err)
	}
	return oldValue.Subpath, nil
}

// ResetSubpath resets all changes to the "subpath" field.
func (m *PackageVersionMutation) ResetSubpath() {
	m.subpath = nil
}

// SetQualifiers sets the "qualifiers" field.
func (m *PackageVersionMutation) SetQualifiers(mq []model.PackageQualifier) {
	m.qualifiers = &mq
	m.appendqualifiers = nil
}

// Qualifiers returns the value of the "qualifiers" field in the mutation.
func (m *PackageVersionMutation) Qualifiers() (r []model.PackageQualifier, exists bool) {
	v := m.qualifiers
	if v == nil {
		return
	}
	return *v, true
}

// OldQualifiers returns the old "qualifiers" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldQualifiers(ctx context.Context) (v []model.PackageQualifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualifiers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualifiers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualifiers: %w", err)
	}
	return oldValue.Qualifiers, nil
}

// AppendQualifiers adds mq to the "qualifiers" field.
func (m *PackageVersionMutation) AppendQualifiers(mq []model.PackageQualifier) {
	m.appendqualifiers = append(m.appendqualifiers, mq...)
}

// AppendedQualifiers returns the list of values that were appended to the "qualifiers" field in this mutation.
func (m *PackageVersionMutation) AppendedQualifiers() ([]model.PackageQualifier, bool) {
	if len(m.appendqualifiers) == 0 {
		return nil, false
	}
	return m.appendqualifiers, true
}

// ClearQualifiers clears the value of the "qualifiers" field.
func (m *PackageVersionMutation) ClearQualifiers() {
	m.qualifiers = nil
	m.appendqualifiers = nil
	m.clearedFields[packageversion.FieldQualifiers] = struct{}{}
}

// QualifiersCleared returns if the "qualifiers" field was cleared in this mutation.
func (m *PackageVersionMutation) QualifiersCleared() bool {
	_, ok := m.clearedFields[packageversion.FieldQualifiers]
	return ok
}

// ResetQualifiers resets all changes to the "qualifiers" field.
func (m *PackageVersionMutation) ResetQualifiers() {
	m.qualifiers = nil
	m.appendqualifiers = nil
	delete(m.clearedFields, packageversion.FieldQualifiers)
}

// SetHash sets the "hash" field.
func (m *PackageVersionMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *PackageVersionMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *PackageVersionMutation) ResetHash() {
	m.hash = nil
}

// ClearName clears the "name" edge to the PackageName entity.
func (m *PackageVersionMutation) ClearName() {
	m.clearedname = true
	m.clearedFields[packageversion.FieldNameID] = struct{}{}
}

// NameCleared reports if the "name" edge to the PackageName entity was cleared.
func (m *PackageVersionMutation) NameCleared() bool {
	return m.clearedname
}

// NameIDs returns the "name" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NameID instead. It exists only for internal usage by the builders.
func (m *PackageVersionMutation) NameIDs() (ids []uuid.UUID) {
	if id := m.name; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetName resets all changes to the "name" edge.
func (m *PackageVersionMutation) ResetName() {
	m.name = nil
	m.clearedname = false
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by ids.
func (m *PackageVersionMutation) AddOccurrenceIDs(ids ...uuid.UUID) {
	if m.occurrences == nil {
		m.occurrences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.occurrences[ids[i]] = struct{}{}
	}
}

// ClearOccurrences clears the "occurrences" edge to the Occurrence entity.
func (m *PackageVersionMutation) ClearOccurrences() {
	m.clearedoccurrences = true
}

// OccurrencesCleared reports if the "occurrences" edge to the Occurrence entity was cleared.
func (m *PackageVersionMutation) OccurrencesCleared() bool {
	return m.clearedoccurrences
}

// RemoveOccurrenceIDs removes the "occurrences" edge to the Occurrence entity by IDs.
func (m *PackageVersionMutation) RemoveOccurrenceIDs(ids ...uuid.UUID) {
	if m.removedoccurrences == nil {
		m.removedoccurrences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.occurrences, ids[i])
		m.removedoccurrences[ids[i]] = struct{}{}
	}
}

// RemovedOccurrences returns the removed IDs of the "occurrences" edge to the Occurrence entity.
func (m *PackageVersionMutation) RemovedOccurrencesIDs() (ids []uuid.UUID) {
	for id := range m.removedoccurrences {
		ids = append(ids, id)
	}
	return
}

// OccurrencesIDs returns the "occurrences" edge IDs in the mutation.
func (m *PackageVersionMutation) OccurrencesIDs() (ids []uuid.UUID) {
	for id := range m.occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetOccurrences resets all changes to the "occurrences" edge.
func (m *PackageVersionMutation) ResetOccurrences() {
	m.occurrences = nil
	m.clearedoccurrences = false
	m.removedoccurrences = nil
}

// AddSbomIDs adds the "sbom" edge to the BillOfMaterials entity by ids.
func (m *PackageVersionMutation) AddSbomIDs(ids ...uuid.UUID) {
	if m.sbom == nil {
		m.sbom = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sbom[ids[i]] = struct{}{}
	}
}

// ClearSbom clears the "sbom" edge to the BillOfMaterials entity.
func (m *PackageVersionMutation) ClearSbom() {
	m.clearedsbom = true
}

// SbomCleared reports if the "sbom" edge to the BillOfMaterials entity was cleared.
func (m *PackageVersionMutation) SbomCleared() bool {
	return m.clearedsbom
}

// RemoveSbomIDs removes the "sbom" edge to the BillOfMaterials entity by IDs.
func (m *PackageVersionMutation) RemoveSbomIDs(ids ...uuid.UUID) {
	if m.removedsbom == nil {
		m.removedsbom = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.sbom, ids[i])
		m.removedsbom[ids[i]] = struct{}{}
	}
}

// RemovedSbom returns the removed IDs of the "sbom" edge to the BillOfMaterials entity.
func (m *PackageVersionMutation) RemovedSbomIDs() (ids []uuid.UUID) {
	for id := range m.removedsbom {
		ids = append(ids, id)
	}
	return
}

// SbomIDs returns the "sbom" edge IDs in the mutation.
func (m *PackageVersionMutation) SbomIDs() (ids []uuid.UUID) {
	for id := range m.sbom {
		ids = append(ids, id)
	}
	return
}

// ResetSbom resets all changes to the "sbom" edge.
func (m *PackageVersionMutation) ResetSbom() {
	m.sbom = nil
	m.clearedsbom = false
	m.removedsbom = nil
}

// AddVulnIDs adds the "vuln" edge to the CertifyVuln entity by ids.
func (m *PackageVersionMutation) AddVulnIDs(ids ...uuid.UUID) {
	if m.vuln == nil {
		m.vuln = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vuln[ids[i]] = struct{}{}
	}
}

// ClearVuln clears the "vuln" edge to the CertifyVuln entity.
func (m *PackageVersionMutation) ClearVuln() {
	m.clearedvuln = true
}

// VulnCleared reports if the "vuln" edge to the CertifyVuln entity was cleared.
func (m *PackageVersionMutation) VulnCleared() bool {
	return m.clearedvuln
}

// RemoveVulnIDs removes the "vuln" edge to the CertifyVuln entity by IDs.
func (m *PackageVersionMutation) RemoveVulnIDs(ids ...uuid.UUID) {
	if m.removedvuln == nil {
		m.removedvuln = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vuln, ids[i])
		m.removedvuln[ids[i]] = struct{}{}
	}
}

// RemovedVuln returns the removed IDs of the "vuln" edge to the CertifyVuln entity.
func (m *PackageVersionMutation) RemovedVulnIDs() (ids []uuid.UUID) {
	for id := range m.removedvuln {
		ids = append(ids, id)
	}
	return
}

// VulnIDs returns the "vuln" edge IDs in the mutation.
func (m *PackageVersionMutation) VulnIDs() (ids []uuid.UUID) {
	for id := range m.vuln {
		ids = append(ids, id)
	}
	return
}

// ResetVuln resets all changes to the "vuln" edge.
func (m *PackageVersionMutation) ResetVuln() {
	m.vuln = nil
	m.clearedvuln = false
	m.removedvuln = nil
}

// AddVexIDs adds the "vex" edge to the CertifyVex entity by ids.
func (m *PackageVersionMutation) AddVexIDs(ids ...uuid.UUID) {
	if m.vex == nil {
		m.vex = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vex[ids[i]] = struct{}{}
	}
}

// ClearVex clears the "vex" edge to the CertifyVex entity.
func (m *PackageVersionMutation) ClearVex() {
	m.clearedvex = true
}

// VexCleared reports if the "vex" edge to the CertifyVex entity was cleared.
func (m *PackageVersionMutation) VexCleared() bool {
	return m.clearedvex
}

// RemoveVexIDs removes the "vex" edge to the CertifyVex entity by IDs.
func (m *PackageVersionMutation) RemoveVexIDs(ids ...uuid.UUID) {
	if m.removedvex == nil {
		m.removedvex = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vex, ids[i])
		m.removedvex[ids[i]] = struct{}{}
	}
}

// RemovedVex returns the removed IDs of the "vex" edge to the CertifyVex entity.
func (m *PackageVersionMutation) RemovedVexIDs() (ids []uuid.UUID) {
	for id := range m.removedvex {
		ids = append(ids, id)
	}
	return
}

// VexIDs returns the "vex" edge IDs in the mutation.
func (m *PackageVersionMutation) VexIDs() (ids []uuid.UUID) {
	for id := range m.vex {
		ids = append(ids, id)
	}
	return
}

// ResetVex resets all changes to the "vex" edge.
func (m *PackageVersionMutation) ResetVex() {
	m.vex = nil
	m.clearedvex = false
	m.removedvex = nil
}

// AddHasSourceAtIDs adds the "has_source_at" edge to the HasSourceAt entity by ids.
func (m *PackageVersionMutation) AddHasSourceAtIDs(ids ...uuid.UUID) {
	if m.has_source_at == nil {
		m.has_source_at = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.has_source_at[ids[i]] = struct{}{}
	}
}

// ClearHasSourceAt clears the "has_source_at" edge to the HasSourceAt entity.
func (m *PackageVersionMutation) ClearHasSourceAt() {
	m.clearedhas_source_at = true
}

// HasSourceAtCleared reports if the "has_source_at" edge to the HasSourceAt entity was cleared.
func (m *PackageVersionMutation) HasSourceAtCleared() bool {
	return m.clearedhas_source_at
}

// RemoveHasSourceAtIDs removes the "has_source_at" edge to the HasSourceAt entity by IDs.
func (m *PackageVersionMutation) RemoveHasSourceAtIDs(ids ...uuid.UUID) {
	if m.removedhas_source_at == nil {
		m.removedhas_source_at = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.has_source_at, ids[i])
		m.removedhas_source_at[ids[i]] = struct{}{}
	}
}

// RemovedHasSourceAt returns the removed IDs of the "has_source_at" edge to the HasSourceAt entity.
func (m *PackageVersionMutation) RemovedHasSourceAtIDs() (ids []uuid.UUID) {
	for id := range m.removedhas_source_at {
		ids = append(ids, id)
	}
	return
}

// HasSourceAtIDs returns the "has_source_at" edge IDs in the mutation.
func (m *PackageVersionMutation) HasSourceAtIDs() (ids []uuid.UUID) {
	for id := range m.has_source_at {
		ids = append(ids, id)
	}
	return
}

// ResetHasSourceAt resets all changes to the "has_source_at" edge.
func (m *PackageVersionMutation) ResetHasSourceAt() {
	m.has_source_at = nil
	m.clearedhas_source_at = false
	m.removedhas_source_at = nil
}

// AddCertificationIDs adds the "certification" edge to the Certification entity by ids.
func (m *PackageVersionMutation) AddCertificationIDs(ids ...uuid.UUID) {
	if m.certification == nil {
		m.certification = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.certification[ids[i]] = struct{}{}
	}
}

// ClearCertification clears the "certification" edge to the Certification entity.
func (m *PackageVersionMutation) ClearCertification() {
	m.clearedcertification = true
}

// CertificationCleared reports if the "certification" edge to the Certification entity was cleared.
func (m *PackageVersionMutation) CertificationCleared() bool {
	return m.clearedcertification
}

// RemoveCertificationIDs removes the "certification" edge to the Certification entity by IDs.
func (m *PackageVersionMutation) RemoveCertificationIDs(ids ...uuid.UUID) {
	if m.removedcertification == nil {
		m.removedcertification = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.certification, ids[i])
		m.removedcertification[ids[i]] = struct{}{}
	}
}

// RemovedCertification returns the removed IDs of the "certification" edge to the Certification entity.
func (m *PackageVersionMutation) RemovedCertificationIDs() (ids []uuid.UUID) {
	for id := range m.removedcertification {
		ids = append(ids, id)
	}
	return
}

// CertificationIDs returns the "certification" edge IDs in the mutation.
func (m *PackageVersionMutation) CertificationIDs() (ids []uuid.UUID) {
	for id := range m.certification {
		ids = append(ids, id)
	}
	return
}

// ResetCertification resets all changes to the "certification" edge.
func (m *PackageVersionMutation) ResetCertification() {
	m.certification = nil
	m.clearedcertification = false
	m.removedcertification = nil
}

// AddMetadatumIDs adds the "metadata" edge to the HasMetadata entity by ids.
func (m *PackageVersionMutation) AddMetadatumIDs(ids ...uuid.UUID) {
	if m.metadata == nil {
		m.metadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the HasMetadata entity.
func (m *PackageVersionMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the HasMetadata entity was cleared.
func (m *PackageVersionMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the HasMetadata entity by IDs.
func (m *PackageVersionMutation) RemoveMetadatumIDs(ids ...uuid.UUID) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the HasMetadata entity.
func (m *PackageVersionMutation) RemovedMetadataIDs() (ids []uuid.UUID) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *PackageVersionMutation) MetadataIDs() (ids []uuid.UUID) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *PackageVersionMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// AddDependencyIDs adds the "dependency" edge to the Dependency entity by ids.
func (m *PackageVersionMutation) AddDependencyIDs(ids ...uuid.UUID) {
	if m.dependency == nil {
		m.dependency = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.dependency[ids[i]] = struct{}{}
	}
}

// ClearDependency clears the "dependency" edge to the Dependency entity.
func (m *PackageVersionMutation) ClearDependency() {
	m.cleareddependency = true
}

// DependencyCleared reports if the "dependency" edge to the Dependency entity was cleared.
func (m *PackageVersionMutation) DependencyCleared() bool {
	return m.cleareddependency
}

// RemoveDependencyIDs removes the "dependency" edge to the Dependency entity by IDs.
func (m *PackageVersionMutation) RemoveDependencyIDs(ids ...uuid.UUID) {
	if m.removeddependency == nil {
		m.removeddependency = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.dependency, ids[i])
		m.removeddependency[ids[i]] = struct{}{}
	}
}

// RemovedDependency returns the removed IDs of the "dependency" edge to the Dependency entity.
func (m *PackageVersionMutation) RemovedDependencyIDs() (ids []uuid.UUID) {
	for id := range m.removeddependency {
		ids = append(ids, id)
	}
	return
}

// DependencyIDs returns the "dependency" edge IDs in the mutation.
func (m *PackageVersionMutation) DependencyIDs() (ids []uuid.UUID) {
	for id := range m.dependency {
		ids = append(ids, id)
	}
	return
}

// ResetDependency resets all changes to the "dependency" edge.
func (m *PackageVersionMutation) ResetDependency() {
	m.dependency = nil
	m.cleareddependency = false
	m.removeddependency = nil
}

// AddDependencySubjectIDs adds the "dependency_subject" edge to the Dependency entity by ids.
func (m *PackageVersionMutation) AddDependencySubjectIDs(ids ...uuid.UUID) {
	if m.dependency_subject == nil {
		m.dependency_subject = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.dependency_subject[ids[i]] = struct{}{}
	}
}

// ClearDependencySubject clears the "dependency_subject" edge to the Dependency entity.
func (m *PackageVersionMutation) ClearDependencySubject() {
	m.cleareddependency_subject = true
}

// DependencySubjectCleared reports if the "dependency_subject" edge to the Dependency entity was cleared.
func (m *PackageVersionMutation) DependencySubjectCleared() bool {
	return m.cleareddependency_subject
}

// RemoveDependencySubjectIDs removes the "dependency_subject" edge to the Dependency entity by IDs.
func (m *PackageVersionMutation) RemoveDependencySubjectIDs(ids ...uuid.UUID) {
	if m.removeddependency_subject == nil {
		m.removeddependency_subject = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.dependency_subject, ids[i])
		m.removeddependency_subject[ids[i]] = struct{}{}
	}
}

// RemovedDependencySubject returns the removed IDs of the "dependency_subject" edge to the Dependency entity.
func (m *PackageVersionMutation) RemovedDependencySubjectIDs() (ids []uuid.UUID) {
	for id := range m.removeddependency_subject {
		ids = append(ids, id)
	}
	return
}

// DependencySubjectIDs returns the "dependency_subject" edge IDs in the mutation.
func (m *PackageVersionMutation) DependencySubjectIDs() (ids []uuid.UUID) {
	for id := range m.dependency_subject {
		ids = append(ids, id)
	}
	return
}

// ResetDependencySubject resets all changes to the "dependency_subject" edge.
func (m *PackageVersionMutation) ResetDependencySubject() {
	m.dependency_subject = nil
	m.cleareddependency_subject = false
	m.removeddependency_subject = nil
}

// AddIncludedInSbomIDs adds the "included_in_sboms" edge to the BillOfMaterials entity by ids.
func (m *PackageVersionMutation) AddIncludedInSbomIDs(ids ...uuid.UUID) {
	if m.included_in_sboms == nil {
		m.included_in_sboms = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.included_in_sboms[ids[i]] = struct{}{}
	}
}

// ClearIncludedInSboms clears the "included_in_sboms" edge to the BillOfMaterials entity.
func (m *PackageVersionMutation) ClearIncludedInSboms() {
	m.clearedincluded_in_sboms = true
}

// IncludedInSbomsCleared reports if the "included_in_sboms" edge to the BillOfMaterials entity was cleared.
func (m *PackageVersionMutation) IncludedInSbomsCleared() bool {
	return m.clearedincluded_in_sboms
}

// RemoveIncludedInSbomIDs removes the "included_in_sboms" edge to the BillOfMaterials entity by IDs.
func (m *PackageVersionMutation) RemoveIncludedInSbomIDs(ids ...uuid.UUID) {
	if m.removedincluded_in_sboms == nil {
		m.removedincluded_in_sboms = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.included_in_sboms, ids[i])
		m.removedincluded_in_sboms[ids[i]] = struct{}{}
	}
}

// RemovedIncludedInSboms returns the removed IDs of the "included_in_sboms" edge to the BillOfMaterials entity.
func (m *PackageVersionMutation) RemovedIncludedInSbomsIDs() (ids []uuid.UUID) {
	for id := range m.removedincluded_in_sboms {
		ids = append(ids, id)
	}
	return
}

// IncludedInSbomsIDs returns the "included_in_sboms" edge IDs in the mutation.
func (m *PackageVersionMutation) IncludedInSbomsIDs() (ids []uuid.UUID) {
	for id := range m.included_in_sboms {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedInSboms resets all changes to the "included_in_sboms" edge.
func (m *PackageVersionMutation) ResetIncludedInSboms() {
	m.included_in_sboms = nil
	m.clearedincluded_in_sboms = false
	m.removedincluded_in_sboms = nil
}

// AddPkgEqualPkgAIDs adds the "pkg_equal_pkg_a" edge to the PkgEqual entity by ids.
func (m *PackageVersionMutation) AddPkgEqualPkgAIDs(ids ...uuid.UUID) {
	if m.pkg_equal_pkg_a == nil {
		m.pkg_equal_pkg_a = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.pkg_equal_pkg_a[ids[i]] = struct{}{}
	}
}

// ClearPkgEqualPkgA clears the "pkg_equal_pkg_a" edge to the PkgEqual entity.
func (m *PackageVersionMutation) ClearPkgEqualPkgA() {
	m.clearedpkg_equal_pkg_a = true
}

// PkgEqualPkgACleared reports if the "pkg_equal_pkg_a" edge to the PkgEqual entity was cleared.
func (m *PackageVersionMutation) PkgEqualPkgACleared() bool {
	return m.clearedpkg_equal_pkg_a
}

// RemovePkgEqualPkgAIDs removes the "pkg_equal_pkg_a" edge to the PkgEqual entity by IDs.
func (m *PackageVersionMutation) RemovePkgEqualPkgAIDs(ids ...uuid.UUID) {
	if m.removedpkg_equal_pkg_a == nil {
		m.removedpkg_equal_pkg_a = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.pkg_equal_pkg_a, ids[i])
		m.removedpkg_equal_pkg_a[ids[i]] = struct{}{}
	}
}

// RemovedPkgEqualPkgA returns the removed IDs of the "pkg_equal_pkg_a" edge to the PkgEqual entity.
func (m *PackageVersionMutation) RemovedPkgEqualPkgAIDs() (ids []uuid.UUID) {
	for id := range m.removedpkg_equal_pkg_a {
		ids = append(ids, id)
	}
	return
}

// PkgEqualPkgAIDs returns the "pkg_equal_pkg_a" edge IDs in the mutation.
func (m *PackageVersionMutation) PkgEqualPkgAIDs() (ids []uuid.UUID) {
	for id := range m.pkg_equal_pkg_a {
		ids = append(ids, id)
	}
	return
}

// ResetPkgEqualPkgA resets all changes to the "pkg_equal_pkg_a" edge.
func (m *PackageVersionMutation) ResetPkgEqualPkgA() {
	m.pkg_equal_pkg_a = nil
	m.clearedpkg_equal_pkg_a = false
	m.removedpkg_equal_pkg_a = nil
}

// AddPkgEqualPkgBIDs adds the "pkg_equal_pkg_b" edge to the PkgEqual entity by ids.
func (m *PackageVersionMutation) AddPkgEqualPkgBIDs(ids ...uuid.UUID) {
	if m.pkg_equal_pkg_b == nil {
		m.pkg_equal_pkg_b = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.pkg_equal_pkg_b[ids[i]] = struct{}{}
	}
}

// ClearPkgEqualPkgB clears the "pkg_equal_pkg_b" edge to the PkgEqual entity.
func (m *PackageVersionMutation) ClearPkgEqualPkgB() {
	m.clearedpkg_equal_pkg_b = true
}

// PkgEqualPkgBCleared reports if the "pkg_equal_pkg_b" edge to the PkgEqual entity was cleared.
func (m *PackageVersionMutation) PkgEqualPkgBCleared() bool {
	return m.clearedpkg_equal_pkg_b
}

// RemovePkgEqualPkgBIDs removes the "pkg_equal_pkg_b" edge to the PkgEqual entity by IDs.
func (m *PackageVersionMutation) RemovePkgEqualPkgBIDs(ids ...uuid.UUID) {
	if m.removedpkg_equal_pkg_b == nil {
		m.removedpkg_equal_pkg_b = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.pkg_equal_pkg_b, ids[i])
		m.removedpkg_equal_pkg_b[ids[i]] = struct{}{}
	}
}

// RemovedPkgEqualPkgB returns the removed IDs of the "pkg_equal_pkg_b" edge to the PkgEqual entity.
func (m *PackageVersionMutation) RemovedPkgEqualPkgBIDs() (ids []uuid.UUID) {
	for id := range m.removedpkg_equal_pkg_b {
		ids = append(ids, id)
	}
	return
}

// PkgEqualPkgBIDs returns the "pkg_equal_pkg_b" edge IDs in the mutation.
func (m *PackageVersionMutation) PkgEqualPkgBIDs() (ids []uuid.UUID) {
	for id := range m.pkg_equal_pkg_b {
		ids = append(ids, id)
	}
	return
}

// ResetPkgEqualPkgB resets all changes to the "pkg_equal_pkg_b" edge.
func (m *PackageVersionMutation) ResetPkgEqualPkgB() {
	m.pkg_equal_pkg_b = nil
	m.clearedpkg_equal_pkg_b = false
	m.removedpkg_equal_pkg_b = nil
}

// AddPocIDs adds the "poc" edge to the PointOfContact entity by ids.
func (m *PackageVersionMutation) AddPocIDs(ids ...uuid.UUID) {
	if m.poc == nil {
		m.poc = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.poc[ids[i]] = struct{}{}
	}
}

// ClearPoc clears the "poc" edge to the PointOfContact entity.
func (m *PackageVersionMutation) ClearPoc() {
	m.clearedpoc = true
}

// PocCleared reports if the "poc" edge to the PointOfContact entity was cleared.
func (m *PackageVersionMutation) PocCleared() bool {
	return m.clearedpoc
}

// RemovePocIDs removes the "poc" edge to the PointOfContact entity by IDs.
func (m *PackageVersionMutation) RemovePocIDs(ids ...uuid.UUID) {
	if m.removedpoc == nil {
		m.removedpoc = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.poc, ids[i])
		m.removedpoc[ids[i]] = struct{}{}
	}
}

// RemovedPoc returns the removed IDs of the "poc" edge to the PointOfContact entity.
func (m *PackageVersionMutation) RemovedPocIDs() (ids []uuid.UUID) {
	for id := range m.removedpoc {
		ids = append(ids, id)
	}
	return
}

// PocIDs returns the "poc" edge IDs in the mutation.
func (m *PackageVersionMutation) PocIDs() (ids []uuid.UUID) {
	for id := range m.poc {
		ids = append(ids, id)
	}
	return
}

// ResetPoc resets all changes to the "poc" edge.
func (m *PackageVersionMutation) ResetPoc() {
	m.poc = nil
	m.clearedpoc = false
	m.removedpoc = nil
}

// AddCertifyLegalIDs adds the "certify_legal" edge to the CertifyLegal entity by ids.
func (m *PackageVersionMutation) AddCertifyLegalIDs(ids ...uuid.UUID) {
	if m.certify_legal == nil {
		m.certify_legal = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.certify_legal[ids[i]] = struct{}{}
	}
}

// ClearCertifyLegal clears the "certify_legal" edge to the CertifyLegal entity.
func (m *PackageVersionMutation) ClearCertifyLegal() {
	m.clearedcertify_legal = true
}

// CertifyLegalCleared reports if the "certify_legal" edge to the CertifyLegal entity was cleared.
func (m *PackageVersionMutation) CertifyLegalCleared() bool {
	return m.clearedcertify_legal
}

// RemoveCertifyLegalIDs removes the "certify_legal" edge to the CertifyLegal entity by IDs.
func (m *PackageVersionMutation) RemoveCertifyLegalIDs(ids ...uuid.UUID) {
	if m.removedcertify_legal == nil {
		m.removedcertify_legal = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.certify_legal, ids[i])
		m.removedcertify_legal[ids[i]] = struct{}{}
	}
}

// RemovedCertifyLegal returns the removed IDs of the "certify_legal" edge to the CertifyLegal entity.
func (m *PackageVersionMutation) RemovedCertifyLegalIDs() (ids []uuid.UUID) {
	for id := range m.removedcertify_legal {
		ids = append(ids, id)
	}
	return
}

// CertifyLegalIDs returns the "certify_legal" edge IDs in the mutation.
func (m *PackageVersionMutation) CertifyLegalIDs() (ids []uuid.UUID) {
	for id := range m.certify_legal {
		ids = append(ids, id)
	}
	return
}

// ResetCertifyLegal resets all changes to the "certify_legal" edge.
func (m *PackageVersionMutation) ResetCertifyLegal() {
	m.certify_legal = nil
	m.clearedcertify_legal = false
	m.removedcertify_legal = nil
}

// Where appends a list predicates to the PackageVersionMutation builder.
func (m *PackageVersionMutation) Where(ps ...predicate.PackageVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageVersion).
func (m *PackageVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageVersionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, packageversion.FieldNameID)
	}
	if m.version != nil {
		fields = append(fields, packageversion.FieldVersion)
	}
	if m.subpath != nil {
		fields = append(fields, packageversion.FieldSubpath)
	}
	if m.qualifiers != nil {
		fields = append(fields, packageversion.FieldQualifiers)
	}
	if m.hash != nil {
		fields = append(fields, packageversion.FieldHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packageversion.FieldNameID:
		return m.NameID()
	case packageversion.FieldVersion:
		return m.Version()
	case packageversion.FieldSubpath:
		return m.Subpath()
	case packageversion.FieldQualifiers:
		return m.Qualifiers()
	case packageversion.FieldHash:
		return m.Hash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packageversion.FieldNameID:
		return m.OldNameID(ctx)
	case packageversion.FieldVersion:
		return m.OldVersion(ctx)
	case packageversion.FieldSubpath:
		return m.OldSubpath(ctx)
	case packageversion.FieldQualifiers:
		return m.OldQualifiers(ctx)
	case packageversion.FieldHash:
		return m.OldHash(ctx)
	}
	return nil, fmt.Errorf("unknown PackageVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packageversion.FieldNameID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameID(v)
		return nil
	case packageversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case packageversion.FieldSubpath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubpath(v)
		return nil
	case packageversion.FieldQualifiers:
		v, ok := value.([]model.PackageQualifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualifiers(v)
		return nil
	case packageversion.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	}
	return fmt.Errorf("unknown PackageVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageVersionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageVersionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(packageversion.FieldQualifiers) {
		fields = append(fields, packageversion.FieldQualifiers)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageVersionMutation) ClearField(name string) error {
	switch name {
	case packageversion.FieldQualifiers:
		m.ClearQualifiers()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageVersionMutation) ResetField(name string) error {
	switch name {
	case packageversion.FieldNameID:
		m.ResetNameID()
		return nil
	case packageversion.FieldVersion:
		m.ResetVersion()
		return nil
	case packageversion.FieldSubpath:
		m.ResetSubpath()
		return nil
	case packageversion.FieldQualifiers:
		m.ResetQualifiers()
		return nil
	case packageversion.FieldHash:
		m.ResetHash()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.name != nil {
		edges = append(edges, packageversion.EdgeName)
	}
	if m.occurrences != nil {
		edges = append(edges, packageversion.EdgeOccurrences)
	}
	if m.sbom != nil {
		edges = append(edges, packageversion.EdgeSbom)
	}
	if m.vuln != nil {
		edges = append(edges, packageversion.EdgeVuln)
	}
	if m.vex != nil {
		edges = append(edges, packageversion.EdgeVex)
	}
	if m.has_source_at != nil {
		edges = append(edges, packageversion.EdgeHasSourceAt)
	}
	if m.certification != nil {
		edges = append(edges, packageversion.EdgeCertification)
	}
	if m.metadata != nil {
		edges = append(edges, packageversion.EdgeMetadata)
	}
	if m.dependency != nil {
		edges = append(edges, packageversion.EdgeDependency)
	}
	if m.dependency_subject != nil {
		edges = append(edges, packageversion.EdgeDependencySubject)
	}
	if m.included_in_sboms != nil {
		edges = append(edges, packageversion.EdgeIncludedInSboms)
	}
	if m.pkg_equal_pkg_a != nil {
		edges = append(edges, packageversion.EdgePkgEqualPkgA)
	}
	if m.pkg_equal_pkg_b != nil {
		edges = append(edges, packageversion.EdgePkgEqualPkgB)
	}
	if m.poc != nil {
		edges = append(edges, packageversion.EdgePoc)
	}
	if m.certify_legal != nil {
		edges = append(edges, packageversion.EdgeCertifyLegal)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packageversion.EdgeName:
		if id := m.name; id != nil {
			return []ent.Value{*id}
		}
	case packageversion.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.occurrences))
		for id := range m.occurrences {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeSbom:
		ids := make([]ent.Value, 0, len(m.sbom))
		for id := range m.sbom {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeVuln:
		ids := make([]ent.Value, 0, len(m.vuln))
		for id := range m.vuln {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeVex:
		ids := make([]ent.Value, 0, len(m.vex))
		for id := range m.vex {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeHasSourceAt:
		ids := make([]ent.Value, 0, len(m.has_source_at))
		for id := range m.has_source_at {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeCertification:
		ids := make([]ent.Value, 0, len(m.certification))
		for id := range m.certification {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeDependency:
		ids := make([]ent.Value, 0, len(m.dependency))
		for id := range m.dependency {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeDependencySubject:
		ids := make([]ent.Value, 0, len(m.dependency_subject))
		for id := range m.dependency_subject {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeIncludedInSboms:
		ids := make([]ent.Value, 0, len(m.included_in_sboms))
		for id := range m.included_in_sboms {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgePkgEqualPkgA:
		ids := make([]ent.Value, 0, len(m.pkg_equal_pkg_a))
		for id := range m.pkg_equal_pkg_a {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgePkgEqualPkgB:
		ids := make([]ent.Value, 0, len(m.pkg_equal_pkg_b))
		for id := range m.pkg_equal_pkg_b {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgePoc:
		ids := make([]ent.Value, 0, len(m.poc))
		for id := range m.poc {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeCertifyLegal:
		ids := make([]ent.Value, 0, len(m.certify_legal))
		for id := range m.certify_legal {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedoccurrences != nil {
		edges = append(edges, packageversion.EdgeOccurrences)
	}
	if m.removedsbom != nil {
		edges = append(edges, packageversion.EdgeSbom)
	}
	if m.removedvuln != nil {
		edges = append(edges, packageversion.EdgeVuln)
	}
	if m.removedvex != nil {
		edges = append(edges, packageversion.EdgeVex)
	}
	if m.removedhas_source_at != nil {
		edges = append(edges, packageversion.EdgeHasSourceAt)
	}
	if m.removedcertification != nil {
		edges = append(edges, packageversion.EdgeCertification)
	}
	if m.removedmetadata != nil {
		edges = append(edges, packageversion.EdgeMetadata)
	}
	if m.removeddependency != nil {
		edges = append(edges, packageversion.EdgeDependency)
	}
	if m.removeddependency_subject != nil {
		edges = append(edges, packageversion.EdgeDependencySubject)
	}
	if m.removedincluded_in_sboms != nil {
		edges = append(edges, packageversion.EdgeIncludedInSboms)
	}
	if m.removedpkg_equal_pkg_a != nil {
		edges = append(edges, packageversion.EdgePkgEqualPkgA)
	}
	if m.removedpkg_equal_pkg_b != nil {
		edges = append(edges, packageversion.EdgePkgEqualPkgB)
	}
	if m.removedpoc != nil {
		edges = append(edges, packageversion.EdgePoc)
	}
	if m.removedcertify_legal != nil {
		edges = append(edges, packageversion.EdgeCertifyLegal)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageVersionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packageversion.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.removedoccurrences))
		for id := range m.removedoccurrences {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeSbom:
		ids := make([]ent.Value, 0, len(m.removedsbom))
		for id := range m.removedsbom {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeVuln:
		ids := make([]ent.Value, 0, len(m.removedvuln))
		for id := range m.removedvuln {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeVex:
		ids := make([]ent.Value, 0, len(m.removedvex))
		for id := range m.removedvex {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeHasSourceAt:
		ids := make([]ent.Value, 0, len(m.removedhas_source_at))
		for id := range m.removedhas_source_at {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeCertification:
		ids := make([]ent.Value, 0, len(m.removedcertification))
		for id := range m.removedcertification {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeDependency:
		ids := make([]ent.Value, 0, len(m.removeddependency))
		for id := range m.removeddependency {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeDependencySubject:
		ids := make([]ent.Value, 0, len(m.removeddependency_subject))
		for id := range m.removeddependency_subject {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeIncludedInSboms:
		ids := make([]ent.Value, 0, len(m.removedincluded_in_sboms))
		for id := range m.removedincluded_in_sboms {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgePkgEqualPkgA:
		ids := make([]ent.Value, 0, len(m.removedpkg_equal_pkg_a))
		for id := range m.removedpkg_equal_pkg_a {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgePkgEqualPkgB:
		ids := make([]ent.Value, 0, len(m.removedpkg_equal_pkg_b))
		for id := range m.removedpkg_equal_pkg_b {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgePoc:
		ids := make([]ent.Value, 0, len(m.removedpoc))
		for id := range m.removedpoc {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeCertifyLegal:
		ids := make([]ent.Value, 0, len(m.removedcertify_legal))
		for id := range m.removedcertify_legal {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedname {
		edges = append(edges, packageversion.EdgeName)
	}
	if m.clearedoccurrences {
		edges = append(edges, packageversion.EdgeOccurrences)
	}
	if m.clearedsbom {
		edges = append(edges, packageversion.EdgeSbom)
	}
	if m.clearedvuln {
		edges = append(edges, packageversion.EdgeVuln)
	}
	if m.clearedvex {
		edges = append(edges, packageversion.EdgeVex)
	}
	if m.clearedhas_source_at {
		edges = append(edges, packageversion.EdgeHasSourceAt)
	}
	if m.clearedcertification {
		edges = append(edges, packageversion.EdgeCertification)
	}
	if m.clearedmetadata {
		edges = append(edges, packageversion.EdgeMetadata)
	}
	if m.cleareddependency {
		edges = append(edges, packageversion.EdgeDependency)
	}
	if m.cleareddependency_subject {
		edges = append(edges, packageversion.EdgeDependencySubject)
	}
	if m.clearedincluded_in_sboms {
		edges = append(edges, packageversion.EdgeIncludedInSboms)
	}
	if m.clearedpkg_equal_pkg_a {
		edges = append(edges, packageversion.EdgePkgEqualPkgA)
	}
	if m.clearedpkg_equal_pkg_b {
		edges = append(edges, packageversion.EdgePkgEqualPkgB)
	}
	if m.clearedpoc {
		edges = append(edges, packageversion.EdgePoc)
	}
	if m.clearedcertify_legal {
		edges = append(edges, packageversion.EdgeCertifyLegal)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case packageversion.EdgeName:
		return m.clearedname
	case packageversion.EdgeOccurrences:
		return m.clearedoccurrences
	case packageversion.EdgeSbom:
		return m.clearedsbom
	case packageversion.EdgeVuln:
		return m.clearedvuln
	case packageversion.EdgeVex:
		return m.clearedvex
	case packageversion.EdgeHasSourceAt:
		return m.clearedhas_source_at
	case packageversion.EdgeCertification:
		return m.clearedcertification
	case packageversion.EdgeMetadata:
		return m.clearedmetadata
	case packageversion.EdgeDependency:
		return m.cleareddependency
	case packageversion.EdgeDependencySubject:
		return m.cleareddependency_subject
	case packageversion.EdgeIncludedInSboms:
		return m.clearedincluded_in_sboms
	case packageversion.EdgePkgEqualPkgA:
		return m.clearedpkg_equal_pkg_a
	case packageversion.EdgePkgEqualPkgB:
		return m.clearedpkg_equal_pkg_b
	case packageversion.EdgePoc:
		return m.clearedpoc
	case packageversion.EdgeCertifyLegal:
		return m.clearedcertify_legal
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageVersionMutation) ClearEdge(name string) error {
	switch name {
	case packageversion.EdgeName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageVersionMutation) ResetEdge(name string) error {
	switch name {
	case packageversion.EdgeName:
		m.ResetName()
		return nil
	case packageversion.EdgeOccurrences:
		m.ResetOccurrences()
		return nil
	case packageversion.EdgeSbom:
		m.ResetSbom()
		return nil
	case packageversion.EdgeVuln:
		m.ResetVuln()
		return nil
	case packageversion.EdgeVex:
		m.ResetVex()
		return nil
	case packageversion.EdgeHasSourceAt:
		m.ResetHasSourceAt()
		return nil
	case packageversion.EdgeCertification:
		m.ResetCertification()
		return nil
	case packageversion.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case packageversion.EdgeDependency:
		m.ResetDependency()
		return nil
	case packageversion.EdgeDependencySubject:
		m.ResetDependencySubject()
		return nil
	case packageversion.EdgeIncludedInSboms:
		m.ResetIncludedInSboms()
		return nil
	case packageversion.EdgePkgEqualPkgA:
		m.ResetPkgEqualPkgA()
		return nil
	case packageversion.EdgePkgEqualPkgB:
		m.ResetPkgEqualPkgB()
		return nil
	case packageversion.EdgePoc:
		m.ResetPoc()
		return nil
	case packageversion.EdgeCertifyLegal:
		m.ResetCertifyLegal()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion edge %s", name)
}

// PkgEqualMutation represents an operation that mutates the PkgEqual nodes in the graph.
type PkgEqualMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	origin           *string
	collector        *string
	document_ref     *string
	justification    *string
	packages_hash    *string
	clearedFields    map[string]struct{}
	package_a        *uuid.UUID
	clearedpackage_a bool
	package_b        *uuid.UUID
	clearedpackage_b bool
	done             bool
	oldValue         func(context.Context) (*PkgEqual, error)
	predicates       []predicate.PkgEqual
}

var _ ent.Mutation = (*PkgEqualMutation)(nil)

// pkgequalOption allows management of the mutation configuration using functional options.
type pkgequalOption func(*PkgEqualMutation)

// newPkgEqualMutation creates new mutation for the PkgEqual entity.
func newPkgEqualMutation(c config, op Op, opts ...pkgequalOption) *PkgEqualMutation {
	m := &PkgEqualMutation{
		config:        c,
		op:            op,
		typ:           TypePkgEqual,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPkgEqualID sets the ID field of the mutation.
func withPkgEqualID(id uuid.UUID) pkgequalOption {
	return func(m *PkgEqualMutation) {
		var (
			err   error
			once  sync.Once
			value *PkgEqual
		)
		m.oldValue = func(ctx context.Context) (*PkgEqual, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PkgEqual.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPkgEqual sets the old PkgEqual of the mutation.
func withPkgEqual(node *PkgEqual) pkgequalOption {
	return func(m *PkgEqualMutation) {
		m.oldValue = func(context.Context) (*PkgEqual, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PkgEqualMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PkgEqualMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PkgEqual entities.
func (m *PkgEqualMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PkgEqualMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PkgEqualMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PkgEqual.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPkgID sets the "pkg_id" field.
func (m *PkgEqualMutation) SetPkgID(u uuid.UUID) {
	m.package_a = &u
}

// PkgID returns the value of the "pkg_id" field in the mutation.
func (m *PkgEqualMutation) PkgID() (r uuid.UUID, exists bool) {
	v := m.package_a
	if v == nil {
		return
	}
	return *v, true
}

// OldPkgID returns the old "pkg_id" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldPkgID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkgID: %w", err)
	}
	return oldValue.PkgID, nil
}

// ResetPkgID resets all changes to the "pkg_id" field.
func (m *PkgEqualMutation) ResetPkgID() {
	m.package_a = nil
}

// SetEqualPkgID sets the "equal_pkg_id" field.
func (m *PkgEqualMutation) SetEqualPkgID(u uuid.UUID) {
	m.package_b = &u
}

// EqualPkgID returns the value of the "equal_pkg_id" field in the mutation.
func (m *PkgEqualMutation) EqualPkgID() (r uuid.UUID, exists bool) {
	v := m.package_b
	if v == nil {
		return
	}
	return *v, true
}

// OldEqualPkgID returns the old "equal_pkg_id" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldEqualPkgID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEqualPkgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEqualPkgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEqualPkgID: %w", err)
	}
	return oldValue.EqualPkgID, nil
}

// ResetEqualPkgID resets all changes to the "equal_pkg_id" field.
func (m *PkgEqualMutation) ResetEqualPkgID() {
	m.package_b = nil
}

// SetOrigin sets the "origin" field.
func (m *PkgEqualMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *PkgEqualMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *PkgEqualMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *PkgEqualMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *PkgEqualMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *PkgEqualMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *PkgEqualMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *PkgEqualMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *PkgEqualMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// SetJustification sets the "justification" field.
func (m *PkgEqualMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *PkgEqualMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *PkgEqualMutation) ResetJustification() {
	m.justification = nil
}

// SetPackagesHash sets the "packages_hash" field.
func (m *PkgEqualMutation) SetPackagesHash(s string) {
	m.packages_hash = &s
}

// PackagesHash returns the value of the "packages_hash" field in the mutation.
func (m *PkgEqualMutation) PackagesHash() (r string, exists bool) {
	v := m.packages_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPackagesHash returns the old "packages_hash" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldPackagesHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackagesHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackagesHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackagesHash: %w", err)
	}
	return oldValue.PackagesHash, nil
}

// ResetPackagesHash resets all changes to the "packages_hash" field.
func (m *PkgEqualMutation) ResetPackagesHash() {
	m.packages_hash = nil
}

// SetPackageAID sets the "package_a" edge to the PackageVersion entity by id.
func (m *PkgEqualMutation) SetPackageAID(id uuid.UUID) {
	m.package_a = &id
}

// ClearPackageA clears the "package_a" edge to the PackageVersion entity.
func (m *PkgEqualMutation) ClearPackageA() {
	m.clearedpackage_a = true
	m.clearedFields[pkgequal.FieldPkgID] = struct{}{}
}

// PackageACleared reports if the "package_a" edge to the PackageVersion entity was cleared.
func (m *PkgEqualMutation) PackageACleared() bool {
	return m.clearedpackage_a
}

// PackageAID returns the "package_a" edge ID in the mutation.
func (m *PkgEqualMutation) PackageAID() (id uuid.UUID, exists bool) {
	if m.package_a != nil {
		return *m.package_a, true
	}
	return
}

// PackageAIDs returns the "package_a" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageAID instead. It exists only for internal usage by the builders.
func (m *PkgEqualMutation) PackageAIDs() (ids []uuid.UUID) {
	if id := m.package_a; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackageA resets all changes to the "package_a" edge.
func (m *PkgEqualMutation) ResetPackageA() {
	m.package_a = nil
	m.clearedpackage_a = false
}

// SetPackageBID sets the "package_b" edge to the PackageVersion entity by id.
func (m *PkgEqualMutation) SetPackageBID(id uuid.UUID) {
	m.package_b = &id
}

// ClearPackageB clears the "package_b" edge to the PackageVersion entity.
func (m *PkgEqualMutation) ClearPackageB() {
	m.clearedpackage_b = true
	m.clearedFields[pkgequal.FieldEqualPkgID] = struct{}{}
}

// PackageBCleared reports if the "package_b" edge to the PackageVersion entity was cleared.
func (m *PkgEqualMutation) PackageBCleared() bool {
	return m.clearedpackage_b
}

// PackageBID returns the "package_b" edge ID in the mutation.
func (m *PkgEqualMutation) PackageBID() (id uuid.UUID, exists bool) {
	if m.package_b != nil {
		return *m.package_b, true
	}
	return
}

// PackageBIDs returns the "package_b" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageBID instead. It exists only for internal usage by the builders.
func (m *PkgEqualMutation) PackageBIDs() (ids []uuid.UUID) {
	if id := m.package_b; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackageB resets all changes to the "package_b" edge.
func (m *PkgEqualMutation) ResetPackageB() {
	m.package_b = nil
	m.clearedpackage_b = false
}

// Where appends a list predicates to the PkgEqualMutation builder.
func (m *PkgEqualMutation) Where(ps ...predicate.PkgEqual) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PkgEqualMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PkgEqualMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PkgEqual, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PkgEqualMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PkgEqualMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PkgEqual).
func (m *PkgEqualMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PkgEqualMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.package_a != nil {
		fields = append(fields, pkgequal.FieldPkgID)
	}
	if m.package_b != nil {
		fields = append(fields, pkgequal.FieldEqualPkgID)
	}
	if m.origin != nil {
		fields = append(fields, pkgequal.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, pkgequal.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, pkgequal.FieldDocumentRef)
	}
	if m.justification != nil {
		fields = append(fields, pkgequal.FieldJustification)
	}
	if m.packages_hash != nil {
		fields = append(fields, pkgequal.FieldPackagesHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PkgEqualMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pkgequal.FieldPkgID:
		return m.PkgID()
	case pkgequal.FieldEqualPkgID:
		return m.EqualPkgID()
	case pkgequal.FieldOrigin:
		return m.Origin()
	case pkgequal.FieldCollector:
		return m.Collector()
	case pkgequal.FieldDocumentRef:
		return m.DocumentRef()
	case pkgequal.FieldJustification:
		return m.Justification()
	case pkgequal.FieldPackagesHash:
		return m.PackagesHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PkgEqualMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pkgequal.FieldPkgID:
		return m.OldPkgID(ctx)
	case pkgequal.FieldEqualPkgID:
		return m.OldEqualPkgID(ctx)
	case pkgequal.FieldOrigin:
		return m.OldOrigin(ctx)
	case pkgequal.FieldCollector:
		return m.OldCollector(ctx)
	case pkgequal.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	case pkgequal.FieldJustification:
		return m.OldJustification(ctx)
	case pkgequal.FieldPackagesHash:
		return m.OldPackagesHash(ctx)
	}
	return nil, fmt.Errorf("unknown PkgEqual field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PkgEqualMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pkgequal.FieldPkgID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkgID(v)
		return nil
	case pkgequal.FieldEqualPkgID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEqualPkgID(v)
		return nil
	case pkgequal.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case pkgequal.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case pkgequal.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	case pkgequal.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case pkgequal.FieldPackagesHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackagesHash(v)
		return nil
	}
	return fmt.Errorf("unknown PkgEqual field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PkgEqualMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PkgEqualMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PkgEqualMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PkgEqual numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PkgEqualMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PkgEqualMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PkgEqualMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PkgEqual nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PkgEqualMutation) ResetField(name string) error {
	switch name {
	case pkgequal.FieldPkgID:
		m.ResetPkgID()
		return nil
	case pkgequal.FieldEqualPkgID:
		m.ResetEqualPkgID()
		return nil
	case pkgequal.FieldOrigin:
		m.ResetOrigin()
		return nil
	case pkgequal.FieldCollector:
		m.ResetCollector()
		return nil
	case pkgequal.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	case pkgequal.FieldJustification:
		m.ResetJustification()
		return nil
	case pkgequal.FieldPackagesHash:
		m.ResetPackagesHash()
		return nil
	}
	return fmt.Errorf("unknown PkgEqual field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PkgEqualMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.package_a != nil {
		edges = append(edges, pkgequal.EdgePackageA)
	}
	if m.package_b != nil {
		edges = append(edges, pkgequal.EdgePackageB)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PkgEqualMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pkgequal.EdgePackageA:
		if id := m.package_a; id != nil {
			return []ent.Value{*id}
		}
	case pkgequal.EdgePackageB:
		if id := m.package_b; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PkgEqualMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PkgEqualMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PkgEqualMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpackage_a {
		edges = append(edges, pkgequal.EdgePackageA)
	}
	if m.clearedpackage_b {
		edges = append(edges, pkgequal.EdgePackageB)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PkgEqualMutation) EdgeCleared(name string) bool {
	switch name {
	case pkgequal.EdgePackageA:
		return m.clearedpackage_a
	case pkgequal.EdgePackageB:
		return m.clearedpackage_b
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PkgEqualMutation) ClearEdge(name string) error {
	switch name {
	case pkgequal.EdgePackageA:
		m.ClearPackageA()
		return nil
	case pkgequal.EdgePackageB:
		m.ClearPackageB()
		return nil
	}
	return fmt.Errorf("unknown PkgEqual unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PkgEqualMutation) ResetEdge(name string) error {
	switch name {
	case pkgequal.EdgePackageA:
		m.ResetPackageA()
		return nil
	case pkgequal.EdgePackageB:
		m.ResetPackageB()
		return nil
	}
	return fmt.Errorf("unknown PkgEqual edge %s", name)
}

// PointOfContactMutation represents an operation that mutates the PointOfContact nodes in the graph.
type PointOfContactMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	email                  *string
	info                   *string
	since                  *time.Time
	justification          *string
	origin                 *string
	collector              *string
	document_ref           *string
	clearedFields          map[string]struct{}
	source                 *uuid.UUID
	clearedsource          bool
	package_version        *uuid.UUID
	clearedpackage_version bool
	all_versions           *uuid.UUID
	clearedall_versions    bool
	artifact               *uuid.UUID
	clearedartifact        bool
	done                   bool
	oldValue               func(context.Context) (*PointOfContact, error)
	predicates             []predicate.PointOfContact
}

var _ ent.Mutation = (*PointOfContactMutation)(nil)

// pointofcontactOption allows management of the mutation configuration using functional options.
type pointofcontactOption func(*PointOfContactMutation)

// newPointOfContactMutation creates new mutation for the PointOfContact entity.
func newPointOfContactMutation(c config, op Op, opts ...pointofcontactOption) *PointOfContactMutation {
	m := &PointOfContactMutation{
		config:        c,
		op:            op,
		typ:           TypePointOfContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPointOfContactID sets the ID field of the mutation.
func withPointOfContactID(id uuid.UUID) pointofcontactOption {
	return func(m *PointOfContactMutation) {
		var (
			err   error
			once  sync.Once
			value *PointOfContact
		)
		m.oldValue = func(ctx context.Context) (*PointOfContact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PointOfContact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPointOfContact sets the old PointOfContact of the mutation.
func withPointOfContact(node *PointOfContact) pointofcontactOption {
	return func(m *PointOfContactMutation) {
		m.oldValue = func(context.Context) (*PointOfContact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PointOfContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PointOfContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PointOfContact entities.
func (m *PointOfContactMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PointOfContactMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PointOfContactMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PointOfContact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceID sets the "source_id" field.
func (m *PointOfContactMutation) SetSourceID(u uuid.UUID) {
	m.source = &u
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *PointOfContactMutation) SourceID() (r uuid.UUID, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldSourceID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *PointOfContactMutation) ClearSourceID() {
	m.source = nil
	m.clearedFields[pointofcontact.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *PointOfContactMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[pointofcontact.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *PointOfContactMutation) ResetSourceID() {
	m.source = nil
	delete(m.clearedFields, pointofcontact.FieldSourceID)
}

// SetPackageVersionID sets the "package_version_id" field.
func (m *PointOfContactMutation) SetPackageVersionID(u uuid.UUID) {
	m.package_version = &u
}

// PackageVersionID returns the value of the "package_version_id" field in the mutation.
func (m *PointOfContactMutation) PackageVersionID() (r uuid.UUID, exists bool) {
	v := m.package_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageVersionID returns the old "package_version_id" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldPackageVersionID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageVersionID: %w", err)
	}
	return oldValue.PackageVersionID, nil
}

// ClearPackageVersionID clears the value of the "package_version_id" field.
func (m *PointOfContactMutation) ClearPackageVersionID() {
	m.package_version = nil
	m.clearedFields[pointofcontact.FieldPackageVersionID] = struct{}{}
}

// PackageVersionIDCleared returns if the "package_version_id" field was cleared in this mutation.
func (m *PointOfContactMutation) PackageVersionIDCleared() bool {
	_, ok := m.clearedFields[pointofcontact.FieldPackageVersionID]
	return ok
}

// ResetPackageVersionID resets all changes to the "package_version_id" field.
func (m *PointOfContactMutation) ResetPackageVersionID() {
	m.package_version = nil
	delete(m.clearedFields, pointofcontact.FieldPackageVersionID)
}

// SetPackageNameID sets the "package_name_id" field.
func (m *PointOfContactMutation) SetPackageNameID(u uuid.UUID) {
	m.all_versions = &u
}

// PackageNameID returns the value of the "package_name_id" field in the mutation.
func (m *PointOfContactMutation) PackageNameID() (r uuid.UUID, exists bool) {
	v := m.all_versions
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageNameID returns the old "package_name_id" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldPackageNameID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageNameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageNameID: %w", err)
	}
	return oldValue.PackageNameID, nil
}

// ClearPackageNameID clears the value of the "package_name_id" field.
func (m *PointOfContactMutation) ClearPackageNameID() {
	m.all_versions = nil
	m.clearedFields[pointofcontact.FieldPackageNameID] = struct{}{}
}

// PackageNameIDCleared returns if the "package_name_id" field was cleared in this mutation.
func (m *PointOfContactMutation) PackageNameIDCleared() bool {
	_, ok := m.clearedFields[pointofcontact.FieldPackageNameID]
	return ok
}

// ResetPackageNameID resets all changes to the "package_name_id" field.
func (m *PointOfContactMutation) ResetPackageNameID() {
	m.all_versions = nil
	delete(m.clearedFields, pointofcontact.FieldPackageNameID)
}

// SetArtifactID sets the "artifact_id" field.
func (m *PointOfContactMutation) SetArtifactID(u uuid.UUID) {
	m.artifact = &u
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *PointOfContactMutation) ArtifactID() (r uuid.UUID, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldArtifactID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ClearArtifactID clears the value of the "artifact_id" field.
func (m *PointOfContactMutation) ClearArtifactID() {
	m.artifact = nil
	m.clearedFields[pointofcontact.FieldArtifactID] = struct{}{}
}

// ArtifactIDCleared returns if the "artifact_id" field was cleared in this mutation.
func (m *PointOfContactMutation) ArtifactIDCleared() bool {
	_, ok := m.clearedFields[pointofcontact.FieldArtifactID]
	return ok
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *PointOfContactMutation) ResetArtifactID() {
	m.artifact = nil
	delete(m.clearedFields, pointofcontact.FieldArtifactID)
}

// SetEmail sets the "email" field.
func (m *PointOfContactMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PointOfContactMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *PointOfContactMutation) ResetEmail() {
	m.email = nil
}

// SetInfo sets the "info" field.
func (m *PointOfContactMutation) SetInfo(s string) {
	m.info = &s
}

// Info returns the value of the "info" field in the mutation.
func (m *PointOfContactMutation) Info() (r string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ResetInfo resets all changes to the "info" field.
func (m *PointOfContactMutation) ResetInfo() {
	m.info = nil
}

// SetSince sets the "since" field.
func (m *PointOfContactMutation) SetSince(t time.Time) {
	m.since = &t
}

// Since returns the value of the "since" field in the mutation.
func (m *PointOfContactMutation) Since() (r time.Time, exists bool) {
	v := m.since
	if v == nil {
		return
	}
	return *v, true
}

// OldSince returns the old "since" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldSince(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSince: %w", err)
	}
	return oldValue.Since, nil
}

// ResetSince resets all changes to the "since" field.
func (m *PointOfContactMutation) ResetSince() {
	m.since = nil
}

// SetJustification sets the "justification" field.
func (m *PointOfContactMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *PointOfContactMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *PointOfContactMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *PointOfContactMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *PointOfContactMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *PointOfContactMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *PointOfContactMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *PointOfContactMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *PointOfContactMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *PointOfContactMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *PointOfContactMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *PointOfContactMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *PointOfContactMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[pointofcontact.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *PointOfContactMutation) SourceCleared() bool {
	return m.SourceIDCleared() || m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *PointOfContactMutation) SourceIDs() (ids []uuid.UUID) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *PointOfContactMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// ClearPackageVersion clears the "package_version" edge to the PackageVersion entity.
func (m *PointOfContactMutation) ClearPackageVersion() {
	m.clearedpackage_version = true
	m.clearedFields[pointofcontact.FieldPackageVersionID] = struct{}{}
}

// PackageVersionCleared reports if the "package_version" edge to the PackageVersion entity was cleared.
func (m *PointOfContactMutation) PackageVersionCleared() bool {
	return m.PackageVersionIDCleared() || m.clearedpackage_version
}

// PackageVersionIDs returns the "package_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageVersionID instead. It exists only for internal usage by the builders.
func (m *PointOfContactMutation) PackageVersionIDs() (ids []uuid.UUID) {
	if id := m.package_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackageVersion resets all changes to the "package_version" edge.
func (m *PointOfContactMutation) ResetPackageVersion() {
	m.package_version = nil
	m.clearedpackage_version = false
}

// SetAllVersionsID sets the "all_versions" edge to the PackageName entity by id.
func (m *PointOfContactMutation) SetAllVersionsID(id uuid.UUID) {
	m.all_versions = &id
}

// ClearAllVersions clears the "all_versions" edge to the PackageName entity.
func (m *PointOfContactMutation) ClearAllVersions() {
	m.clearedall_versions = true
	m.clearedFields[pointofcontact.FieldPackageNameID] = struct{}{}
}

// AllVersionsCleared reports if the "all_versions" edge to the PackageName entity was cleared.
func (m *PointOfContactMutation) AllVersionsCleared() bool {
	return m.PackageNameIDCleared() || m.clearedall_versions
}

// AllVersionsID returns the "all_versions" edge ID in the mutation.
func (m *PointOfContactMutation) AllVersionsID() (id uuid.UUID, exists bool) {
	if m.all_versions != nil {
		return *m.all_versions, true
	}
	return
}

// AllVersionsIDs returns the "all_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AllVersionsID instead. It exists only for internal usage by the builders.
func (m *PointOfContactMutation) AllVersionsIDs() (ids []uuid.UUID) {
	if id := m.all_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAllVersions resets all changes to the "all_versions" edge.
func (m *PointOfContactMutation) ResetAllVersions() {
	m.all_versions = nil
	m.clearedall_versions = false
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *PointOfContactMutation) ClearArtifact() {
	m.clearedartifact = true
	m.clearedFields[pointofcontact.FieldArtifactID] = struct{}{}
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *PointOfContactMutation) ArtifactCleared() bool {
	return m.ArtifactIDCleared() || m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *PointOfContactMutation) ArtifactIDs() (ids []uuid.UUID) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *PointOfContactMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// Where appends a list predicates to the PointOfContactMutation builder.
func (m *PointOfContactMutation) Where(ps ...predicate.PointOfContact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PointOfContactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PointOfContactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PointOfContact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PointOfContactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PointOfContactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PointOfContact).
func (m *PointOfContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PointOfContactMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.source != nil {
		fields = append(fields, pointofcontact.FieldSourceID)
	}
	if m.package_version != nil {
		fields = append(fields, pointofcontact.FieldPackageVersionID)
	}
	if m.all_versions != nil {
		fields = append(fields, pointofcontact.FieldPackageNameID)
	}
	if m.artifact != nil {
		fields = append(fields, pointofcontact.FieldArtifactID)
	}
	if m.email != nil {
		fields = append(fields, pointofcontact.FieldEmail)
	}
	if m.info != nil {
		fields = append(fields, pointofcontact.FieldInfo)
	}
	if m.since != nil {
		fields = append(fields, pointofcontact.FieldSince)
	}
	if m.justification != nil {
		fields = append(fields, pointofcontact.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, pointofcontact.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, pointofcontact.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, pointofcontact.FieldDocumentRef)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PointOfContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pointofcontact.FieldSourceID:
		return m.SourceID()
	case pointofcontact.FieldPackageVersionID:
		return m.PackageVersionID()
	case pointofcontact.FieldPackageNameID:
		return m.PackageNameID()
	case pointofcontact.FieldArtifactID:
		return m.ArtifactID()
	case pointofcontact.FieldEmail:
		return m.Email()
	case pointofcontact.FieldInfo:
		return m.Info()
	case pointofcontact.FieldSince:
		return m.Since()
	case pointofcontact.FieldJustification:
		return m.Justification()
	case pointofcontact.FieldOrigin:
		return m.Origin()
	case pointofcontact.FieldCollector:
		return m.Collector()
	case pointofcontact.FieldDocumentRef:
		return m.DocumentRef()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PointOfContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pointofcontact.FieldSourceID:
		return m.OldSourceID(ctx)
	case pointofcontact.FieldPackageVersionID:
		return m.OldPackageVersionID(ctx)
	case pointofcontact.FieldPackageNameID:
		return m.OldPackageNameID(ctx)
	case pointofcontact.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case pointofcontact.FieldEmail:
		return m.OldEmail(ctx)
	case pointofcontact.FieldInfo:
		return m.OldInfo(ctx)
	case pointofcontact.FieldSince:
		return m.OldSince(ctx)
	case pointofcontact.FieldJustification:
		return m.OldJustification(ctx)
	case pointofcontact.FieldOrigin:
		return m.OldOrigin(ctx)
	case pointofcontact.FieldCollector:
		return m.OldCollector(ctx)
	case pointofcontact.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	}
	return nil, fmt.Errorf("unknown PointOfContact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointOfContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pointofcontact.FieldSourceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case pointofcontact.FieldPackageVersionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageVersionID(v)
		return nil
	case pointofcontact.FieldPackageNameID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageNameID(v)
		return nil
	case pointofcontact.FieldArtifactID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case pointofcontact.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case pointofcontact.FieldInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case pointofcontact.FieldSince:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSince(v)
		return nil
	case pointofcontact.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case pointofcontact.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case pointofcontact.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case pointofcontact.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	}
	return fmt.Errorf("unknown PointOfContact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PointOfContactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PointOfContactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointOfContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PointOfContact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PointOfContactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pointofcontact.FieldSourceID) {
		fields = append(fields, pointofcontact.FieldSourceID)
	}
	if m.FieldCleared(pointofcontact.FieldPackageVersionID) {
		fields = append(fields, pointofcontact.FieldPackageVersionID)
	}
	if m.FieldCleared(pointofcontact.FieldPackageNameID) {
		fields = append(fields, pointofcontact.FieldPackageNameID)
	}
	if m.FieldCleared(pointofcontact.FieldArtifactID) {
		fields = append(fields, pointofcontact.FieldArtifactID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PointOfContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PointOfContactMutation) ClearField(name string) error {
	switch name {
	case pointofcontact.FieldSourceID:
		m.ClearSourceID()
		return nil
	case pointofcontact.FieldPackageVersionID:
		m.ClearPackageVersionID()
		return nil
	case pointofcontact.FieldPackageNameID:
		m.ClearPackageNameID()
		return nil
	case pointofcontact.FieldArtifactID:
		m.ClearArtifactID()
		return nil
	}
	return fmt.Errorf("unknown PointOfContact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PointOfContactMutation) ResetField(name string) error {
	switch name {
	case pointofcontact.FieldSourceID:
		m.ResetSourceID()
		return nil
	case pointofcontact.FieldPackageVersionID:
		m.ResetPackageVersionID()
		return nil
	case pointofcontact.FieldPackageNameID:
		m.ResetPackageNameID()
		return nil
	case pointofcontact.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case pointofcontact.FieldEmail:
		m.ResetEmail()
		return nil
	case pointofcontact.FieldInfo:
		m.ResetInfo()
		return nil
	case pointofcontact.FieldSince:
		m.ResetSince()
		return nil
	case pointofcontact.FieldJustification:
		m.ResetJustification()
		return nil
	case pointofcontact.FieldOrigin:
		m.ResetOrigin()
		return nil
	case pointofcontact.FieldCollector:
		m.ResetCollector()
		return nil
	case pointofcontact.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	}
	return fmt.Errorf("unknown PointOfContact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PointOfContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.source != nil {
		edges = append(edges, pointofcontact.EdgeSource)
	}
	if m.package_version != nil {
		edges = append(edges, pointofcontact.EdgePackageVersion)
	}
	if m.all_versions != nil {
		edges = append(edges, pointofcontact.EdgeAllVersions)
	}
	if m.artifact != nil {
		edges = append(edges, pointofcontact.EdgeArtifact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PointOfContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pointofcontact.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	case pointofcontact.EdgePackageVersion:
		if id := m.package_version; id != nil {
			return []ent.Value{*id}
		}
	case pointofcontact.EdgeAllVersions:
		if id := m.all_versions; id != nil {
			return []ent.Value{*id}
		}
	case pointofcontact.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PointOfContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PointOfContactMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PointOfContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsource {
		edges = append(edges, pointofcontact.EdgeSource)
	}
	if m.clearedpackage_version {
		edges = append(edges, pointofcontact.EdgePackageVersion)
	}
	if m.clearedall_versions {
		edges = append(edges, pointofcontact.EdgeAllVersions)
	}
	if m.clearedartifact {
		edges = append(edges, pointofcontact.EdgeArtifact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PointOfContactMutation) EdgeCleared(name string) bool {
	switch name {
	case pointofcontact.EdgeSource:
		return m.clearedsource
	case pointofcontact.EdgePackageVersion:
		return m.clearedpackage_version
	case pointofcontact.EdgeAllVersions:
		return m.clearedall_versions
	case pointofcontact.EdgeArtifact:
		return m.clearedartifact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PointOfContactMutation) ClearEdge(name string) error {
	switch name {
	case pointofcontact.EdgeSource:
		m.ClearSource()
		return nil
	case pointofcontact.EdgePackageVersion:
		m.ClearPackageVersion()
		return nil
	case pointofcontact.EdgeAllVersions:
		m.ClearAllVersions()
		return nil
	case pointofcontact.EdgeArtifact:
		m.ClearArtifact()
		return nil
	}
	return fmt.Errorf("unknown PointOfContact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PointOfContactMutation) ResetEdge(name string) error {
	switch name {
	case pointofcontact.EdgeSource:
		m.ResetSource()
		return nil
	case pointofcontact.EdgePackageVersion:
		m.ResetPackageVersion()
		return nil
	case pointofcontact.EdgeAllVersions:
		m.ResetAllVersions()
		return nil
	case pointofcontact.EdgeArtifact:
		m.ResetArtifact()
		return nil
	}
	return fmt.Errorf("unknown PointOfContact edge %s", name)
}

// SLSAAttestationMutation represents an operation that mutates the SLSAAttestation nodes in the graph.
type SLSAAttestationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	build_type           *string
	slsa_predicate       *[]*model.SLSAPredicate
	appendslsa_predicate []*model.SLSAPredicate
	slsa_version         *string
	started_on           *time.Time
	finished_on          *time.Time
	origin               *string
	collector            *string
	document_ref         *string
	built_from_hash      *string
	clearedFields        map[string]struct{}
	built_from           map[uuid.UUID]struct{}
	removedbuilt_from    map[uuid.UUID]struct{}
	clearedbuilt_from    bool
	built_by             *uuid.UUID
	clearedbuilt_by      bool
	subject              *uuid.UUID
	clearedsubject       bool
	done                 bool
	oldValue             func(context.Context) (*SLSAAttestation, error)
	predicates           []predicate.SLSAAttestation
}

var _ ent.Mutation = (*SLSAAttestationMutation)(nil)

// slsaattestationOption allows management of the mutation configuration using functional options.
type slsaattestationOption func(*SLSAAttestationMutation)

// newSLSAAttestationMutation creates new mutation for the SLSAAttestation entity.
func newSLSAAttestationMutation(c config, op Op, opts ...slsaattestationOption) *SLSAAttestationMutation {
	m := &SLSAAttestationMutation{
		config:        c,
		op:            op,
		typ:           TypeSLSAAttestation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSLSAAttestationID sets the ID field of the mutation.
func withSLSAAttestationID(id uuid.UUID) slsaattestationOption {
	return func(m *SLSAAttestationMutation) {
		var (
			err   error
			once  sync.Once
			value *SLSAAttestation
		)
		m.oldValue = func(ctx context.Context) (*SLSAAttestation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SLSAAttestation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSLSAAttestation sets the old SLSAAttestation of the mutation.
func withSLSAAttestation(node *SLSAAttestation) slsaattestationOption {
	return func(m *SLSAAttestationMutation) {
		m.oldValue = func(context.Context) (*SLSAAttestation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SLSAAttestationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SLSAAttestationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SLSAAttestation entities.
func (m *SLSAAttestationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SLSAAttestationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SLSAAttestationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SLSAAttestation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBuildType sets the "build_type" field.
func (m *SLSAAttestationMutation) SetBuildType(s string) {
	m.build_type = &s
}

// BuildType returns the value of the "build_type" field in the mutation.
func (m *SLSAAttestationMutation) BuildType() (r string, exists bool) {
	v := m.build_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildType returns the old "build_type" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldBuildType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildType: %w", err)
	}
	return oldValue.BuildType, nil
}

// ResetBuildType resets all changes to the "build_type" field.
func (m *SLSAAttestationMutation) ResetBuildType() {
	m.build_type = nil
}

// SetBuiltByID sets the "built_by_id" field.
func (m *SLSAAttestationMutation) SetBuiltByID(u uuid.UUID) {
	m.built_by = &u
}

// BuiltByID returns the value of the "built_by_id" field in the mutation.
func (m *SLSAAttestationMutation) BuiltByID() (r uuid.UUID, exists bool) {
	v := m.built_by
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltByID returns the old "built_by_id" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldBuiltByID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltByID: %w", err)
	}
	return oldValue.BuiltByID, nil
}

// ResetBuiltByID resets all changes to the "built_by_id" field.
func (m *SLSAAttestationMutation) ResetBuiltByID() {
	m.built_by = nil
}

// SetSubjectID sets the "subject_id" field.
func (m *SLSAAttestationMutation) SetSubjectID(u uuid.UUID) {
	m.subject = &u
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *SLSAAttestationMutation) SubjectID() (r uuid.UUID, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldSubjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *SLSAAttestationMutation) ResetSubjectID() {
	m.subject = nil
}

// SetSlsaPredicate sets the "slsa_predicate" field.
func (m *SLSAAttestationMutation) SetSlsaPredicate(mp []*model.SLSAPredicate) {
	m.slsa_predicate = &mp
	m.appendslsa_predicate = nil
}

// SlsaPredicate returns the value of the "slsa_predicate" field in the mutation.
func (m *SLSAAttestationMutation) SlsaPredicate() (r []*model.SLSAPredicate, exists bool) {
	v := m.slsa_predicate
	if v == nil {
		return
	}
	return *v, true
}

// OldSlsaPredicate returns the old "slsa_predicate" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldSlsaPredicate(ctx context.Context) (v []*model.SLSAPredicate, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlsaPredicate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlsaPredicate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlsaPredicate: %w", err)
	}
	return oldValue.SlsaPredicate, nil
}

// AppendSlsaPredicate adds mp to the "slsa_predicate" field.
func (m *SLSAAttestationMutation) AppendSlsaPredicate(mp []*model.SLSAPredicate) {
	m.appendslsa_predicate = append(m.appendslsa_predicate, mp...)
}

// AppendedSlsaPredicate returns the list of values that were appended to the "slsa_predicate" field in this mutation.
func (m *SLSAAttestationMutation) AppendedSlsaPredicate() ([]*model.SLSAPredicate, bool) {
	if len(m.appendslsa_predicate) == 0 {
		return nil, false
	}
	return m.appendslsa_predicate, true
}

// ClearSlsaPredicate clears the value of the "slsa_predicate" field.
func (m *SLSAAttestationMutation) ClearSlsaPredicate() {
	m.slsa_predicate = nil
	m.appendslsa_predicate = nil
	m.clearedFields[slsaattestation.FieldSlsaPredicate] = struct{}{}
}

// SlsaPredicateCleared returns if the "slsa_predicate" field was cleared in this mutation.
func (m *SLSAAttestationMutation) SlsaPredicateCleared() bool {
	_, ok := m.clearedFields[slsaattestation.FieldSlsaPredicate]
	return ok
}

// ResetSlsaPredicate resets all changes to the "slsa_predicate" field.
func (m *SLSAAttestationMutation) ResetSlsaPredicate() {
	m.slsa_predicate = nil
	m.appendslsa_predicate = nil
	delete(m.clearedFields, slsaattestation.FieldSlsaPredicate)
}

// SetSlsaVersion sets the "slsa_version" field.
func (m *SLSAAttestationMutation) SetSlsaVersion(s string) {
	m.slsa_version = &s
}

// SlsaVersion returns the value of the "slsa_version" field in the mutation.
func (m *SLSAAttestationMutation) SlsaVersion() (r string, exists bool) {
	v := m.slsa_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSlsaVersion returns the old "slsa_version" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldSlsaVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlsaVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlsaVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlsaVersion: %w", err)
	}
	return oldValue.SlsaVersion, nil
}

// ResetSlsaVersion resets all changes to the "slsa_version" field.
func (m *SLSAAttestationMutation) ResetSlsaVersion() {
	m.slsa_version = nil
}

// SetStartedOn sets the "started_on" field.
func (m *SLSAAttestationMutation) SetStartedOn(t time.Time) {
	m.started_on = &t
}

// StartedOn returns the value of the "started_on" field in the mutation.
func (m *SLSAAttestationMutation) StartedOn() (r time.Time, exists bool) {
	v := m.started_on
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedOn returns the old "started_on" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldStartedOn(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedOn: %w", err)
	}
	return oldValue.StartedOn, nil
}

// ResetStartedOn resets all changes to the "started_on" field.
func (m *SLSAAttestationMutation) ResetStartedOn() {
	m.started_on = nil
}

// SetFinishedOn sets the "finished_on" field.
func (m *SLSAAttestationMutation) SetFinishedOn(t time.Time) {
	m.finished_on = &t
}

// FinishedOn returns the value of the "finished_on" field in the mutation.
func (m *SLSAAttestationMutation) FinishedOn() (r time.Time, exists bool) {
	v := m.finished_on
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedOn returns the old "finished_on" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldFinishedOn(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedOn: %w", err)
	}
	return oldValue.FinishedOn, nil
}

// ResetFinishedOn resets all changes to the "finished_on" field.
func (m *SLSAAttestationMutation) ResetFinishedOn() {
	m.finished_on = nil
}

// SetOrigin sets the "origin" field.
func (m *SLSAAttestationMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *SLSAAttestationMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *SLSAAttestationMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *SLSAAttestationMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *SLSAAttestationMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *SLSAAttestationMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *SLSAAttestationMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *SLSAAttestationMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *SLSAAttestationMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// SetBuiltFromHash sets the "built_from_hash" field.
func (m *SLSAAttestationMutation) SetBuiltFromHash(s string) {
	m.built_from_hash = &s
}

// BuiltFromHash returns the value of the "built_from_hash" field in the mutation.
func (m *SLSAAttestationMutation) BuiltFromHash() (r string, exists bool) {
	v := m.built_from_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltFromHash returns the old "built_from_hash" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldBuiltFromHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltFromHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltFromHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltFromHash: %w", err)
	}
	return oldValue.BuiltFromHash, nil
}

// ResetBuiltFromHash resets all changes to the "built_from_hash" field.
func (m *SLSAAttestationMutation) ResetBuiltFromHash() {
	m.built_from_hash = nil
}

// AddBuiltFromIDs adds the "built_from" edge to the Artifact entity by ids.
func (m *SLSAAttestationMutation) AddBuiltFromIDs(ids ...uuid.UUID) {
	if m.built_from == nil {
		m.built_from = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.built_from[ids[i]] = struct{}{}
	}
}

// ClearBuiltFrom clears the "built_from" edge to the Artifact entity.
func (m *SLSAAttestationMutation) ClearBuiltFrom() {
	m.clearedbuilt_from = true
}

// BuiltFromCleared reports if the "built_from" edge to the Artifact entity was cleared.
func (m *SLSAAttestationMutation) BuiltFromCleared() bool {
	return m.clearedbuilt_from
}

// RemoveBuiltFromIDs removes the "built_from" edge to the Artifact entity by IDs.
func (m *SLSAAttestationMutation) RemoveBuiltFromIDs(ids ...uuid.UUID) {
	if m.removedbuilt_from == nil {
		m.removedbuilt_from = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.built_from, ids[i])
		m.removedbuilt_from[ids[i]] = struct{}{}
	}
}

// RemovedBuiltFrom returns the removed IDs of the "built_from" edge to the Artifact entity.
func (m *SLSAAttestationMutation) RemovedBuiltFromIDs() (ids []uuid.UUID) {
	for id := range m.removedbuilt_from {
		ids = append(ids, id)
	}
	return
}

// BuiltFromIDs returns the "built_from" edge IDs in the mutation.
func (m *SLSAAttestationMutation) BuiltFromIDs() (ids []uuid.UUID) {
	for id := range m.built_from {
		ids = append(ids, id)
	}
	return
}

// ResetBuiltFrom resets all changes to the "built_from" edge.
func (m *SLSAAttestationMutation) ResetBuiltFrom() {
	m.built_from = nil
	m.clearedbuilt_from = false
	m.removedbuilt_from = nil
}

// ClearBuiltBy clears the "built_by" edge to the Builder entity.
func (m *SLSAAttestationMutation) ClearBuiltBy() {
	m.clearedbuilt_by = true
	m.clearedFields[slsaattestation.FieldBuiltByID] = struct{}{}
}

// BuiltByCleared reports if the "built_by" edge to the Builder entity was cleared.
func (m *SLSAAttestationMutation) BuiltByCleared() bool {
	return m.clearedbuilt_by
}

// BuiltByIDs returns the "built_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuiltByID instead. It exists only for internal usage by the builders.
func (m *SLSAAttestationMutation) BuiltByIDs() (ids []uuid.UUID) {
	if id := m.built_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuiltBy resets all changes to the "built_by" edge.
func (m *SLSAAttestationMutation) ResetBuiltBy() {
	m.built_by = nil
	m.clearedbuilt_by = false
}

// ClearSubject clears the "subject" edge to the Artifact entity.
func (m *SLSAAttestationMutation) ClearSubject() {
	m.clearedsubject = true
	m.clearedFields[slsaattestation.FieldSubjectID] = struct{}{}
}

// SubjectCleared reports if the "subject" edge to the Artifact entity was cleared.
func (m *SLSAAttestationMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectIDs returns the "subject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *SLSAAttestationMutation) SubjectIDs() (ids []uuid.UUID) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject resets all changes to the "subject" edge.
func (m *SLSAAttestationMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// Where appends a list predicates to the SLSAAttestationMutation builder.
func (m *SLSAAttestationMutation) Where(ps ...predicate.SLSAAttestation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SLSAAttestationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SLSAAttestationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SLSAAttestation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SLSAAttestationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SLSAAttestationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SLSAAttestation).
func (m *SLSAAttestationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SLSAAttestationMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.build_type != nil {
		fields = append(fields, slsaattestation.FieldBuildType)
	}
	if m.built_by != nil {
		fields = append(fields, slsaattestation.FieldBuiltByID)
	}
	if m.subject != nil {
		fields = append(fields, slsaattestation.FieldSubjectID)
	}
	if m.slsa_predicate != nil {
		fields = append(fields, slsaattestation.FieldSlsaPredicate)
	}
	if m.slsa_version != nil {
		fields = append(fields, slsaattestation.FieldSlsaVersion)
	}
	if m.started_on != nil {
		fields = append(fields, slsaattestation.FieldStartedOn)
	}
	if m.finished_on != nil {
		fields = append(fields, slsaattestation.FieldFinishedOn)
	}
	if m.origin != nil {
		fields = append(fields, slsaattestation.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, slsaattestation.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, slsaattestation.FieldDocumentRef)
	}
	if m.built_from_hash != nil {
		fields = append(fields, slsaattestation.FieldBuiltFromHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SLSAAttestationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slsaattestation.FieldBuildType:
		return m.BuildType()
	case slsaattestation.FieldBuiltByID:
		return m.BuiltByID()
	case slsaattestation.FieldSubjectID:
		return m.SubjectID()
	case slsaattestation.FieldSlsaPredicate:
		return m.SlsaPredicate()
	case slsaattestation.FieldSlsaVersion:
		return m.SlsaVersion()
	case slsaattestation.FieldStartedOn:
		return m.StartedOn()
	case slsaattestation.FieldFinishedOn:
		return m.FinishedOn()
	case slsaattestation.FieldOrigin:
		return m.Origin()
	case slsaattestation.FieldCollector:
		return m.Collector()
	case slsaattestation.FieldDocumentRef:
		return m.DocumentRef()
	case slsaattestation.FieldBuiltFromHash:
		return m.BuiltFromHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SLSAAttestationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slsaattestation.FieldBuildType:
		return m.OldBuildType(ctx)
	case slsaattestation.FieldBuiltByID:
		return m.OldBuiltByID(ctx)
	case slsaattestation.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case slsaattestation.FieldSlsaPredicate:
		return m.OldSlsaPredicate(ctx)
	case slsaattestation.FieldSlsaVersion:
		return m.OldSlsaVersion(ctx)
	case slsaattestation.FieldStartedOn:
		return m.OldStartedOn(ctx)
	case slsaattestation.FieldFinishedOn:
		return m.OldFinishedOn(ctx)
	case slsaattestation.FieldOrigin:
		return m.OldOrigin(ctx)
	case slsaattestation.FieldCollector:
		return m.OldCollector(ctx)
	case slsaattestation.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	case slsaattestation.FieldBuiltFromHash:
		return m.OldBuiltFromHash(ctx)
	}
	return nil, fmt.Errorf("unknown SLSAAttestation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLSAAttestationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slsaattestation.FieldBuildType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildType(v)
		return nil
	case slsaattestation.FieldBuiltByID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltByID(v)
		return nil
	case slsaattestation.FieldSubjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case slsaattestation.FieldSlsaPredicate:
		v, ok := value.([]*model.SLSAPredicate)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlsaPredicate(v)
		return nil
	case slsaattestation.FieldSlsaVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlsaVersion(v)
		return nil
	case slsaattestation.FieldStartedOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedOn(v)
		return nil
	case slsaattestation.FieldFinishedOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedOn(v)
		return nil
	case slsaattestation.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case slsaattestation.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case slsaattestation.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	case slsaattestation.FieldBuiltFromHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltFromHash(v)
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SLSAAttestationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SLSAAttestationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLSAAttestationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SLSAAttestation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SLSAAttestationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(slsaattestation.FieldSlsaPredicate) {
		fields = append(fields, slsaattestation.FieldSlsaPredicate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SLSAAttestationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SLSAAttestationMutation) ClearField(name string) error {
	switch name {
	case slsaattestation.FieldSlsaPredicate:
		m.ClearSlsaPredicate()
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SLSAAttestationMutation) ResetField(name string) error {
	switch name {
	case slsaattestation.FieldBuildType:
		m.ResetBuildType()
		return nil
	case slsaattestation.FieldBuiltByID:
		m.ResetBuiltByID()
		return nil
	case slsaattestation.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case slsaattestation.FieldSlsaPredicate:
		m.ResetSlsaPredicate()
		return nil
	case slsaattestation.FieldSlsaVersion:
		m.ResetSlsaVersion()
		return nil
	case slsaattestation.FieldStartedOn:
		m.ResetStartedOn()
		return nil
	case slsaattestation.FieldFinishedOn:
		m.ResetFinishedOn()
		return nil
	case slsaattestation.FieldOrigin:
		m.ResetOrigin()
		return nil
	case slsaattestation.FieldCollector:
		m.ResetCollector()
		return nil
	case slsaattestation.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	case slsaattestation.FieldBuiltFromHash:
		m.ResetBuiltFromHash()
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SLSAAttestationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.built_from != nil {
		edges = append(edges, slsaattestation.EdgeBuiltFrom)
	}
	if m.built_by != nil {
		edges = append(edges, slsaattestation.EdgeBuiltBy)
	}
	if m.subject != nil {
		edges = append(edges, slsaattestation.EdgeSubject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SLSAAttestationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case slsaattestation.EdgeBuiltFrom:
		ids := make([]ent.Value, 0, len(m.built_from))
		for id := range m.built_from {
			ids = append(ids, id)
		}
		return ids
	case slsaattestation.EdgeBuiltBy:
		if id := m.built_by; id != nil {
			return []ent.Value{*id}
		}
	case slsaattestation.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SLSAAttestationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbuilt_from != nil {
		edges = append(edges, slsaattestation.EdgeBuiltFrom)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SLSAAttestationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case slsaattestation.EdgeBuiltFrom:
		ids := make([]ent.Value, 0, len(m.removedbuilt_from))
		for id := range m.removedbuilt_from {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SLSAAttestationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbuilt_from {
		edges = append(edges, slsaattestation.EdgeBuiltFrom)
	}
	if m.clearedbuilt_by {
		edges = append(edges, slsaattestation.EdgeBuiltBy)
	}
	if m.clearedsubject {
		edges = append(edges, slsaattestation.EdgeSubject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SLSAAttestationMutation) EdgeCleared(name string) bool {
	switch name {
	case slsaattestation.EdgeBuiltFrom:
		return m.clearedbuilt_from
	case slsaattestation.EdgeBuiltBy:
		return m.clearedbuilt_by
	case slsaattestation.EdgeSubject:
		return m.clearedsubject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SLSAAttestationMutation) ClearEdge(name string) error {
	switch name {
	case slsaattestation.EdgeBuiltBy:
		m.ClearBuiltBy()
		return nil
	case slsaattestation.EdgeSubject:
		m.ClearSubject()
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SLSAAttestationMutation) ResetEdge(name string) error {
	switch name {
	case slsaattestation.EdgeBuiltFrom:
		m.ResetBuiltFrom()
		return nil
	case slsaattestation.EdgeBuiltBy:
		m.ResetBuiltBy()
		return nil
	case slsaattestation.EdgeSubject:
		m.ResetSubject()
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation edge %s", name)
}

// SourceNameMutation represents an operation that mutates the SourceName nodes in the graph.
type SourceNameMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	_type                *string
	namespace            *string
	name                 *string
	commit               *string
	tag                  *string
	clearedFields        map[string]struct{}
	occurrences          map[uuid.UUID]struct{}
	removedoccurrences   map[uuid.UUID]struct{}
	clearedoccurrences   bool
	has_source_at        map[uuid.UUID]struct{}
	removedhas_source_at map[uuid.UUID]struct{}
	clearedhas_source_at bool
	scorecard            map[uuid.UUID]struct{}
	removedscorecard     map[uuid.UUID]struct{}
	clearedscorecard     bool
	certification        map[uuid.UUID]struct{}
	removedcertification map[uuid.UUID]struct{}
	clearedcertification bool
	metadata             map[uuid.UUID]struct{}
	removedmetadata      map[uuid.UUID]struct{}
	clearedmetadata      bool
	poc                  map[uuid.UUID]struct{}
	removedpoc           map[uuid.UUID]struct{}
	clearedpoc           bool
	certify_legal        map[uuid.UUID]struct{}
	removedcertify_legal map[uuid.UUID]struct{}
	clearedcertify_legal bool
	done                 bool
	oldValue             func(context.Context) (*SourceName, error)
	predicates           []predicate.SourceName
}

var _ ent.Mutation = (*SourceNameMutation)(nil)

// sourcenameOption allows management of the mutation configuration using functional options.
type sourcenameOption func(*SourceNameMutation)

// newSourceNameMutation creates new mutation for the SourceName entity.
func newSourceNameMutation(c config, op Op, opts ...sourcenameOption) *SourceNameMutation {
	m := &SourceNameMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceName,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceNameID sets the ID field of the mutation.
func withSourceNameID(id uuid.UUID) sourcenameOption {
	return func(m *SourceNameMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceName
		)
		m.oldValue = func(ctx context.Context) (*SourceName, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceName.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceName sets the old SourceName of the mutation.
func withSourceName(node *SourceName) sourcenameOption {
	return func(m *SourceNameMutation) {
		m.oldValue = func(context.Context) (*SourceName, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceNameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceNameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SourceName entities.
func (m *SourceNameMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceNameMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceNameMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceName.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *SourceNameMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SourceNameMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SourceNameMutation) ResetType() {
	m._type = nil
}

// SetNamespace sets the "namespace" field.
func (m *SourceNameMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SourceNameMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SourceNameMutation) ResetNamespace() {
	m.namespace = nil
}

// SetName sets the "name" field.
func (m *SourceNameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SourceNameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SourceNameMutation) ResetName() {
	m.name = nil
}

// SetCommit sets the "commit" field.
func (m *SourceNameMutation) SetCommit(s string) {
	m.commit = &s
}

// Commit returns the value of the "commit" field in the mutation.
func (m *SourceNameMutation) Commit() (r string, exists bool) {
	v := m.commit
	if v == nil {
		return
	}
	return *v, true
}

// OldCommit returns the old "commit" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldCommit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommit: %w", err)
	}
	return oldValue.Commit, nil
}

// ClearCommit clears the value of the "commit" field.
func (m *SourceNameMutation) ClearCommit() {
	m.commit = nil
	m.clearedFields[sourcename.FieldCommit] = struct{}{}
}

// CommitCleared returns if the "commit" field was cleared in this mutation.
func (m *SourceNameMutation) CommitCleared() bool {
	_, ok := m.clearedFields[sourcename.FieldCommit]
	return ok
}

// ResetCommit resets all changes to the "commit" field.
func (m *SourceNameMutation) ResetCommit() {
	m.commit = nil
	delete(m.clearedFields, sourcename.FieldCommit)
}

// SetTag sets the "tag" field.
func (m *SourceNameMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *SourceNameMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ClearTag clears the value of the "tag" field.
func (m *SourceNameMutation) ClearTag() {
	m.tag = nil
	m.clearedFields[sourcename.FieldTag] = struct{}{}
}

// TagCleared returns if the "tag" field was cleared in this mutation.
func (m *SourceNameMutation) TagCleared() bool {
	_, ok := m.clearedFields[sourcename.FieldTag]
	return ok
}

// ResetTag resets all changes to the "tag" field.
func (m *SourceNameMutation) ResetTag() {
	m.tag = nil
	delete(m.clearedFields, sourcename.FieldTag)
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by ids.
func (m *SourceNameMutation) AddOccurrenceIDs(ids ...uuid.UUID) {
	if m.occurrences == nil {
		m.occurrences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.occurrences[ids[i]] = struct{}{}
	}
}

// ClearOccurrences clears the "occurrences" edge to the Occurrence entity.
func (m *SourceNameMutation) ClearOccurrences() {
	m.clearedoccurrences = true
}

// OccurrencesCleared reports if the "occurrences" edge to the Occurrence entity was cleared.
func (m *SourceNameMutation) OccurrencesCleared() bool {
	return m.clearedoccurrences
}

// RemoveOccurrenceIDs removes the "occurrences" edge to the Occurrence entity by IDs.
func (m *SourceNameMutation) RemoveOccurrenceIDs(ids ...uuid.UUID) {
	if m.removedoccurrences == nil {
		m.removedoccurrences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.occurrences, ids[i])
		m.removedoccurrences[ids[i]] = struct{}{}
	}
}

// RemovedOccurrences returns the removed IDs of the "occurrences" edge to the Occurrence entity.
func (m *SourceNameMutation) RemovedOccurrencesIDs() (ids []uuid.UUID) {
	for id := range m.removedoccurrences {
		ids = append(ids, id)
	}
	return
}

// OccurrencesIDs returns the "occurrences" edge IDs in the mutation.
func (m *SourceNameMutation) OccurrencesIDs() (ids []uuid.UUID) {
	for id := range m.occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetOccurrences resets all changes to the "occurrences" edge.
func (m *SourceNameMutation) ResetOccurrences() {
	m.occurrences = nil
	m.clearedoccurrences = false
	m.removedoccurrences = nil
}

// AddHasSourceAtIDs adds the "has_source_at" edge to the HasSourceAt entity by ids.
func (m *SourceNameMutation) AddHasSourceAtIDs(ids ...uuid.UUID) {
	if m.has_source_at == nil {
		m.has_source_at = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.has_source_at[ids[i]] = struct{}{}
	}
}

// ClearHasSourceAt clears the "has_source_at" edge to the HasSourceAt entity.
func (m *SourceNameMutation) ClearHasSourceAt() {
	m.clearedhas_source_at = true
}

// HasSourceAtCleared reports if the "has_source_at" edge to the HasSourceAt entity was cleared.
func (m *SourceNameMutation) HasSourceAtCleared() bool {
	return m.clearedhas_source_at
}

// RemoveHasSourceAtIDs removes the "has_source_at" edge to the HasSourceAt entity by IDs.
func (m *SourceNameMutation) RemoveHasSourceAtIDs(ids ...uuid.UUID) {
	if m.removedhas_source_at == nil {
		m.removedhas_source_at = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.has_source_at, ids[i])
		m.removedhas_source_at[ids[i]] = struct{}{}
	}
}

// RemovedHasSourceAt returns the removed IDs of the "has_source_at" edge to the HasSourceAt entity.
func (m *SourceNameMutation) RemovedHasSourceAtIDs() (ids []uuid.UUID) {
	for id := range m.removedhas_source_at {
		ids = append(ids, id)
	}
	return
}

// HasSourceAtIDs returns the "has_source_at" edge IDs in the mutation.
func (m *SourceNameMutation) HasSourceAtIDs() (ids []uuid.UUID) {
	for id := range m.has_source_at {
		ids = append(ids, id)
	}
	return
}

// ResetHasSourceAt resets all changes to the "has_source_at" edge.
func (m *SourceNameMutation) ResetHasSourceAt() {
	m.has_source_at = nil
	m.clearedhas_source_at = false
	m.removedhas_source_at = nil
}

// AddScorecardIDs adds the "scorecard" edge to the CertifyScorecard entity by ids.
func (m *SourceNameMutation) AddScorecardIDs(ids ...uuid.UUID) {
	if m.scorecard == nil {
		m.scorecard = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.scorecard[ids[i]] = struct{}{}
	}
}

// ClearScorecard clears the "scorecard" edge to the CertifyScorecard entity.
func (m *SourceNameMutation) ClearScorecard() {
	m.clearedscorecard = true
}

// ScorecardCleared reports if the "scorecard" edge to the CertifyScorecard entity was cleared.
func (m *SourceNameMutation) ScorecardCleared() bool {
	return m.clearedscorecard
}

// RemoveScorecardIDs removes the "scorecard" edge to the CertifyScorecard entity by IDs.
func (m *SourceNameMutation) RemoveScorecardIDs(ids ...uuid.UUID) {
	if m.removedscorecard == nil {
		m.removedscorecard = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.scorecard, ids[i])
		m.removedscorecard[ids[i]] = struct{}{}
	}
}

// RemovedScorecard returns the removed IDs of the "scorecard" edge to the CertifyScorecard entity.
func (m *SourceNameMutation) RemovedScorecardIDs() (ids []uuid.UUID) {
	for id := range m.removedscorecard {
		ids = append(ids, id)
	}
	return
}

// ScorecardIDs returns the "scorecard" edge IDs in the mutation.
func (m *SourceNameMutation) ScorecardIDs() (ids []uuid.UUID) {
	for id := range m.scorecard {
		ids = append(ids, id)
	}
	return
}

// ResetScorecard resets all changes to the "scorecard" edge.
func (m *SourceNameMutation) ResetScorecard() {
	m.scorecard = nil
	m.clearedscorecard = false
	m.removedscorecard = nil
}

// AddCertificationIDs adds the "certification" edge to the Certification entity by ids.
func (m *SourceNameMutation) AddCertificationIDs(ids ...uuid.UUID) {
	if m.certification == nil {
		m.certification = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.certification[ids[i]] = struct{}{}
	}
}

// ClearCertification clears the "certification" edge to the Certification entity.
func (m *SourceNameMutation) ClearCertification() {
	m.clearedcertification = true
}

// CertificationCleared reports if the "certification" edge to the Certification entity was cleared.
func (m *SourceNameMutation) CertificationCleared() bool {
	return m.clearedcertification
}

// RemoveCertificationIDs removes the "certification" edge to the Certification entity by IDs.
func (m *SourceNameMutation) RemoveCertificationIDs(ids ...uuid.UUID) {
	if m.removedcertification == nil {
		m.removedcertification = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.certification, ids[i])
		m.removedcertification[ids[i]] = struct{}{}
	}
}

// RemovedCertification returns the removed IDs of the "certification" edge to the Certification entity.
func (m *SourceNameMutation) RemovedCertificationIDs() (ids []uuid.UUID) {
	for id := range m.removedcertification {
		ids = append(ids, id)
	}
	return
}

// CertificationIDs returns the "certification" edge IDs in the mutation.
func (m *SourceNameMutation) CertificationIDs() (ids []uuid.UUID) {
	for id := range m.certification {
		ids = append(ids, id)
	}
	return
}

// ResetCertification resets all changes to the "certification" edge.
func (m *SourceNameMutation) ResetCertification() {
	m.certification = nil
	m.clearedcertification = false
	m.removedcertification = nil
}

// AddMetadatumIDs adds the "metadata" edge to the HasMetadata entity by ids.
func (m *SourceNameMutation) AddMetadatumIDs(ids ...uuid.UUID) {
	if m.metadata == nil {
		m.metadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the HasMetadata entity.
func (m *SourceNameMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the HasMetadata entity was cleared.
func (m *SourceNameMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the HasMetadata entity by IDs.
func (m *SourceNameMutation) RemoveMetadatumIDs(ids ...uuid.UUID) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the HasMetadata entity.
func (m *SourceNameMutation) RemovedMetadataIDs() (ids []uuid.UUID) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *SourceNameMutation) MetadataIDs() (ids []uuid.UUID) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *SourceNameMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// AddPocIDs adds the "poc" edge to the PointOfContact entity by ids.
func (m *SourceNameMutation) AddPocIDs(ids ...uuid.UUID) {
	if m.poc == nil {
		m.poc = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.poc[ids[i]] = struct{}{}
	}
}

// ClearPoc clears the "poc" edge to the PointOfContact entity.
func (m *SourceNameMutation) ClearPoc() {
	m.clearedpoc = true
}

// PocCleared reports if the "poc" edge to the PointOfContact entity was cleared.
func (m *SourceNameMutation) PocCleared() bool {
	return m.clearedpoc
}

// RemovePocIDs removes the "poc" edge to the PointOfContact entity by IDs.
func (m *SourceNameMutation) RemovePocIDs(ids ...uuid.UUID) {
	if m.removedpoc == nil {
		m.removedpoc = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.poc, ids[i])
		m.removedpoc[ids[i]] = struct{}{}
	}
}

// RemovedPoc returns the removed IDs of the "poc" edge to the PointOfContact entity.
func (m *SourceNameMutation) RemovedPocIDs() (ids []uuid.UUID) {
	for id := range m.removedpoc {
		ids = append(ids, id)
	}
	return
}

// PocIDs returns the "poc" edge IDs in the mutation.
func (m *SourceNameMutation) PocIDs() (ids []uuid.UUID) {
	for id := range m.poc {
		ids = append(ids, id)
	}
	return
}

// ResetPoc resets all changes to the "poc" edge.
func (m *SourceNameMutation) ResetPoc() {
	m.poc = nil
	m.clearedpoc = false
	m.removedpoc = nil
}

// AddCertifyLegalIDs adds the "certify_legal" edge to the CertifyLegal entity by ids.
func (m *SourceNameMutation) AddCertifyLegalIDs(ids ...uuid.UUID) {
	if m.certify_legal == nil {
		m.certify_legal = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.certify_legal[ids[i]] = struct{}{}
	}
}

// ClearCertifyLegal clears the "certify_legal" edge to the CertifyLegal entity.
func (m *SourceNameMutation) ClearCertifyLegal() {
	m.clearedcertify_legal = true
}

// CertifyLegalCleared reports if the "certify_legal" edge to the CertifyLegal entity was cleared.
func (m *SourceNameMutation) CertifyLegalCleared() bool {
	return m.clearedcertify_legal
}

// RemoveCertifyLegalIDs removes the "certify_legal" edge to the CertifyLegal entity by IDs.
func (m *SourceNameMutation) RemoveCertifyLegalIDs(ids ...uuid.UUID) {
	if m.removedcertify_legal == nil {
		m.removedcertify_legal = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.certify_legal, ids[i])
		m.removedcertify_legal[ids[i]] = struct{}{}
	}
}

// RemovedCertifyLegal returns the removed IDs of the "certify_legal" edge to the CertifyLegal entity.
func (m *SourceNameMutation) RemovedCertifyLegalIDs() (ids []uuid.UUID) {
	for id := range m.removedcertify_legal {
		ids = append(ids, id)
	}
	return
}

// CertifyLegalIDs returns the "certify_legal" edge IDs in the mutation.
func (m *SourceNameMutation) CertifyLegalIDs() (ids []uuid.UUID) {
	for id := range m.certify_legal {
		ids = append(ids, id)
	}
	return
}

// ResetCertifyLegal resets all changes to the "certify_legal" edge.
func (m *SourceNameMutation) ResetCertifyLegal() {
	m.certify_legal = nil
	m.clearedcertify_legal = false
	m.removedcertify_legal = nil
}

// Where appends a list predicates to the SourceNameMutation builder.
func (m *SourceNameMutation) Where(ps ...predicate.SourceName) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceNameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceNameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceName, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceNameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceNameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceName).
func (m *SourceNameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceNameMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._type != nil {
		fields = append(fields, sourcename.FieldType)
	}
	if m.namespace != nil {
		fields = append(fields, sourcename.FieldNamespace)
	}
	if m.name != nil {
		fields = append(fields, sourcename.FieldName)
	}
	if m.commit != nil {
		fields = append(fields, sourcename.FieldCommit)
	}
	if m.tag != nil {
		fields = append(fields, sourcename.FieldTag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceNameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcename.FieldType:
		return m.GetType()
	case sourcename.FieldNamespace:
		return m.Namespace()
	case sourcename.FieldName:
		return m.Name()
	case sourcename.FieldCommit:
		return m.Commit()
	case sourcename.FieldTag:
		return m.Tag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceNameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcename.FieldType:
		return m.OldType(ctx)
	case sourcename.FieldNamespace:
		return m.OldNamespace(ctx)
	case sourcename.FieldName:
		return m.OldName(ctx)
	case sourcename.FieldCommit:
		return m.OldCommit(ctx)
	case sourcename.FieldTag:
		return m.OldTag(ctx)
	}
	return nil, fmt.Errorf("unknown SourceName field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcename.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case sourcename.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case sourcename.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sourcename.FieldCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommit(v)
		return nil
	case sourcename.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	}
	return fmt.Errorf("unknown SourceName field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceNameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceNameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceName numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceNameMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sourcename.FieldCommit) {
		fields = append(fields, sourcename.FieldCommit)
	}
	if m.FieldCleared(sourcename.FieldTag) {
		fields = append(fields, sourcename.FieldTag)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceNameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceNameMutation) ClearField(name string) error {
	switch name {
	case sourcename.FieldCommit:
		m.ClearCommit()
		return nil
	case sourcename.FieldTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown SourceName nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceNameMutation) ResetField(name string) error {
	switch name {
	case sourcename.FieldType:
		m.ResetType()
		return nil
	case sourcename.FieldNamespace:
		m.ResetNamespace()
		return nil
	case sourcename.FieldName:
		m.ResetName()
		return nil
	case sourcename.FieldCommit:
		m.ResetCommit()
		return nil
	case sourcename.FieldTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown SourceName field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceNameMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.occurrences != nil {
		edges = append(edges, sourcename.EdgeOccurrences)
	}
	if m.has_source_at != nil {
		edges = append(edges, sourcename.EdgeHasSourceAt)
	}
	if m.scorecard != nil {
		edges = append(edges, sourcename.EdgeScorecard)
	}
	if m.certification != nil {
		edges = append(edges, sourcename.EdgeCertification)
	}
	if m.metadata != nil {
		edges = append(edges, sourcename.EdgeMetadata)
	}
	if m.poc != nil {
		edges = append(edges, sourcename.EdgePoc)
	}
	if m.certify_legal != nil {
		edges = append(edges, sourcename.EdgeCertifyLegal)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceNameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourcename.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.occurrences))
		for id := range m.occurrences {
			ids = append(ids, id)
		}
		return ids
	case sourcename.EdgeHasSourceAt:
		ids := make([]ent.Value, 0, len(m.has_source_at))
		for id := range m.has_source_at {
			ids = append(ids, id)
		}
		return ids
	case sourcename.EdgeScorecard:
		ids := make([]ent.Value, 0, len(m.scorecard))
		for id := range m.scorecard {
			ids = append(ids, id)
		}
		return ids
	case sourcename.EdgeCertification:
		ids := make([]ent.Value, 0, len(m.certification))
		for id := range m.certification {
			ids = append(ids, id)
		}
		return ids
	case sourcename.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case sourcename.EdgePoc:
		ids := make([]ent.Value, 0, len(m.poc))
		for id := range m.poc {
			ids = append(ids, id)
		}
		return ids
	case sourcename.EdgeCertifyLegal:
		ids := make([]ent.Value, 0, len(m.certify_legal))
		for id := range m.certify_legal {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceNameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedoccurrences != nil {
		edges = append(edges, sourcename.EdgeOccurrences)
	}
	if m.removedhas_source_at != nil {
		edges = append(edges, sourcename.EdgeHasSourceAt)
	}
	if m.removedscorecard != nil {
		edges = append(edges, sourcename.EdgeScorecard)
	}
	if m.removedcertification != nil {
		edges = append(edges, sourcename.EdgeCertification)
	}
	if m.removedmetadata != nil {
		edges = append(edges, sourcename.EdgeMetadata)
	}
	if m.removedpoc != nil {
		edges = append(edges, sourcename.EdgePoc)
	}
	if m.removedcertify_legal != nil {
		edges = append(edges, sourcename.EdgeCertifyLegal)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceNameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sourcename.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.removedoccurrences))
		for id := range m.removedoccurrences {
			ids = append(ids, id)
		}
		return ids
	case sourcename.EdgeHasSourceAt:
		ids := make([]ent.Value, 0, len(m.removedhas_source_at))
		for id := range m.removedhas_source_at {
			ids = append(ids, id)
		}
		return ids
	case sourcename.EdgeScorecard:
		ids := make([]ent.Value, 0, len(m.removedscorecard))
		for id := range m.removedscorecard {
			ids = append(ids, id)
		}
		return ids
	case sourcename.EdgeCertification:
		ids := make([]ent.Value, 0, len(m.removedcertification))
		for id := range m.removedcertification {
			ids = append(ids, id)
		}
		return ids
	case sourcename.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	case sourcename.EdgePoc:
		ids := make([]ent.Value, 0, len(m.removedpoc))
		for id := range m.removedpoc {
			ids = append(ids, id)
		}
		return ids
	case sourcename.EdgeCertifyLegal:
		ids := make([]ent.Value, 0, len(m.removedcertify_legal))
		for id := range m.removedcertify_legal {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceNameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedoccurrences {
		edges = append(edges, sourcename.EdgeOccurrences)
	}
	if m.clearedhas_source_at {
		edges = append(edges, sourcename.EdgeHasSourceAt)
	}
	if m.clearedscorecard {
		edges = append(edges, sourcename.EdgeScorecard)
	}
	if m.clearedcertification {
		edges = append(edges, sourcename.EdgeCertification)
	}
	if m.clearedmetadata {
		edges = append(edges, sourcename.EdgeMetadata)
	}
	if m.clearedpoc {
		edges = append(edges, sourcename.EdgePoc)
	}
	if m.clearedcertify_legal {
		edges = append(edges, sourcename.EdgeCertifyLegal)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceNameMutation) EdgeCleared(name string) bool {
	switch name {
	case sourcename.EdgeOccurrences:
		return m.clearedoccurrences
	case sourcename.EdgeHasSourceAt:
		return m.clearedhas_source_at
	case sourcename.EdgeScorecard:
		return m.clearedscorecard
	case sourcename.EdgeCertification:
		return m.clearedcertification
	case sourcename.EdgeMetadata:
		return m.clearedmetadata
	case sourcename.EdgePoc:
		return m.clearedpoc
	case sourcename.EdgeCertifyLegal:
		return m.clearedcertify_legal
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceNameMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceName unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceNameMutation) ResetEdge(name string) error {
	switch name {
	case sourcename.EdgeOccurrences:
		m.ResetOccurrences()
		return nil
	case sourcename.EdgeHasSourceAt:
		m.ResetHasSourceAt()
		return nil
	case sourcename.EdgeScorecard:
		m.ResetScorecard()
		return nil
	case sourcename.EdgeCertification:
		m.ResetCertification()
		return nil
	case sourcename.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case sourcename.EdgePoc:
		m.ResetPoc()
		return nil
	case sourcename.EdgeCertifyLegal:
		m.ResetCertifyLegal()
		return nil
	}
	return fmt.Errorf("unknown SourceName edge %s", name)
}

// VulnEqualMutation represents an operation that mutates the VulnEqual nodes in the graph.
type VulnEqualMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	justification          *string
	origin                 *string
	collector              *string
	document_ref           *string
	vulnerabilities_hash   *string
	clearedFields          map[string]struct{}
	vulnerability_a        *uuid.UUID
	clearedvulnerability_a bool
	vulnerability_b        *uuid.UUID
	clearedvulnerability_b bool
	done                   bool
	oldValue               func(context.Context) (*VulnEqual, error)
	predicates             []predicate.VulnEqual
}

var _ ent.Mutation = (*VulnEqualMutation)(nil)

// vulnequalOption allows management of the mutation configuration using functional options.
type vulnequalOption func(*VulnEqualMutation)

// newVulnEqualMutation creates new mutation for the VulnEqual entity.
func newVulnEqualMutation(c config, op Op, opts ...vulnequalOption) *VulnEqualMutation {
	m := &VulnEqualMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnEqual,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnEqualID sets the ID field of the mutation.
func withVulnEqualID(id uuid.UUID) vulnequalOption {
	return func(m *VulnEqualMutation) {
		var (
			err   error
			once  sync.Once
			value *VulnEqual
		)
		m.oldValue = func(ctx context.Context) (*VulnEqual, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VulnEqual.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnEqual sets the old VulnEqual of the mutation.
func withVulnEqual(node *VulnEqual) vulnequalOption {
	return func(m *VulnEqualMutation) {
		m.oldValue = func(context.Context) (*VulnEqual, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnEqualMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnEqualMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VulnEqual entities.
func (m *VulnEqualMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnEqualMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VulnEqualMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VulnEqual.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVulnID sets the "vuln_id" field.
func (m *VulnEqualMutation) SetVulnID(u uuid.UUID) {
	m.vulnerability_a = &u
}

// VulnID returns the value of the "vuln_id" field in the mutation.
func (m *VulnEqualMutation) VulnID() (r uuid.UUID, exists bool) {
	v := m.vulnerability_a
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnID returns the old "vuln_id" field's value of the VulnEqual entity.
// If the VulnEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnEqualMutation) OldVulnID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVulnID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVulnID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnID: %w", err)
	}
	return oldValue.VulnID, nil
}

// ResetVulnID resets all changes to the "vuln_id" field.
func (m *VulnEqualMutation) ResetVulnID() {
	m.vulnerability_a = nil
}

// SetEqualVulnID sets the "equal_vuln_id" field.
func (m *VulnEqualMutation) SetEqualVulnID(u uuid.UUID) {
	m.vulnerability_b = &u
}

// EqualVulnID returns the value of the "equal_vuln_id" field in the mutation.
func (m *VulnEqualMutation) EqualVulnID() (r uuid.UUID, exists bool) {
	v := m.vulnerability_b
	if v == nil {
		return
	}
	return *v, true
}

// OldEqualVulnID returns the old "equal_vuln_id" field's value of the VulnEqual entity.
// If the VulnEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnEqualMutation) OldEqualVulnID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEqualVulnID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEqualVulnID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEqualVulnID: %w", err)
	}
	return oldValue.EqualVulnID, nil
}

// ResetEqualVulnID resets all changes to the "equal_vuln_id" field.
func (m *VulnEqualMutation) ResetEqualVulnID() {
	m.vulnerability_b = nil
}

// SetJustification sets the "justification" field.
func (m *VulnEqualMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *VulnEqualMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the VulnEqual entity.
// If the VulnEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnEqualMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *VulnEqualMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *VulnEqualMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *VulnEqualMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the VulnEqual entity.
// If the VulnEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnEqualMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *VulnEqualMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *VulnEqualMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *VulnEqualMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the VulnEqual entity.
// If the VulnEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnEqualMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *VulnEqualMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *VulnEqualMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *VulnEqualMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the VulnEqual entity.
// If the VulnEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnEqualMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *VulnEqualMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// SetVulnerabilitiesHash sets the "vulnerabilities_hash" field.
func (m *VulnEqualMutation) SetVulnerabilitiesHash(s string) {
	m.vulnerabilities_hash = &s
}

// VulnerabilitiesHash returns the value of the "vulnerabilities_hash" field in the mutation.
func (m *VulnEqualMutation) VulnerabilitiesHash() (r string, exists bool) {
	v := m.vulnerabilities_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnerabilitiesHash returns the old "vulnerabilities_hash" field's value of the VulnEqual entity.
// If the VulnEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnEqualMutation) OldVulnerabilitiesHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVulnerabilitiesHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVulnerabilitiesHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnerabilitiesHash: %w", err)
	}
	return oldValue.VulnerabilitiesHash, nil
}

// ResetVulnerabilitiesHash resets all changes to the "vulnerabilities_hash" field.
func (m *VulnEqualMutation) ResetVulnerabilitiesHash() {
	m.vulnerabilities_hash = nil
}

// SetVulnerabilityAID sets the "vulnerability_a" edge to the VulnerabilityID entity by id.
func (m *VulnEqualMutation) SetVulnerabilityAID(id uuid.UUID) {
	m.vulnerability_a = &id
}

// ClearVulnerabilityA clears the "vulnerability_a" edge to the VulnerabilityID entity.
func (m *VulnEqualMutation) ClearVulnerabilityA() {
	m.clearedvulnerability_a = true
	m.clearedFields[vulnequal.FieldVulnID] = struct{}{}
}

// VulnerabilityACleared reports if the "vulnerability_a" edge to the VulnerabilityID entity was cleared.
func (m *VulnEqualMutation) VulnerabilityACleared() bool {
	return m.clearedvulnerability_a
}

// VulnerabilityAID returns the "vulnerability_a" edge ID in the mutation.
func (m *VulnEqualMutation) VulnerabilityAID() (id uuid.UUID, exists bool) {
	if m.vulnerability_a != nil {
		return *m.vulnerability_a, true
	}
	return
}

// VulnerabilityAIDs returns the "vulnerability_a" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityAID instead. It exists only for internal usage by the builders.
func (m *VulnEqualMutation) VulnerabilityAIDs() (ids []uuid.UUID) {
	if id := m.vulnerability_a; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerabilityA resets all changes to the "vulnerability_a" edge.
func (m *VulnEqualMutation) ResetVulnerabilityA() {
	m.vulnerability_a = nil
	m.clearedvulnerability_a = false
}

// SetVulnerabilityBID sets the "vulnerability_b" edge to the VulnerabilityID entity by id.
func (m *VulnEqualMutation) SetVulnerabilityBID(id uuid.UUID) {
	m.vulnerability_b = &id
}

// ClearVulnerabilityB clears the "vulnerability_b" edge to the VulnerabilityID entity.
func (m *VulnEqualMutation) ClearVulnerabilityB() {
	m.clearedvulnerability_b = true
	m.clearedFields[vulnequal.FieldEqualVulnID] = struct{}{}
}

// VulnerabilityBCleared reports if the "vulnerability_b" edge to the VulnerabilityID entity was cleared.
func (m *VulnEqualMutation) VulnerabilityBCleared() bool {
	return m.clearedvulnerability_b
}

// VulnerabilityBID returns the "vulnerability_b" edge ID in the mutation.
func (m *VulnEqualMutation) VulnerabilityBID() (id uuid.UUID, exists bool) {
	if m.vulnerability_b != nil {
		return *m.vulnerability_b, true
	}
	return
}

// VulnerabilityBIDs returns the "vulnerability_b" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityBID instead. It exists only for internal usage by the builders.
func (m *VulnEqualMutation) VulnerabilityBIDs() (ids []uuid.UUID) {
	if id := m.vulnerability_b; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerabilityB resets all changes to the "vulnerability_b" edge.
func (m *VulnEqualMutation) ResetVulnerabilityB() {
	m.vulnerability_b = nil
	m.clearedvulnerability_b = false
}

// Where appends a list predicates to the VulnEqualMutation builder.
func (m *VulnEqualMutation) Where(ps ...predicate.VulnEqual) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VulnEqualMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VulnEqualMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VulnEqual, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VulnEqualMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VulnEqualMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VulnEqual).
func (m *VulnEqualMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnEqualMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.vulnerability_a != nil {
		fields = append(fields, vulnequal.FieldVulnID)
	}
	if m.vulnerability_b != nil {
		fields = append(fields, vulnequal.FieldEqualVulnID)
	}
	if m.justification != nil {
		fields = append(fields, vulnequal.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, vulnequal.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, vulnequal.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, vulnequal.FieldDocumentRef)
	}
	if m.vulnerabilities_hash != nil {
		fields = append(fields, vulnequal.FieldVulnerabilitiesHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnEqualMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnequal.FieldVulnID:
		return m.VulnID()
	case vulnequal.FieldEqualVulnID:
		return m.EqualVulnID()
	case vulnequal.FieldJustification:
		return m.Justification()
	case vulnequal.FieldOrigin:
		return m.Origin()
	case vulnequal.FieldCollector:
		return m.Collector()
	case vulnequal.FieldDocumentRef:
		return m.DocumentRef()
	case vulnequal.FieldVulnerabilitiesHash:
		return m.VulnerabilitiesHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnEqualMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnequal.FieldVulnID:
		return m.OldVulnID(ctx)
	case vulnequal.FieldEqualVulnID:
		return m.OldEqualVulnID(ctx)
	case vulnequal.FieldJustification:
		return m.OldJustification(ctx)
	case vulnequal.FieldOrigin:
		return m.OldOrigin(ctx)
	case vulnequal.FieldCollector:
		return m.OldCollector(ctx)
	case vulnequal.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	case vulnequal.FieldVulnerabilitiesHash:
		return m.OldVulnerabilitiesHash(ctx)
	}
	return nil, fmt.Errorf("unknown VulnEqual field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnEqualMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnequal.FieldVulnID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnID(v)
		return nil
	case vulnequal.FieldEqualVulnID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEqualVulnID(v)
		return nil
	case vulnequal.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case vulnequal.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case vulnequal.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case vulnequal.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	case vulnequal.FieldVulnerabilitiesHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnerabilitiesHash(v)
		return nil
	}
	return fmt.Errorf("unknown VulnEqual field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnEqualMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnEqualMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnEqualMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VulnEqual numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnEqualMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnEqualMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnEqualMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VulnEqual nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnEqualMutation) ResetField(name string) error {
	switch name {
	case vulnequal.FieldVulnID:
		m.ResetVulnID()
		return nil
	case vulnequal.FieldEqualVulnID:
		m.ResetEqualVulnID()
		return nil
	case vulnequal.FieldJustification:
		m.ResetJustification()
		return nil
	case vulnequal.FieldOrigin:
		m.ResetOrigin()
		return nil
	case vulnequal.FieldCollector:
		m.ResetCollector()
		return nil
	case vulnequal.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	case vulnequal.FieldVulnerabilitiesHash:
		m.ResetVulnerabilitiesHash()
		return nil
	}
	return fmt.Errorf("unknown VulnEqual field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnEqualMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.vulnerability_a != nil {
		edges = append(edges, vulnequal.EdgeVulnerabilityA)
	}
	if m.vulnerability_b != nil {
		edges = append(edges, vulnequal.EdgeVulnerabilityB)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnEqualMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnequal.EdgeVulnerabilityA:
		if id := m.vulnerability_a; id != nil {
			return []ent.Value{*id}
		}
	case vulnequal.EdgeVulnerabilityB:
		if id := m.vulnerability_b; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnEqualMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnEqualMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnEqualMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvulnerability_a {
		edges = append(edges, vulnequal.EdgeVulnerabilityA)
	}
	if m.clearedvulnerability_b {
		edges = append(edges, vulnequal.EdgeVulnerabilityB)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnEqualMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnequal.EdgeVulnerabilityA:
		return m.clearedvulnerability_a
	case vulnequal.EdgeVulnerabilityB:
		return m.clearedvulnerability_b
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnEqualMutation) ClearEdge(name string) error {
	switch name {
	case vulnequal.EdgeVulnerabilityA:
		m.ClearVulnerabilityA()
		return nil
	case vulnequal.EdgeVulnerabilityB:
		m.ClearVulnerabilityB()
		return nil
	}
	return fmt.Errorf("unknown VulnEqual unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnEqualMutation) ResetEdge(name string) error {
	switch name {
	case vulnequal.EdgeVulnerabilityA:
		m.ResetVulnerabilityA()
		return nil
	case vulnequal.EdgeVulnerabilityB:
		m.ResetVulnerabilityB()
		return nil
	}
	return fmt.Errorf("unknown VulnEqual edge %s", name)
}

// VulnerabilityIDMutation represents an operation that mutates the VulnerabilityID nodes in the graph.
type VulnerabilityIDMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	vulnerability_id         *string
	_type                    *string
	clearedFields            map[string]struct{}
	vuln_equal_vuln_a        map[uuid.UUID]struct{}
	removedvuln_equal_vuln_a map[uuid.UUID]struct{}
	clearedvuln_equal_vuln_a bool
	vuln_equal_vuln_b        map[uuid.UUID]struct{}
	removedvuln_equal_vuln_b map[uuid.UUID]struct{}
	clearedvuln_equal_vuln_b bool
	metadata                 map[uuid.UUID]struct{}
	removedmetadata          map[uuid.UUID]struct{}
	clearedmetadata          bool
	certify_vuln             map[uuid.UUID]struct{}
	removedcertify_vuln      map[uuid.UUID]struct{}
	clearedcertify_vuln      bool
	vex                      map[uuid.UUID]struct{}
	removedvex               map[uuid.UUID]struct{}
	clearedvex               bool
	done                     bool
	oldValue                 func(context.Context) (*VulnerabilityID, error)
	predicates               []predicate.VulnerabilityID
}

var _ ent.Mutation = (*VulnerabilityIDMutation)(nil)

// vulnerabilityidOption allows management of the mutation configuration using functional options.
type vulnerabilityidOption func(*VulnerabilityIDMutation)

// newVulnerabilityIDMutation creates new mutation for the VulnerabilityID entity.
func newVulnerabilityIDMutation(c config, op Op, opts ...vulnerabilityidOption) *VulnerabilityIDMutation {
	m := &VulnerabilityIDMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnerabilityID,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnerabilityIDID sets the ID field of the mutation.
func withVulnerabilityIDID(id uuid.UUID) vulnerabilityidOption {
	return func(m *VulnerabilityIDMutation) {
		var (
			err   error
			once  sync.Once
			value *VulnerabilityID
		)
		m.oldValue = func(ctx context.Context) (*VulnerabilityID, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VulnerabilityID.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnerabilityID sets the old VulnerabilityID of the mutation.
func withVulnerabilityID(node *VulnerabilityID) vulnerabilityidOption {
	return func(m *VulnerabilityIDMutation) {
		m.oldValue = func(context.Context) (*VulnerabilityID, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnerabilityIDMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnerabilityIDMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VulnerabilityID entities.
func (m *VulnerabilityIDMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnerabilityIDMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VulnerabilityIDMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VulnerabilityID.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVulnerabilityID sets the "vulnerability_id" field.
func (m *VulnerabilityIDMutation) SetVulnerabilityID(s string) {
	m.vulnerability_id = &s
}

// VulnerabilityID returns the value of the "vulnerability_id" field in the mutation.
func (m *VulnerabilityIDMutation) VulnerabilityID() (r string, exists bool) {
	v := m.vulnerability_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnerabilityID returns the old "vulnerability_id" field's value of the VulnerabilityID entity.
// If the VulnerabilityID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityIDMutation) OldVulnerabilityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVulnerabilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVulnerabilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnerabilityID: %w", err)
	}
	return oldValue.VulnerabilityID, nil
}

// ResetVulnerabilityID resets all changes to the "vulnerability_id" field.
func (m *VulnerabilityIDMutation) ResetVulnerabilityID() {
	m.vulnerability_id = nil
}

// SetType sets the "type" field.
func (m *VulnerabilityIDMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *VulnerabilityIDMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the VulnerabilityID entity.
// If the VulnerabilityID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityIDMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *VulnerabilityIDMutation) ResetType() {
	m._type = nil
}

// AddVulnEqualVulnAIDs adds the "vuln_equal_vuln_a" edge to the VulnEqual entity by ids.
func (m *VulnerabilityIDMutation) AddVulnEqualVulnAIDs(ids ...uuid.UUID) {
	if m.vuln_equal_vuln_a == nil {
		m.vuln_equal_vuln_a = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vuln_equal_vuln_a[ids[i]] = struct{}{}
	}
}

// ClearVulnEqualVulnA clears the "vuln_equal_vuln_a" edge to the VulnEqual entity.
func (m *VulnerabilityIDMutation) ClearVulnEqualVulnA() {
	m.clearedvuln_equal_vuln_a = true
}

// VulnEqualVulnACleared reports if the "vuln_equal_vuln_a" edge to the VulnEqual entity was cleared.
func (m *VulnerabilityIDMutation) VulnEqualVulnACleared() bool {
	return m.clearedvuln_equal_vuln_a
}

// RemoveVulnEqualVulnAIDs removes the "vuln_equal_vuln_a" edge to the VulnEqual entity by IDs.
func (m *VulnerabilityIDMutation) RemoveVulnEqualVulnAIDs(ids ...uuid.UUID) {
	if m.removedvuln_equal_vuln_a == nil {
		m.removedvuln_equal_vuln_a = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vuln_equal_vuln_a, ids[i])
		m.removedvuln_equal_vuln_a[ids[i]] = struct{}{}
	}
}

// RemovedVulnEqualVulnA returns the removed IDs of the "vuln_equal_vuln_a" edge to the VulnEqual entity.
func (m *VulnerabilityIDMutation) RemovedVulnEqualVulnAIDs() (ids []uuid.UUID) {
	for id := range m.removedvuln_equal_vuln_a {
		ids = append(ids, id)
	}
	return
}

// VulnEqualVulnAIDs returns the "vuln_equal_vuln_a" edge IDs in the mutation.
func (m *VulnerabilityIDMutation) VulnEqualVulnAIDs() (ids []uuid.UUID) {
	for id := range m.vuln_equal_vuln_a {
		ids = append(ids, id)
	}
	return
}

// ResetVulnEqualVulnA resets all changes to the "vuln_equal_vuln_a" edge.
func (m *VulnerabilityIDMutation) ResetVulnEqualVulnA() {
	m.vuln_equal_vuln_a = nil
	m.clearedvuln_equal_vuln_a = false
	m.removedvuln_equal_vuln_a = nil
}

// AddVulnEqualVulnBIDs adds the "vuln_equal_vuln_b" edge to the VulnEqual entity by ids.
func (m *VulnerabilityIDMutation) AddVulnEqualVulnBIDs(ids ...uuid.UUID) {
	if m.vuln_equal_vuln_b == nil {
		m.vuln_equal_vuln_b = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vuln_equal_vuln_b[ids[i]] = struct{}{}
	}
}

// ClearVulnEqualVulnB clears the "vuln_equal_vuln_b" edge to the VulnEqual entity.
func (m *VulnerabilityIDMutation) ClearVulnEqualVulnB() {
	m.clearedvuln_equal_vuln_b = true
}

// VulnEqualVulnBCleared reports if the "vuln_equal_vuln_b" edge to the VulnEqual entity was cleared.
func (m *VulnerabilityIDMutation) VulnEqualVulnBCleared() bool {
	return m.clearedvuln_equal_vuln_b
}

// RemoveVulnEqualVulnBIDs removes the "vuln_equal_vuln_b" edge to the VulnEqual entity by IDs.
func (m *VulnerabilityIDMutation) RemoveVulnEqualVulnBIDs(ids ...uuid.UUID) {
	if m.removedvuln_equal_vuln_b == nil {
		m.removedvuln_equal_vuln_b = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vuln_equal_vuln_b, ids[i])
		m.removedvuln_equal_vuln_b[ids[i]] = struct{}{}
	}
}

// RemovedVulnEqualVulnB returns the removed IDs of the "vuln_equal_vuln_b" edge to the VulnEqual entity.
func (m *VulnerabilityIDMutation) RemovedVulnEqualVulnBIDs() (ids []uuid.UUID) {
	for id := range m.removedvuln_equal_vuln_b {
		ids = append(ids, id)
	}
	return
}

// VulnEqualVulnBIDs returns the "vuln_equal_vuln_b" edge IDs in the mutation.
func (m *VulnerabilityIDMutation) VulnEqualVulnBIDs() (ids []uuid.UUID) {
	for id := range m.vuln_equal_vuln_b {
		ids = append(ids, id)
	}
	return
}

// ResetVulnEqualVulnB resets all changes to the "vuln_equal_vuln_b" edge.
func (m *VulnerabilityIDMutation) ResetVulnEqualVulnB() {
	m.vuln_equal_vuln_b = nil
	m.clearedvuln_equal_vuln_b = false
	m.removedvuln_equal_vuln_b = nil
}

// AddMetadatumIDs adds the "metadata" edge to the VulnerabilityMetadata entity by ids.
func (m *VulnerabilityIDMutation) AddMetadatumIDs(ids ...uuid.UUID) {
	if m.metadata == nil {
		m.metadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the VulnerabilityMetadata entity.
func (m *VulnerabilityIDMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the VulnerabilityMetadata entity was cleared.
func (m *VulnerabilityIDMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the VulnerabilityMetadata entity by IDs.
func (m *VulnerabilityIDMutation) RemoveMetadatumIDs(ids ...uuid.UUID) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the VulnerabilityMetadata entity.
func (m *VulnerabilityIDMutation) RemovedMetadataIDs() (ids []uuid.UUID) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *VulnerabilityIDMutation) MetadataIDs() (ids []uuid.UUID) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *VulnerabilityIDMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// AddCertifyVulnIDs adds the "certify_vuln" edge to the CertifyVuln entity by ids.
func (m *VulnerabilityIDMutation) AddCertifyVulnIDs(ids ...uuid.UUID) {
	if m.certify_vuln == nil {
		m.certify_vuln = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.certify_vuln[ids[i]] = struct{}{}
	}
}

// ClearCertifyVuln clears the "certify_vuln" edge to the CertifyVuln entity.
func (m *VulnerabilityIDMutation) ClearCertifyVuln() {
	m.clearedcertify_vuln = true
}

// CertifyVulnCleared reports if the "certify_vuln" edge to the CertifyVuln entity was cleared.
func (m *VulnerabilityIDMutation) CertifyVulnCleared() bool {
	return m.clearedcertify_vuln
}

// RemoveCertifyVulnIDs removes the "certify_vuln" edge to the CertifyVuln entity by IDs.
func (m *VulnerabilityIDMutation) RemoveCertifyVulnIDs(ids ...uuid.UUID) {
	if m.removedcertify_vuln == nil {
		m.removedcertify_vuln = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.certify_vuln, ids[i])
		m.removedcertify_vuln[ids[i]] = struct{}{}
	}
}

// RemovedCertifyVuln returns the removed IDs of the "certify_vuln" edge to the CertifyVuln entity.
func (m *VulnerabilityIDMutation) RemovedCertifyVulnIDs() (ids []uuid.UUID) {
	for id := range m.removedcertify_vuln {
		ids = append(ids, id)
	}
	return
}

// CertifyVulnIDs returns the "certify_vuln" edge IDs in the mutation.
func (m *VulnerabilityIDMutation) CertifyVulnIDs() (ids []uuid.UUID) {
	for id := range m.certify_vuln {
		ids = append(ids, id)
	}
	return
}

// ResetCertifyVuln resets all changes to the "certify_vuln" edge.
func (m *VulnerabilityIDMutation) ResetCertifyVuln() {
	m.certify_vuln = nil
	m.clearedcertify_vuln = false
	m.removedcertify_vuln = nil
}

// AddVexIDs adds the "vex" edge to the CertifyVex entity by ids.
func (m *VulnerabilityIDMutation) AddVexIDs(ids ...uuid.UUID) {
	if m.vex == nil {
		m.vex = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vex[ids[i]] = struct{}{}
	}
}

// ClearVex clears the "vex" edge to the CertifyVex entity.
func (m *VulnerabilityIDMutation) ClearVex() {
	m.clearedvex = true
}

// VexCleared reports if the "vex" edge to the CertifyVex entity was cleared.
func (m *VulnerabilityIDMutation) VexCleared() bool {
	return m.clearedvex
}

// RemoveVexIDs removes the "vex" edge to the CertifyVex entity by IDs.
func (m *VulnerabilityIDMutation) RemoveVexIDs(ids ...uuid.UUID) {
	if m.removedvex == nil {
		m.removedvex = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vex, ids[i])
		m.removedvex[ids[i]] = struct{}{}
	}
}

// RemovedVex returns the removed IDs of the "vex" edge to the CertifyVex entity.
func (m *VulnerabilityIDMutation) RemovedVexIDs() (ids []uuid.UUID) {
	for id := range m.removedvex {
		ids = append(ids, id)
	}
	return
}

// VexIDs returns the "vex" edge IDs in the mutation.
func (m *VulnerabilityIDMutation) VexIDs() (ids []uuid.UUID) {
	for id := range m.vex {
		ids = append(ids, id)
	}
	return
}

// ResetVex resets all changes to the "vex" edge.
func (m *VulnerabilityIDMutation) ResetVex() {
	m.vex = nil
	m.clearedvex = false
	m.removedvex = nil
}

// Where appends a list predicates to the VulnerabilityIDMutation builder.
func (m *VulnerabilityIDMutation) Where(ps ...predicate.VulnerabilityID) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VulnerabilityIDMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VulnerabilityIDMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VulnerabilityID, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VulnerabilityIDMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VulnerabilityIDMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VulnerabilityID).
func (m *VulnerabilityIDMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnerabilityIDMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.vulnerability_id != nil {
		fields = append(fields, vulnerabilityid.FieldVulnerabilityID)
	}
	if m._type != nil {
		fields = append(fields, vulnerabilityid.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnerabilityIDMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnerabilityid.FieldVulnerabilityID:
		return m.VulnerabilityID()
	case vulnerabilityid.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnerabilityIDMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnerabilityid.FieldVulnerabilityID:
		return m.OldVulnerabilityID(ctx)
	case vulnerabilityid.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown VulnerabilityID field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityIDMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnerabilityid.FieldVulnerabilityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnerabilityID(v)
		return nil
	case vulnerabilityid.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityID field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnerabilityIDMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnerabilityIDMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityIDMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VulnerabilityID numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnerabilityIDMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnerabilityIDMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnerabilityIDMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VulnerabilityID nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnerabilityIDMutation) ResetField(name string) error {
	switch name {
	case vulnerabilityid.FieldVulnerabilityID:
		m.ResetVulnerabilityID()
		return nil
	case vulnerabilityid.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityID field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnerabilityIDMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.vuln_equal_vuln_a != nil {
		edges = append(edges, vulnerabilityid.EdgeVulnEqualVulnA)
	}
	if m.vuln_equal_vuln_b != nil {
		edges = append(edges, vulnerabilityid.EdgeVulnEqualVulnB)
	}
	if m.metadata != nil {
		edges = append(edges, vulnerabilityid.EdgeMetadata)
	}
	if m.certify_vuln != nil {
		edges = append(edges, vulnerabilityid.EdgeCertifyVuln)
	}
	if m.vex != nil {
		edges = append(edges, vulnerabilityid.EdgeVex)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnerabilityIDMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnerabilityid.EdgeVulnEqualVulnA:
		ids := make([]ent.Value, 0, len(m.vuln_equal_vuln_a))
		for id := range m.vuln_equal_vuln_a {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityid.EdgeVulnEqualVulnB:
		ids := make([]ent.Value, 0, len(m.vuln_equal_vuln_b))
		for id := range m.vuln_equal_vuln_b {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityid.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityid.EdgeCertifyVuln:
		ids := make([]ent.Value, 0, len(m.certify_vuln))
		for id := range m.certify_vuln {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityid.EdgeVex:
		ids := make([]ent.Value, 0, len(m.vex))
		for id := range m.vex {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnerabilityIDMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedvuln_equal_vuln_a != nil {
		edges = append(edges, vulnerabilityid.EdgeVulnEqualVulnA)
	}
	if m.removedvuln_equal_vuln_b != nil {
		edges = append(edges, vulnerabilityid.EdgeVulnEqualVulnB)
	}
	if m.removedmetadata != nil {
		edges = append(edges, vulnerabilityid.EdgeMetadata)
	}
	if m.removedcertify_vuln != nil {
		edges = append(edges, vulnerabilityid.EdgeCertifyVuln)
	}
	if m.removedvex != nil {
		edges = append(edges, vulnerabilityid.EdgeVex)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnerabilityIDMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vulnerabilityid.EdgeVulnEqualVulnA:
		ids := make([]ent.Value, 0, len(m.removedvuln_equal_vuln_a))
		for id := range m.removedvuln_equal_vuln_a {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityid.EdgeVulnEqualVulnB:
		ids := make([]ent.Value, 0, len(m.removedvuln_equal_vuln_b))
		for id := range m.removedvuln_equal_vuln_b {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityid.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityid.EdgeCertifyVuln:
		ids := make([]ent.Value, 0, len(m.removedcertify_vuln))
		for id := range m.removedcertify_vuln {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityid.EdgeVex:
		ids := make([]ent.Value, 0, len(m.removedvex))
		for id := range m.removedvex {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnerabilityIDMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedvuln_equal_vuln_a {
		edges = append(edges, vulnerabilityid.EdgeVulnEqualVulnA)
	}
	if m.clearedvuln_equal_vuln_b {
		edges = append(edges, vulnerabilityid.EdgeVulnEqualVulnB)
	}
	if m.clearedmetadata {
		edges = append(edges, vulnerabilityid.EdgeMetadata)
	}
	if m.clearedcertify_vuln {
		edges = append(edges, vulnerabilityid.EdgeCertifyVuln)
	}
	if m.clearedvex {
		edges = append(edges, vulnerabilityid.EdgeVex)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnerabilityIDMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnerabilityid.EdgeVulnEqualVulnA:
		return m.clearedvuln_equal_vuln_a
	case vulnerabilityid.EdgeVulnEqualVulnB:
		return m.clearedvuln_equal_vuln_b
	case vulnerabilityid.EdgeMetadata:
		return m.clearedmetadata
	case vulnerabilityid.EdgeCertifyVuln:
		return m.clearedcertify_vuln
	case vulnerabilityid.EdgeVex:
		return m.clearedvex
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnerabilityIDMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown VulnerabilityID unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnerabilityIDMutation) ResetEdge(name string) error {
	switch name {
	case vulnerabilityid.EdgeVulnEqualVulnA:
		m.ResetVulnEqualVulnA()
		return nil
	case vulnerabilityid.EdgeVulnEqualVulnB:
		m.ResetVulnEqualVulnB()
		return nil
	case vulnerabilityid.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case vulnerabilityid.EdgeCertifyVuln:
		m.ResetCertifyVuln()
		return nil
	case vulnerabilityid.EdgeVex:
		m.ResetVex()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityID edge %s", name)
}

// VulnerabilityMetadataMutation represents an operation that mutates the VulnerabilityMetadata nodes in the graph.
type VulnerabilityMetadataMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	score_type              *vulnerabilitymetadata.ScoreType
	score_value             *float64
	addscore_value          *float64
	timestamp               *time.Time
	origin                  *string
	collector               *string
	document_ref            *string
	clearedFields           map[string]struct{}
	vulnerability_id        *uuid.UUID
	clearedvulnerability_id bool
	done                    bool
	oldValue                func(context.Context) (*VulnerabilityMetadata, error)
	predicates              []predicate.VulnerabilityMetadata
}

var _ ent.Mutation = (*VulnerabilityMetadataMutation)(nil)

// vulnerabilitymetadataOption allows management of the mutation configuration using functional options.
type vulnerabilitymetadataOption func(*VulnerabilityMetadataMutation)

// newVulnerabilityMetadataMutation creates new mutation for the VulnerabilityMetadata entity.
func newVulnerabilityMetadataMutation(c config, op Op, opts ...vulnerabilitymetadataOption) *VulnerabilityMetadataMutation {
	m := &VulnerabilityMetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnerabilityMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnerabilityMetadataID sets the ID field of the mutation.
func withVulnerabilityMetadataID(id uuid.UUID) vulnerabilitymetadataOption {
	return func(m *VulnerabilityMetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *VulnerabilityMetadata
		)
		m.oldValue = func(ctx context.Context) (*VulnerabilityMetadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VulnerabilityMetadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnerabilityMetadata sets the old VulnerabilityMetadata of the mutation.
func withVulnerabilityMetadata(node *VulnerabilityMetadata) vulnerabilitymetadataOption {
	return func(m *VulnerabilityMetadataMutation) {
		m.oldValue = func(context.Context) (*VulnerabilityMetadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnerabilityMetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnerabilityMetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VulnerabilityMetadata entities.
func (m *VulnerabilityMetadataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnerabilityMetadataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VulnerabilityMetadataMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VulnerabilityMetadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVulnerabilityIDID sets the "vulnerability_id_id" field.
func (m *VulnerabilityMetadataMutation) SetVulnerabilityIDID(u uuid.UUID) {
	m.vulnerability_id = &u
}

// VulnerabilityIDID returns the value of the "vulnerability_id_id" field in the mutation.
func (m *VulnerabilityMetadataMutation) VulnerabilityIDID() (r uuid.UUID, exists bool) {
	v := m.vulnerability_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnerabilityIDID returns the old "vulnerability_id_id" field's value of the VulnerabilityMetadata entity.
// If the VulnerabilityMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMetadataMutation) OldVulnerabilityIDID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVulnerabilityIDID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVulnerabilityIDID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnerabilityIDID: %w", err)
	}
	return oldValue.VulnerabilityIDID, nil
}

// ResetVulnerabilityIDID resets all changes to the "vulnerability_id_id" field.
func (m *VulnerabilityMetadataMutation) ResetVulnerabilityIDID() {
	m.vulnerability_id = nil
}

// SetScoreType sets the "score_type" field.
func (m *VulnerabilityMetadataMutation) SetScoreType(vt vulnerabilitymetadata.ScoreType) {
	m.score_type = &vt
}

// ScoreType returns the value of the "score_type" field in the mutation.
func (m *VulnerabilityMetadataMutation) ScoreType() (r vulnerabilitymetadata.ScoreType, exists bool) {
	v := m.score_type
	if v == nil {
		return
	}
	return *v, true
}

// OldScoreType returns the old "score_type" field's value of the VulnerabilityMetadata entity.
// If the VulnerabilityMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMetadataMutation) OldScoreType(ctx context.Context) (v vulnerabilitymetadata.ScoreType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScoreType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScoreType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScoreType: %w", err)
	}
	return oldValue.ScoreType, nil
}

// ResetScoreType resets all changes to the "score_type" field.
func (m *VulnerabilityMetadataMutation) ResetScoreType() {
	m.score_type = nil
}

// SetScoreValue sets the "score_value" field.
func (m *VulnerabilityMetadataMutation) SetScoreValue(f float64) {
	m.score_value = &f
	m.addscore_value = nil
}

// ScoreValue returns the value of the "score_value" field in the mutation.
func (m *VulnerabilityMetadataMutation) ScoreValue() (r float64, exists bool) {
	v := m.score_value
	if v == nil {
		return
	}
	return *v, true
}

// OldScoreValue returns the old "score_value" field's value of the VulnerabilityMetadata entity.
// If the VulnerabilityMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMetadataMutation) OldScoreValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScoreValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScoreValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScoreValue: %w", err)
	}
	return oldValue.ScoreValue, nil
}

// AddScoreValue adds f to the "score_value" field.
func (m *VulnerabilityMetadataMutation) AddScoreValue(f float64) {
	if m.addscore_value != nil {
		*m.addscore_value += f
	} else {
		m.addscore_value = &f
	}
}

// AddedScoreValue returns the value that was added to the "score_value" field in this mutation.
func (m *VulnerabilityMetadataMutation) AddedScoreValue() (r float64, exists bool) {
	v := m.addscore_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetScoreValue resets all changes to the "score_value" field.
func (m *VulnerabilityMetadataMutation) ResetScoreValue() {
	m.score_value = nil
	m.addscore_value = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *VulnerabilityMetadataMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *VulnerabilityMetadataMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the VulnerabilityMetadata entity.
// If the VulnerabilityMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMetadataMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *VulnerabilityMetadataMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetOrigin sets the "origin" field.
func (m *VulnerabilityMetadataMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *VulnerabilityMetadataMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the VulnerabilityMetadata entity.
// If the VulnerabilityMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMetadataMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *VulnerabilityMetadataMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *VulnerabilityMetadataMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *VulnerabilityMetadataMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the VulnerabilityMetadata entity.
// If the VulnerabilityMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMetadataMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *VulnerabilityMetadataMutation) ResetCollector() {
	m.collector = nil
}

// SetDocumentRef sets the "document_ref" field.
func (m *VulnerabilityMetadataMutation) SetDocumentRef(s string) {
	m.document_ref = &s
}

// DocumentRef returns the value of the "document_ref" field in the mutation.
func (m *VulnerabilityMetadataMutation) DocumentRef() (r string, exists bool) {
	v := m.document_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentRef returns the old "document_ref" field's value of the VulnerabilityMetadata entity.
// If the VulnerabilityMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMetadataMutation) OldDocumentRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentRef: %w", err)
	}
	return oldValue.DocumentRef, nil
}

// ResetDocumentRef resets all changes to the "document_ref" field.
func (m *VulnerabilityMetadataMutation) ResetDocumentRef() {
	m.document_ref = nil
}

// ClearVulnerabilityID clears the "vulnerability_id" edge to the VulnerabilityID entity.
func (m *VulnerabilityMetadataMutation) ClearVulnerabilityID() {
	m.clearedvulnerability_id = true
	m.clearedFields[vulnerabilitymetadata.FieldVulnerabilityIDID] = struct{}{}
}

// VulnerabilityIDCleared reports if the "vulnerability_id" edge to the VulnerabilityID entity was cleared.
func (m *VulnerabilityMetadataMutation) VulnerabilityIDCleared() bool {
	return m.clearedvulnerability_id
}

// VulnerabilityIDIDs returns the "vulnerability_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityIDID instead. It exists only for internal usage by the builders.
func (m *VulnerabilityMetadataMutation) VulnerabilityIDIDs() (ids []uuid.UUID) {
	if id := m.vulnerability_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerabilityID resets all changes to the "vulnerability_id" edge.
func (m *VulnerabilityMetadataMutation) ResetVulnerabilityID() {
	m.vulnerability_id = nil
	m.clearedvulnerability_id = false
}

// Where appends a list predicates to the VulnerabilityMetadataMutation builder.
func (m *VulnerabilityMetadataMutation) Where(ps ...predicate.VulnerabilityMetadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VulnerabilityMetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VulnerabilityMetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VulnerabilityMetadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VulnerabilityMetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VulnerabilityMetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VulnerabilityMetadata).
func (m *VulnerabilityMetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnerabilityMetadataMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.vulnerability_id != nil {
		fields = append(fields, vulnerabilitymetadata.FieldVulnerabilityIDID)
	}
	if m.score_type != nil {
		fields = append(fields, vulnerabilitymetadata.FieldScoreType)
	}
	if m.score_value != nil {
		fields = append(fields, vulnerabilitymetadata.FieldScoreValue)
	}
	if m.timestamp != nil {
		fields = append(fields, vulnerabilitymetadata.FieldTimestamp)
	}
	if m.origin != nil {
		fields = append(fields, vulnerabilitymetadata.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, vulnerabilitymetadata.FieldCollector)
	}
	if m.document_ref != nil {
		fields = append(fields, vulnerabilitymetadata.FieldDocumentRef)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnerabilityMetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnerabilitymetadata.FieldVulnerabilityIDID:
		return m.VulnerabilityIDID()
	case vulnerabilitymetadata.FieldScoreType:
		return m.ScoreType()
	case vulnerabilitymetadata.FieldScoreValue:
		return m.ScoreValue()
	case vulnerabilitymetadata.FieldTimestamp:
		return m.Timestamp()
	case vulnerabilitymetadata.FieldOrigin:
		return m.Origin()
	case vulnerabilitymetadata.FieldCollector:
		return m.Collector()
	case vulnerabilitymetadata.FieldDocumentRef:
		return m.DocumentRef()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnerabilityMetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnerabilitymetadata.FieldVulnerabilityIDID:
		return m.OldVulnerabilityIDID(ctx)
	case vulnerabilitymetadata.FieldScoreType:
		return m.OldScoreType(ctx)
	case vulnerabilitymetadata.FieldScoreValue:
		return m.OldScoreValue(ctx)
	case vulnerabilitymetadata.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case vulnerabilitymetadata.FieldOrigin:
		return m.OldOrigin(ctx)
	case vulnerabilitymetadata.FieldCollector:
		return m.OldCollector(ctx)
	case vulnerabilitymetadata.FieldDocumentRef:
		return m.OldDocumentRef(ctx)
	}
	return nil, fmt.Errorf("unknown VulnerabilityMetadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityMetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnerabilitymetadata.FieldVulnerabilityIDID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnerabilityIDID(v)
		return nil
	case vulnerabilitymetadata.FieldScoreType:
		v, ok := value.(vulnerabilitymetadata.ScoreType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScoreType(v)
		return nil
	case vulnerabilitymetadata.FieldScoreValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScoreValue(v)
		return nil
	case vulnerabilitymetadata.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case vulnerabilitymetadata.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case vulnerabilitymetadata.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case vulnerabilitymetadata.FieldDocumentRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentRef(v)
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityMetadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnerabilityMetadataMutation) AddedFields() []string {
	var fields []string
	if m.addscore_value != nil {
		fields = append(fields, vulnerabilitymetadata.FieldScoreValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnerabilityMetadataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vulnerabilitymetadata.FieldScoreValue:
		return m.AddedScoreValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityMetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vulnerabilitymetadata.FieldScoreValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScoreValue(v)
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityMetadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnerabilityMetadataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnerabilityMetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnerabilityMetadataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VulnerabilityMetadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnerabilityMetadataMutation) ResetField(name string) error {
	switch name {
	case vulnerabilitymetadata.FieldVulnerabilityIDID:
		m.ResetVulnerabilityIDID()
		return nil
	case vulnerabilitymetadata.FieldScoreType:
		m.ResetScoreType()
		return nil
	case vulnerabilitymetadata.FieldScoreValue:
		m.ResetScoreValue()
		return nil
	case vulnerabilitymetadata.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case vulnerabilitymetadata.FieldOrigin:
		m.ResetOrigin()
		return nil
	case vulnerabilitymetadata.FieldCollector:
		m.ResetCollector()
		return nil
	case vulnerabilitymetadata.FieldDocumentRef:
		m.ResetDocumentRef()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityMetadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnerabilityMetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vulnerability_id != nil {
		edges = append(edges, vulnerabilitymetadata.EdgeVulnerabilityID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnerabilityMetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnerabilitymetadata.EdgeVulnerabilityID:
		if id := m.vulnerability_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnerabilityMetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnerabilityMetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnerabilityMetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvulnerability_id {
		edges = append(edges, vulnerabilitymetadata.EdgeVulnerabilityID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnerabilityMetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnerabilitymetadata.EdgeVulnerabilityID:
		return m.clearedvulnerability_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnerabilityMetadataMutation) ClearEdge(name string) error {
	switch name {
	case vulnerabilitymetadata.EdgeVulnerabilityID:
		m.ClearVulnerabilityID()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityMetadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnerabilityMetadataMutation) ResetEdge(name string) error {
	switch name {
	case vulnerabilitymetadata.EdgeVulnerabilityID:
		m.ResetVulnerabilityID()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityMetadata edge %s", name)
}
