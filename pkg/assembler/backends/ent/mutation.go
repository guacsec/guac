// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/artifact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/billofmaterials"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/builder"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certification"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvuln"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/dependency"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hashequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hassourceat"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/isvulnerability"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/occurrence"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagetype"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pkgequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/predicate"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/securityadvisory"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/slsaattestation"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcetype"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArtifact         = "Artifact"
	TypeBillOfMaterials  = "BillOfMaterials"
	TypeBuilder          = "Builder"
	TypeCertification    = "Certification"
	TypeCertifyVuln      = "CertifyVuln"
	TypeDependency       = "Dependency"
	TypeHasSourceAt      = "HasSourceAt"
	TypeHashEqual        = "HashEqual"
	TypeIsVulnerability  = "IsVulnerability"
	TypeOccurrence       = "Occurrence"
	TypePackageName      = "PackageName"
	TypePackageNamespace = "PackageNamespace"
	TypePackageType      = "PackageType"
	TypePackageVersion   = "PackageVersion"
	TypePkgEqual         = "PkgEqual"
	TypeSLSAAttestation  = "SLSAAttestation"
	TypeSecurityAdvisory = "SecurityAdvisory"
	TypeSourceName       = "SourceName"
	TypeSourceNamespace  = "SourceNamespace"
	TypeSourceType       = "SourceType"
)

// ArtifactMutation represents an operation that mutates the Artifact nodes in the graph.
type ArtifactMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	algorithm           *string
	digest              *string
	clearedFields       map[string]struct{}
	occurrences         map[int]struct{}
	removedoccurrences  map[int]struct{}
	clearedoccurrences  bool
	sbom                map[int]struct{}
	removedsbom         map[int]struct{}
	clearedsbom         bool
	attestations        map[int]struct{}
	removedattestations map[int]struct{}
	clearedattestations bool
	same                map[int]struct{}
	removedsame         map[int]struct{}
	clearedsame         bool
	done                bool
	oldValue            func(context.Context) (*Artifact, error)
	predicates          []predicate.Artifact
}

var _ ent.Mutation = (*ArtifactMutation)(nil)

// artifactOption allows management of the mutation configuration using functional options.
type artifactOption func(*ArtifactMutation)

// newArtifactMutation creates new mutation for the Artifact entity.
func newArtifactMutation(c config, op Op, opts ...artifactOption) *ArtifactMutation {
	m := &ArtifactMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactID sets the ID field of the mutation.
func withArtifactID(id int) artifactOption {
	return func(m *ArtifactMutation) {
		var (
			err   error
			once  sync.Once
			value *Artifact
		)
		m.oldValue = func(ctx context.Context) (*Artifact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artifact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifact sets the old Artifact of the mutation.
func withArtifact(node *Artifact) artifactOption {
	return func(m *ArtifactMutation) {
		m.oldValue = func(context.Context) (*Artifact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtifactMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artifact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlgorithm sets the "algorithm" field.
func (m *ArtifactMutation) SetAlgorithm(s string) {
	m.algorithm = &s
}

// Algorithm returns the value of the "algorithm" field in the mutation.
func (m *ArtifactMutation) Algorithm() (r string, exists bool) {
	v := m.algorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgorithm returns the old "algorithm" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldAlgorithm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgorithm: %w", err)
	}
	return oldValue.Algorithm, nil
}

// ResetAlgorithm resets all changes to the "algorithm" field.
func (m *ArtifactMutation) ResetAlgorithm() {
	m.algorithm = nil
}

// SetDigest sets the "digest" field.
func (m *ArtifactMutation) SetDigest(s string) {
	m.digest = &s
}

// Digest returns the value of the "digest" field in the mutation.
func (m *ArtifactMutation) Digest() (r string, exists bool) {
	v := m.digest
	if v == nil {
		return
	}
	return *v, true
}

// OldDigest returns the old "digest" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDigest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigest: %w", err)
	}
	return oldValue.Digest, nil
}

// ResetDigest resets all changes to the "digest" field.
func (m *ArtifactMutation) ResetDigest() {
	m.digest = nil
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by ids.
func (m *ArtifactMutation) AddOccurrenceIDs(ids ...int) {
	if m.occurrences == nil {
		m.occurrences = make(map[int]struct{})
	}
	for i := range ids {
		m.occurrences[ids[i]] = struct{}{}
	}
}

// ClearOccurrences clears the "occurrences" edge to the Occurrence entity.
func (m *ArtifactMutation) ClearOccurrences() {
	m.clearedoccurrences = true
}

// OccurrencesCleared reports if the "occurrences" edge to the Occurrence entity was cleared.
func (m *ArtifactMutation) OccurrencesCleared() bool {
	return m.clearedoccurrences
}

// RemoveOccurrenceIDs removes the "occurrences" edge to the Occurrence entity by IDs.
func (m *ArtifactMutation) RemoveOccurrenceIDs(ids ...int) {
	if m.removedoccurrences == nil {
		m.removedoccurrences = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occurrences, ids[i])
		m.removedoccurrences[ids[i]] = struct{}{}
	}
}

// RemovedOccurrences returns the removed IDs of the "occurrences" edge to the Occurrence entity.
func (m *ArtifactMutation) RemovedOccurrencesIDs() (ids []int) {
	for id := range m.removedoccurrences {
		ids = append(ids, id)
	}
	return
}

// OccurrencesIDs returns the "occurrences" edge IDs in the mutation.
func (m *ArtifactMutation) OccurrencesIDs() (ids []int) {
	for id := range m.occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetOccurrences resets all changes to the "occurrences" edge.
func (m *ArtifactMutation) ResetOccurrences() {
	m.occurrences = nil
	m.clearedoccurrences = false
	m.removedoccurrences = nil
}

// AddSbomIDs adds the "sbom" edge to the BillOfMaterials entity by ids.
func (m *ArtifactMutation) AddSbomIDs(ids ...int) {
	if m.sbom == nil {
		m.sbom = make(map[int]struct{})
	}
	for i := range ids {
		m.sbom[ids[i]] = struct{}{}
	}
}

// ClearSbom clears the "sbom" edge to the BillOfMaterials entity.
func (m *ArtifactMutation) ClearSbom() {
	m.clearedsbom = true
}

// SbomCleared reports if the "sbom" edge to the BillOfMaterials entity was cleared.
func (m *ArtifactMutation) SbomCleared() bool {
	return m.clearedsbom
}

// RemoveSbomIDs removes the "sbom" edge to the BillOfMaterials entity by IDs.
func (m *ArtifactMutation) RemoveSbomIDs(ids ...int) {
	if m.removedsbom == nil {
		m.removedsbom = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sbom, ids[i])
		m.removedsbom[ids[i]] = struct{}{}
	}
}

// RemovedSbom returns the removed IDs of the "sbom" edge to the BillOfMaterials entity.
func (m *ArtifactMutation) RemovedSbomIDs() (ids []int) {
	for id := range m.removedsbom {
		ids = append(ids, id)
	}
	return
}

// SbomIDs returns the "sbom" edge IDs in the mutation.
func (m *ArtifactMutation) SbomIDs() (ids []int) {
	for id := range m.sbom {
		ids = append(ids, id)
	}
	return
}

// ResetSbom resets all changes to the "sbom" edge.
func (m *ArtifactMutation) ResetSbom() {
	m.sbom = nil
	m.clearedsbom = false
	m.removedsbom = nil
}

// AddAttestationIDs adds the "attestations" edge to the SLSAAttestation entity by ids.
func (m *ArtifactMutation) AddAttestationIDs(ids ...int) {
	if m.attestations == nil {
		m.attestations = make(map[int]struct{})
	}
	for i := range ids {
		m.attestations[ids[i]] = struct{}{}
	}
}

// ClearAttestations clears the "attestations" edge to the SLSAAttestation entity.
func (m *ArtifactMutation) ClearAttestations() {
	m.clearedattestations = true
}

// AttestationsCleared reports if the "attestations" edge to the SLSAAttestation entity was cleared.
func (m *ArtifactMutation) AttestationsCleared() bool {
	return m.clearedattestations
}

// RemoveAttestationIDs removes the "attestations" edge to the SLSAAttestation entity by IDs.
func (m *ArtifactMutation) RemoveAttestationIDs(ids ...int) {
	if m.removedattestations == nil {
		m.removedattestations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attestations, ids[i])
		m.removedattestations[ids[i]] = struct{}{}
	}
}

// RemovedAttestations returns the removed IDs of the "attestations" edge to the SLSAAttestation entity.
func (m *ArtifactMutation) RemovedAttestationsIDs() (ids []int) {
	for id := range m.removedattestations {
		ids = append(ids, id)
	}
	return
}

// AttestationsIDs returns the "attestations" edge IDs in the mutation.
func (m *ArtifactMutation) AttestationsIDs() (ids []int) {
	for id := range m.attestations {
		ids = append(ids, id)
	}
	return
}

// ResetAttestations resets all changes to the "attestations" edge.
func (m *ArtifactMutation) ResetAttestations() {
	m.attestations = nil
	m.clearedattestations = false
	m.removedattestations = nil
}

// AddSameIDs adds the "same" edge to the HashEqual entity by ids.
func (m *ArtifactMutation) AddSameIDs(ids ...int) {
	if m.same == nil {
		m.same = make(map[int]struct{})
	}
	for i := range ids {
		m.same[ids[i]] = struct{}{}
	}
}

// ClearSame clears the "same" edge to the HashEqual entity.
func (m *ArtifactMutation) ClearSame() {
	m.clearedsame = true
}

// SameCleared reports if the "same" edge to the HashEqual entity was cleared.
func (m *ArtifactMutation) SameCleared() bool {
	return m.clearedsame
}

// RemoveSameIDs removes the "same" edge to the HashEqual entity by IDs.
func (m *ArtifactMutation) RemoveSameIDs(ids ...int) {
	if m.removedsame == nil {
		m.removedsame = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.same, ids[i])
		m.removedsame[ids[i]] = struct{}{}
	}
}

// RemovedSame returns the removed IDs of the "same" edge to the HashEqual entity.
func (m *ArtifactMutation) RemovedSameIDs() (ids []int) {
	for id := range m.removedsame {
		ids = append(ids, id)
	}
	return
}

// SameIDs returns the "same" edge IDs in the mutation.
func (m *ArtifactMutation) SameIDs() (ids []int) {
	for id := range m.same {
		ids = append(ids, id)
	}
	return
}

// ResetSame resets all changes to the "same" edge.
func (m *ArtifactMutation) ResetSame() {
	m.same = nil
	m.clearedsame = false
	m.removedsame = nil
}

// Where appends a list predicates to the ArtifactMutation builder.
func (m *ArtifactMutation) Where(ps ...predicate.Artifact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtifactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtifactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Artifact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtifactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtifactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Artifact).
func (m *ArtifactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.algorithm != nil {
		fields = append(fields, artifact.FieldAlgorithm)
	}
	if m.digest != nil {
		fields = append(fields, artifact.FieldDigest)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifact.FieldAlgorithm:
		return m.Algorithm()
	case artifact.FieldDigest:
		return m.Digest()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifact.FieldAlgorithm:
		return m.OldAlgorithm(ctx)
	case artifact.FieldDigest:
		return m.OldDigest(ctx)
	}
	return nil, fmt.Errorf("unknown Artifact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifact.FieldAlgorithm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgorithm(v)
		return nil
	case artifact.FieldDigest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigest(v)
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Artifact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactMutation) ResetField(name string) error {
	switch name {
	case artifact.FieldAlgorithm:
		m.ResetAlgorithm()
		return nil
	case artifact.FieldDigest:
		m.ResetDigest()
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.occurrences != nil {
		edges = append(edges, artifact.EdgeOccurrences)
	}
	if m.sbom != nil {
		edges = append(edges, artifact.EdgeSbom)
	}
	if m.attestations != nil {
		edges = append(edges, artifact.EdgeAttestations)
	}
	if m.same != nil {
		edges = append(edges, artifact.EdgeSame)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.occurrences))
		for id := range m.occurrences {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeSbom:
		ids := make([]ent.Value, 0, len(m.sbom))
		for id := range m.sbom {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeAttestations:
		ids := make([]ent.Value, 0, len(m.attestations))
		for id := range m.attestations {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeSame:
		ids := make([]ent.Value, 0, len(m.same))
		for id := range m.same {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedoccurrences != nil {
		edges = append(edges, artifact.EdgeOccurrences)
	}
	if m.removedsbom != nil {
		edges = append(edges, artifact.EdgeSbom)
	}
	if m.removedattestations != nil {
		edges = append(edges, artifact.EdgeAttestations)
	}
	if m.removedsame != nil {
		edges = append(edges, artifact.EdgeSame)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.removedoccurrences))
		for id := range m.removedoccurrences {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeSbom:
		ids := make([]ent.Value, 0, len(m.removedsbom))
		for id := range m.removedsbom {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeAttestations:
		ids := make([]ent.Value, 0, len(m.removedattestations))
		for id := range m.removedattestations {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeSame:
		ids := make([]ent.Value, 0, len(m.removedsame))
		for id := range m.removedsame {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedoccurrences {
		edges = append(edges, artifact.EdgeOccurrences)
	}
	if m.clearedsbom {
		edges = append(edges, artifact.EdgeSbom)
	}
	if m.clearedattestations {
		edges = append(edges, artifact.EdgeAttestations)
	}
	if m.clearedsame {
		edges = append(edges, artifact.EdgeSame)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactMutation) EdgeCleared(name string) bool {
	switch name {
	case artifact.EdgeOccurrences:
		return m.clearedoccurrences
	case artifact.EdgeSbom:
		return m.clearedsbom
	case artifact.EdgeAttestations:
		return m.clearedattestations
	case artifact.EdgeSame:
		return m.clearedsame
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactMutation) ResetEdge(name string) error {
	switch name {
	case artifact.EdgeOccurrences:
		m.ResetOccurrences()
		return nil
	case artifact.EdgeSbom:
		m.ResetSbom()
		return nil
	case artifact.EdgeAttestations:
		m.ResetAttestations()
		return nil
	case artifact.EdgeSame:
		m.ResetSame()
		return nil
	}
	return fmt.Errorf("unknown Artifact edge %s", name)
}

// BillOfMaterialsMutation represents an operation that mutates the BillOfMaterials nodes in the graph.
type BillOfMaterialsMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uri               *string
	algorithm         *string
	digest            *string
	download_location *string
	origin            *string
	collector         *string
	annotations       *[]model.Annotation
	appendannotations []model.Annotation
	clearedFields     map[string]struct{}
	_package          *int
	cleared_package   bool
	artifact          *int
	clearedartifact   bool
	done              bool
	oldValue          func(context.Context) (*BillOfMaterials, error)
	predicates        []predicate.BillOfMaterials
}

var _ ent.Mutation = (*BillOfMaterialsMutation)(nil)

// billofmaterialsOption allows management of the mutation configuration using functional options.
type billofmaterialsOption func(*BillOfMaterialsMutation)

// newBillOfMaterialsMutation creates new mutation for the BillOfMaterials entity.
func newBillOfMaterialsMutation(c config, op Op, opts ...billofmaterialsOption) *BillOfMaterialsMutation {
	m := &BillOfMaterialsMutation{
		config:        c,
		op:            op,
		typ:           TypeBillOfMaterials,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillOfMaterialsID sets the ID field of the mutation.
func withBillOfMaterialsID(id int) billofmaterialsOption {
	return func(m *BillOfMaterialsMutation) {
		var (
			err   error
			once  sync.Once
			value *BillOfMaterials
		)
		m.oldValue = func(ctx context.Context) (*BillOfMaterials, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillOfMaterials.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillOfMaterials sets the old BillOfMaterials of the mutation.
func withBillOfMaterials(node *BillOfMaterials) billofmaterialsOption {
	return func(m *BillOfMaterialsMutation) {
		m.oldValue = func(context.Context) (*BillOfMaterials, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillOfMaterialsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillOfMaterialsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillOfMaterialsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillOfMaterialsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillOfMaterials.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *BillOfMaterialsMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *BillOfMaterialsMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldPackageID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *BillOfMaterialsMutation) ClearPackageID() {
	m._package = nil
	m.clearedFields[billofmaterials.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *BillOfMaterialsMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[billofmaterials.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *BillOfMaterialsMutation) ResetPackageID() {
	m._package = nil
	delete(m.clearedFields, billofmaterials.FieldPackageID)
}

// SetArtifactID sets the "artifact_id" field.
func (m *BillOfMaterialsMutation) SetArtifactID(i int) {
	m.artifact = &i
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *BillOfMaterialsMutation) ArtifactID() (r int, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldArtifactID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ClearArtifactID clears the value of the "artifact_id" field.
func (m *BillOfMaterialsMutation) ClearArtifactID() {
	m.artifact = nil
	m.clearedFields[billofmaterials.FieldArtifactID] = struct{}{}
}

// ArtifactIDCleared returns if the "artifact_id" field was cleared in this mutation.
func (m *BillOfMaterialsMutation) ArtifactIDCleared() bool {
	_, ok := m.clearedFields[billofmaterials.FieldArtifactID]
	return ok
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *BillOfMaterialsMutation) ResetArtifactID() {
	m.artifact = nil
	delete(m.clearedFields, billofmaterials.FieldArtifactID)
}

// SetURI sets the "uri" field.
func (m *BillOfMaterialsMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *BillOfMaterialsMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *BillOfMaterialsMutation) ResetURI() {
	m.uri = nil
}

// SetAlgorithm sets the "algorithm" field.
func (m *BillOfMaterialsMutation) SetAlgorithm(s string) {
	m.algorithm = &s
}

// Algorithm returns the value of the "algorithm" field in the mutation.
func (m *BillOfMaterialsMutation) Algorithm() (r string, exists bool) {
	v := m.algorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgorithm returns the old "algorithm" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldAlgorithm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgorithm: %w", err)
	}
	return oldValue.Algorithm, nil
}

// ResetAlgorithm resets all changes to the "algorithm" field.
func (m *BillOfMaterialsMutation) ResetAlgorithm() {
	m.algorithm = nil
}

// SetDigest sets the "digest" field.
func (m *BillOfMaterialsMutation) SetDigest(s string) {
	m.digest = &s
}

// Digest returns the value of the "digest" field in the mutation.
func (m *BillOfMaterialsMutation) Digest() (r string, exists bool) {
	v := m.digest
	if v == nil {
		return
	}
	return *v, true
}

// OldDigest returns the old "digest" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldDigest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigest: %w", err)
	}
	return oldValue.Digest, nil
}

// ResetDigest resets all changes to the "digest" field.
func (m *BillOfMaterialsMutation) ResetDigest() {
	m.digest = nil
}

// SetDownloadLocation sets the "download_location" field.
func (m *BillOfMaterialsMutation) SetDownloadLocation(s string) {
	m.download_location = &s
}

// DownloadLocation returns the value of the "download_location" field in the mutation.
func (m *BillOfMaterialsMutation) DownloadLocation() (r string, exists bool) {
	v := m.download_location
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadLocation returns the old "download_location" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldDownloadLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadLocation: %w", err)
	}
	return oldValue.DownloadLocation, nil
}

// ResetDownloadLocation resets all changes to the "download_location" field.
func (m *BillOfMaterialsMutation) ResetDownloadLocation() {
	m.download_location = nil
}

// SetOrigin sets the "origin" field.
func (m *BillOfMaterialsMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *BillOfMaterialsMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *BillOfMaterialsMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *BillOfMaterialsMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *BillOfMaterialsMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *BillOfMaterialsMutation) ResetCollector() {
	m.collector = nil
}

// SetAnnotations sets the "annotations" field.
func (m *BillOfMaterialsMutation) SetAnnotations(value []model.Annotation) {
	m.annotations = &value
	m.appendannotations = nil
}

// Annotations returns the value of the "annotations" field in the mutation.
func (m *BillOfMaterialsMutation) Annotations() (r []model.Annotation, exists bool) {
	v := m.annotations
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotations returns the old "annotations" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldAnnotations(ctx context.Context) (v []model.Annotation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotations: %w", err)
	}
	return oldValue.Annotations, nil
}

// AppendAnnotations adds value to the "annotations" field.
func (m *BillOfMaterialsMutation) AppendAnnotations(value []model.Annotation) {
	m.appendannotations = append(m.appendannotations, value...)
}

// AppendedAnnotations returns the list of values that were appended to the "annotations" field in this mutation.
func (m *BillOfMaterialsMutation) AppendedAnnotations() ([]model.Annotation, bool) {
	if len(m.appendannotations) == 0 {
		return nil, false
	}
	return m.appendannotations, true
}

// ClearAnnotations clears the value of the "annotations" field.
func (m *BillOfMaterialsMutation) ClearAnnotations() {
	m.annotations = nil
	m.appendannotations = nil
	m.clearedFields[billofmaterials.FieldAnnotations] = struct{}{}
}

// AnnotationsCleared returns if the "annotations" field was cleared in this mutation.
func (m *BillOfMaterialsMutation) AnnotationsCleared() bool {
	_, ok := m.clearedFields[billofmaterials.FieldAnnotations]
	return ok
}

// ResetAnnotations resets all changes to the "annotations" field.
func (m *BillOfMaterialsMutation) ResetAnnotations() {
	m.annotations = nil
	m.appendannotations = nil
	delete(m.clearedFields, billofmaterials.FieldAnnotations)
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *BillOfMaterialsMutation) ClearPackage() {
	m.cleared_package = true
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *BillOfMaterialsMutation) PackageCleared() bool {
	return m.PackageIDCleared() || m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *BillOfMaterialsMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *BillOfMaterialsMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *BillOfMaterialsMutation) ClearArtifact() {
	m.clearedartifact = true
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *BillOfMaterialsMutation) ArtifactCleared() bool {
	return m.ArtifactIDCleared() || m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *BillOfMaterialsMutation) ArtifactIDs() (ids []int) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *BillOfMaterialsMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// Where appends a list predicates to the BillOfMaterialsMutation builder.
func (m *BillOfMaterialsMutation) Where(ps ...predicate.BillOfMaterials) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillOfMaterialsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillOfMaterialsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillOfMaterials, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillOfMaterialsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillOfMaterialsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillOfMaterials).
func (m *BillOfMaterialsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillOfMaterialsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._package != nil {
		fields = append(fields, billofmaterials.FieldPackageID)
	}
	if m.artifact != nil {
		fields = append(fields, billofmaterials.FieldArtifactID)
	}
	if m.uri != nil {
		fields = append(fields, billofmaterials.FieldURI)
	}
	if m.algorithm != nil {
		fields = append(fields, billofmaterials.FieldAlgorithm)
	}
	if m.digest != nil {
		fields = append(fields, billofmaterials.FieldDigest)
	}
	if m.download_location != nil {
		fields = append(fields, billofmaterials.FieldDownloadLocation)
	}
	if m.origin != nil {
		fields = append(fields, billofmaterials.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, billofmaterials.FieldCollector)
	}
	if m.annotations != nil {
		fields = append(fields, billofmaterials.FieldAnnotations)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillOfMaterialsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billofmaterials.FieldPackageID:
		return m.PackageID()
	case billofmaterials.FieldArtifactID:
		return m.ArtifactID()
	case billofmaterials.FieldURI:
		return m.URI()
	case billofmaterials.FieldAlgorithm:
		return m.Algorithm()
	case billofmaterials.FieldDigest:
		return m.Digest()
	case billofmaterials.FieldDownloadLocation:
		return m.DownloadLocation()
	case billofmaterials.FieldOrigin:
		return m.Origin()
	case billofmaterials.FieldCollector:
		return m.Collector()
	case billofmaterials.FieldAnnotations:
		return m.Annotations()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillOfMaterialsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billofmaterials.FieldPackageID:
		return m.OldPackageID(ctx)
	case billofmaterials.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case billofmaterials.FieldURI:
		return m.OldURI(ctx)
	case billofmaterials.FieldAlgorithm:
		return m.OldAlgorithm(ctx)
	case billofmaterials.FieldDigest:
		return m.OldDigest(ctx)
	case billofmaterials.FieldDownloadLocation:
		return m.OldDownloadLocation(ctx)
	case billofmaterials.FieldOrigin:
		return m.OldOrigin(ctx)
	case billofmaterials.FieldCollector:
		return m.OldCollector(ctx)
	case billofmaterials.FieldAnnotations:
		return m.OldAnnotations(ctx)
	}
	return nil, fmt.Errorf("unknown BillOfMaterials field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillOfMaterialsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billofmaterials.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case billofmaterials.FieldArtifactID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case billofmaterials.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case billofmaterials.FieldAlgorithm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgorithm(v)
		return nil
	case billofmaterials.FieldDigest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigest(v)
		return nil
	case billofmaterials.FieldDownloadLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadLocation(v)
		return nil
	case billofmaterials.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case billofmaterials.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case billofmaterials.FieldAnnotations:
		v, ok := value.([]model.Annotation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotations(v)
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillOfMaterialsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillOfMaterialsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillOfMaterialsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillOfMaterials numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillOfMaterialsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billofmaterials.FieldPackageID) {
		fields = append(fields, billofmaterials.FieldPackageID)
	}
	if m.FieldCleared(billofmaterials.FieldArtifactID) {
		fields = append(fields, billofmaterials.FieldArtifactID)
	}
	if m.FieldCleared(billofmaterials.FieldAnnotations) {
		fields = append(fields, billofmaterials.FieldAnnotations)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillOfMaterialsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillOfMaterialsMutation) ClearField(name string) error {
	switch name {
	case billofmaterials.FieldPackageID:
		m.ClearPackageID()
		return nil
	case billofmaterials.FieldArtifactID:
		m.ClearArtifactID()
		return nil
	case billofmaterials.FieldAnnotations:
		m.ClearAnnotations()
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillOfMaterialsMutation) ResetField(name string) error {
	switch name {
	case billofmaterials.FieldPackageID:
		m.ResetPackageID()
		return nil
	case billofmaterials.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case billofmaterials.FieldURI:
		m.ResetURI()
		return nil
	case billofmaterials.FieldAlgorithm:
		m.ResetAlgorithm()
		return nil
	case billofmaterials.FieldDigest:
		m.ResetDigest()
		return nil
	case billofmaterials.FieldDownloadLocation:
		m.ResetDownloadLocation()
		return nil
	case billofmaterials.FieldOrigin:
		m.ResetOrigin()
		return nil
	case billofmaterials.FieldCollector:
		m.ResetCollector()
		return nil
	case billofmaterials.FieldAnnotations:
		m.ResetAnnotations()
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillOfMaterialsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._package != nil {
		edges = append(edges, billofmaterials.EdgePackage)
	}
	if m.artifact != nil {
		edges = append(edges, billofmaterials.EdgeArtifact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillOfMaterialsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billofmaterials.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case billofmaterials.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillOfMaterialsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillOfMaterialsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillOfMaterialsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_package {
		edges = append(edges, billofmaterials.EdgePackage)
	}
	if m.clearedartifact {
		edges = append(edges, billofmaterials.EdgeArtifact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillOfMaterialsMutation) EdgeCleared(name string) bool {
	switch name {
	case billofmaterials.EdgePackage:
		return m.cleared_package
	case billofmaterials.EdgeArtifact:
		return m.clearedartifact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillOfMaterialsMutation) ClearEdge(name string) error {
	switch name {
	case billofmaterials.EdgePackage:
		m.ClearPackage()
		return nil
	case billofmaterials.EdgeArtifact:
		m.ClearArtifact()
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillOfMaterialsMutation) ResetEdge(name string) error {
	switch name {
	case billofmaterials.EdgePackage:
		m.ResetPackage()
		return nil
	case billofmaterials.EdgeArtifact:
		m.ResetArtifact()
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials edge %s", name)
}

// BuilderMutation represents an operation that mutates the Builder nodes in the graph.
type BuilderMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	uri                      *string
	clearedFields            map[string]struct{}
	slsa_attestations        map[int]struct{}
	removedslsa_attestations map[int]struct{}
	clearedslsa_attestations bool
	done                     bool
	oldValue                 func(context.Context) (*Builder, error)
	predicates               []predicate.Builder
}

var _ ent.Mutation = (*BuilderMutation)(nil)

// builderOption allows management of the mutation configuration using functional options.
type builderOption func(*BuilderMutation)

// newBuilderMutation creates new mutation for the Builder entity.
func newBuilderMutation(c config, op Op, opts ...builderOption) *BuilderMutation {
	m := &BuilderMutation{
		config:        c,
		op:            op,
		typ:           TypeBuilder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuilderID sets the ID field of the mutation.
func withBuilderID(id int) builderOption {
	return func(m *BuilderMutation) {
		var (
			err   error
			once  sync.Once
			value *Builder
		)
		m.oldValue = func(ctx context.Context) (*Builder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Builder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuilder sets the old Builder of the mutation.
func withBuilder(node *Builder) builderOption {
	return func(m *BuilderMutation) {
		m.oldValue = func(context.Context) (*Builder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuilderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuilderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuilderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuilderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Builder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURI sets the "uri" field.
func (m *BuilderMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *BuilderMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the Builder entity.
// If the Builder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuilderMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *BuilderMutation) ResetURI() {
	m.uri = nil
}

// AddSlsaAttestationIDs adds the "slsa_attestations" edge to the SLSAAttestation entity by ids.
func (m *BuilderMutation) AddSlsaAttestationIDs(ids ...int) {
	if m.slsa_attestations == nil {
		m.slsa_attestations = make(map[int]struct{})
	}
	for i := range ids {
		m.slsa_attestations[ids[i]] = struct{}{}
	}
}

// ClearSlsaAttestations clears the "slsa_attestations" edge to the SLSAAttestation entity.
func (m *BuilderMutation) ClearSlsaAttestations() {
	m.clearedslsa_attestations = true
}

// SlsaAttestationsCleared reports if the "slsa_attestations" edge to the SLSAAttestation entity was cleared.
func (m *BuilderMutation) SlsaAttestationsCleared() bool {
	return m.clearedslsa_attestations
}

// RemoveSlsaAttestationIDs removes the "slsa_attestations" edge to the SLSAAttestation entity by IDs.
func (m *BuilderMutation) RemoveSlsaAttestationIDs(ids ...int) {
	if m.removedslsa_attestations == nil {
		m.removedslsa_attestations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.slsa_attestations, ids[i])
		m.removedslsa_attestations[ids[i]] = struct{}{}
	}
}

// RemovedSlsaAttestations returns the removed IDs of the "slsa_attestations" edge to the SLSAAttestation entity.
func (m *BuilderMutation) RemovedSlsaAttestationsIDs() (ids []int) {
	for id := range m.removedslsa_attestations {
		ids = append(ids, id)
	}
	return
}

// SlsaAttestationsIDs returns the "slsa_attestations" edge IDs in the mutation.
func (m *BuilderMutation) SlsaAttestationsIDs() (ids []int) {
	for id := range m.slsa_attestations {
		ids = append(ids, id)
	}
	return
}

// ResetSlsaAttestations resets all changes to the "slsa_attestations" edge.
func (m *BuilderMutation) ResetSlsaAttestations() {
	m.slsa_attestations = nil
	m.clearedslsa_attestations = false
	m.removedslsa_attestations = nil
}

// Where appends a list predicates to the BuilderMutation builder.
func (m *BuilderMutation) Where(ps ...predicate.Builder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BuilderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BuilderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Builder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BuilderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BuilderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Builder).
func (m *BuilderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuilderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.uri != nil {
		fields = append(fields, builder.FieldURI)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuilderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case builder.FieldURI:
		return m.URI()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuilderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case builder.FieldURI:
		return m.OldURI(ctx)
	}
	return nil, fmt.Errorf("unknown Builder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuilderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case builder.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	}
	return fmt.Errorf("unknown Builder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuilderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuilderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuilderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Builder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuilderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuilderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuilderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Builder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuilderMutation) ResetField(name string) error {
	switch name {
	case builder.FieldURI:
		m.ResetURI()
		return nil
	}
	return fmt.Errorf("unknown Builder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuilderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.slsa_attestations != nil {
		edges = append(edges, builder.EdgeSlsaAttestations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuilderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case builder.EdgeSlsaAttestations:
		ids := make([]ent.Value, 0, len(m.slsa_attestations))
		for id := range m.slsa_attestations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuilderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedslsa_attestations != nil {
		edges = append(edges, builder.EdgeSlsaAttestations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuilderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case builder.EdgeSlsaAttestations:
		ids := make([]ent.Value, 0, len(m.removedslsa_attestations))
		for id := range m.removedslsa_attestations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuilderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedslsa_attestations {
		edges = append(edges, builder.EdgeSlsaAttestations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuilderMutation) EdgeCleared(name string) bool {
	switch name {
	case builder.EdgeSlsaAttestations:
		return m.clearedslsa_attestations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuilderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Builder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuilderMutation) ResetEdge(name string) error {
	switch name {
	case builder.EdgeSlsaAttestations:
		m.ResetSlsaAttestations()
		return nil
	}
	return fmt.Errorf("unknown Builder edge %s", name)
}

// CertificationMutation represents an operation that mutates the Certification nodes in the graph.
type CertificationMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_type                  *certification.Type
	justification          *string
	origin                 *string
	collector              *string
	clearedFields          map[string]struct{}
	source                 *int
	clearedsource          bool
	package_version        *int
	clearedpackage_version bool
	all_versions           *int
	clearedall_versions    bool
	artifact               *int
	clearedartifact        bool
	done                   bool
	oldValue               func(context.Context) (*Certification, error)
	predicates             []predicate.Certification
}

var _ ent.Mutation = (*CertificationMutation)(nil)

// certificationOption allows management of the mutation configuration using functional options.
type certificationOption func(*CertificationMutation)

// newCertificationMutation creates new mutation for the Certification entity.
func newCertificationMutation(c config, op Op, opts ...certificationOption) *CertificationMutation {
	m := &CertificationMutation{
		config:        c,
		op:            op,
		typ:           TypeCertification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificationID sets the ID field of the mutation.
func withCertificationID(id int) certificationOption {
	return func(m *CertificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Certification
		)
		m.oldValue = func(ctx context.Context) (*Certification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Certification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertification sets the old Certification of the mutation.
func withCertification(node *Certification) certificationOption {
	return func(m *CertificationMutation) {
		m.oldValue = func(context.Context) (*Certification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Certification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceID sets the "source_id" field.
func (m *CertificationMutation) SetSourceID(i int) {
	m.source = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *CertificationMutation) SourceID() (r int, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldSourceID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *CertificationMutation) ClearSourceID() {
	m.source = nil
	m.clearedFields[certification.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *CertificationMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[certification.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *CertificationMutation) ResetSourceID() {
	m.source = nil
	delete(m.clearedFields, certification.FieldSourceID)
}

// SetPackageVersionID sets the "package_version_id" field.
func (m *CertificationMutation) SetPackageVersionID(i int) {
	m.package_version = &i
}

// PackageVersionID returns the value of the "package_version_id" field in the mutation.
func (m *CertificationMutation) PackageVersionID() (r int, exists bool) {
	v := m.package_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageVersionID returns the old "package_version_id" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldPackageVersionID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageVersionID: %w", err)
	}
	return oldValue.PackageVersionID, nil
}

// ClearPackageVersionID clears the value of the "package_version_id" field.
func (m *CertificationMutation) ClearPackageVersionID() {
	m.package_version = nil
	m.clearedFields[certification.FieldPackageVersionID] = struct{}{}
}

// PackageVersionIDCleared returns if the "package_version_id" field was cleared in this mutation.
func (m *CertificationMutation) PackageVersionIDCleared() bool {
	_, ok := m.clearedFields[certification.FieldPackageVersionID]
	return ok
}

// ResetPackageVersionID resets all changes to the "package_version_id" field.
func (m *CertificationMutation) ResetPackageVersionID() {
	m.package_version = nil
	delete(m.clearedFields, certification.FieldPackageVersionID)
}

// SetPackageNameID sets the "package_name_id" field.
func (m *CertificationMutation) SetPackageNameID(i int) {
	m.all_versions = &i
}

// PackageNameID returns the value of the "package_name_id" field in the mutation.
func (m *CertificationMutation) PackageNameID() (r int, exists bool) {
	v := m.all_versions
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageNameID returns the old "package_name_id" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldPackageNameID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageNameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageNameID: %w", err)
	}
	return oldValue.PackageNameID, nil
}

// ClearPackageNameID clears the value of the "package_name_id" field.
func (m *CertificationMutation) ClearPackageNameID() {
	m.all_versions = nil
	m.clearedFields[certification.FieldPackageNameID] = struct{}{}
}

// PackageNameIDCleared returns if the "package_name_id" field was cleared in this mutation.
func (m *CertificationMutation) PackageNameIDCleared() bool {
	_, ok := m.clearedFields[certification.FieldPackageNameID]
	return ok
}

// ResetPackageNameID resets all changes to the "package_name_id" field.
func (m *CertificationMutation) ResetPackageNameID() {
	m.all_versions = nil
	delete(m.clearedFields, certification.FieldPackageNameID)
}

// SetArtifactID sets the "artifact_id" field.
func (m *CertificationMutation) SetArtifactID(i int) {
	m.artifact = &i
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *CertificationMutation) ArtifactID() (r int, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldArtifactID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ClearArtifactID clears the value of the "artifact_id" field.
func (m *CertificationMutation) ClearArtifactID() {
	m.artifact = nil
	m.clearedFields[certification.FieldArtifactID] = struct{}{}
}

// ArtifactIDCleared returns if the "artifact_id" field was cleared in this mutation.
func (m *CertificationMutation) ArtifactIDCleared() bool {
	_, ok := m.clearedFields[certification.FieldArtifactID]
	return ok
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *CertificationMutation) ResetArtifactID() {
	m.artifact = nil
	delete(m.clearedFields, certification.FieldArtifactID)
}

// SetType sets the "type" field.
func (m *CertificationMutation) SetType(c certification.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CertificationMutation) GetType() (r certification.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldType(ctx context.Context) (v certification.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CertificationMutation) ResetType() {
	m._type = nil
}

// SetJustification sets the "justification" field.
func (m *CertificationMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *CertificationMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *CertificationMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *CertificationMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *CertificationMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *CertificationMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *CertificationMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *CertificationMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *CertificationMutation) ResetCollector() {
	m.collector = nil
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *CertificationMutation) ClearSource() {
	m.clearedsource = true
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *CertificationMutation) SourceCleared() bool {
	return m.SourceIDCleared() || m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *CertificationMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *CertificationMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// ClearPackageVersion clears the "package_version" edge to the PackageVersion entity.
func (m *CertificationMutation) ClearPackageVersion() {
	m.clearedpackage_version = true
}

// PackageVersionCleared reports if the "package_version" edge to the PackageVersion entity was cleared.
func (m *CertificationMutation) PackageVersionCleared() bool {
	return m.PackageVersionIDCleared() || m.clearedpackage_version
}

// PackageVersionIDs returns the "package_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageVersionID instead. It exists only for internal usage by the builders.
func (m *CertificationMutation) PackageVersionIDs() (ids []int) {
	if id := m.package_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackageVersion resets all changes to the "package_version" edge.
func (m *CertificationMutation) ResetPackageVersion() {
	m.package_version = nil
	m.clearedpackage_version = false
}

// SetAllVersionsID sets the "all_versions" edge to the PackageName entity by id.
func (m *CertificationMutation) SetAllVersionsID(id int) {
	m.all_versions = &id
}

// ClearAllVersions clears the "all_versions" edge to the PackageName entity.
func (m *CertificationMutation) ClearAllVersions() {
	m.clearedall_versions = true
}

// AllVersionsCleared reports if the "all_versions" edge to the PackageName entity was cleared.
func (m *CertificationMutation) AllVersionsCleared() bool {
	return m.PackageNameIDCleared() || m.clearedall_versions
}

// AllVersionsID returns the "all_versions" edge ID in the mutation.
func (m *CertificationMutation) AllVersionsID() (id int, exists bool) {
	if m.all_versions != nil {
		return *m.all_versions, true
	}
	return
}

// AllVersionsIDs returns the "all_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AllVersionsID instead. It exists only for internal usage by the builders.
func (m *CertificationMutation) AllVersionsIDs() (ids []int) {
	if id := m.all_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAllVersions resets all changes to the "all_versions" edge.
func (m *CertificationMutation) ResetAllVersions() {
	m.all_versions = nil
	m.clearedall_versions = false
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *CertificationMutation) ClearArtifact() {
	m.clearedartifact = true
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *CertificationMutation) ArtifactCleared() bool {
	return m.ArtifactIDCleared() || m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *CertificationMutation) ArtifactIDs() (ids []int) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *CertificationMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// Where appends a list predicates to the CertificationMutation builder.
func (m *CertificationMutation) Where(ps ...predicate.Certification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Certification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Certification).
func (m *CertificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertificationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.source != nil {
		fields = append(fields, certification.FieldSourceID)
	}
	if m.package_version != nil {
		fields = append(fields, certification.FieldPackageVersionID)
	}
	if m.all_versions != nil {
		fields = append(fields, certification.FieldPackageNameID)
	}
	if m.artifact != nil {
		fields = append(fields, certification.FieldArtifactID)
	}
	if m._type != nil {
		fields = append(fields, certification.FieldType)
	}
	if m.justification != nil {
		fields = append(fields, certification.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, certification.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, certification.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certification.FieldSourceID:
		return m.SourceID()
	case certification.FieldPackageVersionID:
		return m.PackageVersionID()
	case certification.FieldPackageNameID:
		return m.PackageNameID()
	case certification.FieldArtifactID:
		return m.ArtifactID()
	case certification.FieldType:
		return m.GetType()
	case certification.FieldJustification:
		return m.Justification()
	case certification.FieldOrigin:
		return m.Origin()
	case certification.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certification.FieldSourceID:
		return m.OldSourceID(ctx)
	case certification.FieldPackageVersionID:
		return m.OldPackageVersionID(ctx)
	case certification.FieldPackageNameID:
		return m.OldPackageNameID(ctx)
	case certification.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case certification.FieldType:
		return m.OldType(ctx)
	case certification.FieldJustification:
		return m.OldJustification(ctx)
	case certification.FieldOrigin:
		return m.OldOrigin(ctx)
	case certification.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown Certification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certification.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case certification.FieldPackageVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageVersionID(v)
		return nil
	case certification.FieldPackageNameID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageNameID(v)
		return nil
	case certification.FieldArtifactID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case certification.FieldType:
		v, ok := value.(certification.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case certification.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case certification.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case certification.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown Certification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertificationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Certification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certification.FieldSourceID) {
		fields = append(fields, certification.FieldSourceID)
	}
	if m.FieldCleared(certification.FieldPackageVersionID) {
		fields = append(fields, certification.FieldPackageVersionID)
	}
	if m.FieldCleared(certification.FieldPackageNameID) {
		fields = append(fields, certification.FieldPackageNameID)
	}
	if m.FieldCleared(certification.FieldArtifactID) {
		fields = append(fields, certification.FieldArtifactID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificationMutation) ClearField(name string) error {
	switch name {
	case certification.FieldSourceID:
		m.ClearSourceID()
		return nil
	case certification.FieldPackageVersionID:
		m.ClearPackageVersionID()
		return nil
	case certification.FieldPackageNameID:
		m.ClearPackageNameID()
		return nil
	case certification.FieldArtifactID:
		m.ClearArtifactID()
		return nil
	}
	return fmt.Errorf("unknown Certification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertificationMutation) ResetField(name string) error {
	switch name {
	case certification.FieldSourceID:
		m.ResetSourceID()
		return nil
	case certification.FieldPackageVersionID:
		m.ResetPackageVersionID()
		return nil
	case certification.FieldPackageNameID:
		m.ResetPackageNameID()
		return nil
	case certification.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case certification.FieldType:
		m.ResetType()
		return nil
	case certification.FieldJustification:
		m.ResetJustification()
		return nil
	case certification.FieldOrigin:
		m.ResetOrigin()
		return nil
	case certification.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown Certification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.source != nil {
		edges = append(edges, certification.EdgeSource)
	}
	if m.package_version != nil {
		edges = append(edges, certification.EdgePackageVersion)
	}
	if m.all_versions != nil {
		edges = append(edges, certification.EdgeAllVersions)
	}
	if m.artifact != nil {
		edges = append(edges, certification.EdgeArtifact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certification.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	case certification.EdgePackageVersion:
		if id := m.package_version; id != nil {
			return []ent.Value{*id}
		}
	case certification.EdgeAllVersions:
		if id := m.all_versions; id != nil {
			return []ent.Value{*id}
		}
	case certification.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsource {
		edges = append(edges, certification.EdgeSource)
	}
	if m.clearedpackage_version {
		edges = append(edges, certification.EdgePackageVersion)
	}
	if m.clearedall_versions {
		edges = append(edges, certification.EdgeAllVersions)
	}
	if m.clearedartifact {
		edges = append(edges, certification.EdgeArtifact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertificationMutation) EdgeCleared(name string) bool {
	switch name {
	case certification.EdgeSource:
		return m.clearedsource
	case certification.EdgePackageVersion:
		return m.clearedpackage_version
	case certification.EdgeAllVersions:
		return m.clearedall_versions
	case certification.EdgeArtifact:
		return m.clearedartifact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertificationMutation) ClearEdge(name string) error {
	switch name {
	case certification.EdgeSource:
		m.ClearSource()
		return nil
	case certification.EdgePackageVersion:
		m.ClearPackageVersion()
		return nil
	case certification.EdgeAllVersions:
		m.ClearAllVersions()
		return nil
	case certification.EdgeArtifact:
		m.ClearArtifact()
		return nil
	}
	return fmt.Errorf("unknown Certification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertificationMutation) ResetEdge(name string) error {
	switch name {
	case certification.EdgeSource:
		m.ResetSource()
		return nil
	case certification.EdgePackageVersion:
		m.ResetPackageVersion()
		return nil
	case certification.EdgeAllVersions:
		m.ResetAllVersions()
		return nil
	case certification.EdgeArtifact:
		m.ResetArtifact()
		return nil
	}
	return fmt.Errorf("unknown Certification edge %s", name)
}

// CertifyVulnMutation represents an operation that mutates the CertifyVuln nodes in the graph.
type CertifyVulnMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	time_scanned         *time.Time
	db_uri               *string
	db_version           *string
	scanner_uri          *string
	scanner_version      *string
	origin               *string
	collector            *string
	clearedFields        map[string]struct{}
	vulnerability        *int
	clearedvulnerability bool
	_package             *int
	cleared_package      bool
	done                 bool
	oldValue             func(context.Context) (*CertifyVuln, error)
	predicates           []predicate.CertifyVuln
}

var _ ent.Mutation = (*CertifyVulnMutation)(nil)

// certifyvulnOption allows management of the mutation configuration using functional options.
type certifyvulnOption func(*CertifyVulnMutation)

// newCertifyVulnMutation creates new mutation for the CertifyVuln entity.
func newCertifyVulnMutation(c config, op Op, opts ...certifyvulnOption) *CertifyVulnMutation {
	m := &CertifyVulnMutation{
		config:        c,
		op:            op,
		typ:           TypeCertifyVuln,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertifyVulnID sets the ID field of the mutation.
func withCertifyVulnID(id int) certifyvulnOption {
	return func(m *CertifyVulnMutation) {
		var (
			err   error
			once  sync.Once
			value *CertifyVuln
		)
		m.oldValue = func(ctx context.Context) (*CertifyVuln, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertifyVuln.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertifyVuln sets the old CertifyVuln of the mutation.
func withCertifyVuln(node *CertifyVuln) certifyvulnOption {
	return func(m *CertifyVulnMutation) {
		m.oldValue = func(context.Context) (*CertifyVuln, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertifyVulnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertifyVulnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertifyVulnMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertifyVulnMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertifyVuln.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVulnerabilityID sets the "vulnerability_id" field.
func (m *CertifyVulnMutation) SetVulnerabilityID(i int) {
	m.vulnerability = &i
}

// VulnerabilityID returns the value of the "vulnerability_id" field in the mutation.
func (m *CertifyVulnMutation) VulnerabilityID() (r int, exists bool) {
	v := m.vulnerability
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnerabilityID returns the old "vulnerability_id" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldVulnerabilityID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVulnerabilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVulnerabilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnerabilityID: %w", err)
	}
	return oldValue.VulnerabilityID, nil
}

// ClearVulnerabilityID clears the value of the "vulnerability_id" field.
func (m *CertifyVulnMutation) ClearVulnerabilityID() {
	m.vulnerability = nil
	m.clearedFields[certifyvuln.FieldVulnerabilityID] = struct{}{}
}

// VulnerabilityIDCleared returns if the "vulnerability_id" field was cleared in this mutation.
func (m *CertifyVulnMutation) VulnerabilityIDCleared() bool {
	_, ok := m.clearedFields[certifyvuln.FieldVulnerabilityID]
	return ok
}

// ResetVulnerabilityID resets all changes to the "vulnerability_id" field.
func (m *CertifyVulnMutation) ResetVulnerabilityID() {
	m.vulnerability = nil
	delete(m.clearedFields, certifyvuln.FieldVulnerabilityID)
}

// SetPackageID sets the "package_id" field.
func (m *CertifyVulnMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *CertifyVulnMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldPackageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *CertifyVulnMutation) ResetPackageID() {
	m._package = nil
}

// SetTimeScanned sets the "time_scanned" field.
func (m *CertifyVulnMutation) SetTimeScanned(t time.Time) {
	m.time_scanned = &t
}

// TimeScanned returns the value of the "time_scanned" field in the mutation.
func (m *CertifyVulnMutation) TimeScanned() (r time.Time, exists bool) {
	v := m.time_scanned
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeScanned returns the old "time_scanned" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldTimeScanned(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeScanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeScanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeScanned: %w", err)
	}
	return oldValue.TimeScanned, nil
}

// ResetTimeScanned resets all changes to the "time_scanned" field.
func (m *CertifyVulnMutation) ResetTimeScanned() {
	m.time_scanned = nil
}

// SetDbURI sets the "db_uri" field.
func (m *CertifyVulnMutation) SetDbURI(s string) {
	m.db_uri = &s
}

// DbURI returns the value of the "db_uri" field in the mutation.
func (m *CertifyVulnMutation) DbURI() (r string, exists bool) {
	v := m.db_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldDbURI returns the old "db_uri" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldDbURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDbURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDbURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDbURI: %w", err)
	}
	return oldValue.DbURI, nil
}

// ResetDbURI resets all changes to the "db_uri" field.
func (m *CertifyVulnMutation) ResetDbURI() {
	m.db_uri = nil
}

// SetDbVersion sets the "db_version" field.
func (m *CertifyVulnMutation) SetDbVersion(s string) {
	m.db_version = &s
}

// DbVersion returns the value of the "db_version" field in the mutation.
func (m *CertifyVulnMutation) DbVersion() (r string, exists bool) {
	v := m.db_version
	if v == nil {
		return
	}
	return *v, true
}

// OldDbVersion returns the old "db_version" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldDbVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDbVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDbVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDbVersion: %w", err)
	}
	return oldValue.DbVersion, nil
}

// ResetDbVersion resets all changes to the "db_version" field.
func (m *CertifyVulnMutation) ResetDbVersion() {
	m.db_version = nil
}

// SetScannerURI sets the "scanner_uri" field.
func (m *CertifyVulnMutation) SetScannerURI(s string) {
	m.scanner_uri = &s
}

// ScannerURI returns the value of the "scanner_uri" field in the mutation.
func (m *CertifyVulnMutation) ScannerURI() (r string, exists bool) {
	v := m.scanner_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldScannerURI returns the old "scanner_uri" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldScannerURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScannerURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScannerURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScannerURI: %w", err)
	}
	return oldValue.ScannerURI, nil
}

// ResetScannerURI resets all changes to the "scanner_uri" field.
func (m *CertifyVulnMutation) ResetScannerURI() {
	m.scanner_uri = nil
}

// SetScannerVersion sets the "scanner_version" field.
func (m *CertifyVulnMutation) SetScannerVersion(s string) {
	m.scanner_version = &s
}

// ScannerVersion returns the value of the "scanner_version" field in the mutation.
func (m *CertifyVulnMutation) ScannerVersion() (r string, exists bool) {
	v := m.scanner_version
	if v == nil {
		return
	}
	return *v, true
}

// OldScannerVersion returns the old "scanner_version" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldScannerVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScannerVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScannerVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScannerVersion: %w", err)
	}
	return oldValue.ScannerVersion, nil
}

// ResetScannerVersion resets all changes to the "scanner_version" field.
func (m *CertifyVulnMutation) ResetScannerVersion() {
	m.scanner_version = nil
}

// SetOrigin sets the "origin" field.
func (m *CertifyVulnMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *CertifyVulnMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *CertifyVulnMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *CertifyVulnMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *CertifyVulnMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *CertifyVulnMutation) ResetCollector() {
	m.collector = nil
}

// ClearVulnerability clears the "vulnerability" edge to the SecurityAdvisory entity.
func (m *CertifyVulnMutation) ClearVulnerability() {
	m.clearedvulnerability = true
}

// VulnerabilityCleared reports if the "vulnerability" edge to the SecurityAdvisory entity was cleared.
func (m *CertifyVulnMutation) VulnerabilityCleared() bool {
	return m.VulnerabilityIDCleared() || m.clearedvulnerability
}

// VulnerabilityIDs returns the "vulnerability" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityID instead. It exists only for internal usage by the builders.
func (m *CertifyVulnMutation) VulnerabilityIDs() (ids []int) {
	if id := m.vulnerability; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerability resets all changes to the "vulnerability" edge.
func (m *CertifyVulnMutation) ResetVulnerability() {
	m.vulnerability = nil
	m.clearedvulnerability = false
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *CertifyVulnMutation) ClearPackage() {
	m.cleared_package = true
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *CertifyVulnMutation) PackageCleared() bool {
	return m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *CertifyVulnMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *CertifyVulnMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// Where appends a list predicates to the CertifyVulnMutation builder.
func (m *CertifyVulnMutation) Where(ps ...predicate.CertifyVuln) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertifyVulnMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertifyVulnMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CertifyVuln, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertifyVulnMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertifyVulnMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CertifyVuln).
func (m *CertifyVulnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertifyVulnMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.vulnerability != nil {
		fields = append(fields, certifyvuln.FieldVulnerabilityID)
	}
	if m._package != nil {
		fields = append(fields, certifyvuln.FieldPackageID)
	}
	if m.time_scanned != nil {
		fields = append(fields, certifyvuln.FieldTimeScanned)
	}
	if m.db_uri != nil {
		fields = append(fields, certifyvuln.FieldDbURI)
	}
	if m.db_version != nil {
		fields = append(fields, certifyvuln.FieldDbVersion)
	}
	if m.scanner_uri != nil {
		fields = append(fields, certifyvuln.FieldScannerURI)
	}
	if m.scanner_version != nil {
		fields = append(fields, certifyvuln.FieldScannerVersion)
	}
	if m.origin != nil {
		fields = append(fields, certifyvuln.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, certifyvuln.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertifyVulnMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certifyvuln.FieldVulnerabilityID:
		return m.VulnerabilityID()
	case certifyvuln.FieldPackageID:
		return m.PackageID()
	case certifyvuln.FieldTimeScanned:
		return m.TimeScanned()
	case certifyvuln.FieldDbURI:
		return m.DbURI()
	case certifyvuln.FieldDbVersion:
		return m.DbVersion()
	case certifyvuln.FieldScannerURI:
		return m.ScannerURI()
	case certifyvuln.FieldScannerVersion:
		return m.ScannerVersion()
	case certifyvuln.FieldOrigin:
		return m.Origin()
	case certifyvuln.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertifyVulnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certifyvuln.FieldVulnerabilityID:
		return m.OldVulnerabilityID(ctx)
	case certifyvuln.FieldPackageID:
		return m.OldPackageID(ctx)
	case certifyvuln.FieldTimeScanned:
		return m.OldTimeScanned(ctx)
	case certifyvuln.FieldDbURI:
		return m.OldDbURI(ctx)
	case certifyvuln.FieldDbVersion:
		return m.OldDbVersion(ctx)
	case certifyvuln.FieldScannerURI:
		return m.OldScannerURI(ctx)
	case certifyvuln.FieldScannerVersion:
		return m.OldScannerVersion(ctx)
	case certifyvuln.FieldOrigin:
		return m.OldOrigin(ctx)
	case certifyvuln.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown CertifyVuln field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyVulnMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certifyvuln.FieldVulnerabilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnerabilityID(v)
		return nil
	case certifyvuln.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case certifyvuln.FieldTimeScanned:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeScanned(v)
		return nil
	case certifyvuln.FieldDbURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDbURI(v)
		return nil
	case certifyvuln.FieldDbVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDbVersion(v)
		return nil
	case certifyvuln.FieldScannerURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScannerURI(v)
		return nil
	case certifyvuln.FieldScannerVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScannerVersion(v)
		return nil
	case certifyvuln.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case certifyvuln.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown CertifyVuln field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertifyVulnMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertifyVulnMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyVulnMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CertifyVuln numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertifyVulnMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certifyvuln.FieldVulnerabilityID) {
		fields = append(fields, certifyvuln.FieldVulnerabilityID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertifyVulnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertifyVulnMutation) ClearField(name string) error {
	switch name {
	case certifyvuln.FieldVulnerabilityID:
		m.ClearVulnerabilityID()
		return nil
	}
	return fmt.Errorf("unknown CertifyVuln nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertifyVulnMutation) ResetField(name string) error {
	switch name {
	case certifyvuln.FieldVulnerabilityID:
		m.ResetVulnerabilityID()
		return nil
	case certifyvuln.FieldPackageID:
		m.ResetPackageID()
		return nil
	case certifyvuln.FieldTimeScanned:
		m.ResetTimeScanned()
		return nil
	case certifyvuln.FieldDbURI:
		m.ResetDbURI()
		return nil
	case certifyvuln.FieldDbVersion:
		m.ResetDbVersion()
		return nil
	case certifyvuln.FieldScannerURI:
		m.ResetScannerURI()
		return nil
	case certifyvuln.FieldScannerVersion:
		m.ResetScannerVersion()
		return nil
	case certifyvuln.FieldOrigin:
		m.ResetOrigin()
		return nil
	case certifyvuln.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown CertifyVuln field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertifyVulnMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.vulnerability != nil {
		edges = append(edges, certifyvuln.EdgeVulnerability)
	}
	if m._package != nil {
		edges = append(edges, certifyvuln.EdgePackage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertifyVulnMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certifyvuln.EdgeVulnerability:
		if id := m.vulnerability; id != nil {
			return []ent.Value{*id}
		}
	case certifyvuln.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertifyVulnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertifyVulnMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertifyVulnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvulnerability {
		edges = append(edges, certifyvuln.EdgeVulnerability)
	}
	if m.cleared_package {
		edges = append(edges, certifyvuln.EdgePackage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertifyVulnMutation) EdgeCleared(name string) bool {
	switch name {
	case certifyvuln.EdgeVulnerability:
		return m.clearedvulnerability
	case certifyvuln.EdgePackage:
		return m.cleared_package
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertifyVulnMutation) ClearEdge(name string) error {
	switch name {
	case certifyvuln.EdgeVulnerability:
		m.ClearVulnerability()
		return nil
	case certifyvuln.EdgePackage:
		m.ClearPackage()
		return nil
	}
	return fmt.Errorf("unknown CertifyVuln unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertifyVulnMutation) ResetEdge(name string) error {
	switch name {
	case certifyvuln.EdgeVulnerability:
		m.ResetVulnerability()
		return nil
	case certifyvuln.EdgePackage:
		m.ResetPackage()
		return nil
	}
	return fmt.Errorf("unknown CertifyVuln edge %s", name)
}

// DependencyMutation represents an operation that mutates the Dependency nodes in the graph.
type DependencyMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	version_range            *string
	dependency_type          *dependency.DependencyType
	justification            *string
	origin                   *string
	collector                *string
	clearedFields            map[string]struct{}
	_package                 *int
	cleared_package          bool
	dependent_package        *int
	cleareddependent_package bool
	done                     bool
	oldValue                 func(context.Context) (*Dependency, error)
	predicates               []predicate.Dependency
}

var _ ent.Mutation = (*DependencyMutation)(nil)

// dependencyOption allows management of the mutation configuration using functional options.
type dependencyOption func(*DependencyMutation)

// newDependencyMutation creates new mutation for the Dependency entity.
func newDependencyMutation(c config, op Op, opts ...dependencyOption) *DependencyMutation {
	m := &DependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDependencyID sets the ID field of the mutation.
func withDependencyID(id int) dependencyOption {
	return func(m *DependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Dependency
		)
		m.oldValue = func(ctx context.Context) (*Dependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDependency sets the old Dependency of the mutation.
func withDependency(node *Dependency) dependencyOption {
	return func(m *DependencyMutation) {
		m.oldValue = func(context.Context) (*Dependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DependencyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DependencyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *DependencyMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *DependencyMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldPackageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *DependencyMutation) ResetPackageID() {
	m._package = nil
}

// SetDependentPackageID sets the "dependent_package_id" field.
func (m *DependencyMutation) SetDependentPackageID(i int) {
	m.dependent_package = &i
}

// DependentPackageID returns the value of the "dependent_package_id" field in the mutation.
func (m *DependencyMutation) DependentPackageID() (r int, exists bool) {
	v := m.dependent_package
	if v == nil {
		return
	}
	return *v, true
}

// OldDependentPackageID returns the old "dependent_package_id" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldDependentPackageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependentPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependentPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependentPackageID: %w", err)
	}
	return oldValue.DependentPackageID, nil
}

// ResetDependentPackageID resets all changes to the "dependent_package_id" field.
func (m *DependencyMutation) ResetDependentPackageID() {
	m.dependent_package = nil
}

// SetVersionRange sets the "version_range" field.
func (m *DependencyMutation) SetVersionRange(s string) {
	m.version_range = &s
}

// VersionRange returns the value of the "version_range" field in the mutation.
func (m *DependencyMutation) VersionRange() (r string, exists bool) {
	v := m.version_range
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionRange returns the old "version_range" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldVersionRange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionRange: %w", err)
	}
	return oldValue.VersionRange, nil
}

// ResetVersionRange resets all changes to the "version_range" field.
func (m *DependencyMutation) ResetVersionRange() {
	m.version_range = nil
}

// SetDependencyType sets the "dependency_type" field.
func (m *DependencyMutation) SetDependencyType(dt dependency.DependencyType) {
	m.dependency_type = &dt
}

// DependencyType returns the value of the "dependency_type" field in the mutation.
func (m *DependencyMutation) DependencyType() (r dependency.DependencyType, exists bool) {
	v := m.dependency_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyType returns the old "dependency_type" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldDependencyType(ctx context.Context) (v dependency.DependencyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyType: %w", err)
	}
	return oldValue.DependencyType, nil
}

// ResetDependencyType resets all changes to the "dependency_type" field.
func (m *DependencyMutation) ResetDependencyType() {
	m.dependency_type = nil
}

// SetJustification sets the "justification" field.
func (m *DependencyMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *DependencyMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *DependencyMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *DependencyMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *DependencyMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *DependencyMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *DependencyMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *DependencyMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *DependencyMutation) ResetCollector() {
	m.collector = nil
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *DependencyMutation) ClearPackage() {
	m.cleared_package = true
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *DependencyMutation) PackageCleared() bool {
	return m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *DependencyMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *DependencyMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearDependentPackage clears the "dependent_package" edge to the PackageName entity.
func (m *DependencyMutation) ClearDependentPackage() {
	m.cleareddependent_package = true
}

// DependentPackageCleared reports if the "dependent_package" edge to the PackageName entity was cleared.
func (m *DependencyMutation) DependentPackageCleared() bool {
	return m.cleareddependent_package
}

// DependentPackageIDs returns the "dependent_package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DependentPackageID instead. It exists only for internal usage by the builders.
func (m *DependencyMutation) DependentPackageIDs() (ids []int) {
	if id := m.dependent_package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDependentPackage resets all changes to the "dependent_package" edge.
func (m *DependencyMutation) ResetDependentPackage() {
	m.dependent_package = nil
	m.cleareddependent_package = false
}

// Where appends a list predicates to the DependencyMutation builder.
func (m *DependencyMutation) Where(ps ...predicate.Dependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dependency).
func (m *DependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DependencyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._package != nil {
		fields = append(fields, dependency.FieldPackageID)
	}
	if m.dependent_package != nil {
		fields = append(fields, dependency.FieldDependentPackageID)
	}
	if m.version_range != nil {
		fields = append(fields, dependency.FieldVersionRange)
	}
	if m.dependency_type != nil {
		fields = append(fields, dependency.FieldDependencyType)
	}
	if m.justification != nil {
		fields = append(fields, dependency.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, dependency.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, dependency.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dependency.FieldPackageID:
		return m.PackageID()
	case dependency.FieldDependentPackageID:
		return m.DependentPackageID()
	case dependency.FieldVersionRange:
		return m.VersionRange()
	case dependency.FieldDependencyType:
		return m.DependencyType()
	case dependency.FieldJustification:
		return m.Justification()
	case dependency.FieldOrigin:
		return m.Origin()
	case dependency.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dependency.FieldPackageID:
		return m.OldPackageID(ctx)
	case dependency.FieldDependentPackageID:
		return m.OldDependentPackageID(ctx)
	case dependency.FieldVersionRange:
		return m.OldVersionRange(ctx)
	case dependency.FieldDependencyType:
		return m.OldDependencyType(ctx)
	case dependency.FieldJustification:
		return m.OldJustification(ctx)
	case dependency.FieldOrigin:
		return m.OldOrigin(ctx)
	case dependency.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown Dependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dependency.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case dependency.FieldDependentPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependentPackageID(v)
		return nil
	case dependency.FieldVersionRange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionRange(v)
		return nil
	case dependency.FieldDependencyType:
		v, ok := value.(dependency.DependencyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyType(v)
		return nil
	case dependency.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case dependency.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case dependency.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown Dependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DependencyMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DependencyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Dependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DependencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DependencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Dependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DependencyMutation) ResetField(name string) error {
	switch name {
	case dependency.FieldPackageID:
		m.ResetPackageID()
		return nil
	case dependency.FieldDependentPackageID:
		m.ResetDependentPackageID()
		return nil
	case dependency.FieldVersionRange:
		m.ResetVersionRange()
		return nil
	case dependency.FieldDependencyType:
		m.ResetDependencyType()
		return nil
	case dependency.FieldJustification:
		m.ResetJustification()
		return nil
	case dependency.FieldOrigin:
		m.ResetOrigin()
		return nil
	case dependency.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown Dependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._package != nil {
		edges = append(edges, dependency.EdgePackage)
	}
	if m.dependent_package != nil {
		edges = append(edges, dependency.EdgeDependentPackage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dependency.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case dependency.EdgeDependentPackage:
		if id := m.dependent_package; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_package {
		edges = append(edges, dependency.EdgePackage)
	}
	if m.cleareddependent_package {
		edges = append(edges, dependency.EdgeDependentPackage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case dependency.EdgePackage:
		return m.cleared_package
	case dependency.EdgeDependentPackage:
		return m.cleareddependent_package
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DependencyMutation) ClearEdge(name string) error {
	switch name {
	case dependency.EdgePackage:
		m.ClearPackage()
		return nil
	case dependency.EdgeDependentPackage:
		m.ClearDependentPackage()
		return nil
	}
	return fmt.Errorf("unknown Dependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DependencyMutation) ResetEdge(name string) error {
	switch name {
	case dependency.EdgePackage:
		m.ResetPackage()
		return nil
	case dependency.EdgeDependentPackage:
		m.ResetDependentPackage()
		return nil
	}
	return fmt.Errorf("unknown Dependency edge %s", name)
}

// HasSourceAtMutation represents an operation that mutates the HasSourceAt nodes in the graph.
type HasSourceAtMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	known_since            *time.Time
	justification          *string
	origin                 *string
	collector              *string
	clearedFields          map[string]struct{}
	package_version        *int
	clearedpackage_version bool
	all_versions           *int
	clearedall_versions    bool
	source                 *int
	clearedsource          bool
	done                   bool
	oldValue               func(context.Context) (*HasSourceAt, error)
	predicates             []predicate.HasSourceAt
}

var _ ent.Mutation = (*HasSourceAtMutation)(nil)

// hassourceatOption allows management of the mutation configuration using functional options.
type hassourceatOption func(*HasSourceAtMutation)

// newHasSourceAtMutation creates new mutation for the HasSourceAt entity.
func newHasSourceAtMutation(c config, op Op, opts ...hassourceatOption) *HasSourceAtMutation {
	m := &HasSourceAtMutation{
		config:        c,
		op:            op,
		typ:           TypeHasSourceAt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHasSourceAtID sets the ID field of the mutation.
func withHasSourceAtID(id int) hassourceatOption {
	return func(m *HasSourceAtMutation) {
		var (
			err   error
			once  sync.Once
			value *HasSourceAt
		)
		m.oldValue = func(ctx context.Context) (*HasSourceAt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HasSourceAt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHasSourceAt sets the old HasSourceAt of the mutation.
func withHasSourceAt(node *HasSourceAt) hassourceatOption {
	return func(m *HasSourceAtMutation) {
		m.oldValue = func(context.Context) (*HasSourceAt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HasSourceAtMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HasSourceAtMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HasSourceAtMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HasSourceAtMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HasSourceAt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageVersionID sets the "package_version_id" field.
func (m *HasSourceAtMutation) SetPackageVersionID(i int) {
	m.package_version = &i
}

// PackageVersionID returns the value of the "package_version_id" field in the mutation.
func (m *HasSourceAtMutation) PackageVersionID() (r int, exists bool) {
	v := m.package_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageVersionID returns the old "package_version_id" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldPackageVersionID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageVersionID: %w", err)
	}
	return oldValue.PackageVersionID, nil
}

// ClearPackageVersionID clears the value of the "package_version_id" field.
func (m *HasSourceAtMutation) ClearPackageVersionID() {
	m.package_version = nil
	m.clearedFields[hassourceat.FieldPackageVersionID] = struct{}{}
}

// PackageVersionIDCleared returns if the "package_version_id" field was cleared in this mutation.
func (m *HasSourceAtMutation) PackageVersionIDCleared() bool {
	_, ok := m.clearedFields[hassourceat.FieldPackageVersionID]
	return ok
}

// ResetPackageVersionID resets all changes to the "package_version_id" field.
func (m *HasSourceAtMutation) ResetPackageVersionID() {
	m.package_version = nil
	delete(m.clearedFields, hassourceat.FieldPackageVersionID)
}

// SetPackageNameID sets the "package_name_id" field.
func (m *HasSourceAtMutation) SetPackageNameID(i int) {
	m.all_versions = &i
}

// PackageNameID returns the value of the "package_name_id" field in the mutation.
func (m *HasSourceAtMutation) PackageNameID() (r int, exists bool) {
	v := m.all_versions
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageNameID returns the old "package_name_id" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldPackageNameID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageNameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageNameID: %w", err)
	}
	return oldValue.PackageNameID, nil
}

// ClearPackageNameID clears the value of the "package_name_id" field.
func (m *HasSourceAtMutation) ClearPackageNameID() {
	m.all_versions = nil
	m.clearedFields[hassourceat.FieldPackageNameID] = struct{}{}
}

// PackageNameIDCleared returns if the "package_name_id" field was cleared in this mutation.
func (m *HasSourceAtMutation) PackageNameIDCleared() bool {
	_, ok := m.clearedFields[hassourceat.FieldPackageNameID]
	return ok
}

// ResetPackageNameID resets all changes to the "package_name_id" field.
func (m *HasSourceAtMutation) ResetPackageNameID() {
	m.all_versions = nil
	delete(m.clearedFields, hassourceat.FieldPackageNameID)
}

// SetSourceID sets the "source_id" field.
func (m *HasSourceAtMutation) SetSourceID(i int) {
	m.source = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *HasSourceAtMutation) SourceID() (r int, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldSourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *HasSourceAtMutation) ResetSourceID() {
	m.source = nil
}

// SetKnownSince sets the "known_since" field.
func (m *HasSourceAtMutation) SetKnownSince(t time.Time) {
	m.known_since = &t
}

// KnownSince returns the value of the "known_since" field in the mutation.
func (m *HasSourceAtMutation) KnownSince() (r time.Time, exists bool) {
	v := m.known_since
	if v == nil {
		return
	}
	return *v, true
}

// OldKnownSince returns the old "known_since" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldKnownSince(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnownSince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnownSince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnownSince: %w", err)
	}
	return oldValue.KnownSince, nil
}

// ResetKnownSince resets all changes to the "known_since" field.
func (m *HasSourceAtMutation) ResetKnownSince() {
	m.known_since = nil
}

// SetJustification sets the "justification" field.
func (m *HasSourceAtMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *HasSourceAtMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *HasSourceAtMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *HasSourceAtMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *HasSourceAtMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *HasSourceAtMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *HasSourceAtMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *HasSourceAtMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *HasSourceAtMutation) ResetCollector() {
	m.collector = nil
}

// ClearPackageVersion clears the "package_version" edge to the PackageVersion entity.
func (m *HasSourceAtMutation) ClearPackageVersion() {
	m.clearedpackage_version = true
}

// PackageVersionCleared reports if the "package_version" edge to the PackageVersion entity was cleared.
func (m *HasSourceAtMutation) PackageVersionCleared() bool {
	return m.PackageVersionIDCleared() || m.clearedpackage_version
}

// PackageVersionIDs returns the "package_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageVersionID instead. It exists only for internal usage by the builders.
func (m *HasSourceAtMutation) PackageVersionIDs() (ids []int) {
	if id := m.package_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackageVersion resets all changes to the "package_version" edge.
func (m *HasSourceAtMutation) ResetPackageVersion() {
	m.package_version = nil
	m.clearedpackage_version = false
}

// SetAllVersionsID sets the "all_versions" edge to the PackageName entity by id.
func (m *HasSourceAtMutation) SetAllVersionsID(id int) {
	m.all_versions = &id
}

// ClearAllVersions clears the "all_versions" edge to the PackageName entity.
func (m *HasSourceAtMutation) ClearAllVersions() {
	m.clearedall_versions = true
}

// AllVersionsCleared reports if the "all_versions" edge to the PackageName entity was cleared.
func (m *HasSourceAtMutation) AllVersionsCleared() bool {
	return m.PackageNameIDCleared() || m.clearedall_versions
}

// AllVersionsID returns the "all_versions" edge ID in the mutation.
func (m *HasSourceAtMutation) AllVersionsID() (id int, exists bool) {
	if m.all_versions != nil {
		return *m.all_versions, true
	}
	return
}

// AllVersionsIDs returns the "all_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AllVersionsID instead. It exists only for internal usage by the builders.
func (m *HasSourceAtMutation) AllVersionsIDs() (ids []int) {
	if id := m.all_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAllVersions resets all changes to the "all_versions" edge.
func (m *HasSourceAtMutation) ResetAllVersions() {
	m.all_versions = nil
	m.clearedall_versions = false
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *HasSourceAtMutation) ClearSource() {
	m.clearedsource = true
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *HasSourceAtMutation) SourceCleared() bool {
	return m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *HasSourceAtMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *HasSourceAtMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Where appends a list predicates to the HasSourceAtMutation builder.
func (m *HasSourceAtMutation) Where(ps ...predicate.HasSourceAt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HasSourceAtMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HasSourceAtMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HasSourceAt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HasSourceAtMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HasSourceAtMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HasSourceAt).
func (m *HasSourceAtMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HasSourceAtMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.package_version != nil {
		fields = append(fields, hassourceat.FieldPackageVersionID)
	}
	if m.all_versions != nil {
		fields = append(fields, hassourceat.FieldPackageNameID)
	}
	if m.source != nil {
		fields = append(fields, hassourceat.FieldSourceID)
	}
	if m.known_since != nil {
		fields = append(fields, hassourceat.FieldKnownSince)
	}
	if m.justification != nil {
		fields = append(fields, hassourceat.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, hassourceat.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, hassourceat.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HasSourceAtMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hassourceat.FieldPackageVersionID:
		return m.PackageVersionID()
	case hassourceat.FieldPackageNameID:
		return m.PackageNameID()
	case hassourceat.FieldSourceID:
		return m.SourceID()
	case hassourceat.FieldKnownSince:
		return m.KnownSince()
	case hassourceat.FieldJustification:
		return m.Justification()
	case hassourceat.FieldOrigin:
		return m.Origin()
	case hassourceat.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HasSourceAtMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hassourceat.FieldPackageVersionID:
		return m.OldPackageVersionID(ctx)
	case hassourceat.FieldPackageNameID:
		return m.OldPackageNameID(ctx)
	case hassourceat.FieldSourceID:
		return m.OldSourceID(ctx)
	case hassourceat.FieldKnownSince:
		return m.OldKnownSince(ctx)
	case hassourceat.FieldJustification:
		return m.OldJustification(ctx)
	case hassourceat.FieldOrigin:
		return m.OldOrigin(ctx)
	case hassourceat.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown HasSourceAt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HasSourceAtMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hassourceat.FieldPackageVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageVersionID(v)
		return nil
	case hassourceat.FieldPackageNameID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageNameID(v)
		return nil
	case hassourceat.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case hassourceat.FieldKnownSince:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnownSince(v)
		return nil
	case hassourceat.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case hassourceat.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case hassourceat.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HasSourceAtMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HasSourceAtMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HasSourceAtMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HasSourceAt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HasSourceAtMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hassourceat.FieldPackageVersionID) {
		fields = append(fields, hassourceat.FieldPackageVersionID)
	}
	if m.FieldCleared(hassourceat.FieldPackageNameID) {
		fields = append(fields, hassourceat.FieldPackageNameID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HasSourceAtMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HasSourceAtMutation) ClearField(name string) error {
	switch name {
	case hassourceat.FieldPackageVersionID:
		m.ClearPackageVersionID()
		return nil
	case hassourceat.FieldPackageNameID:
		m.ClearPackageNameID()
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HasSourceAtMutation) ResetField(name string) error {
	switch name {
	case hassourceat.FieldPackageVersionID:
		m.ResetPackageVersionID()
		return nil
	case hassourceat.FieldPackageNameID:
		m.ResetPackageNameID()
		return nil
	case hassourceat.FieldSourceID:
		m.ResetSourceID()
		return nil
	case hassourceat.FieldKnownSince:
		m.ResetKnownSince()
		return nil
	case hassourceat.FieldJustification:
		m.ResetJustification()
		return nil
	case hassourceat.FieldOrigin:
		m.ResetOrigin()
		return nil
	case hassourceat.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HasSourceAtMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.package_version != nil {
		edges = append(edges, hassourceat.EdgePackageVersion)
	}
	if m.all_versions != nil {
		edges = append(edges, hassourceat.EdgeAllVersions)
	}
	if m.source != nil {
		edges = append(edges, hassourceat.EdgeSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HasSourceAtMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hassourceat.EdgePackageVersion:
		if id := m.package_version; id != nil {
			return []ent.Value{*id}
		}
	case hassourceat.EdgeAllVersions:
		if id := m.all_versions; id != nil {
			return []ent.Value{*id}
		}
	case hassourceat.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HasSourceAtMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HasSourceAtMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HasSourceAtMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpackage_version {
		edges = append(edges, hassourceat.EdgePackageVersion)
	}
	if m.clearedall_versions {
		edges = append(edges, hassourceat.EdgeAllVersions)
	}
	if m.clearedsource {
		edges = append(edges, hassourceat.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HasSourceAtMutation) EdgeCleared(name string) bool {
	switch name {
	case hassourceat.EdgePackageVersion:
		return m.clearedpackage_version
	case hassourceat.EdgeAllVersions:
		return m.clearedall_versions
	case hassourceat.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HasSourceAtMutation) ClearEdge(name string) error {
	switch name {
	case hassourceat.EdgePackageVersion:
		m.ClearPackageVersion()
		return nil
	case hassourceat.EdgeAllVersions:
		m.ClearAllVersions()
		return nil
	case hassourceat.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HasSourceAtMutation) ResetEdge(name string) error {
	switch name {
	case hassourceat.EdgePackageVersion:
		m.ResetPackageVersion()
		return nil
	case hassourceat.EdgeAllVersions:
		m.ResetAllVersions()
		return nil
	case hassourceat.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt edge %s", name)
}

// HashEqualMutation represents an operation that mutates the HashEqual nodes in the graph.
type HashEqualMutation struct {
	config
	op               Op
	typ              string
	id               *int
	origin           *string
	collector        *string
	justification    *string
	clearedFields    map[string]struct{}
	artifacts        map[int]struct{}
	removedartifacts map[int]struct{}
	clearedartifacts bool
	done             bool
	oldValue         func(context.Context) (*HashEqual, error)
	predicates       []predicate.HashEqual
}

var _ ent.Mutation = (*HashEqualMutation)(nil)

// hashequalOption allows management of the mutation configuration using functional options.
type hashequalOption func(*HashEqualMutation)

// newHashEqualMutation creates new mutation for the HashEqual entity.
func newHashEqualMutation(c config, op Op, opts ...hashequalOption) *HashEqualMutation {
	m := &HashEqualMutation{
		config:        c,
		op:            op,
		typ:           TypeHashEqual,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHashEqualID sets the ID field of the mutation.
func withHashEqualID(id int) hashequalOption {
	return func(m *HashEqualMutation) {
		var (
			err   error
			once  sync.Once
			value *HashEqual
		)
		m.oldValue = func(ctx context.Context) (*HashEqual, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HashEqual.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHashEqual sets the old HashEqual of the mutation.
func withHashEqual(node *HashEqual) hashequalOption {
	return func(m *HashEqualMutation) {
		m.oldValue = func(context.Context) (*HashEqual, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HashEqualMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HashEqualMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HashEqualMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HashEqualMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HashEqual.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrigin sets the "origin" field.
func (m *HashEqualMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *HashEqualMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the HashEqual entity.
// If the HashEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashEqualMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *HashEqualMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *HashEqualMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *HashEqualMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the HashEqual entity.
// If the HashEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashEqualMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *HashEqualMutation) ResetCollector() {
	m.collector = nil
}

// SetJustification sets the "justification" field.
func (m *HashEqualMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *HashEqualMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the HashEqual entity.
// If the HashEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashEqualMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *HashEqualMutation) ResetJustification() {
	m.justification = nil
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *HashEqualMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *HashEqualMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *HashEqualMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *HashEqualMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *HashEqualMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *HashEqualMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *HashEqualMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// Where appends a list predicates to the HashEqualMutation builder.
func (m *HashEqualMutation) Where(ps ...predicate.HashEqual) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HashEqualMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HashEqualMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HashEqual, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HashEqualMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HashEqualMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HashEqual).
func (m *HashEqualMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HashEqualMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.origin != nil {
		fields = append(fields, hashequal.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, hashequal.FieldCollector)
	}
	if m.justification != nil {
		fields = append(fields, hashequal.FieldJustification)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HashEqualMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hashequal.FieldOrigin:
		return m.Origin()
	case hashequal.FieldCollector:
		return m.Collector()
	case hashequal.FieldJustification:
		return m.Justification()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HashEqualMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hashequal.FieldOrigin:
		return m.OldOrigin(ctx)
	case hashequal.FieldCollector:
		return m.OldCollector(ctx)
	case hashequal.FieldJustification:
		return m.OldJustification(ctx)
	}
	return nil, fmt.Errorf("unknown HashEqual field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HashEqualMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hashequal.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case hashequal.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case hashequal.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	}
	return fmt.Errorf("unknown HashEqual field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HashEqualMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HashEqualMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HashEqualMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HashEqual numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HashEqualMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HashEqualMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HashEqualMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HashEqual nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HashEqualMutation) ResetField(name string) error {
	switch name {
	case hashequal.FieldOrigin:
		m.ResetOrigin()
		return nil
	case hashequal.FieldCollector:
		m.ResetCollector()
		return nil
	case hashequal.FieldJustification:
		m.ResetJustification()
		return nil
	}
	return fmt.Errorf("unknown HashEqual field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HashEqualMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.artifacts != nil {
		edges = append(edges, hashequal.EdgeArtifacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HashEqualMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hashequal.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HashEqualMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedartifacts != nil {
		edges = append(edges, hashequal.EdgeArtifacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HashEqualMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hashequal.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HashEqualMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedartifacts {
		edges = append(edges, hashequal.EdgeArtifacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HashEqualMutation) EdgeCleared(name string) bool {
	switch name {
	case hashequal.EdgeArtifacts:
		return m.clearedartifacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HashEqualMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HashEqual unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HashEqualMutation) ResetEdge(name string) error {
	switch name {
	case hashequal.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	}
	return fmt.Errorf("unknown HashEqual edge %s", name)
}

// IsVulnerabilityMutation represents an operation that mutates the IsVulnerability nodes in the graph.
type IsVulnerabilityMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	justification        *string
	origin               *string
	collector            *string
	clearedFields        map[string]struct{}
	osv                  *int
	clearedosv           bool
	vulnerability        *int
	clearedvulnerability bool
	done                 bool
	oldValue             func(context.Context) (*IsVulnerability, error)
	predicates           []predicate.IsVulnerability
}

var _ ent.Mutation = (*IsVulnerabilityMutation)(nil)

// isvulnerabilityOption allows management of the mutation configuration using functional options.
type isvulnerabilityOption func(*IsVulnerabilityMutation)

// newIsVulnerabilityMutation creates new mutation for the IsVulnerability entity.
func newIsVulnerabilityMutation(c config, op Op, opts ...isvulnerabilityOption) *IsVulnerabilityMutation {
	m := &IsVulnerabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeIsVulnerability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIsVulnerabilityID sets the ID field of the mutation.
func withIsVulnerabilityID(id int) isvulnerabilityOption {
	return func(m *IsVulnerabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *IsVulnerability
		)
		m.oldValue = func(ctx context.Context) (*IsVulnerability, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IsVulnerability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIsVulnerability sets the old IsVulnerability of the mutation.
func withIsVulnerability(node *IsVulnerability) isvulnerabilityOption {
	return func(m *IsVulnerabilityMutation) {
		m.oldValue = func(context.Context) (*IsVulnerability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IsVulnerabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IsVulnerabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IsVulnerabilityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IsVulnerabilityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IsVulnerability.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOsvID sets the "osv_id" field.
func (m *IsVulnerabilityMutation) SetOsvID(i int) {
	m.osv = &i
}

// OsvID returns the value of the "osv_id" field in the mutation.
func (m *IsVulnerabilityMutation) OsvID() (r int, exists bool) {
	v := m.osv
	if v == nil {
		return
	}
	return *v, true
}

// OldOsvID returns the old "osv_id" field's value of the IsVulnerability entity.
// If the IsVulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IsVulnerabilityMutation) OldOsvID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsvID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsvID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsvID: %w", err)
	}
	return oldValue.OsvID, nil
}

// ResetOsvID resets all changes to the "osv_id" field.
func (m *IsVulnerabilityMutation) ResetOsvID() {
	m.osv = nil
}

// SetVulnerabilityID sets the "vulnerability_id" field.
func (m *IsVulnerabilityMutation) SetVulnerabilityID(i int) {
	m.vulnerability = &i
}

// VulnerabilityID returns the value of the "vulnerability_id" field in the mutation.
func (m *IsVulnerabilityMutation) VulnerabilityID() (r int, exists bool) {
	v := m.vulnerability
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnerabilityID returns the old "vulnerability_id" field's value of the IsVulnerability entity.
// If the IsVulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IsVulnerabilityMutation) OldVulnerabilityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVulnerabilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVulnerabilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnerabilityID: %w", err)
	}
	return oldValue.VulnerabilityID, nil
}

// ResetVulnerabilityID resets all changes to the "vulnerability_id" field.
func (m *IsVulnerabilityMutation) ResetVulnerabilityID() {
	m.vulnerability = nil
}

// SetJustification sets the "justification" field.
func (m *IsVulnerabilityMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *IsVulnerabilityMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the IsVulnerability entity.
// If the IsVulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IsVulnerabilityMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *IsVulnerabilityMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *IsVulnerabilityMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *IsVulnerabilityMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the IsVulnerability entity.
// If the IsVulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IsVulnerabilityMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *IsVulnerabilityMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *IsVulnerabilityMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *IsVulnerabilityMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the IsVulnerability entity.
// If the IsVulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IsVulnerabilityMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *IsVulnerabilityMutation) ResetCollector() {
	m.collector = nil
}

// ClearOsv clears the "osv" edge to the SecurityAdvisory entity.
func (m *IsVulnerabilityMutation) ClearOsv() {
	m.clearedosv = true
}

// OsvCleared reports if the "osv" edge to the SecurityAdvisory entity was cleared.
func (m *IsVulnerabilityMutation) OsvCleared() bool {
	return m.clearedosv
}

// OsvIDs returns the "osv" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OsvID instead. It exists only for internal usage by the builders.
func (m *IsVulnerabilityMutation) OsvIDs() (ids []int) {
	if id := m.osv; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOsv resets all changes to the "osv" edge.
func (m *IsVulnerabilityMutation) ResetOsv() {
	m.osv = nil
	m.clearedosv = false
}

// ClearVulnerability clears the "vulnerability" edge to the SecurityAdvisory entity.
func (m *IsVulnerabilityMutation) ClearVulnerability() {
	m.clearedvulnerability = true
}

// VulnerabilityCleared reports if the "vulnerability" edge to the SecurityAdvisory entity was cleared.
func (m *IsVulnerabilityMutation) VulnerabilityCleared() bool {
	return m.clearedvulnerability
}

// VulnerabilityIDs returns the "vulnerability" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityID instead. It exists only for internal usage by the builders.
func (m *IsVulnerabilityMutation) VulnerabilityIDs() (ids []int) {
	if id := m.vulnerability; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerability resets all changes to the "vulnerability" edge.
func (m *IsVulnerabilityMutation) ResetVulnerability() {
	m.vulnerability = nil
	m.clearedvulnerability = false
}

// Where appends a list predicates to the IsVulnerabilityMutation builder.
func (m *IsVulnerabilityMutation) Where(ps ...predicate.IsVulnerability) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IsVulnerabilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IsVulnerabilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IsVulnerability, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IsVulnerabilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IsVulnerabilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IsVulnerability).
func (m *IsVulnerabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IsVulnerabilityMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.osv != nil {
		fields = append(fields, isvulnerability.FieldOsvID)
	}
	if m.vulnerability != nil {
		fields = append(fields, isvulnerability.FieldVulnerabilityID)
	}
	if m.justification != nil {
		fields = append(fields, isvulnerability.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, isvulnerability.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, isvulnerability.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IsVulnerabilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case isvulnerability.FieldOsvID:
		return m.OsvID()
	case isvulnerability.FieldVulnerabilityID:
		return m.VulnerabilityID()
	case isvulnerability.FieldJustification:
		return m.Justification()
	case isvulnerability.FieldOrigin:
		return m.Origin()
	case isvulnerability.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IsVulnerabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case isvulnerability.FieldOsvID:
		return m.OldOsvID(ctx)
	case isvulnerability.FieldVulnerabilityID:
		return m.OldVulnerabilityID(ctx)
	case isvulnerability.FieldJustification:
		return m.OldJustification(ctx)
	case isvulnerability.FieldOrigin:
		return m.OldOrigin(ctx)
	case isvulnerability.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown IsVulnerability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IsVulnerabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case isvulnerability.FieldOsvID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsvID(v)
		return nil
	case isvulnerability.FieldVulnerabilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnerabilityID(v)
		return nil
	case isvulnerability.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case isvulnerability.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case isvulnerability.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown IsVulnerability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IsVulnerabilityMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IsVulnerabilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IsVulnerabilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IsVulnerability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IsVulnerabilityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IsVulnerabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IsVulnerabilityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IsVulnerability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IsVulnerabilityMutation) ResetField(name string) error {
	switch name {
	case isvulnerability.FieldOsvID:
		m.ResetOsvID()
		return nil
	case isvulnerability.FieldVulnerabilityID:
		m.ResetVulnerabilityID()
		return nil
	case isvulnerability.FieldJustification:
		m.ResetJustification()
		return nil
	case isvulnerability.FieldOrigin:
		m.ResetOrigin()
		return nil
	case isvulnerability.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown IsVulnerability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IsVulnerabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.osv != nil {
		edges = append(edges, isvulnerability.EdgeOsv)
	}
	if m.vulnerability != nil {
		edges = append(edges, isvulnerability.EdgeVulnerability)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IsVulnerabilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case isvulnerability.EdgeOsv:
		if id := m.osv; id != nil {
			return []ent.Value{*id}
		}
	case isvulnerability.EdgeVulnerability:
		if id := m.vulnerability; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IsVulnerabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IsVulnerabilityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IsVulnerabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedosv {
		edges = append(edges, isvulnerability.EdgeOsv)
	}
	if m.clearedvulnerability {
		edges = append(edges, isvulnerability.EdgeVulnerability)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IsVulnerabilityMutation) EdgeCleared(name string) bool {
	switch name {
	case isvulnerability.EdgeOsv:
		return m.clearedosv
	case isvulnerability.EdgeVulnerability:
		return m.clearedvulnerability
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IsVulnerabilityMutation) ClearEdge(name string) error {
	switch name {
	case isvulnerability.EdgeOsv:
		m.ClearOsv()
		return nil
	case isvulnerability.EdgeVulnerability:
		m.ClearVulnerability()
		return nil
	}
	return fmt.Errorf("unknown IsVulnerability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IsVulnerabilityMutation) ResetEdge(name string) error {
	switch name {
	case isvulnerability.EdgeOsv:
		m.ResetOsv()
		return nil
	case isvulnerability.EdgeVulnerability:
		m.ResetVulnerability()
		return nil
	}
	return fmt.Errorf("unknown IsVulnerability edge %s", name)
}

// OccurrenceMutation represents an operation that mutates the Occurrence nodes in the graph.
type OccurrenceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	justification   *string
	origin          *string
	collector       *string
	clearedFields   map[string]struct{}
	artifact        *int
	clearedartifact bool
	_package        *int
	cleared_package bool
	source          *int
	clearedsource   bool
	done            bool
	oldValue        func(context.Context) (*Occurrence, error)
	predicates      []predicate.Occurrence
}

var _ ent.Mutation = (*OccurrenceMutation)(nil)

// occurrenceOption allows management of the mutation configuration using functional options.
type occurrenceOption func(*OccurrenceMutation)

// newOccurrenceMutation creates new mutation for the Occurrence entity.
func newOccurrenceMutation(c config, op Op, opts ...occurrenceOption) *OccurrenceMutation {
	m := &OccurrenceMutation{
		config:        c,
		op:            op,
		typ:           TypeOccurrence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOccurrenceID sets the ID field of the mutation.
func withOccurrenceID(id int) occurrenceOption {
	return func(m *OccurrenceMutation) {
		var (
			err   error
			once  sync.Once
			value *Occurrence
		)
		m.oldValue = func(ctx context.Context) (*Occurrence, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Occurrence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOccurrence sets the old Occurrence of the mutation.
func withOccurrence(node *Occurrence) occurrenceOption {
	return func(m *OccurrenceMutation) {
		m.oldValue = func(context.Context) (*Occurrence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OccurrenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OccurrenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OccurrenceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OccurrenceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Occurrence.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArtifactID sets the "artifact_id" field.
func (m *OccurrenceMutation) SetArtifactID(i int) {
	m.artifact = &i
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *OccurrenceMutation) ArtifactID() (r int, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldArtifactID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *OccurrenceMutation) ResetArtifactID() {
	m.artifact = nil
}

// SetJustification sets the "justification" field.
func (m *OccurrenceMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *OccurrenceMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *OccurrenceMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *OccurrenceMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *OccurrenceMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *OccurrenceMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *OccurrenceMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *OccurrenceMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *OccurrenceMutation) ResetCollector() {
	m.collector = nil
}

// SetSourceID sets the "source_id" field.
func (m *OccurrenceMutation) SetSourceID(i int) {
	m.source = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *OccurrenceMutation) SourceID() (r int, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldSourceID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *OccurrenceMutation) ClearSourceID() {
	m.source = nil
	m.clearedFields[occurrence.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *OccurrenceMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *OccurrenceMutation) ResetSourceID() {
	m.source = nil
	delete(m.clearedFields, occurrence.FieldSourceID)
}

// SetPackageID sets the "package_id" field.
func (m *OccurrenceMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *OccurrenceMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldPackageID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *OccurrenceMutation) ClearPackageID() {
	m._package = nil
	m.clearedFields[occurrence.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *OccurrenceMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *OccurrenceMutation) ResetPackageID() {
	m._package = nil
	delete(m.clearedFields, occurrence.FieldPackageID)
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *OccurrenceMutation) ClearArtifact() {
	m.clearedartifact = true
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *OccurrenceMutation) ArtifactCleared() bool {
	return m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *OccurrenceMutation) ArtifactIDs() (ids []int) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *OccurrenceMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *OccurrenceMutation) ClearPackage() {
	m.cleared_package = true
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *OccurrenceMutation) PackageCleared() bool {
	return m.PackageIDCleared() || m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *OccurrenceMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *OccurrenceMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *OccurrenceMutation) ClearSource() {
	m.clearedsource = true
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *OccurrenceMutation) SourceCleared() bool {
	return m.SourceIDCleared() || m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *OccurrenceMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *OccurrenceMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Where appends a list predicates to the OccurrenceMutation builder.
func (m *OccurrenceMutation) Where(ps ...predicate.Occurrence) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OccurrenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OccurrenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Occurrence, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OccurrenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OccurrenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Occurrence).
func (m *OccurrenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OccurrenceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.artifact != nil {
		fields = append(fields, occurrence.FieldArtifactID)
	}
	if m.justification != nil {
		fields = append(fields, occurrence.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, occurrence.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, occurrence.FieldCollector)
	}
	if m.source != nil {
		fields = append(fields, occurrence.FieldSourceID)
	}
	if m._package != nil {
		fields = append(fields, occurrence.FieldPackageID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OccurrenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case occurrence.FieldArtifactID:
		return m.ArtifactID()
	case occurrence.FieldJustification:
		return m.Justification()
	case occurrence.FieldOrigin:
		return m.Origin()
	case occurrence.FieldCollector:
		return m.Collector()
	case occurrence.FieldSourceID:
		return m.SourceID()
	case occurrence.FieldPackageID:
		return m.PackageID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OccurrenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case occurrence.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case occurrence.FieldJustification:
		return m.OldJustification(ctx)
	case occurrence.FieldOrigin:
		return m.OldOrigin(ctx)
	case occurrence.FieldCollector:
		return m.OldCollector(ctx)
	case occurrence.FieldSourceID:
		return m.OldSourceID(ctx)
	case occurrence.FieldPackageID:
		return m.OldPackageID(ctx)
	}
	return nil, fmt.Errorf("unknown Occurrence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurrenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case occurrence.FieldArtifactID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case occurrence.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case occurrence.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case occurrence.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case occurrence.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case occurrence.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	}
	return fmt.Errorf("unknown Occurrence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OccurrenceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OccurrenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurrenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Occurrence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OccurrenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(occurrence.FieldSourceID) {
		fields = append(fields, occurrence.FieldSourceID)
	}
	if m.FieldCleared(occurrence.FieldPackageID) {
		fields = append(fields, occurrence.FieldPackageID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OccurrenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OccurrenceMutation) ClearField(name string) error {
	switch name {
	case occurrence.FieldSourceID:
		m.ClearSourceID()
		return nil
	case occurrence.FieldPackageID:
		m.ClearPackageID()
		return nil
	}
	return fmt.Errorf("unknown Occurrence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OccurrenceMutation) ResetField(name string) error {
	switch name {
	case occurrence.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case occurrence.FieldJustification:
		m.ResetJustification()
		return nil
	case occurrence.FieldOrigin:
		m.ResetOrigin()
		return nil
	case occurrence.FieldCollector:
		m.ResetCollector()
		return nil
	case occurrence.FieldSourceID:
		m.ResetSourceID()
		return nil
	case occurrence.FieldPackageID:
		m.ResetPackageID()
		return nil
	}
	return fmt.Errorf("unknown Occurrence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OccurrenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.artifact != nil {
		edges = append(edges, occurrence.EdgeArtifact)
	}
	if m._package != nil {
		edges = append(edges, occurrence.EdgePackage)
	}
	if m.source != nil {
		edges = append(edges, occurrence.EdgeSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OccurrenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case occurrence.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	case occurrence.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case occurrence.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OccurrenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OccurrenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OccurrenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedartifact {
		edges = append(edges, occurrence.EdgeArtifact)
	}
	if m.cleared_package {
		edges = append(edges, occurrence.EdgePackage)
	}
	if m.clearedsource {
		edges = append(edges, occurrence.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OccurrenceMutation) EdgeCleared(name string) bool {
	switch name {
	case occurrence.EdgeArtifact:
		return m.clearedartifact
	case occurrence.EdgePackage:
		return m.cleared_package
	case occurrence.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OccurrenceMutation) ClearEdge(name string) error {
	switch name {
	case occurrence.EdgeArtifact:
		m.ClearArtifact()
		return nil
	case occurrence.EdgePackage:
		m.ClearPackage()
		return nil
	case occurrence.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown Occurrence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OccurrenceMutation) ResetEdge(name string) error {
	switch name {
	case occurrence.EdgeArtifact:
		m.ResetArtifact()
		return nil
	case occurrence.EdgePackage:
		m.ResetPackage()
		return nil
	case occurrence.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown Occurrence edge %s", name)
}

// PackageNameMutation represents an operation that mutates the PackageName nodes in the graph.
type PackageNameMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	namespace        *int
	clearednamespace bool
	versions         map[int]struct{}
	removedversions  map[int]struct{}
	clearedversions  bool
	done             bool
	oldValue         func(context.Context) (*PackageName, error)
	predicates       []predicate.PackageName
}

var _ ent.Mutation = (*PackageNameMutation)(nil)

// packagenameOption allows management of the mutation configuration using functional options.
type packagenameOption func(*PackageNameMutation)

// newPackageNameMutation creates new mutation for the PackageName entity.
func newPackageNameMutation(c config, op Op, opts ...packagenameOption) *PackageNameMutation {
	m := &PackageNameMutation{
		config:        c,
		op:            op,
		typ:           TypePackageName,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageNameID sets the ID field of the mutation.
func withPackageNameID(id int) packagenameOption {
	return func(m *PackageNameMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageName
		)
		m.oldValue = func(ctx context.Context) (*PackageName, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageName.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageName sets the old PackageName of the mutation.
func withPackageName(node *PackageName) packagenameOption {
	return func(m *PackageNameMutation) {
		m.oldValue = func(context.Context) (*PackageName, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageNameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageNameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageNameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageNameMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageName.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespaceID sets the "namespace_id" field.
func (m *PackageNameMutation) SetNamespaceID(i int) {
	m.namespace = &i
}

// NamespaceID returns the value of the "namespace_id" field in the mutation.
func (m *PackageNameMutation) NamespaceID() (r int, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespaceID returns the old "namespace_id" field's value of the PackageName entity.
// If the PackageName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNameMutation) OldNamespaceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespaceID: %w", err)
	}
	return oldValue.NamespaceID, nil
}

// ResetNamespaceID resets all changes to the "namespace_id" field.
func (m *PackageNameMutation) ResetNamespaceID() {
	m.namespace = nil
}

// SetName sets the "name" field.
func (m *PackageNameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PackageNameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PackageName entity.
// If the PackageName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PackageNameMutation) ResetName() {
	m.name = nil
}

// ClearNamespace clears the "namespace" edge to the PackageNamespace entity.
func (m *PackageNameMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the PackageNamespace entity was cleared.
func (m *PackageNameMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *PackageNameMutation) NamespaceIDs() (ids []int) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *PackageNameMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// AddVersionIDs adds the "versions" edge to the PackageVersion entity by ids.
func (m *PackageNameMutation) AddVersionIDs(ids ...int) {
	if m.versions == nil {
		m.versions = make(map[int]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the PackageVersion entity.
func (m *PackageNameMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the PackageVersion entity was cleared.
func (m *PackageNameMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the PackageVersion entity by IDs.
func (m *PackageNameMutation) RemoveVersionIDs(ids ...int) {
	if m.removedversions == nil {
		m.removedversions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the PackageVersion entity.
func (m *PackageNameMutation) RemovedVersionsIDs() (ids []int) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *PackageNameMutation) VersionsIDs() (ids []int) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *PackageNameMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// Where appends a list predicates to the PackageNameMutation builder.
func (m *PackageNameMutation) Where(ps ...predicate.PackageName) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageNameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageNameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageName, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageNameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageNameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageName).
func (m *PackageNameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageNameMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.namespace != nil {
		fields = append(fields, packagename.FieldNamespaceID)
	}
	if m.name != nil {
		fields = append(fields, packagename.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageNameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagename.FieldNamespaceID:
		return m.NamespaceID()
	case packagename.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageNameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagename.FieldNamespaceID:
		return m.OldNamespaceID(ctx)
	case packagename.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown PackageName field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagename.FieldNamespaceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespaceID(v)
		return nil
	case packagename.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown PackageName field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageNameMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageNameMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageName numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageNameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageNameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageNameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackageName nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageNameMutation) ResetField(name string) error {
	switch name {
	case packagename.FieldNamespaceID:
		m.ResetNamespaceID()
		return nil
	case packagename.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PackageName field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageNameMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.namespace != nil {
		edges = append(edges, packagename.EdgeNamespace)
	}
	if m.versions != nil {
		edges = append(edges, packagename.EdgeVersions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageNameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagename.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case packagename.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageNameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedversions != nil {
		edges = append(edges, packagename.EdgeVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageNameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packagename.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageNameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednamespace {
		edges = append(edges, packagename.EdgeNamespace)
	}
	if m.clearedversions {
		edges = append(edges, packagename.EdgeVersions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageNameMutation) EdgeCleared(name string) bool {
	switch name {
	case packagename.EdgeNamespace:
		return m.clearednamespace
	case packagename.EdgeVersions:
		return m.clearedversions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageNameMutation) ClearEdge(name string) error {
	switch name {
	case packagename.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown PackageName unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageNameMutation) ResetEdge(name string) error {
	switch name {
	case packagename.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case packagename.EdgeVersions:
		m.ResetVersions()
		return nil
	}
	return fmt.Errorf("unknown PackageName edge %s", name)
}

// PackageNamespaceMutation represents an operation that mutates the PackageNamespace nodes in the graph.
type PackageNamespaceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	namespace       *string
	clearedFields   map[string]struct{}
	_package        *int
	cleared_package bool
	names           map[int]struct{}
	removednames    map[int]struct{}
	clearednames    bool
	done            bool
	oldValue        func(context.Context) (*PackageNamespace, error)
	predicates      []predicate.PackageNamespace
}

var _ ent.Mutation = (*PackageNamespaceMutation)(nil)

// packagenamespaceOption allows management of the mutation configuration using functional options.
type packagenamespaceOption func(*PackageNamespaceMutation)

// newPackageNamespaceMutation creates new mutation for the PackageNamespace entity.
func newPackageNamespaceMutation(c config, op Op, opts ...packagenamespaceOption) *PackageNamespaceMutation {
	m := &PackageNamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypePackageNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageNamespaceID sets the ID field of the mutation.
func withPackageNamespaceID(id int) packagenamespaceOption {
	return func(m *PackageNamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageNamespace
		)
		m.oldValue = func(ctx context.Context) (*PackageNamespace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageNamespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageNamespace sets the old PackageNamespace of the mutation.
func withPackageNamespace(node *PackageNamespace) packagenamespaceOption {
	return func(m *PackageNamespaceMutation) {
		m.oldValue = func(context.Context) (*PackageNamespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageNamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageNamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageNamespaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageNamespaceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageNamespace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *PackageNamespaceMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *PackageNamespaceMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the PackageNamespace entity.
// If the PackageNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNamespaceMutation) OldPackageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *PackageNamespaceMutation) ResetPackageID() {
	m._package = nil
}

// SetNamespace sets the "namespace" field.
func (m *PackageNamespaceMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PackageNamespaceMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the PackageNamespace entity.
// If the PackageNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNamespaceMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PackageNamespaceMutation) ResetNamespace() {
	m.namespace = nil
}

// ClearPackage clears the "package" edge to the PackageType entity.
func (m *PackageNamespaceMutation) ClearPackage() {
	m.cleared_package = true
}

// PackageCleared reports if the "package" edge to the PackageType entity was cleared.
func (m *PackageNamespaceMutation) PackageCleared() bool {
	return m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *PackageNamespaceMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *PackageNamespaceMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// AddNameIDs adds the "names" edge to the PackageName entity by ids.
func (m *PackageNamespaceMutation) AddNameIDs(ids ...int) {
	if m.names == nil {
		m.names = make(map[int]struct{})
	}
	for i := range ids {
		m.names[ids[i]] = struct{}{}
	}
}

// ClearNames clears the "names" edge to the PackageName entity.
func (m *PackageNamespaceMutation) ClearNames() {
	m.clearednames = true
}

// NamesCleared reports if the "names" edge to the PackageName entity was cleared.
func (m *PackageNamespaceMutation) NamesCleared() bool {
	return m.clearednames
}

// RemoveNameIDs removes the "names" edge to the PackageName entity by IDs.
func (m *PackageNamespaceMutation) RemoveNameIDs(ids ...int) {
	if m.removednames == nil {
		m.removednames = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.names, ids[i])
		m.removednames[ids[i]] = struct{}{}
	}
}

// RemovedNames returns the removed IDs of the "names" edge to the PackageName entity.
func (m *PackageNamespaceMutation) RemovedNamesIDs() (ids []int) {
	for id := range m.removednames {
		ids = append(ids, id)
	}
	return
}

// NamesIDs returns the "names" edge IDs in the mutation.
func (m *PackageNamespaceMutation) NamesIDs() (ids []int) {
	for id := range m.names {
		ids = append(ids, id)
	}
	return
}

// ResetNames resets all changes to the "names" edge.
func (m *PackageNamespaceMutation) ResetNames() {
	m.names = nil
	m.clearednames = false
	m.removednames = nil
}

// Where appends a list predicates to the PackageNamespaceMutation builder.
func (m *PackageNamespaceMutation) Where(ps ...predicate.PackageNamespace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageNamespaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageNamespaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageNamespace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageNamespaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageNamespaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageNamespace).
func (m *PackageNamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageNamespaceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._package != nil {
		fields = append(fields, packagenamespace.FieldPackageID)
	}
	if m.namespace != nil {
		fields = append(fields, packagenamespace.FieldNamespace)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageNamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagenamespace.FieldPackageID:
		return m.PackageID()
	case packagenamespace.FieldNamespace:
		return m.Namespace()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageNamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagenamespace.FieldPackageID:
		return m.OldPackageID(ctx)
	case packagenamespace.FieldNamespace:
		return m.OldNamespace(ctx)
	}
	return nil, fmt.Errorf("unknown PackageNamespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagenamespace.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case packagenamespace.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	}
	return fmt.Errorf("unknown PackageNamespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageNamespaceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageNamespaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageNamespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageNamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageNamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageNamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackageNamespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageNamespaceMutation) ResetField(name string) error {
	switch name {
	case packagenamespace.FieldPackageID:
		m.ResetPackageID()
		return nil
	case packagenamespace.FieldNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown PackageNamespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageNamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._package != nil {
		edges = append(edges, packagenamespace.EdgePackage)
	}
	if m.names != nil {
		edges = append(edges, packagenamespace.EdgeNames)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageNamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagenamespace.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case packagenamespace.EdgeNames:
		ids := make([]ent.Value, 0, len(m.names))
		for id := range m.names {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageNamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednames != nil {
		edges = append(edges, packagenamespace.EdgeNames)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageNamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packagenamespace.EdgeNames:
		ids := make([]ent.Value, 0, len(m.removednames))
		for id := range m.removednames {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageNamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_package {
		edges = append(edges, packagenamespace.EdgePackage)
	}
	if m.clearednames {
		edges = append(edges, packagenamespace.EdgeNames)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageNamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case packagenamespace.EdgePackage:
		return m.cleared_package
	case packagenamespace.EdgeNames:
		return m.clearednames
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageNamespaceMutation) ClearEdge(name string) error {
	switch name {
	case packagenamespace.EdgePackage:
		m.ClearPackage()
		return nil
	}
	return fmt.Errorf("unknown PackageNamespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageNamespaceMutation) ResetEdge(name string) error {
	switch name {
	case packagenamespace.EdgePackage:
		m.ResetPackage()
		return nil
	case packagenamespace.EdgeNames:
		m.ResetNames()
		return nil
	}
	return fmt.Errorf("unknown PackageNamespace edge %s", name)
}

// PackageTypeMutation represents an operation that mutates the PackageType nodes in the graph.
type PackageTypeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_type             *string
	clearedFields     map[string]struct{}
	namespaces        map[int]struct{}
	removednamespaces map[int]struct{}
	clearednamespaces bool
	done              bool
	oldValue          func(context.Context) (*PackageType, error)
	predicates        []predicate.PackageType
}

var _ ent.Mutation = (*PackageTypeMutation)(nil)

// packagetypeOption allows management of the mutation configuration using functional options.
type packagetypeOption func(*PackageTypeMutation)

// newPackageTypeMutation creates new mutation for the PackageType entity.
func newPackageTypeMutation(c config, op Op, opts ...packagetypeOption) *PackageTypeMutation {
	m := &PackageTypeMutation{
		config:        c,
		op:            op,
		typ:           TypePackageType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageTypeID sets the ID field of the mutation.
func withPackageTypeID(id int) packagetypeOption {
	return func(m *PackageTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageType
		)
		m.oldValue = func(ctx context.Context) (*PackageType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageType sets the old PackageType of the mutation.
func withPackageType(node *PackageType) packagetypeOption {
	return func(m *PackageTypeMutation) {
		m.oldValue = func(context.Context) (*PackageType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *PackageTypeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PackageTypeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PackageType entity.
// If the PackageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageTypeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PackageTypeMutation) ResetType() {
	m._type = nil
}

// AddNamespaceIDs adds the "namespaces" edge to the PackageNamespace entity by ids.
func (m *PackageTypeMutation) AddNamespaceIDs(ids ...int) {
	if m.namespaces == nil {
		m.namespaces = make(map[int]struct{})
	}
	for i := range ids {
		m.namespaces[ids[i]] = struct{}{}
	}
}

// ClearNamespaces clears the "namespaces" edge to the PackageNamespace entity.
func (m *PackageTypeMutation) ClearNamespaces() {
	m.clearednamespaces = true
}

// NamespacesCleared reports if the "namespaces" edge to the PackageNamespace entity was cleared.
func (m *PackageTypeMutation) NamespacesCleared() bool {
	return m.clearednamespaces
}

// RemoveNamespaceIDs removes the "namespaces" edge to the PackageNamespace entity by IDs.
func (m *PackageTypeMutation) RemoveNamespaceIDs(ids ...int) {
	if m.removednamespaces == nil {
		m.removednamespaces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.namespaces, ids[i])
		m.removednamespaces[ids[i]] = struct{}{}
	}
}

// RemovedNamespaces returns the removed IDs of the "namespaces" edge to the PackageNamespace entity.
func (m *PackageTypeMutation) RemovedNamespacesIDs() (ids []int) {
	for id := range m.removednamespaces {
		ids = append(ids, id)
	}
	return
}

// NamespacesIDs returns the "namespaces" edge IDs in the mutation.
func (m *PackageTypeMutation) NamespacesIDs() (ids []int) {
	for id := range m.namespaces {
		ids = append(ids, id)
	}
	return
}

// ResetNamespaces resets all changes to the "namespaces" edge.
func (m *PackageTypeMutation) ResetNamespaces() {
	m.namespaces = nil
	m.clearednamespaces = false
	m.removednamespaces = nil
}

// Where appends a list predicates to the PackageTypeMutation builder.
func (m *PackageTypeMutation) Where(ps ...predicate.PackageType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageType).
func (m *PackageTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._type != nil {
		fields = append(fields, packagetype.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagetype.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagetype.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown PackageType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagetype.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown PackageType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackageType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageTypeMutation) ResetField(name string) error {
	switch name {
	case packagetype.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown PackageType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespaces != nil {
		edges = append(edges, packagetype.EdgeNamespaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagetype.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.namespaces))
		for id := range m.namespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednamespaces != nil {
		edges = append(edges, packagetype.EdgeNamespaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packagetype.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.removednamespaces))
		for id := range m.removednamespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespaces {
		edges = append(edges, packagetype.EdgeNamespaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case packagetype.EdgeNamespaces:
		return m.clearednamespaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageTypeMutation) ResetEdge(name string) error {
	switch name {
	case packagetype.EdgeNamespaces:
		m.ResetNamespaces()
		return nil
	}
	return fmt.Errorf("unknown PackageType edge %s", name)
}

// PackageVersionMutation represents an operation that mutates the PackageVersion nodes in the graph.
type PackageVersionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	version            *string
	subpath            *string
	qualifiers         *[]model.PackageQualifier
	appendqualifiers   []model.PackageQualifier
	hash               *string
	clearedFields      map[string]struct{}
	name               *int
	clearedname        bool
	occurrences        map[int]struct{}
	removedoccurrences map[int]struct{}
	clearedoccurrences bool
	sbom               map[int]struct{}
	removedsbom        map[int]struct{}
	clearedsbom        bool
	pkg_equals         map[int]struct{}
	removedpkg_equals  map[int]struct{}
	clearedpkg_equals  bool
	done               bool
	oldValue           func(context.Context) (*PackageVersion, error)
	predicates         []predicate.PackageVersion
}

var _ ent.Mutation = (*PackageVersionMutation)(nil)

// packageversionOption allows management of the mutation configuration using functional options.
type packageversionOption func(*PackageVersionMutation)

// newPackageVersionMutation creates new mutation for the PackageVersion entity.
func newPackageVersionMutation(c config, op Op, opts ...packageversionOption) *PackageVersionMutation {
	m := &PackageVersionMutation{
		config:        c,
		op:            op,
		typ:           TypePackageVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageVersionID sets the ID field of the mutation.
func withPackageVersionID(id int) packageversionOption {
	return func(m *PackageVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageVersion
		)
		m.oldValue = func(ctx context.Context) (*PackageVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageVersion sets the old PackageVersion of the mutation.
func withPackageVersion(node *PackageVersion) packageversionOption {
	return func(m *PackageVersionMutation) {
		m.oldValue = func(context.Context) (*PackageVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameID sets the "name_id" field.
func (m *PackageVersionMutation) SetNameID(i int) {
	m.name = &i
}

// NameID returns the value of the "name_id" field in the mutation.
func (m *PackageVersionMutation) NameID() (r int, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldNameID returns the old "name_id" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldNameID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameID: %w", err)
	}
	return oldValue.NameID, nil
}

// ResetNameID resets all changes to the "name_id" field.
func (m *PackageVersionMutation) ResetNameID() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *PackageVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PackageVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PackageVersionMutation) ResetVersion() {
	m.version = nil
}

// SetSubpath sets the "subpath" field.
func (m *PackageVersionMutation) SetSubpath(s string) {
	m.subpath = &s
}

// Subpath returns the value of the "subpath" field in the mutation.
func (m *PackageVersionMutation) Subpath() (r string, exists bool) {
	v := m.subpath
	if v == nil {
		return
	}
	return *v, true
}

// OldSubpath returns the old "subpath" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldSubpath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubpath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubpath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubpath: %w", err)
	}
	return oldValue.Subpath, nil
}

// ResetSubpath resets all changes to the "subpath" field.
func (m *PackageVersionMutation) ResetSubpath() {
	m.subpath = nil
}

// SetQualifiers sets the "qualifiers" field.
func (m *PackageVersionMutation) SetQualifiers(mq []model.PackageQualifier) {
	m.qualifiers = &mq
	m.appendqualifiers = nil
}

// Qualifiers returns the value of the "qualifiers" field in the mutation.
func (m *PackageVersionMutation) Qualifiers() (r []model.PackageQualifier, exists bool) {
	v := m.qualifiers
	if v == nil {
		return
	}
	return *v, true
}

// OldQualifiers returns the old "qualifiers" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldQualifiers(ctx context.Context) (v []model.PackageQualifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualifiers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualifiers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualifiers: %w", err)
	}
	return oldValue.Qualifiers, nil
}

// AppendQualifiers adds mq to the "qualifiers" field.
func (m *PackageVersionMutation) AppendQualifiers(mq []model.PackageQualifier) {
	m.appendqualifiers = append(m.appendqualifiers, mq...)
}

// AppendedQualifiers returns the list of values that were appended to the "qualifiers" field in this mutation.
func (m *PackageVersionMutation) AppendedQualifiers() ([]model.PackageQualifier, bool) {
	if len(m.appendqualifiers) == 0 {
		return nil, false
	}
	return m.appendqualifiers, true
}

// ClearQualifiers clears the value of the "qualifiers" field.
func (m *PackageVersionMutation) ClearQualifiers() {
	m.qualifiers = nil
	m.appendqualifiers = nil
	m.clearedFields[packageversion.FieldQualifiers] = struct{}{}
}

// QualifiersCleared returns if the "qualifiers" field was cleared in this mutation.
func (m *PackageVersionMutation) QualifiersCleared() bool {
	_, ok := m.clearedFields[packageversion.FieldQualifiers]
	return ok
}

// ResetQualifiers resets all changes to the "qualifiers" field.
func (m *PackageVersionMutation) ResetQualifiers() {
	m.qualifiers = nil
	m.appendqualifiers = nil
	delete(m.clearedFields, packageversion.FieldQualifiers)
}

// SetHash sets the "hash" field.
func (m *PackageVersionMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *PackageVersionMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *PackageVersionMutation) ResetHash() {
	m.hash = nil
}

// ClearName clears the "name" edge to the PackageName entity.
func (m *PackageVersionMutation) ClearName() {
	m.clearedname = true
}

// NameCleared reports if the "name" edge to the PackageName entity was cleared.
func (m *PackageVersionMutation) NameCleared() bool {
	return m.clearedname
}

// NameIDs returns the "name" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NameID instead. It exists only for internal usage by the builders.
func (m *PackageVersionMutation) NameIDs() (ids []int) {
	if id := m.name; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetName resets all changes to the "name" edge.
func (m *PackageVersionMutation) ResetName() {
	m.name = nil
	m.clearedname = false
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by ids.
func (m *PackageVersionMutation) AddOccurrenceIDs(ids ...int) {
	if m.occurrences == nil {
		m.occurrences = make(map[int]struct{})
	}
	for i := range ids {
		m.occurrences[ids[i]] = struct{}{}
	}
}

// ClearOccurrences clears the "occurrences" edge to the Occurrence entity.
func (m *PackageVersionMutation) ClearOccurrences() {
	m.clearedoccurrences = true
}

// OccurrencesCleared reports if the "occurrences" edge to the Occurrence entity was cleared.
func (m *PackageVersionMutation) OccurrencesCleared() bool {
	return m.clearedoccurrences
}

// RemoveOccurrenceIDs removes the "occurrences" edge to the Occurrence entity by IDs.
func (m *PackageVersionMutation) RemoveOccurrenceIDs(ids ...int) {
	if m.removedoccurrences == nil {
		m.removedoccurrences = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occurrences, ids[i])
		m.removedoccurrences[ids[i]] = struct{}{}
	}
}

// RemovedOccurrences returns the removed IDs of the "occurrences" edge to the Occurrence entity.
func (m *PackageVersionMutation) RemovedOccurrencesIDs() (ids []int) {
	for id := range m.removedoccurrences {
		ids = append(ids, id)
	}
	return
}

// OccurrencesIDs returns the "occurrences" edge IDs in the mutation.
func (m *PackageVersionMutation) OccurrencesIDs() (ids []int) {
	for id := range m.occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetOccurrences resets all changes to the "occurrences" edge.
func (m *PackageVersionMutation) ResetOccurrences() {
	m.occurrences = nil
	m.clearedoccurrences = false
	m.removedoccurrences = nil
}

// AddSbomIDs adds the "sbom" edge to the BillOfMaterials entity by ids.
func (m *PackageVersionMutation) AddSbomIDs(ids ...int) {
	if m.sbom == nil {
		m.sbom = make(map[int]struct{})
	}
	for i := range ids {
		m.sbom[ids[i]] = struct{}{}
	}
}

// ClearSbom clears the "sbom" edge to the BillOfMaterials entity.
func (m *PackageVersionMutation) ClearSbom() {
	m.clearedsbom = true
}

// SbomCleared reports if the "sbom" edge to the BillOfMaterials entity was cleared.
func (m *PackageVersionMutation) SbomCleared() bool {
	return m.clearedsbom
}

// RemoveSbomIDs removes the "sbom" edge to the BillOfMaterials entity by IDs.
func (m *PackageVersionMutation) RemoveSbomIDs(ids ...int) {
	if m.removedsbom == nil {
		m.removedsbom = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sbom, ids[i])
		m.removedsbom[ids[i]] = struct{}{}
	}
}

// RemovedSbom returns the removed IDs of the "sbom" edge to the BillOfMaterials entity.
func (m *PackageVersionMutation) RemovedSbomIDs() (ids []int) {
	for id := range m.removedsbom {
		ids = append(ids, id)
	}
	return
}

// SbomIDs returns the "sbom" edge IDs in the mutation.
func (m *PackageVersionMutation) SbomIDs() (ids []int) {
	for id := range m.sbom {
		ids = append(ids, id)
	}
	return
}

// ResetSbom resets all changes to the "sbom" edge.
func (m *PackageVersionMutation) ResetSbom() {
	m.sbom = nil
	m.clearedsbom = false
	m.removedsbom = nil
}

// AddPkgEqualIDs adds the "pkg_equals" edge to the PkgEqual entity by ids.
func (m *PackageVersionMutation) AddPkgEqualIDs(ids ...int) {
	if m.pkg_equals == nil {
		m.pkg_equals = make(map[int]struct{})
	}
	for i := range ids {
		m.pkg_equals[ids[i]] = struct{}{}
	}
}

// ClearPkgEquals clears the "pkg_equals" edge to the PkgEqual entity.
func (m *PackageVersionMutation) ClearPkgEquals() {
	m.clearedpkg_equals = true
}

// PkgEqualsCleared reports if the "pkg_equals" edge to the PkgEqual entity was cleared.
func (m *PackageVersionMutation) PkgEqualsCleared() bool {
	return m.clearedpkg_equals
}

// RemovePkgEqualIDs removes the "pkg_equals" edge to the PkgEqual entity by IDs.
func (m *PackageVersionMutation) RemovePkgEqualIDs(ids ...int) {
	if m.removedpkg_equals == nil {
		m.removedpkg_equals = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pkg_equals, ids[i])
		m.removedpkg_equals[ids[i]] = struct{}{}
	}
}

// RemovedPkgEquals returns the removed IDs of the "pkg_equals" edge to the PkgEqual entity.
func (m *PackageVersionMutation) RemovedPkgEqualsIDs() (ids []int) {
	for id := range m.removedpkg_equals {
		ids = append(ids, id)
	}
	return
}

// PkgEqualsIDs returns the "pkg_equals" edge IDs in the mutation.
func (m *PackageVersionMutation) PkgEqualsIDs() (ids []int) {
	for id := range m.pkg_equals {
		ids = append(ids, id)
	}
	return
}

// ResetPkgEquals resets all changes to the "pkg_equals" edge.
func (m *PackageVersionMutation) ResetPkgEquals() {
	m.pkg_equals = nil
	m.clearedpkg_equals = false
	m.removedpkg_equals = nil
}

// Where appends a list predicates to the PackageVersionMutation builder.
func (m *PackageVersionMutation) Where(ps ...predicate.PackageVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageVersion).
func (m *PackageVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageVersionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, packageversion.FieldNameID)
	}
	if m.version != nil {
		fields = append(fields, packageversion.FieldVersion)
	}
	if m.subpath != nil {
		fields = append(fields, packageversion.FieldSubpath)
	}
	if m.qualifiers != nil {
		fields = append(fields, packageversion.FieldQualifiers)
	}
	if m.hash != nil {
		fields = append(fields, packageversion.FieldHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packageversion.FieldNameID:
		return m.NameID()
	case packageversion.FieldVersion:
		return m.Version()
	case packageversion.FieldSubpath:
		return m.Subpath()
	case packageversion.FieldQualifiers:
		return m.Qualifiers()
	case packageversion.FieldHash:
		return m.Hash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packageversion.FieldNameID:
		return m.OldNameID(ctx)
	case packageversion.FieldVersion:
		return m.OldVersion(ctx)
	case packageversion.FieldSubpath:
		return m.OldSubpath(ctx)
	case packageversion.FieldQualifiers:
		return m.OldQualifiers(ctx)
	case packageversion.FieldHash:
		return m.OldHash(ctx)
	}
	return nil, fmt.Errorf("unknown PackageVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packageversion.FieldNameID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameID(v)
		return nil
	case packageversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case packageversion.FieldSubpath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubpath(v)
		return nil
	case packageversion.FieldQualifiers:
		v, ok := value.([]model.PackageQualifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualifiers(v)
		return nil
	case packageversion.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	}
	return fmt.Errorf("unknown PackageVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageVersionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(packageversion.FieldQualifiers) {
		fields = append(fields, packageversion.FieldQualifiers)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageVersionMutation) ClearField(name string) error {
	switch name {
	case packageversion.FieldQualifiers:
		m.ClearQualifiers()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageVersionMutation) ResetField(name string) error {
	switch name {
	case packageversion.FieldNameID:
		m.ResetNameID()
		return nil
	case packageversion.FieldVersion:
		m.ResetVersion()
		return nil
	case packageversion.FieldSubpath:
		m.ResetSubpath()
		return nil
	case packageversion.FieldQualifiers:
		m.ResetQualifiers()
		return nil
	case packageversion.FieldHash:
		m.ResetHash()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.name != nil {
		edges = append(edges, packageversion.EdgeName)
	}
	if m.occurrences != nil {
		edges = append(edges, packageversion.EdgeOccurrences)
	}
	if m.sbom != nil {
		edges = append(edges, packageversion.EdgeSbom)
	}
	if m.pkg_equals != nil {
		edges = append(edges, packageversion.EdgePkgEquals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packageversion.EdgeName:
		if id := m.name; id != nil {
			return []ent.Value{*id}
		}
	case packageversion.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.occurrences))
		for id := range m.occurrences {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeSbom:
		ids := make([]ent.Value, 0, len(m.sbom))
		for id := range m.sbom {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgePkgEquals:
		ids := make([]ent.Value, 0, len(m.pkg_equals))
		for id := range m.pkg_equals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedoccurrences != nil {
		edges = append(edges, packageversion.EdgeOccurrences)
	}
	if m.removedsbom != nil {
		edges = append(edges, packageversion.EdgeSbom)
	}
	if m.removedpkg_equals != nil {
		edges = append(edges, packageversion.EdgePkgEquals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageVersionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packageversion.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.removedoccurrences))
		for id := range m.removedoccurrences {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeSbom:
		ids := make([]ent.Value, 0, len(m.removedsbom))
		for id := range m.removedsbom {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgePkgEquals:
		ids := make([]ent.Value, 0, len(m.removedpkg_equals))
		for id := range m.removedpkg_equals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedname {
		edges = append(edges, packageversion.EdgeName)
	}
	if m.clearedoccurrences {
		edges = append(edges, packageversion.EdgeOccurrences)
	}
	if m.clearedsbom {
		edges = append(edges, packageversion.EdgeSbom)
	}
	if m.clearedpkg_equals {
		edges = append(edges, packageversion.EdgePkgEquals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case packageversion.EdgeName:
		return m.clearedname
	case packageversion.EdgeOccurrences:
		return m.clearedoccurrences
	case packageversion.EdgeSbom:
		return m.clearedsbom
	case packageversion.EdgePkgEquals:
		return m.clearedpkg_equals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageVersionMutation) ClearEdge(name string) error {
	switch name {
	case packageversion.EdgeName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageVersionMutation) ResetEdge(name string) error {
	switch name {
	case packageversion.EdgeName:
		m.ResetName()
		return nil
	case packageversion.EdgeOccurrences:
		m.ResetOccurrences()
		return nil
	case packageversion.EdgeSbom:
		m.ResetSbom()
		return nil
	case packageversion.EdgePkgEquals:
		m.ResetPkgEquals()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion edge %s", name)
}

// PkgEqualMutation represents an operation that mutates the PkgEqual nodes in the graph.
type PkgEqualMutation struct {
	config
	op              Op
	typ             string
	id              *int
	origin          *string
	collector       *string
	justification   *string
	packages_hash   *string
	clearedFields   map[string]struct{}
	packages        map[int]struct{}
	removedpackages map[int]struct{}
	clearedpackages bool
	done            bool
	oldValue        func(context.Context) (*PkgEqual, error)
	predicates      []predicate.PkgEqual
}

var _ ent.Mutation = (*PkgEqualMutation)(nil)

// pkgequalOption allows management of the mutation configuration using functional options.
type pkgequalOption func(*PkgEqualMutation)

// newPkgEqualMutation creates new mutation for the PkgEqual entity.
func newPkgEqualMutation(c config, op Op, opts ...pkgequalOption) *PkgEqualMutation {
	m := &PkgEqualMutation{
		config:        c,
		op:            op,
		typ:           TypePkgEqual,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPkgEqualID sets the ID field of the mutation.
func withPkgEqualID(id int) pkgequalOption {
	return func(m *PkgEqualMutation) {
		var (
			err   error
			once  sync.Once
			value *PkgEqual
		)
		m.oldValue = func(ctx context.Context) (*PkgEqual, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PkgEqual.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPkgEqual sets the old PkgEqual of the mutation.
func withPkgEqual(node *PkgEqual) pkgequalOption {
	return func(m *PkgEqualMutation) {
		m.oldValue = func(context.Context) (*PkgEqual, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PkgEqualMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PkgEqualMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PkgEqualMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PkgEqualMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PkgEqual.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrigin sets the "origin" field.
func (m *PkgEqualMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *PkgEqualMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *PkgEqualMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *PkgEqualMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *PkgEqualMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *PkgEqualMutation) ResetCollector() {
	m.collector = nil
}

// SetJustification sets the "justification" field.
func (m *PkgEqualMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *PkgEqualMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *PkgEqualMutation) ResetJustification() {
	m.justification = nil
}

// SetPackagesHash sets the "packages_hash" field.
func (m *PkgEqualMutation) SetPackagesHash(s string) {
	m.packages_hash = &s
}

// PackagesHash returns the value of the "packages_hash" field in the mutation.
func (m *PkgEqualMutation) PackagesHash() (r string, exists bool) {
	v := m.packages_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPackagesHash returns the old "packages_hash" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldPackagesHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackagesHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackagesHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackagesHash: %w", err)
	}
	return oldValue.PackagesHash, nil
}

// ResetPackagesHash resets all changes to the "packages_hash" field.
func (m *PkgEqualMutation) ResetPackagesHash() {
	m.packages_hash = nil
}

// AddPackageIDs adds the "packages" edge to the PackageVersion entity by ids.
func (m *PkgEqualMutation) AddPackageIDs(ids ...int) {
	if m.packages == nil {
		m.packages = make(map[int]struct{})
	}
	for i := range ids {
		m.packages[ids[i]] = struct{}{}
	}
}

// ClearPackages clears the "packages" edge to the PackageVersion entity.
func (m *PkgEqualMutation) ClearPackages() {
	m.clearedpackages = true
}

// PackagesCleared reports if the "packages" edge to the PackageVersion entity was cleared.
func (m *PkgEqualMutation) PackagesCleared() bool {
	return m.clearedpackages
}

// RemovePackageIDs removes the "packages" edge to the PackageVersion entity by IDs.
func (m *PkgEqualMutation) RemovePackageIDs(ids ...int) {
	if m.removedpackages == nil {
		m.removedpackages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.packages, ids[i])
		m.removedpackages[ids[i]] = struct{}{}
	}
}

// RemovedPackages returns the removed IDs of the "packages" edge to the PackageVersion entity.
func (m *PkgEqualMutation) RemovedPackagesIDs() (ids []int) {
	for id := range m.removedpackages {
		ids = append(ids, id)
	}
	return
}

// PackagesIDs returns the "packages" edge IDs in the mutation.
func (m *PkgEqualMutation) PackagesIDs() (ids []int) {
	for id := range m.packages {
		ids = append(ids, id)
	}
	return
}

// ResetPackages resets all changes to the "packages" edge.
func (m *PkgEqualMutation) ResetPackages() {
	m.packages = nil
	m.clearedpackages = false
	m.removedpackages = nil
}

// Where appends a list predicates to the PkgEqualMutation builder.
func (m *PkgEqualMutation) Where(ps ...predicate.PkgEqual) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PkgEqualMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PkgEqualMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PkgEqual, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PkgEqualMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PkgEqualMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PkgEqual).
func (m *PkgEqualMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PkgEqualMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.origin != nil {
		fields = append(fields, pkgequal.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, pkgequal.FieldCollector)
	}
	if m.justification != nil {
		fields = append(fields, pkgequal.FieldJustification)
	}
	if m.packages_hash != nil {
		fields = append(fields, pkgequal.FieldPackagesHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PkgEqualMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pkgequal.FieldOrigin:
		return m.Origin()
	case pkgequal.FieldCollector:
		return m.Collector()
	case pkgequal.FieldJustification:
		return m.Justification()
	case pkgequal.FieldPackagesHash:
		return m.PackagesHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PkgEqualMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pkgequal.FieldOrigin:
		return m.OldOrigin(ctx)
	case pkgequal.FieldCollector:
		return m.OldCollector(ctx)
	case pkgequal.FieldJustification:
		return m.OldJustification(ctx)
	case pkgequal.FieldPackagesHash:
		return m.OldPackagesHash(ctx)
	}
	return nil, fmt.Errorf("unknown PkgEqual field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PkgEqualMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pkgequal.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case pkgequal.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case pkgequal.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case pkgequal.FieldPackagesHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackagesHash(v)
		return nil
	}
	return fmt.Errorf("unknown PkgEqual field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PkgEqualMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PkgEqualMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PkgEqualMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PkgEqual numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PkgEqualMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PkgEqualMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PkgEqualMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PkgEqual nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PkgEqualMutation) ResetField(name string) error {
	switch name {
	case pkgequal.FieldOrigin:
		m.ResetOrigin()
		return nil
	case pkgequal.FieldCollector:
		m.ResetCollector()
		return nil
	case pkgequal.FieldJustification:
		m.ResetJustification()
		return nil
	case pkgequal.FieldPackagesHash:
		m.ResetPackagesHash()
		return nil
	}
	return fmt.Errorf("unknown PkgEqual field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PkgEqualMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.packages != nil {
		edges = append(edges, pkgequal.EdgePackages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PkgEqualMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pkgequal.EdgePackages:
		ids := make([]ent.Value, 0, len(m.packages))
		for id := range m.packages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PkgEqualMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpackages != nil {
		edges = append(edges, pkgequal.EdgePackages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PkgEqualMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pkgequal.EdgePackages:
		ids := make([]ent.Value, 0, len(m.removedpackages))
		for id := range m.removedpackages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PkgEqualMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpackages {
		edges = append(edges, pkgequal.EdgePackages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PkgEqualMutation) EdgeCleared(name string) bool {
	switch name {
	case pkgequal.EdgePackages:
		return m.clearedpackages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PkgEqualMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PkgEqual unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PkgEqualMutation) ResetEdge(name string) error {
	switch name {
	case pkgequal.EdgePackages:
		m.ResetPackages()
		return nil
	}
	return fmt.Errorf("unknown PkgEqual edge %s", name)
}

// SLSAAttestationMutation represents an operation that mutates the SLSAAttestation nodes in the graph.
type SLSAAttestationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	build_type           *string
	slsa_predicate       *[]*model.SLSAPredicate
	appendslsa_predicate []*model.SLSAPredicate
	slsa_version         *string
	started_on           *time.Time
	finished_on          *time.Time
	origin               *string
	collector            *string
	built_from_hash      *string
	clearedFields        map[string]struct{}
	built_from           map[int]struct{}
	removedbuilt_from    map[int]struct{}
	clearedbuilt_from    bool
	built_by             *int
	clearedbuilt_by      bool
	subject              *int
	clearedsubject       bool
	done                 bool
	oldValue             func(context.Context) (*SLSAAttestation, error)
	predicates           []predicate.SLSAAttestation
}

var _ ent.Mutation = (*SLSAAttestationMutation)(nil)

// slsaattestationOption allows management of the mutation configuration using functional options.
type slsaattestationOption func(*SLSAAttestationMutation)

// newSLSAAttestationMutation creates new mutation for the SLSAAttestation entity.
func newSLSAAttestationMutation(c config, op Op, opts ...slsaattestationOption) *SLSAAttestationMutation {
	m := &SLSAAttestationMutation{
		config:        c,
		op:            op,
		typ:           TypeSLSAAttestation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSLSAAttestationID sets the ID field of the mutation.
func withSLSAAttestationID(id int) slsaattestationOption {
	return func(m *SLSAAttestationMutation) {
		var (
			err   error
			once  sync.Once
			value *SLSAAttestation
		)
		m.oldValue = func(ctx context.Context) (*SLSAAttestation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SLSAAttestation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSLSAAttestation sets the old SLSAAttestation of the mutation.
func withSLSAAttestation(node *SLSAAttestation) slsaattestationOption {
	return func(m *SLSAAttestationMutation) {
		m.oldValue = func(context.Context) (*SLSAAttestation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SLSAAttestationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SLSAAttestationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SLSAAttestationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SLSAAttestationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SLSAAttestation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBuildType sets the "build_type" field.
func (m *SLSAAttestationMutation) SetBuildType(s string) {
	m.build_type = &s
}

// BuildType returns the value of the "build_type" field in the mutation.
func (m *SLSAAttestationMutation) BuildType() (r string, exists bool) {
	v := m.build_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildType returns the old "build_type" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldBuildType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildType: %w", err)
	}
	return oldValue.BuildType, nil
}

// ResetBuildType resets all changes to the "build_type" field.
func (m *SLSAAttestationMutation) ResetBuildType() {
	m.build_type = nil
}

// SetBuiltByID sets the "built_by_id" field.
func (m *SLSAAttestationMutation) SetBuiltByID(i int) {
	m.built_by = &i
}

// BuiltByID returns the value of the "built_by_id" field in the mutation.
func (m *SLSAAttestationMutation) BuiltByID() (r int, exists bool) {
	v := m.built_by
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltByID returns the old "built_by_id" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldBuiltByID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltByID: %w", err)
	}
	return oldValue.BuiltByID, nil
}

// ResetBuiltByID resets all changes to the "built_by_id" field.
func (m *SLSAAttestationMutation) ResetBuiltByID() {
	m.built_by = nil
}

// SetSubjectID sets the "subject_id" field.
func (m *SLSAAttestationMutation) SetSubjectID(i int) {
	m.subject = &i
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *SLSAAttestationMutation) SubjectID() (r int, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldSubjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *SLSAAttestationMutation) ResetSubjectID() {
	m.subject = nil
}

// SetSlsaPredicate sets the "slsa_predicate" field.
func (m *SLSAAttestationMutation) SetSlsaPredicate(mp []*model.SLSAPredicate) {
	m.slsa_predicate = &mp
	m.appendslsa_predicate = nil
}

// SlsaPredicate returns the value of the "slsa_predicate" field in the mutation.
func (m *SLSAAttestationMutation) SlsaPredicate() (r []*model.SLSAPredicate, exists bool) {
	v := m.slsa_predicate
	if v == nil {
		return
	}
	return *v, true
}

// OldSlsaPredicate returns the old "slsa_predicate" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldSlsaPredicate(ctx context.Context) (v []*model.SLSAPredicate, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlsaPredicate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlsaPredicate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlsaPredicate: %w", err)
	}
	return oldValue.SlsaPredicate, nil
}

// AppendSlsaPredicate adds mp to the "slsa_predicate" field.
func (m *SLSAAttestationMutation) AppendSlsaPredicate(mp []*model.SLSAPredicate) {
	m.appendslsa_predicate = append(m.appendslsa_predicate, mp...)
}

// AppendedSlsaPredicate returns the list of values that were appended to the "slsa_predicate" field in this mutation.
func (m *SLSAAttestationMutation) AppendedSlsaPredicate() ([]*model.SLSAPredicate, bool) {
	if len(m.appendslsa_predicate) == 0 {
		return nil, false
	}
	return m.appendslsa_predicate, true
}

// ClearSlsaPredicate clears the value of the "slsa_predicate" field.
func (m *SLSAAttestationMutation) ClearSlsaPredicate() {
	m.slsa_predicate = nil
	m.appendslsa_predicate = nil
	m.clearedFields[slsaattestation.FieldSlsaPredicate] = struct{}{}
}

// SlsaPredicateCleared returns if the "slsa_predicate" field was cleared in this mutation.
func (m *SLSAAttestationMutation) SlsaPredicateCleared() bool {
	_, ok := m.clearedFields[slsaattestation.FieldSlsaPredicate]
	return ok
}

// ResetSlsaPredicate resets all changes to the "slsa_predicate" field.
func (m *SLSAAttestationMutation) ResetSlsaPredicate() {
	m.slsa_predicate = nil
	m.appendslsa_predicate = nil
	delete(m.clearedFields, slsaattestation.FieldSlsaPredicate)
}

// SetSlsaVersion sets the "slsa_version" field.
func (m *SLSAAttestationMutation) SetSlsaVersion(s string) {
	m.slsa_version = &s
}

// SlsaVersion returns the value of the "slsa_version" field in the mutation.
func (m *SLSAAttestationMutation) SlsaVersion() (r string, exists bool) {
	v := m.slsa_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSlsaVersion returns the old "slsa_version" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldSlsaVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlsaVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlsaVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlsaVersion: %w", err)
	}
	return oldValue.SlsaVersion, nil
}

// ResetSlsaVersion resets all changes to the "slsa_version" field.
func (m *SLSAAttestationMutation) ResetSlsaVersion() {
	m.slsa_version = nil
}

// SetStartedOn sets the "started_on" field.
func (m *SLSAAttestationMutation) SetStartedOn(t time.Time) {
	m.started_on = &t
}

// StartedOn returns the value of the "started_on" field in the mutation.
func (m *SLSAAttestationMutation) StartedOn() (r time.Time, exists bool) {
	v := m.started_on
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedOn returns the old "started_on" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldStartedOn(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedOn: %w", err)
	}
	return oldValue.StartedOn, nil
}

// ClearStartedOn clears the value of the "started_on" field.
func (m *SLSAAttestationMutation) ClearStartedOn() {
	m.started_on = nil
	m.clearedFields[slsaattestation.FieldStartedOn] = struct{}{}
}

// StartedOnCleared returns if the "started_on" field was cleared in this mutation.
func (m *SLSAAttestationMutation) StartedOnCleared() bool {
	_, ok := m.clearedFields[slsaattestation.FieldStartedOn]
	return ok
}

// ResetStartedOn resets all changes to the "started_on" field.
func (m *SLSAAttestationMutation) ResetStartedOn() {
	m.started_on = nil
	delete(m.clearedFields, slsaattestation.FieldStartedOn)
}

// SetFinishedOn sets the "finished_on" field.
func (m *SLSAAttestationMutation) SetFinishedOn(t time.Time) {
	m.finished_on = &t
}

// FinishedOn returns the value of the "finished_on" field in the mutation.
func (m *SLSAAttestationMutation) FinishedOn() (r time.Time, exists bool) {
	v := m.finished_on
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedOn returns the old "finished_on" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldFinishedOn(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedOn: %w", err)
	}
	return oldValue.FinishedOn, nil
}

// ClearFinishedOn clears the value of the "finished_on" field.
func (m *SLSAAttestationMutation) ClearFinishedOn() {
	m.finished_on = nil
	m.clearedFields[slsaattestation.FieldFinishedOn] = struct{}{}
}

// FinishedOnCleared returns if the "finished_on" field was cleared in this mutation.
func (m *SLSAAttestationMutation) FinishedOnCleared() bool {
	_, ok := m.clearedFields[slsaattestation.FieldFinishedOn]
	return ok
}

// ResetFinishedOn resets all changes to the "finished_on" field.
func (m *SLSAAttestationMutation) ResetFinishedOn() {
	m.finished_on = nil
	delete(m.clearedFields, slsaattestation.FieldFinishedOn)
}

// SetOrigin sets the "origin" field.
func (m *SLSAAttestationMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *SLSAAttestationMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *SLSAAttestationMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *SLSAAttestationMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *SLSAAttestationMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *SLSAAttestationMutation) ResetCollector() {
	m.collector = nil
}

// SetBuiltFromHash sets the "built_from_hash" field.
func (m *SLSAAttestationMutation) SetBuiltFromHash(s string) {
	m.built_from_hash = &s
}

// BuiltFromHash returns the value of the "built_from_hash" field in the mutation.
func (m *SLSAAttestationMutation) BuiltFromHash() (r string, exists bool) {
	v := m.built_from_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltFromHash returns the old "built_from_hash" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldBuiltFromHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltFromHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltFromHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltFromHash: %w", err)
	}
	return oldValue.BuiltFromHash, nil
}

// ResetBuiltFromHash resets all changes to the "built_from_hash" field.
func (m *SLSAAttestationMutation) ResetBuiltFromHash() {
	m.built_from_hash = nil
}

// AddBuiltFromIDs adds the "built_from" edge to the Artifact entity by ids.
func (m *SLSAAttestationMutation) AddBuiltFromIDs(ids ...int) {
	if m.built_from == nil {
		m.built_from = make(map[int]struct{})
	}
	for i := range ids {
		m.built_from[ids[i]] = struct{}{}
	}
}

// ClearBuiltFrom clears the "built_from" edge to the Artifact entity.
func (m *SLSAAttestationMutation) ClearBuiltFrom() {
	m.clearedbuilt_from = true
}

// BuiltFromCleared reports if the "built_from" edge to the Artifact entity was cleared.
func (m *SLSAAttestationMutation) BuiltFromCleared() bool {
	return m.clearedbuilt_from
}

// RemoveBuiltFromIDs removes the "built_from" edge to the Artifact entity by IDs.
func (m *SLSAAttestationMutation) RemoveBuiltFromIDs(ids ...int) {
	if m.removedbuilt_from == nil {
		m.removedbuilt_from = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.built_from, ids[i])
		m.removedbuilt_from[ids[i]] = struct{}{}
	}
}

// RemovedBuiltFrom returns the removed IDs of the "built_from" edge to the Artifact entity.
func (m *SLSAAttestationMutation) RemovedBuiltFromIDs() (ids []int) {
	for id := range m.removedbuilt_from {
		ids = append(ids, id)
	}
	return
}

// BuiltFromIDs returns the "built_from" edge IDs in the mutation.
func (m *SLSAAttestationMutation) BuiltFromIDs() (ids []int) {
	for id := range m.built_from {
		ids = append(ids, id)
	}
	return
}

// ResetBuiltFrom resets all changes to the "built_from" edge.
func (m *SLSAAttestationMutation) ResetBuiltFrom() {
	m.built_from = nil
	m.clearedbuilt_from = false
	m.removedbuilt_from = nil
}

// ClearBuiltBy clears the "built_by" edge to the Builder entity.
func (m *SLSAAttestationMutation) ClearBuiltBy() {
	m.clearedbuilt_by = true
}

// BuiltByCleared reports if the "built_by" edge to the Builder entity was cleared.
func (m *SLSAAttestationMutation) BuiltByCleared() bool {
	return m.clearedbuilt_by
}

// BuiltByIDs returns the "built_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuiltByID instead. It exists only for internal usage by the builders.
func (m *SLSAAttestationMutation) BuiltByIDs() (ids []int) {
	if id := m.built_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuiltBy resets all changes to the "built_by" edge.
func (m *SLSAAttestationMutation) ResetBuiltBy() {
	m.built_by = nil
	m.clearedbuilt_by = false
}

// ClearSubject clears the "subject" edge to the Artifact entity.
func (m *SLSAAttestationMutation) ClearSubject() {
	m.clearedsubject = true
}

// SubjectCleared reports if the "subject" edge to the Artifact entity was cleared.
func (m *SLSAAttestationMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectIDs returns the "subject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *SLSAAttestationMutation) SubjectIDs() (ids []int) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject resets all changes to the "subject" edge.
func (m *SLSAAttestationMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// Where appends a list predicates to the SLSAAttestationMutation builder.
func (m *SLSAAttestationMutation) Where(ps ...predicate.SLSAAttestation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SLSAAttestationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SLSAAttestationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SLSAAttestation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SLSAAttestationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SLSAAttestationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SLSAAttestation).
func (m *SLSAAttestationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SLSAAttestationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.build_type != nil {
		fields = append(fields, slsaattestation.FieldBuildType)
	}
	if m.built_by != nil {
		fields = append(fields, slsaattestation.FieldBuiltByID)
	}
	if m.subject != nil {
		fields = append(fields, slsaattestation.FieldSubjectID)
	}
	if m.slsa_predicate != nil {
		fields = append(fields, slsaattestation.FieldSlsaPredicate)
	}
	if m.slsa_version != nil {
		fields = append(fields, slsaattestation.FieldSlsaVersion)
	}
	if m.started_on != nil {
		fields = append(fields, slsaattestation.FieldStartedOn)
	}
	if m.finished_on != nil {
		fields = append(fields, slsaattestation.FieldFinishedOn)
	}
	if m.origin != nil {
		fields = append(fields, slsaattestation.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, slsaattestation.FieldCollector)
	}
	if m.built_from_hash != nil {
		fields = append(fields, slsaattestation.FieldBuiltFromHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SLSAAttestationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slsaattestation.FieldBuildType:
		return m.BuildType()
	case slsaattestation.FieldBuiltByID:
		return m.BuiltByID()
	case slsaattestation.FieldSubjectID:
		return m.SubjectID()
	case slsaattestation.FieldSlsaPredicate:
		return m.SlsaPredicate()
	case slsaattestation.FieldSlsaVersion:
		return m.SlsaVersion()
	case slsaattestation.FieldStartedOn:
		return m.StartedOn()
	case slsaattestation.FieldFinishedOn:
		return m.FinishedOn()
	case slsaattestation.FieldOrigin:
		return m.Origin()
	case slsaattestation.FieldCollector:
		return m.Collector()
	case slsaattestation.FieldBuiltFromHash:
		return m.BuiltFromHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SLSAAttestationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slsaattestation.FieldBuildType:
		return m.OldBuildType(ctx)
	case slsaattestation.FieldBuiltByID:
		return m.OldBuiltByID(ctx)
	case slsaattestation.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case slsaattestation.FieldSlsaPredicate:
		return m.OldSlsaPredicate(ctx)
	case slsaattestation.FieldSlsaVersion:
		return m.OldSlsaVersion(ctx)
	case slsaattestation.FieldStartedOn:
		return m.OldStartedOn(ctx)
	case slsaattestation.FieldFinishedOn:
		return m.OldFinishedOn(ctx)
	case slsaattestation.FieldOrigin:
		return m.OldOrigin(ctx)
	case slsaattestation.FieldCollector:
		return m.OldCollector(ctx)
	case slsaattestation.FieldBuiltFromHash:
		return m.OldBuiltFromHash(ctx)
	}
	return nil, fmt.Errorf("unknown SLSAAttestation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLSAAttestationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slsaattestation.FieldBuildType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildType(v)
		return nil
	case slsaattestation.FieldBuiltByID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltByID(v)
		return nil
	case slsaattestation.FieldSubjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case slsaattestation.FieldSlsaPredicate:
		v, ok := value.([]*model.SLSAPredicate)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlsaPredicate(v)
		return nil
	case slsaattestation.FieldSlsaVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlsaVersion(v)
		return nil
	case slsaattestation.FieldStartedOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedOn(v)
		return nil
	case slsaattestation.FieldFinishedOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedOn(v)
		return nil
	case slsaattestation.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case slsaattestation.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case slsaattestation.FieldBuiltFromHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltFromHash(v)
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SLSAAttestationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SLSAAttestationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLSAAttestationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SLSAAttestation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SLSAAttestationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(slsaattestation.FieldSlsaPredicate) {
		fields = append(fields, slsaattestation.FieldSlsaPredicate)
	}
	if m.FieldCleared(slsaattestation.FieldStartedOn) {
		fields = append(fields, slsaattestation.FieldStartedOn)
	}
	if m.FieldCleared(slsaattestation.FieldFinishedOn) {
		fields = append(fields, slsaattestation.FieldFinishedOn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SLSAAttestationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SLSAAttestationMutation) ClearField(name string) error {
	switch name {
	case slsaattestation.FieldSlsaPredicate:
		m.ClearSlsaPredicate()
		return nil
	case slsaattestation.FieldStartedOn:
		m.ClearStartedOn()
		return nil
	case slsaattestation.FieldFinishedOn:
		m.ClearFinishedOn()
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SLSAAttestationMutation) ResetField(name string) error {
	switch name {
	case slsaattestation.FieldBuildType:
		m.ResetBuildType()
		return nil
	case slsaattestation.FieldBuiltByID:
		m.ResetBuiltByID()
		return nil
	case slsaattestation.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case slsaattestation.FieldSlsaPredicate:
		m.ResetSlsaPredicate()
		return nil
	case slsaattestation.FieldSlsaVersion:
		m.ResetSlsaVersion()
		return nil
	case slsaattestation.FieldStartedOn:
		m.ResetStartedOn()
		return nil
	case slsaattestation.FieldFinishedOn:
		m.ResetFinishedOn()
		return nil
	case slsaattestation.FieldOrigin:
		m.ResetOrigin()
		return nil
	case slsaattestation.FieldCollector:
		m.ResetCollector()
		return nil
	case slsaattestation.FieldBuiltFromHash:
		m.ResetBuiltFromHash()
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SLSAAttestationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.built_from != nil {
		edges = append(edges, slsaattestation.EdgeBuiltFrom)
	}
	if m.built_by != nil {
		edges = append(edges, slsaattestation.EdgeBuiltBy)
	}
	if m.subject != nil {
		edges = append(edges, slsaattestation.EdgeSubject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SLSAAttestationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case slsaattestation.EdgeBuiltFrom:
		ids := make([]ent.Value, 0, len(m.built_from))
		for id := range m.built_from {
			ids = append(ids, id)
		}
		return ids
	case slsaattestation.EdgeBuiltBy:
		if id := m.built_by; id != nil {
			return []ent.Value{*id}
		}
	case slsaattestation.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SLSAAttestationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbuilt_from != nil {
		edges = append(edges, slsaattestation.EdgeBuiltFrom)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SLSAAttestationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case slsaattestation.EdgeBuiltFrom:
		ids := make([]ent.Value, 0, len(m.removedbuilt_from))
		for id := range m.removedbuilt_from {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SLSAAttestationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbuilt_from {
		edges = append(edges, slsaattestation.EdgeBuiltFrom)
	}
	if m.clearedbuilt_by {
		edges = append(edges, slsaattestation.EdgeBuiltBy)
	}
	if m.clearedsubject {
		edges = append(edges, slsaattestation.EdgeSubject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SLSAAttestationMutation) EdgeCleared(name string) bool {
	switch name {
	case slsaattestation.EdgeBuiltFrom:
		return m.clearedbuilt_from
	case slsaattestation.EdgeBuiltBy:
		return m.clearedbuilt_by
	case slsaattestation.EdgeSubject:
		return m.clearedsubject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SLSAAttestationMutation) ClearEdge(name string) error {
	switch name {
	case slsaattestation.EdgeBuiltBy:
		m.ClearBuiltBy()
		return nil
	case slsaattestation.EdgeSubject:
		m.ClearSubject()
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SLSAAttestationMutation) ResetEdge(name string) error {
	switch name {
	case slsaattestation.EdgeBuiltFrom:
		m.ResetBuiltFrom()
		return nil
	case slsaattestation.EdgeBuiltBy:
		m.ResetBuiltBy()
		return nil
	case slsaattestation.EdgeSubject:
		m.ResetSubject()
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation edge %s", name)
}

// SecurityAdvisoryMutation represents an operation that mutates the SecurityAdvisory nodes in the graph.
type SecurityAdvisoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	ghsa_id       *string
	cve_id        *string
	cve_year      *int
	addcve_year   *int
	osv_id        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SecurityAdvisory, error)
	predicates    []predicate.SecurityAdvisory
}

var _ ent.Mutation = (*SecurityAdvisoryMutation)(nil)

// securityadvisoryOption allows management of the mutation configuration using functional options.
type securityadvisoryOption func(*SecurityAdvisoryMutation)

// newSecurityAdvisoryMutation creates new mutation for the SecurityAdvisory entity.
func newSecurityAdvisoryMutation(c config, op Op, opts ...securityadvisoryOption) *SecurityAdvisoryMutation {
	m := &SecurityAdvisoryMutation{
		config:        c,
		op:            op,
		typ:           TypeSecurityAdvisory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSecurityAdvisoryID sets the ID field of the mutation.
func withSecurityAdvisoryID(id int) securityadvisoryOption {
	return func(m *SecurityAdvisoryMutation) {
		var (
			err   error
			once  sync.Once
			value *SecurityAdvisory
		)
		m.oldValue = func(ctx context.Context) (*SecurityAdvisory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SecurityAdvisory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSecurityAdvisory sets the old SecurityAdvisory of the mutation.
func withSecurityAdvisory(node *SecurityAdvisory) securityadvisoryOption {
	return func(m *SecurityAdvisoryMutation) {
		m.oldValue = func(context.Context) (*SecurityAdvisory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SecurityAdvisoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SecurityAdvisoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SecurityAdvisoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SecurityAdvisoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SecurityAdvisory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGhsaID sets the "ghsa_id" field.
func (m *SecurityAdvisoryMutation) SetGhsaID(s string) {
	m.ghsa_id = &s
}

// GhsaID returns the value of the "ghsa_id" field in the mutation.
func (m *SecurityAdvisoryMutation) GhsaID() (r string, exists bool) {
	v := m.ghsa_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGhsaID returns the old "ghsa_id" field's value of the SecurityAdvisory entity.
// If the SecurityAdvisory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityAdvisoryMutation) OldGhsaID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGhsaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGhsaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGhsaID: %w", err)
	}
	return oldValue.GhsaID, nil
}

// ClearGhsaID clears the value of the "ghsa_id" field.
func (m *SecurityAdvisoryMutation) ClearGhsaID() {
	m.ghsa_id = nil
	m.clearedFields[securityadvisory.FieldGhsaID] = struct{}{}
}

// GhsaIDCleared returns if the "ghsa_id" field was cleared in this mutation.
func (m *SecurityAdvisoryMutation) GhsaIDCleared() bool {
	_, ok := m.clearedFields[securityadvisory.FieldGhsaID]
	return ok
}

// ResetGhsaID resets all changes to the "ghsa_id" field.
func (m *SecurityAdvisoryMutation) ResetGhsaID() {
	m.ghsa_id = nil
	delete(m.clearedFields, securityadvisory.FieldGhsaID)
}

// SetCveID sets the "cve_id" field.
func (m *SecurityAdvisoryMutation) SetCveID(s string) {
	m.cve_id = &s
}

// CveID returns the value of the "cve_id" field in the mutation.
func (m *SecurityAdvisoryMutation) CveID() (r string, exists bool) {
	v := m.cve_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCveID returns the old "cve_id" field's value of the SecurityAdvisory entity.
// If the SecurityAdvisory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityAdvisoryMutation) OldCveID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCveID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCveID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCveID: %w", err)
	}
	return oldValue.CveID, nil
}

// ClearCveID clears the value of the "cve_id" field.
func (m *SecurityAdvisoryMutation) ClearCveID() {
	m.cve_id = nil
	m.clearedFields[securityadvisory.FieldCveID] = struct{}{}
}

// CveIDCleared returns if the "cve_id" field was cleared in this mutation.
func (m *SecurityAdvisoryMutation) CveIDCleared() bool {
	_, ok := m.clearedFields[securityadvisory.FieldCveID]
	return ok
}

// ResetCveID resets all changes to the "cve_id" field.
func (m *SecurityAdvisoryMutation) ResetCveID() {
	m.cve_id = nil
	delete(m.clearedFields, securityadvisory.FieldCveID)
}

// SetCveYear sets the "cve_year" field.
func (m *SecurityAdvisoryMutation) SetCveYear(i int) {
	m.cve_year = &i
	m.addcve_year = nil
}

// CveYear returns the value of the "cve_year" field in the mutation.
func (m *SecurityAdvisoryMutation) CveYear() (r int, exists bool) {
	v := m.cve_year
	if v == nil {
		return
	}
	return *v, true
}

// OldCveYear returns the old "cve_year" field's value of the SecurityAdvisory entity.
// If the SecurityAdvisory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityAdvisoryMutation) OldCveYear(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCveYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCveYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCveYear: %w", err)
	}
	return oldValue.CveYear, nil
}

// AddCveYear adds i to the "cve_year" field.
func (m *SecurityAdvisoryMutation) AddCveYear(i int) {
	if m.addcve_year != nil {
		*m.addcve_year += i
	} else {
		m.addcve_year = &i
	}
}

// AddedCveYear returns the value that was added to the "cve_year" field in this mutation.
func (m *SecurityAdvisoryMutation) AddedCveYear() (r int, exists bool) {
	v := m.addcve_year
	if v == nil {
		return
	}
	return *v, true
}

// ClearCveYear clears the value of the "cve_year" field.
func (m *SecurityAdvisoryMutation) ClearCveYear() {
	m.cve_year = nil
	m.addcve_year = nil
	m.clearedFields[securityadvisory.FieldCveYear] = struct{}{}
}

// CveYearCleared returns if the "cve_year" field was cleared in this mutation.
func (m *SecurityAdvisoryMutation) CveYearCleared() bool {
	_, ok := m.clearedFields[securityadvisory.FieldCveYear]
	return ok
}

// ResetCveYear resets all changes to the "cve_year" field.
func (m *SecurityAdvisoryMutation) ResetCveYear() {
	m.cve_year = nil
	m.addcve_year = nil
	delete(m.clearedFields, securityadvisory.FieldCveYear)
}

// SetOsvID sets the "osv_id" field.
func (m *SecurityAdvisoryMutation) SetOsvID(s string) {
	m.osv_id = &s
}

// OsvID returns the value of the "osv_id" field in the mutation.
func (m *SecurityAdvisoryMutation) OsvID() (r string, exists bool) {
	v := m.osv_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOsvID returns the old "osv_id" field's value of the SecurityAdvisory entity.
// If the SecurityAdvisory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityAdvisoryMutation) OldOsvID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsvID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsvID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsvID: %w", err)
	}
	return oldValue.OsvID, nil
}

// ClearOsvID clears the value of the "osv_id" field.
func (m *SecurityAdvisoryMutation) ClearOsvID() {
	m.osv_id = nil
	m.clearedFields[securityadvisory.FieldOsvID] = struct{}{}
}

// OsvIDCleared returns if the "osv_id" field was cleared in this mutation.
func (m *SecurityAdvisoryMutation) OsvIDCleared() bool {
	_, ok := m.clearedFields[securityadvisory.FieldOsvID]
	return ok
}

// ResetOsvID resets all changes to the "osv_id" field.
func (m *SecurityAdvisoryMutation) ResetOsvID() {
	m.osv_id = nil
	delete(m.clearedFields, securityadvisory.FieldOsvID)
}

// Where appends a list predicates to the SecurityAdvisoryMutation builder.
func (m *SecurityAdvisoryMutation) Where(ps ...predicate.SecurityAdvisory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SecurityAdvisoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SecurityAdvisoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SecurityAdvisory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SecurityAdvisoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SecurityAdvisoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SecurityAdvisory).
func (m *SecurityAdvisoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SecurityAdvisoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.ghsa_id != nil {
		fields = append(fields, securityadvisory.FieldGhsaID)
	}
	if m.cve_id != nil {
		fields = append(fields, securityadvisory.FieldCveID)
	}
	if m.cve_year != nil {
		fields = append(fields, securityadvisory.FieldCveYear)
	}
	if m.osv_id != nil {
		fields = append(fields, securityadvisory.FieldOsvID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SecurityAdvisoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case securityadvisory.FieldGhsaID:
		return m.GhsaID()
	case securityadvisory.FieldCveID:
		return m.CveID()
	case securityadvisory.FieldCveYear:
		return m.CveYear()
	case securityadvisory.FieldOsvID:
		return m.OsvID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SecurityAdvisoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case securityadvisory.FieldGhsaID:
		return m.OldGhsaID(ctx)
	case securityadvisory.FieldCveID:
		return m.OldCveID(ctx)
	case securityadvisory.FieldCveYear:
		return m.OldCveYear(ctx)
	case securityadvisory.FieldOsvID:
		return m.OldOsvID(ctx)
	}
	return nil, fmt.Errorf("unknown SecurityAdvisory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityAdvisoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case securityadvisory.FieldGhsaID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGhsaID(v)
		return nil
	case securityadvisory.FieldCveID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCveID(v)
		return nil
	case securityadvisory.FieldCveYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCveYear(v)
		return nil
	case securityadvisory.FieldOsvID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsvID(v)
		return nil
	}
	return fmt.Errorf("unknown SecurityAdvisory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SecurityAdvisoryMutation) AddedFields() []string {
	var fields []string
	if m.addcve_year != nil {
		fields = append(fields, securityadvisory.FieldCveYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SecurityAdvisoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case securityadvisory.FieldCveYear:
		return m.AddedCveYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityAdvisoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case securityadvisory.FieldCveYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCveYear(v)
		return nil
	}
	return fmt.Errorf("unknown SecurityAdvisory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SecurityAdvisoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(securityadvisory.FieldGhsaID) {
		fields = append(fields, securityadvisory.FieldGhsaID)
	}
	if m.FieldCleared(securityadvisory.FieldCveID) {
		fields = append(fields, securityadvisory.FieldCveID)
	}
	if m.FieldCleared(securityadvisory.FieldCveYear) {
		fields = append(fields, securityadvisory.FieldCveYear)
	}
	if m.FieldCleared(securityadvisory.FieldOsvID) {
		fields = append(fields, securityadvisory.FieldOsvID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SecurityAdvisoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SecurityAdvisoryMutation) ClearField(name string) error {
	switch name {
	case securityadvisory.FieldGhsaID:
		m.ClearGhsaID()
		return nil
	case securityadvisory.FieldCveID:
		m.ClearCveID()
		return nil
	case securityadvisory.FieldCveYear:
		m.ClearCveYear()
		return nil
	case securityadvisory.FieldOsvID:
		m.ClearOsvID()
		return nil
	}
	return fmt.Errorf("unknown SecurityAdvisory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SecurityAdvisoryMutation) ResetField(name string) error {
	switch name {
	case securityadvisory.FieldGhsaID:
		m.ResetGhsaID()
		return nil
	case securityadvisory.FieldCveID:
		m.ResetCveID()
		return nil
	case securityadvisory.FieldCveYear:
		m.ResetCveYear()
		return nil
	case securityadvisory.FieldOsvID:
		m.ResetOsvID()
		return nil
	}
	return fmt.Errorf("unknown SecurityAdvisory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SecurityAdvisoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SecurityAdvisoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SecurityAdvisoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SecurityAdvisoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SecurityAdvisoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SecurityAdvisoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SecurityAdvisoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SecurityAdvisory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SecurityAdvisoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SecurityAdvisory edge %s", name)
}

// SourceNameMutation represents an operation that mutates the SourceName nodes in the graph.
type SourceNameMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	commit             *string
	tag                *string
	clearedFields      map[string]struct{}
	namespace          *int
	clearednamespace   bool
	occurrences        map[int]struct{}
	removedoccurrences map[int]struct{}
	clearedoccurrences bool
	done               bool
	oldValue           func(context.Context) (*SourceName, error)
	predicates         []predicate.SourceName
}

var _ ent.Mutation = (*SourceNameMutation)(nil)

// sourcenameOption allows management of the mutation configuration using functional options.
type sourcenameOption func(*SourceNameMutation)

// newSourceNameMutation creates new mutation for the SourceName entity.
func newSourceNameMutation(c config, op Op, opts ...sourcenameOption) *SourceNameMutation {
	m := &SourceNameMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceName,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceNameID sets the ID field of the mutation.
func withSourceNameID(id int) sourcenameOption {
	return func(m *SourceNameMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceName
		)
		m.oldValue = func(ctx context.Context) (*SourceName, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceName.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceName sets the old SourceName of the mutation.
func withSourceName(node *SourceName) sourcenameOption {
	return func(m *SourceNameMutation) {
		m.oldValue = func(context.Context) (*SourceName, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceNameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceNameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceNameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceNameMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceName.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SourceNameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SourceNameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SourceNameMutation) ResetName() {
	m.name = nil
}

// SetCommit sets the "commit" field.
func (m *SourceNameMutation) SetCommit(s string) {
	m.commit = &s
}

// Commit returns the value of the "commit" field in the mutation.
func (m *SourceNameMutation) Commit() (r string, exists bool) {
	v := m.commit
	if v == nil {
		return
	}
	return *v, true
}

// OldCommit returns the old "commit" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldCommit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommit: %w", err)
	}
	return oldValue.Commit, nil
}

// ClearCommit clears the value of the "commit" field.
func (m *SourceNameMutation) ClearCommit() {
	m.commit = nil
	m.clearedFields[sourcename.FieldCommit] = struct{}{}
}

// CommitCleared returns if the "commit" field was cleared in this mutation.
func (m *SourceNameMutation) CommitCleared() bool {
	_, ok := m.clearedFields[sourcename.FieldCommit]
	return ok
}

// ResetCommit resets all changes to the "commit" field.
func (m *SourceNameMutation) ResetCommit() {
	m.commit = nil
	delete(m.clearedFields, sourcename.FieldCommit)
}

// SetTag sets the "tag" field.
func (m *SourceNameMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *SourceNameMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ClearTag clears the value of the "tag" field.
func (m *SourceNameMutation) ClearTag() {
	m.tag = nil
	m.clearedFields[sourcename.FieldTag] = struct{}{}
}

// TagCleared returns if the "tag" field was cleared in this mutation.
func (m *SourceNameMutation) TagCleared() bool {
	_, ok := m.clearedFields[sourcename.FieldTag]
	return ok
}

// ResetTag resets all changes to the "tag" field.
func (m *SourceNameMutation) ResetTag() {
	m.tag = nil
	delete(m.clearedFields, sourcename.FieldTag)
}

// SetNamespaceID sets the "namespace_id" field.
func (m *SourceNameMutation) SetNamespaceID(i int) {
	m.namespace = &i
}

// NamespaceID returns the value of the "namespace_id" field in the mutation.
func (m *SourceNameMutation) NamespaceID() (r int, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespaceID returns the old "namespace_id" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldNamespaceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespaceID: %w", err)
	}
	return oldValue.NamespaceID, nil
}

// ResetNamespaceID resets all changes to the "namespace_id" field.
func (m *SourceNameMutation) ResetNamespaceID() {
	m.namespace = nil
}

// ClearNamespace clears the "namespace" edge to the SourceNamespace entity.
func (m *SourceNameMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the SourceNamespace entity was cleared.
func (m *SourceNameMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *SourceNameMutation) NamespaceIDs() (ids []int) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *SourceNameMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by ids.
func (m *SourceNameMutation) AddOccurrenceIDs(ids ...int) {
	if m.occurrences == nil {
		m.occurrences = make(map[int]struct{})
	}
	for i := range ids {
		m.occurrences[ids[i]] = struct{}{}
	}
}

// ClearOccurrences clears the "occurrences" edge to the Occurrence entity.
func (m *SourceNameMutation) ClearOccurrences() {
	m.clearedoccurrences = true
}

// OccurrencesCleared reports if the "occurrences" edge to the Occurrence entity was cleared.
func (m *SourceNameMutation) OccurrencesCleared() bool {
	return m.clearedoccurrences
}

// RemoveOccurrenceIDs removes the "occurrences" edge to the Occurrence entity by IDs.
func (m *SourceNameMutation) RemoveOccurrenceIDs(ids ...int) {
	if m.removedoccurrences == nil {
		m.removedoccurrences = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occurrences, ids[i])
		m.removedoccurrences[ids[i]] = struct{}{}
	}
}

// RemovedOccurrences returns the removed IDs of the "occurrences" edge to the Occurrence entity.
func (m *SourceNameMutation) RemovedOccurrencesIDs() (ids []int) {
	for id := range m.removedoccurrences {
		ids = append(ids, id)
	}
	return
}

// OccurrencesIDs returns the "occurrences" edge IDs in the mutation.
func (m *SourceNameMutation) OccurrencesIDs() (ids []int) {
	for id := range m.occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetOccurrences resets all changes to the "occurrences" edge.
func (m *SourceNameMutation) ResetOccurrences() {
	m.occurrences = nil
	m.clearedoccurrences = false
	m.removedoccurrences = nil
}

// Where appends a list predicates to the SourceNameMutation builder.
func (m *SourceNameMutation) Where(ps ...predicate.SourceName) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceNameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceNameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceName, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceNameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceNameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceName).
func (m *SourceNameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceNameMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, sourcename.FieldName)
	}
	if m.commit != nil {
		fields = append(fields, sourcename.FieldCommit)
	}
	if m.tag != nil {
		fields = append(fields, sourcename.FieldTag)
	}
	if m.namespace != nil {
		fields = append(fields, sourcename.FieldNamespaceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceNameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcename.FieldName:
		return m.Name()
	case sourcename.FieldCommit:
		return m.Commit()
	case sourcename.FieldTag:
		return m.Tag()
	case sourcename.FieldNamespaceID:
		return m.NamespaceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceNameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcename.FieldName:
		return m.OldName(ctx)
	case sourcename.FieldCommit:
		return m.OldCommit(ctx)
	case sourcename.FieldTag:
		return m.OldTag(ctx)
	case sourcename.FieldNamespaceID:
		return m.OldNamespaceID(ctx)
	}
	return nil, fmt.Errorf("unknown SourceName field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcename.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sourcename.FieldCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommit(v)
		return nil
	case sourcename.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case sourcename.FieldNamespaceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespaceID(v)
		return nil
	}
	return fmt.Errorf("unknown SourceName field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceNameMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceNameMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceName numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceNameMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sourcename.FieldCommit) {
		fields = append(fields, sourcename.FieldCommit)
	}
	if m.FieldCleared(sourcename.FieldTag) {
		fields = append(fields, sourcename.FieldTag)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceNameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceNameMutation) ClearField(name string) error {
	switch name {
	case sourcename.FieldCommit:
		m.ClearCommit()
		return nil
	case sourcename.FieldTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown SourceName nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceNameMutation) ResetField(name string) error {
	switch name {
	case sourcename.FieldName:
		m.ResetName()
		return nil
	case sourcename.FieldCommit:
		m.ResetCommit()
		return nil
	case sourcename.FieldTag:
		m.ResetTag()
		return nil
	case sourcename.FieldNamespaceID:
		m.ResetNamespaceID()
		return nil
	}
	return fmt.Errorf("unknown SourceName field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceNameMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.namespace != nil {
		edges = append(edges, sourcename.EdgeNamespace)
	}
	if m.occurrences != nil {
		edges = append(edges, sourcename.EdgeOccurrences)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceNameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourcename.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case sourcename.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.occurrences))
		for id := range m.occurrences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceNameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoccurrences != nil {
		edges = append(edges, sourcename.EdgeOccurrences)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceNameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sourcename.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.removedoccurrences))
		for id := range m.removedoccurrences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceNameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednamespace {
		edges = append(edges, sourcename.EdgeNamespace)
	}
	if m.clearedoccurrences {
		edges = append(edges, sourcename.EdgeOccurrences)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceNameMutation) EdgeCleared(name string) bool {
	switch name {
	case sourcename.EdgeNamespace:
		return m.clearednamespace
	case sourcename.EdgeOccurrences:
		return m.clearedoccurrences
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceNameMutation) ClearEdge(name string) error {
	switch name {
	case sourcename.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown SourceName unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceNameMutation) ResetEdge(name string) error {
	switch name {
	case sourcename.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case sourcename.EdgeOccurrences:
		m.ResetOccurrences()
		return nil
	}
	return fmt.Errorf("unknown SourceName edge %s", name)
}

// SourceNamespaceMutation represents an operation that mutates the SourceNamespace nodes in the graph.
type SourceNamespaceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	namespace          *string
	clearedFields      map[string]struct{}
	source_type        *int
	clearedsource_type bool
	names              map[int]struct{}
	removednames       map[int]struct{}
	clearednames       bool
	done               bool
	oldValue           func(context.Context) (*SourceNamespace, error)
	predicates         []predicate.SourceNamespace
}

var _ ent.Mutation = (*SourceNamespaceMutation)(nil)

// sourcenamespaceOption allows management of the mutation configuration using functional options.
type sourcenamespaceOption func(*SourceNamespaceMutation)

// newSourceNamespaceMutation creates new mutation for the SourceNamespace entity.
func newSourceNamespaceMutation(c config, op Op, opts ...sourcenamespaceOption) *SourceNamespaceMutation {
	m := &SourceNamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceNamespaceID sets the ID field of the mutation.
func withSourceNamespaceID(id int) sourcenamespaceOption {
	return func(m *SourceNamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceNamespace
		)
		m.oldValue = func(ctx context.Context) (*SourceNamespace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceNamespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceNamespace sets the old SourceNamespace of the mutation.
func withSourceNamespace(node *SourceNamespace) sourcenamespaceOption {
	return func(m *SourceNamespaceMutation) {
		m.oldValue = func(context.Context) (*SourceNamespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceNamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceNamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceNamespaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceNamespaceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceNamespace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SourceNamespaceMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SourceNamespaceMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the SourceNamespace entity.
// If the SourceNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNamespaceMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SourceNamespaceMutation) ResetNamespace() {
	m.namespace = nil
}

// SetSourceID sets the "source_id" field.
func (m *SourceNamespaceMutation) SetSourceID(i int) {
	m.source_type = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *SourceNamespaceMutation) SourceID() (r int, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the SourceNamespace entity.
// If the SourceNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNamespaceMutation) OldSourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *SourceNamespaceMutation) ResetSourceID() {
	m.source_type = nil
}

// SetSourceTypeID sets the "source_type" edge to the SourceType entity by id.
func (m *SourceNamespaceMutation) SetSourceTypeID(id int) {
	m.source_type = &id
}

// ClearSourceType clears the "source_type" edge to the SourceType entity.
func (m *SourceNamespaceMutation) ClearSourceType() {
	m.clearedsource_type = true
}

// SourceTypeCleared reports if the "source_type" edge to the SourceType entity was cleared.
func (m *SourceNamespaceMutation) SourceTypeCleared() bool {
	return m.clearedsource_type
}

// SourceTypeID returns the "source_type" edge ID in the mutation.
func (m *SourceNamespaceMutation) SourceTypeID() (id int, exists bool) {
	if m.source_type != nil {
		return *m.source_type, true
	}
	return
}

// SourceTypeIDs returns the "source_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceTypeID instead. It exists only for internal usage by the builders.
func (m *SourceNamespaceMutation) SourceTypeIDs() (ids []int) {
	if id := m.source_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceType resets all changes to the "source_type" edge.
func (m *SourceNamespaceMutation) ResetSourceType() {
	m.source_type = nil
	m.clearedsource_type = false
}

// AddNameIDs adds the "names" edge to the SourceName entity by ids.
func (m *SourceNamespaceMutation) AddNameIDs(ids ...int) {
	if m.names == nil {
		m.names = make(map[int]struct{})
	}
	for i := range ids {
		m.names[ids[i]] = struct{}{}
	}
}

// ClearNames clears the "names" edge to the SourceName entity.
func (m *SourceNamespaceMutation) ClearNames() {
	m.clearednames = true
}

// NamesCleared reports if the "names" edge to the SourceName entity was cleared.
func (m *SourceNamespaceMutation) NamesCleared() bool {
	return m.clearednames
}

// RemoveNameIDs removes the "names" edge to the SourceName entity by IDs.
func (m *SourceNamespaceMutation) RemoveNameIDs(ids ...int) {
	if m.removednames == nil {
		m.removednames = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.names, ids[i])
		m.removednames[ids[i]] = struct{}{}
	}
}

// RemovedNames returns the removed IDs of the "names" edge to the SourceName entity.
func (m *SourceNamespaceMutation) RemovedNamesIDs() (ids []int) {
	for id := range m.removednames {
		ids = append(ids, id)
	}
	return
}

// NamesIDs returns the "names" edge IDs in the mutation.
func (m *SourceNamespaceMutation) NamesIDs() (ids []int) {
	for id := range m.names {
		ids = append(ids, id)
	}
	return
}

// ResetNames resets all changes to the "names" edge.
func (m *SourceNamespaceMutation) ResetNames() {
	m.names = nil
	m.clearednames = false
	m.removednames = nil
}

// Where appends a list predicates to the SourceNamespaceMutation builder.
func (m *SourceNamespaceMutation) Where(ps ...predicate.SourceNamespace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceNamespaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceNamespaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceNamespace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceNamespaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceNamespaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceNamespace).
func (m *SourceNamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceNamespaceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.namespace != nil {
		fields = append(fields, sourcenamespace.FieldNamespace)
	}
	if m.source_type != nil {
		fields = append(fields, sourcenamespace.FieldSourceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceNamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcenamespace.FieldNamespace:
		return m.Namespace()
	case sourcenamespace.FieldSourceID:
		return m.SourceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceNamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcenamespace.FieldNamespace:
		return m.OldNamespace(ctx)
	case sourcenamespace.FieldSourceID:
		return m.OldSourceID(ctx)
	}
	return nil, fmt.Errorf("unknown SourceNamespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcenamespace.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case sourcenamespace.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	}
	return fmt.Errorf("unknown SourceNamespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceNamespaceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceNamespaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceNamespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceNamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceNamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceNamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SourceNamespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceNamespaceMutation) ResetField(name string) error {
	switch name {
	case sourcenamespace.FieldNamespace:
		m.ResetNamespace()
		return nil
	case sourcenamespace.FieldSourceID:
		m.ResetSourceID()
		return nil
	}
	return fmt.Errorf("unknown SourceNamespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceNamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.source_type != nil {
		edges = append(edges, sourcenamespace.EdgeSourceType)
	}
	if m.names != nil {
		edges = append(edges, sourcenamespace.EdgeNames)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceNamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourcenamespace.EdgeSourceType:
		if id := m.source_type; id != nil {
			return []ent.Value{*id}
		}
	case sourcenamespace.EdgeNames:
		ids := make([]ent.Value, 0, len(m.names))
		for id := range m.names {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceNamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednames != nil {
		edges = append(edges, sourcenamespace.EdgeNames)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceNamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sourcenamespace.EdgeNames:
		ids := make([]ent.Value, 0, len(m.removednames))
		for id := range m.removednames {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceNamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsource_type {
		edges = append(edges, sourcenamespace.EdgeSourceType)
	}
	if m.clearednames {
		edges = append(edges, sourcenamespace.EdgeNames)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceNamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case sourcenamespace.EdgeSourceType:
		return m.clearedsource_type
	case sourcenamespace.EdgeNames:
		return m.clearednames
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceNamespaceMutation) ClearEdge(name string) error {
	switch name {
	case sourcenamespace.EdgeSourceType:
		m.ClearSourceType()
		return nil
	}
	return fmt.Errorf("unknown SourceNamespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceNamespaceMutation) ResetEdge(name string) error {
	switch name {
	case sourcenamespace.EdgeSourceType:
		m.ResetSourceType()
		return nil
	case sourcenamespace.EdgeNames:
		m.ResetNames()
		return nil
	}
	return fmt.Errorf("unknown SourceNamespace edge %s", name)
}

// SourceTypeMutation represents an operation that mutates the SourceType nodes in the graph.
type SourceTypeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_type             *string
	clearedFields     map[string]struct{}
	namespaces        map[int]struct{}
	removednamespaces map[int]struct{}
	clearednamespaces bool
	done              bool
	oldValue          func(context.Context) (*SourceType, error)
	predicates        []predicate.SourceType
}

var _ ent.Mutation = (*SourceTypeMutation)(nil)

// sourcetypeOption allows management of the mutation configuration using functional options.
type sourcetypeOption func(*SourceTypeMutation)

// newSourceTypeMutation creates new mutation for the SourceType entity.
func newSourceTypeMutation(c config, op Op, opts ...sourcetypeOption) *SourceTypeMutation {
	m := &SourceTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceTypeID sets the ID field of the mutation.
func withSourceTypeID(id int) sourcetypeOption {
	return func(m *SourceTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceType
		)
		m.oldValue = func(ctx context.Context) (*SourceType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceType sets the old SourceType of the mutation.
func withSourceType(node *SourceType) sourcetypeOption {
	return func(m *SourceTypeMutation) {
		m.oldValue = func(context.Context) (*SourceType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *SourceTypeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SourceTypeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SourceType entity.
// If the SourceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceTypeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SourceTypeMutation) ResetType() {
	m._type = nil
}

// AddNamespaceIDs adds the "namespaces" edge to the SourceNamespace entity by ids.
func (m *SourceTypeMutation) AddNamespaceIDs(ids ...int) {
	if m.namespaces == nil {
		m.namespaces = make(map[int]struct{})
	}
	for i := range ids {
		m.namespaces[ids[i]] = struct{}{}
	}
}

// ClearNamespaces clears the "namespaces" edge to the SourceNamespace entity.
func (m *SourceTypeMutation) ClearNamespaces() {
	m.clearednamespaces = true
}

// NamespacesCleared reports if the "namespaces" edge to the SourceNamespace entity was cleared.
func (m *SourceTypeMutation) NamespacesCleared() bool {
	return m.clearednamespaces
}

// RemoveNamespaceIDs removes the "namespaces" edge to the SourceNamespace entity by IDs.
func (m *SourceTypeMutation) RemoveNamespaceIDs(ids ...int) {
	if m.removednamespaces == nil {
		m.removednamespaces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.namespaces, ids[i])
		m.removednamespaces[ids[i]] = struct{}{}
	}
}

// RemovedNamespaces returns the removed IDs of the "namespaces" edge to the SourceNamespace entity.
func (m *SourceTypeMutation) RemovedNamespacesIDs() (ids []int) {
	for id := range m.removednamespaces {
		ids = append(ids, id)
	}
	return
}

// NamespacesIDs returns the "namespaces" edge IDs in the mutation.
func (m *SourceTypeMutation) NamespacesIDs() (ids []int) {
	for id := range m.namespaces {
		ids = append(ids, id)
	}
	return
}

// ResetNamespaces resets all changes to the "namespaces" edge.
func (m *SourceTypeMutation) ResetNamespaces() {
	m.namespaces = nil
	m.clearednamespaces = false
	m.removednamespaces = nil
}

// Where appends a list predicates to the SourceTypeMutation builder.
func (m *SourceTypeMutation) Where(ps ...predicate.SourceType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceType).
func (m *SourceTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._type != nil {
		fields = append(fields, sourcetype.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcetype.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcetype.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown SourceType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcetype.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown SourceType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SourceType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceTypeMutation) ResetField(name string) error {
	switch name {
	case sourcetype.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown SourceType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespaces != nil {
		edges = append(edges, sourcetype.EdgeNamespaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourcetype.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.namespaces))
		for id := range m.namespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednamespaces != nil {
		edges = append(edges, sourcetype.EdgeNamespaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sourcetype.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.removednamespaces))
		for id := range m.removednamespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespaces {
		edges = append(edges, sourcetype.EdgeNamespaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case sourcetype.EdgeNamespaces:
		return m.clearednamespaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceTypeMutation) ResetEdge(name string) error {
	switch name {
	case sourcetype.EdgeNamespaces:
		m.ResetNamespaces()
		return nil
	}
	return fmt.Errorf("unknown SourceType edge %s", name)
}
