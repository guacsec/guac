// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/artifact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/billofmaterials"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/builder"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certification"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifylegal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyscorecard"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvex"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvuln"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/dependency"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hashequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hassourceat"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/isvulnerability"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/license"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/occurrence"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagetype"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pkgequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/predicate"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/scorecard"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/slsaattestation"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcetype"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilityid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilitytype"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArtifact          = "Artifact"
	TypeBillOfMaterials   = "BillOfMaterials"
	TypeBuilder           = "Builder"
	TypeCertification     = "Certification"
	TypeCertifyLegal      = "CertifyLegal"
	TypeCertifyScorecard  = "CertifyScorecard"
	TypeCertifyVex        = "CertifyVex"
	TypeCertifyVuln       = "CertifyVuln"
	TypeDependency        = "Dependency"
	TypeHasSourceAt       = "HasSourceAt"
	TypeHashEqual         = "HashEqual"
	TypeIsVulnerability   = "IsVulnerability"
	TypeLicense           = "License"
	TypeOccurrence        = "Occurrence"
	TypePackageName       = "PackageName"
	TypePackageNamespace  = "PackageNamespace"
	TypePackageType       = "PackageType"
	TypePackageVersion    = "PackageVersion"
	TypePkgEqual          = "PkgEqual"
	TypeSLSAAttestation   = "SLSAAttestation"
	TypeScorecard         = "Scorecard"
	TypeSourceName        = "SourceName"
	TypeSourceNamespace   = "SourceNamespace"
	TypeSourceType        = "SourceType"
	TypeVulnEqual         = "VulnEqual"
	TypeVulnerabilityID   = "VulnerabilityID"
	TypeVulnerabilityType = "VulnerabilityType"
)

// ArtifactMutation represents an operation that mutates the Artifact nodes in the graph.
type ArtifactMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	algorithm           *string
	digest              *string
	clearedFields       map[string]struct{}
	occurrences         map[int]struct{}
	removedoccurrences  map[int]struct{}
	clearedoccurrences  bool
	sbom                map[int]struct{}
	removedsbom         map[int]struct{}
	clearedsbom         bool
	attestations        map[int]struct{}
	removedattestations map[int]struct{}
	clearedattestations bool
	same                map[int]struct{}
	removedsame         map[int]struct{}
	clearedsame         bool
	done                bool
	oldValue            func(context.Context) (*Artifact, error)
	predicates          []predicate.Artifact
}

var _ ent.Mutation = (*ArtifactMutation)(nil)

// artifactOption allows management of the mutation configuration using functional options.
type artifactOption func(*ArtifactMutation)

// newArtifactMutation creates new mutation for the Artifact entity.
func newArtifactMutation(c config, op Op, opts ...artifactOption) *ArtifactMutation {
	m := &ArtifactMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactID sets the ID field of the mutation.
func withArtifactID(id int) artifactOption {
	return func(m *ArtifactMutation) {
		var (
			err   error
			once  sync.Once
			value *Artifact
		)
		m.oldValue = func(ctx context.Context) (*Artifact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artifact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifact sets the old Artifact of the mutation.
func withArtifact(node *Artifact) artifactOption {
	return func(m *ArtifactMutation) {
		m.oldValue = func(context.Context) (*Artifact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtifactMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artifact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlgorithm sets the "algorithm" field.
func (m *ArtifactMutation) SetAlgorithm(s string) {
	m.algorithm = &s
}

// Algorithm returns the value of the "algorithm" field in the mutation.
func (m *ArtifactMutation) Algorithm() (r string, exists bool) {
	v := m.algorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgorithm returns the old "algorithm" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldAlgorithm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgorithm: %w", err)
	}
	return oldValue.Algorithm, nil
}

// ResetAlgorithm resets all changes to the "algorithm" field.
func (m *ArtifactMutation) ResetAlgorithm() {
	m.algorithm = nil
}

// SetDigest sets the "digest" field.
func (m *ArtifactMutation) SetDigest(s string) {
	m.digest = &s
}

// Digest returns the value of the "digest" field in the mutation.
func (m *ArtifactMutation) Digest() (r string, exists bool) {
	v := m.digest
	if v == nil {
		return
	}
	return *v, true
}

// OldDigest returns the old "digest" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDigest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigest: %w", err)
	}
	return oldValue.Digest, nil
}

// ResetDigest resets all changes to the "digest" field.
func (m *ArtifactMutation) ResetDigest() {
	m.digest = nil
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by ids.
func (m *ArtifactMutation) AddOccurrenceIDs(ids ...int) {
	if m.occurrences == nil {
		m.occurrences = make(map[int]struct{})
	}
	for i := range ids {
		m.occurrences[ids[i]] = struct{}{}
	}
}

// ClearOccurrences clears the "occurrences" edge to the Occurrence entity.
func (m *ArtifactMutation) ClearOccurrences() {
	m.clearedoccurrences = true
}

// OccurrencesCleared reports if the "occurrences" edge to the Occurrence entity was cleared.
func (m *ArtifactMutation) OccurrencesCleared() bool {
	return m.clearedoccurrences
}

// RemoveOccurrenceIDs removes the "occurrences" edge to the Occurrence entity by IDs.
func (m *ArtifactMutation) RemoveOccurrenceIDs(ids ...int) {
	if m.removedoccurrences == nil {
		m.removedoccurrences = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occurrences, ids[i])
		m.removedoccurrences[ids[i]] = struct{}{}
	}
}

// RemovedOccurrences returns the removed IDs of the "occurrences" edge to the Occurrence entity.
func (m *ArtifactMutation) RemovedOccurrencesIDs() (ids []int) {
	for id := range m.removedoccurrences {
		ids = append(ids, id)
	}
	return
}

// OccurrencesIDs returns the "occurrences" edge IDs in the mutation.
func (m *ArtifactMutation) OccurrencesIDs() (ids []int) {
	for id := range m.occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetOccurrences resets all changes to the "occurrences" edge.
func (m *ArtifactMutation) ResetOccurrences() {
	m.occurrences = nil
	m.clearedoccurrences = false
	m.removedoccurrences = nil
}

// AddSbomIDs adds the "sbom" edge to the BillOfMaterials entity by ids.
func (m *ArtifactMutation) AddSbomIDs(ids ...int) {
	if m.sbom == nil {
		m.sbom = make(map[int]struct{})
	}
	for i := range ids {
		m.sbom[ids[i]] = struct{}{}
	}
}

// ClearSbom clears the "sbom" edge to the BillOfMaterials entity.
func (m *ArtifactMutation) ClearSbom() {
	m.clearedsbom = true
}

// SbomCleared reports if the "sbom" edge to the BillOfMaterials entity was cleared.
func (m *ArtifactMutation) SbomCleared() bool {
	return m.clearedsbom
}

// RemoveSbomIDs removes the "sbom" edge to the BillOfMaterials entity by IDs.
func (m *ArtifactMutation) RemoveSbomIDs(ids ...int) {
	if m.removedsbom == nil {
		m.removedsbom = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sbom, ids[i])
		m.removedsbom[ids[i]] = struct{}{}
	}
}

// RemovedSbom returns the removed IDs of the "sbom" edge to the BillOfMaterials entity.
func (m *ArtifactMutation) RemovedSbomIDs() (ids []int) {
	for id := range m.removedsbom {
		ids = append(ids, id)
	}
	return
}

// SbomIDs returns the "sbom" edge IDs in the mutation.
func (m *ArtifactMutation) SbomIDs() (ids []int) {
	for id := range m.sbom {
		ids = append(ids, id)
	}
	return
}

// ResetSbom resets all changes to the "sbom" edge.
func (m *ArtifactMutation) ResetSbom() {
	m.sbom = nil
	m.clearedsbom = false
	m.removedsbom = nil
}

// AddAttestationIDs adds the "attestations" edge to the SLSAAttestation entity by ids.
func (m *ArtifactMutation) AddAttestationIDs(ids ...int) {
	if m.attestations == nil {
		m.attestations = make(map[int]struct{})
	}
	for i := range ids {
		m.attestations[ids[i]] = struct{}{}
	}
}

// ClearAttestations clears the "attestations" edge to the SLSAAttestation entity.
func (m *ArtifactMutation) ClearAttestations() {
	m.clearedattestations = true
}

// AttestationsCleared reports if the "attestations" edge to the SLSAAttestation entity was cleared.
func (m *ArtifactMutation) AttestationsCleared() bool {
	return m.clearedattestations
}

// RemoveAttestationIDs removes the "attestations" edge to the SLSAAttestation entity by IDs.
func (m *ArtifactMutation) RemoveAttestationIDs(ids ...int) {
	if m.removedattestations == nil {
		m.removedattestations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attestations, ids[i])
		m.removedattestations[ids[i]] = struct{}{}
	}
}

// RemovedAttestations returns the removed IDs of the "attestations" edge to the SLSAAttestation entity.
func (m *ArtifactMutation) RemovedAttestationsIDs() (ids []int) {
	for id := range m.removedattestations {
		ids = append(ids, id)
	}
	return
}

// AttestationsIDs returns the "attestations" edge IDs in the mutation.
func (m *ArtifactMutation) AttestationsIDs() (ids []int) {
	for id := range m.attestations {
		ids = append(ids, id)
	}
	return
}

// ResetAttestations resets all changes to the "attestations" edge.
func (m *ArtifactMutation) ResetAttestations() {
	m.attestations = nil
	m.clearedattestations = false
	m.removedattestations = nil
}

// AddSameIDs adds the "same" edge to the HashEqual entity by ids.
func (m *ArtifactMutation) AddSameIDs(ids ...int) {
	if m.same == nil {
		m.same = make(map[int]struct{})
	}
	for i := range ids {
		m.same[ids[i]] = struct{}{}
	}
}

// ClearSame clears the "same" edge to the HashEqual entity.
func (m *ArtifactMutation) ClearSame() {
	m.clearedsame = true
}

// SameCleared reports if the "same" edge to the HashEqual entity was cleared.
func (m *ArtifactMutation) SameCleared() bool {
	return m.clearedsame
}

// RemoveSameIDs removes the "same" edge to the HashEqual entity by IDs.
func (m *ArtifactMutation) RemoveSameIDs(ids ...int) {
	if m.removedsame == nil {
		m.removedsame = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.same, ids[i])
		m.removedsame[ids[i]] = struct{}{}
	}
}

// RemovedSame returns the removed IDs of the "same" edge to the HashEqual entity.
func (m *ArtifactMutation) RemovedSameIDs() (ids []int) {
	for id := range m.removedsame {
		ids = append(ids, id)
	}
	return
}

// SameIDs returns the "same" edge IDs in the mutation.
func (m *ArtifactMutation) SameIDs() (ids []int) {
	for id := range m.same {
		ids = append(ids, id)
	}
	return
}

// ResetSame resets all changes to the "same" edge.
func (m *ArtifactMutation) ResetSame() {
	m.same = nil
	m.clearedsame = false
	m.removedsame = nil
}

// Where appends a list predicates to the ArtifactMutation builder.
func (m *ArtifactMutation) Where(ps ...predicate.Artifact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtifactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtifactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Artifact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtifactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtifactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Artifact).
func (m *ArtifactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.algorithm != nil {
		fields = append(fields, artifact.FieldAlgorithm)
	}
	if m.digest != nil {
		fields = append(fields, artifact.FieldDigest)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifact.FieldAlgorithm:
		return m.Algorithm()
	case artifact.FieldDigest:
		return m.Digest()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifact.FieldAlgorithm:
		return m.OldAlgorithm(ctx)
	case artifact.FieldDigest:
		return m.OldDigest(ctx)
	}
	return nil, fmt.Errorf("unknown Artifact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifact.FieldAlgorithm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgorithm(v)
		return nil
	case artifact.FieldDigest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigest(v)
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Artifact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactMutation) ResetField(name string) error {
	switch name {
	case artifact.FieldAlgorithm:
		m.ResetAlgorithm()
		return nil
	case artifact.FieldDigest:
		m.ResetDigest()
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.occurrences != nil {
		edges = append(edges, artifact.EdgeOccurrences)
	}
	if m.sbom != nil {
		edges = append(edges, artifact.EdgeSbom)
	}
	if m.attestations != nil {
		edges = append(edges, artifact.EdgeAttestations)
	}
	if m.same != nil {
		edges = append(edges, artifact.EdgeSame)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.occurrences))
		for id := range m.occurrences {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeSbom:
		ids := make([]ent.Value, 0, len(m.sbom))
		for id := range m.sbom {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeAttestations:
		ids := make([]ent.Value, 0, len(m.attestations))
		for id := range m.attestations {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeSame:
		ids := make([]ent.Value, 0, len(m.same))
		for id := range m.same {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedoccurrences != nil {
		edges = append(edges, artifact.EdgeOccurrences)
	}
	if m.removedsbom != nil {
		edges = append(edges, artifact.EdgeSbom)
	}
	if m.removedattestations != nil {
		edges = append(edges, artifact.EdgeAttestations)
	}
	if m.removedsame != nil {
		edges = append(edges, artifact.EdgeSame)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.removedoccurrences))
		for id := range m.removedoccurrences {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeSbom:
		ids := make([]ent.Value, 0, len(m.removedsbom))
		for id := range m.removedsbom {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeAttestations:
		ids := make([]ent.Value, 0, len(m.removedattestations))
		for id := range m.removedattestations {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeSame:
		ids := make([]ent.Value, 0, len(m.removedsame))
		for id := range m.removedsame {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedoccurrences {
		edges = append(edges, artifact.EdgeOccurrences)
	}
	if m.clearedsbom {
		edges = append(edges, artifact.EdgeSbom)
	}
	if m.clearedattestations {
		edges = append(edges, artifact.EdgeAttestations)
	}
	if m.clearedsame {
		edges = append(edges, artifact.EdgeSame)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactMutation) EdgeCleared(name string) bool {
	switch name {
	case artifact.EdgeOccurrences:
		return m.clearedoccurrences
	case artifact.EdgeSbom:
		return m.clearedsbom
	case artifact.EdgeAttestations:
		return m.clearedattestations
	case artifact.EdgeSame:
		return m.clearedsame
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactMutation) ResetEdge(name string) error {
	switch name {
	case artifact.EdgeOccurrences:
		m.ResetOccurrences()
		return nil
	case artifact.EdgeSbom:
		m.ResetSbom()
		return nil
	case artifact.EdgeAttestations:
		m.ResetAttestations()
		return nil
	case artifact.EdgeSame:
		m.ResetSame()
		return nil
	}
	return fmt.Errorf("unknown Artifact edge %s", name)
}

// BillOfMaterialsMutation represents an operation that mutates the BillOfMaterials nodes in the graph.
type BillOfMaterialsMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uri               *string
	algorithm         *string
	digest            *string
	download_location *string
	origin            *string
	collector         *string
	clearedFields     map[string]struct{}
	_package          *int
	cleared_package   bool
	artifact          *int
	clearedartifact   bool
	done              bool
	oldValue          func(context.Context) (*BillOfMaterials, error)
	predicates        []predicate.BillOfMaterials
}

var _ ent.Mutation = (*BillOfMaterialsMutation)(nil)

// billofmaterialsOption allows management of the mutation configuration using functional options.
type billofmaterialsOption func(*BillOfMaterialsMutation)

// newBillOfMaterialsMutation creates new mutation for the BillOfMaterials entity.
func newBillOfMaterialsMutation(c config, op Op, opts ...billofmaterialsOption) *BillOfMaterialsMutation {
	m := &BillOfMaterialsMutation{
		config:        c,
		op:            op,
		typ:           TypeBillOfMaterials,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillOfMaterialsID sets the ID field of the mutation.
func withBillOfMaterialsID(id int) billofmaterialsOption {
	return func(m *BillOfMaterialsMutation) {
		var (
			err   error
			once  sync.Once
			value *BillOfMaterials
		)
		m.oldValue = func(ctx context.Context) (*BillOfMaterials, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillOfMaterials.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillOfMaterials sets the old BillOfMaterials of the mutation.
func withBillOfMaterials(node *BillOfMaterials) billofmaterialsOption {
	return func(m *BillOfMaterialsMutation) {
		m.oldValue = func(context.Context) (*BillOfMaterials, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillOfMaterialsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillOfMaterialsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillOfMaterialsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillOfMaterialsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillOfMaterials.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *BillOfMaterialsMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *BillOfMaterialsMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldPackageID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *BillOfMaterialsMutation) ClearPackageID() {
	m._package = nil
	m.clearedFields[billofmaterials.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *BillOfMaterialsMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[billofmaterials.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *BillOfMaterialsMutation) ResetPackageID() {
	m._package = nil
	delete(m.clearedFields, billofmaterials.FieldPackageID)
}

// SetArtifactID sets the "artifact_id" field.
func (m *BillOfMaterialsMutation) SetArtifactID(i int) {
	m.artifact = &i
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *BillOfMaterialsMutation) ArtifactID() (r int, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldArtifactID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ClearArtifactID clears the value of the "artifact_id" field.
func (m *BillOfMaterialsMutation) ClearArtifactID() {
	m.artifact = nil
	m.clearedFields[billofmaterials.FieldArtifactID] = struct{}{}
}

// ArtifactIDCleared returns if the "artifact_id" field was cleared in this mutation.
func (m *BillOfMaterialsMutation) ArtifactIDCleared() bool {
	_, ok := m.clearedFields[billofmaterials.FieldArtifactID]
	return ok
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *BillOfMaterialsMutation) ResetArtifactID() {
	m.artifact = nil
	delete(m.clearedFields, billofmaterials.FieldArtifactID)
}

// SetURI sets the "uri" field.
func (m *BillOfMaterialsMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *BillOfMaterialsMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *BillOfMaterialsMutation) ResetURI() {
	m.uri = nil
}

// SetAlgorithm sets the "algorithm" field.
func (m *BillOfMaterialsMutation) SetAlgorithm(s string) {
	m.algorithm = &s
}

// Algorithm returns the value of the "algorithm" field in the mutation.
func (m *BillOfMaterialsMutation) Algorithm() (r string, exists bool) {
	v := m.algorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgorithm returns the old "algorithm" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldAlgorithm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgorithm: %w", err)
	}
	return oldValue.Algorithm, nil
}

// ResetAlgorithm resets all changes to the "algorithm" field.
func (m *BillOfMaterialsMutation) ResetAlgorithm() {
	m.algorithm = nil
}

// SetDigest sets the "digest" field.
func (m *BillOfMaterialsMutation) SetDigest(s string) {
	m.digest = &s
}

// Digest returns the value of the "digest" field in the mutation.
func (m *BillOfMaterialsMutation) Digest() (r string, exists bool) {
	v := m.digest
	if v == nil {
		return
	}
	return *v, true
}

// OldDigest returns the old "digest" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldDigest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigest: %w", err)
	}
	return oldValue.Digest, nil
}

// ResetDigest resets all changes to the "digest" field.
func (m *BillOfMaterialsMutation) ResetDigest() {
	m.digest = nil
}

// SetDownloadLocation sets the "download_location" field.
func (m *BillOfMaterialsMutation) SetDownloadLocation(s string) {
	m.download_location = &s
}

// DownloadLocation returns the value of the "download_location" field in the mutation.
func (m *BillOfMaterialsMutation) DownloadLocation() (r string, exists bool) {
	v := m.download_location
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadLocation returns the old "download_location" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldDownloadLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadLocation: %w", err)
	}
	return oldValue.DownloadLocation, nil
}

// ResetDownloadLocation resets all changes to the "download_location" field.
func (m *BillOfMaterialsMutation) ResetDownloadLocation() {
	m.download_location = nil
}

// SetOrigin sets the "origin" field.
func (m *BillOfMaterialsMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *BillOfMaterialsMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *BillOfMaterialsMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *BillOfMaterialsMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *BillOfMaterialsMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the BillOfMaterials entity.
// If the BillOfMaterials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillOfMaterialsMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *BillOfMaterialsMutation) ResetCollector() {
	m.collector = nil
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *BillOfMaterialsMutation) ClearPackage() {
	m.cleared_package = true
	m.clearedFields[billofmaterials.FieldPackageID] = struct{}{}
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *BillOfMaterialsMutation) PackageCleared() bool {
	return m.PackageIDCleared() || m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *BillOfMaterialsMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *BillOfMaterialsMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *BillOfMaterialsMutation) ClearArtifact() {
	m.clearedartifact = true
	m.clearedFields[billofmaterials.FieldArtifactID] = struct{}{}
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *BillOfMaterialsMutation) ArtifactCleared() bool {
	return m.ArtifactIDCleared() || m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *BillOfMaterialsMutation) ArtifactIDs() (ids []int) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *BillOfMaterialsMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// Where appends a list predicates to the BillOfMaterialsMutation builder.
func (m *BillOfMaterialsMutation) Where(ps ...predicate.BillOfMaterials) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillOfMaterialsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillOfMaterialsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillOfMaterials, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillOfMaterialsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillOfMaterialsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillOfMaterials).
func (m *BillOfMaterialsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillOfMaterialsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._package != nil {
		fields = append(fields, billofmaterials.FieldPackageID)
	}
	if m.artifact != nil {
		fields = append(fields, billofmaterials.FieldArtifactID)
	}
	if m.uri != nil {
		fields = append(fields, billofmaterials.FieldURI)
	}
	if m.algorithm != nil {
		fields = append(fields, billofmaterials.FieldAlgorithm)
	}
	if m.digest != nil {
		fields = append(fields, billofmaterials.FieldDigest)
	}
	if m.download_location != nil {
		fields = append(fields, billofmaterials.FieldDownloadLocation)
	}
	if m.origin != nil {
		fields = append(fields, billofmaterials.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, billofmaterials.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillOfMaterialsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billofmaterials.FieldPackageID:
		return m.PackageID()
	case billofmaterials.FieldArtifactID:
		return m.ArtifactID()
	case billofmaterials.FieldURI:
		return m.URI()
	case billofmaterials.FieldAlgorithm:
		return m.Algorithm()
	case billofmaterials.FieldDigest:
		return m.Digest()
	case billofmaterials.FieldDownloadLocation:
		return m.DownloadLocation()
	case billofmaterials.FieldOrigin:
		return m.Origin()
	case billofmaterials.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillOfMaterialsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billofmaterials.FieldPackageID:
		return m.OldPackageID(ctx)
	case billofmaterials.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case billofmaterials.FieldURI:
		return m.OldURI(ctx)
	case billofmaterials.FieldAlgorithm:
		return m.OldAlgorithm(ctx)
	case billofmaterials.FieldDigest:
		return m.OldDigest(ctx)
	case billofmaterials.FieldDownloadLocation:
		return m.OldDownloadLocation(ctx)
	case billofmaterials.FieldOrigin:
		return m.OldOrigin(ctx)
	case billofmaterials.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown BillOfMaterials field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillOfMaterialsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billofmaterials.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case billofmaterials.FieldArtifactID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case billofmaterials.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case billofmaterials.FieldAlgorithm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgorithm(v)
		return nil
	case billofmaterials.FieldDigest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigest(v)
		return nil
	case billofmaterials.FieldDownloadLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadLocation(v)
		return nil
	case billofmaterials.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case billofmaterials.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillOfMaterialsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillOfMaterialsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillOfMaterialsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillOfMaterials numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillOfMaterialsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(billofmaterials.FieldPackageID) {
		fields = append(fields, billofmaterials.FieldPackageID)
	}
	if m.FieldCleared(billofmaterials.FieldArtifactID) {
		fields = append(fields, billofmaterials.FieldArtifactID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillOfMaterialsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillOfMaterialsMutation) ClearField(name string) error {
	switch name {
	case billofmaterials.FieldPackageID:
		m.ClearPackageID()
		return nil
	case billofmaterials.FieldArtifactID:
		m.ClearArtifactID()
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillOfMaterialsMutation) ResetField(name string) error {
	switch name {
	case billofmaterials.FieldPackageID:
		m.ResetPackageID()
		return nil
	case billofmaterials.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case billofmaterials.FieldURI:
		m.ResetURI()
		return nil
	case billofmaterials.FieldAlgorithm:
		m.ResetAlgorithm()
		return nil
	case billofmaterials.FieldDigest:
		m.ResetDigest()
		return nil
	case billofmaterials.FieldDownloadLocation:
		m.ResetDownloadLocation()
		return nil
	case billofmaterials.FieldOrigin:
		m.ResetOrigin()
		return nil
	case billofmaterials.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillOfMaterialsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._package != nil {
		edges = append(edges, billofmaterials.EdgePackage)
	}
	if m.artifact != nil {
		edges = append(edges, billofmaterials.EdgeArtifact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillOfMaterialsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billofmaterials.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case billofmaterials.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillOfMaterialsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillOfMaterialsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillOfMaterialsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_package {
		edges = append(edges, billofmaterials.EdgePackage)
	}
	if m.clearedartifact {
		edges = append(edges, billofmaterials.EdgeArtifact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillOfMaterialsMutation) EdgeCleared(name string) bool {
	switch name {
	case billofmaterials.EdgePackage:
		return m.cleared_package
	case billofmaterials.EdgeArtifact:
		return m.clearedartifact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillOfMaterialsMutation) ClearEdge(name string) error {
	switch name {
	case billofmaterials.EdgePackage:
		m.ClearPackage()
		return nil
	case billofmaterials.EdgeArtifact:
		m.ClearArtifact()
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillOfMaterialsMutation) ResetEdge(name string) error {
	switch name {
	case billofmaterials.EdgePackage:
		m.ResetPackage()
		return nil
	case billofmaterials.EdgeArtifact:
		m.ResetArtifact()
		return nil
	}
	return fmt.Errorf("unknown BillOfMaterials edge %s", name)
}

// BuilderMutation represents an operation that mutates the Builder nodes in the graph.
type BuilderMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	uri                      *string
	clearedFields            map[string]struct{}
	slsa_attestations        map[int]struct{}
	removedslsa_attestations map[int]struct{}
	clearedslsa_attestations bool
	done                     bool
	oldValue                 func(context.Context) (*Builder, error)
	predicates               []predicate.Builder
}

var _ ent.Mutation = (*BuilderMutation)(nil)

// builderOption allows management of the mutation configuration using functional options.
type builderOption func(*BuilderMutation)

// newBuilderMutation creates new mutation for the Builder entity.
func newBuilderMutation(c config, op Op, opts ...builderOption) *BuilderMutation {
	m := &BuilderMutation{
		config:        c,
		op:            op,
		typ:           TypeBuilder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuilderID sets the ID field of the mutation.
func withBuilderID(id int) builderOption {
	return func(m *BuilderMutation) {
		var (
			err   error
			once  sync.Once
			value *Builder
		)
		m.oldValue = func(ctx context.Context) (*Builder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Builder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuilder sets the old Builder of the mutation.
func withBuilder(node *Builder) builderOption {
	return func(m *BuilderMutation) {
		m.oldValue = func(context.Context) (*Builder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuilderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuilderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuilderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuilderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Builder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURI sets the "uri" field.
func (m *BuilderMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *BuilderMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the Builder entity.
// If the Builder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuilderMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *BuilderMutation) ResetURI() {
	m.uri = nil
}

// AddSlsaAttestationIDs adds the "slsa_attestations" edge to the SLSAAttestation entity by ids.
func (m *BuilderMutation) AddSlsaAttestationIDs(ids ...int) {
	if m.slsa_attestations == nil {
		m.slsa_attestations = make(map[int]struct{})
	}
	for i := range ids {
		m.slsa_attestations[ids[i]] = struct{}{}
	}
}

// ClearSlsaAttestations clears the "slsa_attestations" edge to the SLSAAttestation entity.
func (m *BuilderMutation) ClearSlsaAttestations() {
	m.clearedslsa_attestations = true
}

// SlsaAttestationsCleared reports if the "slsa_attestations" edge to the SLSAAttestation entity was cleared.
func (m *BuilderMutation) SlsaAttestationsCleared() bool {
	return m.clearedslsa_attestations
}

// RemoveSlsaAttestationIDs removes the "slsa_attestations" edge to the SLSAAttestation entity by IDs.
func (m *BuilderMutation) RemoveSlsaAttestationIDs(ids ...int) {
	if m.removedslsa_attestations == nil {
		m.removedslsa_attestations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.slsa_attestations, ids[i])
		m.removedslsa_attestations[ids[i]] = struct{}{}
	}
}

// RemovedSlsaAttestations returns the removed IDs of the "slsa_attestations" edge to the SLSAAttestation entity.
func (m *BuilderMutation) RemovedSlsaAttestationsIDs() (ids []int) {
	for id := range m.removedslsa_attestations {
		ids = append(ids, id)
	}
	return
}

// SlsaAttestationsIDs returns the "slsa_attestations" edge IDs in the mutation.
func (m *BuilderMutation) SlsaAttestationsIDs() (ids []int) {
	for id := range m.slsa_attestations {
		ids = append(ids, id)
	}
	return
}

// ResetSlsaAttestations resets all changes to the "slsa_attestations" edge.
func (m *BuilderMutation) ResetSlsaAttestations() {
	m.slsa_attestations = nil
	m.clearedslsa_attestations = false
	m.removedslsa_attestations = nil
}

// Where appends a list predicates to the BuilderMutation builder.
func (m *BuilderMutation) Where(ps ...predicate.Builder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BuilderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BuilderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Builder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BuilderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BuilderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Builder).
func (m *BuilderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuilderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.uri != nil {
		fields = append(fields, builder.FieldURI)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuilderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case builder.FieldURI:
		return m.URI()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuilderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case builder.FieldURI:
		return m.OldURI(ctx)
	}
	return nil, fmt.Errorf("unknown Builder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuilderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case builder.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	}
	return fmt.Errorf("unknown Builder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuilderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuilderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuilderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Builder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuilderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuilderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuilderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Builder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuilderMutation) ResetField(name string) error {
	switch name {
	case builder.FieldURI:
		m.ResetURI()
		return nil
	}
	return fmt.Errorf("unknown Builder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuilderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.slsa_attestations != nil {
		edges = append(edges, builder.EdgeSlsaAttestations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuilderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case builder.EdgeSlsaAttestations:
		ids := make([]ent.Value, 0, len(m.slsa_attestations))
		for id := range m.slsa_attestations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuilderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedslsa_attestations != nil {
		edges = append(edges, builder.EdgeSlsaAttestations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuilderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case builder.EdgeSlsaAttestations:
		ids := make([]ent.Value, 0, len(m.removedslsa_attestations))
		for id := range m.removedslsa_attestations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuilderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedslsa_attestations {
		edges = append(edges, builder.EdgeSlsaAttestations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuilderMutation) EdgeCleared(name string) bool {
	switch name {
	case builder.EdgeSlsaAttestations:
		return m.clearedslsa_attestations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuilderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Builder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuilderMutation) ResetEdge(name string) error {
	switch name {
	case builder.EdgeSlsaAttestations:
		m.ResetSlsaAttestations()
		return nil
	}
	return fmt.Errorf("unknown Builder edge %s", name)
}

// CertificationMutation represents an operation that mutates the Certification nodes in the graph.
type CertificationMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_type                  *certification.Type
	justification          *string
	origin                 *string
	collector              *string
	clearedFields          map[string]struct{}
	source                 *int
	clearedsource          bool
	package_version        *int
	clearedpackage_version bool
	all_versions           *int
	clearedall_versions    bool
	artifact               *int
	clearedartifact        bool
	done                   bool
	oldValue               func(context.Context) (*Certification, error)
	predicates             []predicate.Certification
}

var _ ent.Mutation = (*CertificationMutation)(nil)

// certificationOption allows management of the mutation configuration using functional options.
type certificationOption func(*CertificationMutation)

// newCertificationMutation creates new mutation for the Certification entity.
func newCertificationMutation(c config, op Op, opts ...certificationOption) *CertificationMutation {
	m := &CertificationMutation{
		config:        c,
		op:            op,
		typ:           TypeCertification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificationID sets the ID field of the mutation.
func withCertificationID(id int) certificationOption {
	return func(m *CertificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Certification
		)
		m.oldValue = func(ctx context.Context) (*Certification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Certification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertification sets the old Certification of the mutation.
func withCertification(node *Certification) certificationOption {
	return func(m *CertificationMutation) {
		m.oldValue = func(context.Context) (*Certification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Certification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceID sets the "source_id" field.
func (m *CertificationMutation) SetSourceID(i int) {
	m.source = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *CertificationMutation) SourceID() (r int, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldSourceID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *CertificationMutation) ClearSourceID() {
	m.source = nil
	m.clearedFields[certification.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *CertificationMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[certification.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *CertificationMutation) ResetSourceID() {
	m.source = nil
	delete(m.clearedFields, certification.FieldSourceID)
}

// SetPackageVersionID sets the "package_version_id" field.
func (m *CertificationMutation) SetPackageVersionID(i int) {
	m.package_version = &i
}

// PackageVersionID returns the value of the "package_version_id" field in the mutation.
func (m *CertificationMutation) PackageVersionID() (r int, exists bool) {
	v := m.package_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageVersionID returns the old "package_version_id" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldPackageVersionID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageVersionID: %w", err)
	}
	return oldValue.PackageVersionID, nil
}

// ClearPackageVersionID clears the value of the "package_version_id" field.
func (m *CertificationMutation) ClearPackageVersionID() {
	m.package_version = nil
	m.clearedFields[certification.FieldPackageVersionID] = struct{}{}
}

// PackageVersionIDCleared returns if the "package_version_id" field was cleared in this mutation.
func (m *CertificationMutation) PackageVersionIDCleared() bool {
	_, ok := m.clearedFields[certification.FieldPackageVersionID]
	return ok
}

// ResetPackageVersionID resets all changes to the "package_version_id" field.
func (m *CertificationMutation) ResetPackageVersionID() {
	m.package_version = nil
	delete(m.clearedFields, certification.FieldPackageVersionID)
}

// SetPackageNameID sets the "package_name_id" field.
func (m *CertificationMutation) SetPackageNameID(i int) {
	m.all_versions = &i
}

// PackageNameID returns the value of the "package_name_id" field in the mutation.
func (m *CertificationMutation) PackageNameID() (r int, exists bool) {
	v := m.all_versions
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageNameID returns the old "package_name_id" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldPackageNameID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageNameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageNameID: %w", err)
	}
	return oldValue.PackageNameID, nil
}

// ClearPackageNameID clears the value of the "package_name_id" field.
func (m *CertificationMutation) ClearPackageNameID() {
	m.all_versions = nil
	m.clearedFields[certification.FieldPackageNameID] = struct{}{}
}

// PackageNameIDCleared returns if the "package_name_id" field was cleared in this mutation.
func (m *CertificationMutation) PackageNameIDCleared() bool {
	_, ok := m.clearedFields[certification.FieldPackageNameID]
	return ok
}

// ResetPackageNameID resets all changes to the "package_name_id" field.
func (m *CertificationMutation) ResetPackageNameID() {
	m.all_versions = nil
	delete(m.clearedFields, certification.FieldPackageNameID)
}

// SetArtifactID sets the "artifact_id" field.
func (m *CertificationMutation) SetArtifactID(i int) {
	m.artifact = &i
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *CertificationMutation) ArtifactID() (r int, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldArtifactID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ClearArtifactID clears the value of the "artifact_id" field.
func (m *CertificationMutation) ClearArtifactID() {
	m.artifact = nil
	m.clearedFields[certification.FieldArtifactID] = struct{}{}
}

// ArtifactIDCleared returns if the "artifact_id" field was cleared in this mutation.
func (m *CertificationMutation) ArtifactIDCleared() bool {
	_, ok := m.clearedFields[certification.FieldArtifactID]
	return ok
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *CertificationMutation) ResetArtifactID() {
	m.artifact = nil
	delete(m.clearedFields, certification.FieldArtifactID)
}

// SetType sets the "type" field.
func (m *CertificationMutation) SetType(c certification.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CertificationMutation) GetType() (r certification.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldType(ctx context.Context) (v certification.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CertificationMutation) ResetType() {
	m._type = nil
}

// SetJustification sets the "justification" field.
func (m *CertificationMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *CertificationMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *CertificationMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *CertificationMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *CertificationMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *CertificationMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *CertificationMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *CertificationMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *CertificationMutation) ResetCollector() {
	m.collector = nil
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *CertificationMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[certification.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *CertificationMutation) SourceCleared() bool {
	return m.SourceIDCleared() || m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *CertificationMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *CertificationMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// ClearPackageVersion clears the "package_version" edge to the PackageVersion entity.
func (m *CertificationMutation) ClearPackageVersion() {
	m.clearedpackage_version = true
	m.clearedFields[certification.FieldPackageVersionID] = struct{}{}
}

// PackageVersionCleared reports if the "package_version" edge to the PackageVersion entity was cleared.
func (m *CertificationMutation) PackageVersionCleared() bool {
	return m.PackageVersionIDCleared() || m.clearedpackage_version
}

// PackageVersionIDs returns the "package_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageVersionID instead. It exists only for internal usage by the builders.
func (m *CertificationMutation) PackageVersionIDs() (ids []int) {
	if id := m.package_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackageVersion resets all changes to the "package_version" edge.
func (m *CertificationMutation) ResetPackageVersion() {
	m.package_version = nil
	m.clearedpackage_version = false
}

// SetAllVersionsID sets the "all_versions" edge to the PackageName entity by id.
func (m *CertificationMutation) SetAllVersionsID(id int) {
	m.all_versions = &id
}

// ClearAllVersions clears the "all_versions" edge to the PackageName entity.
func (m *CertificationMutation) ClearAllVersions() {
	m.clearedall_versions = true
	m.clearedFields[certification.FieldPackageNameID] = struct{}{}
}

// AllVersionsCleared reports if the "all_versions" edge to the PackageName entity was cleared.
func (m *CertificationMutation) AllVersionsCleared() bool {
	return m.PackageNameIDCleared() || m.clearedall_versions
}

// AllVersionsID returns the "all_versions" edge ID in the mutation.
func (m *CertificationMutation) AllVersionsID() (id int, exists bool) {
	if m.all_versions != nil {
		return *m.all_versions, true
	}
	return
}

// AllVersionsIDs returns the "all_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AllVersionsID instead. It exists only for internal usage by the builders.
func (m *CertificationMutation) AllVersionsIDs() (ids []int) {
	if id := m.all_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAllVersions resets all changes to the "all_versions" edge.
func (m *CertificationMutation) ResetAllVersions() {
	m.all_versions = nil
	m.clearedall_versions = false
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *CertificationMutation) ClearArtifact() {
	m.clearedartifact = true
	m.clearedFields[certification.FieldArtifactID] = struct{}{}
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *CertificationMutation) ArtifactCleared() bool {
	return m.ArtifactIDCleared() || m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *CertificationMutation) ArtifactIDs() (ids []int) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *CertificationMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// Where appends a list predicates to the CertificationMutation builder.
func (m *CertificationMutation) Where(ps ...predicate.Certification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Certification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Certification).
func (m *CertificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertificationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.source != nil {
		fields = append(fields, certification.FieldSourceID)
	}
	if m.package_version != nil {
		fields = append(fields, certification.FieldPackageVersionID)
	}
	if m.all_versions != nil {
		fields = append(fields, certification.FieldPackageNameID)
	}
	if m.artifact != nil {
		fields = append(fields, certification.FieldArtifactID)
	}
	if m._type != nil {
		fields = append(fields, certification.FieldType)
	}
	if m.justification != nil {
		fields = append(fields, certification.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, certification.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, certification.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certification.FieldSourceID:
		return m.SourceID()
	case certification.FieldPackageVersionID:
		return m.PackageVersionID()
	case certification.FieldPackageNameID:
		return m.PackageNameID()
	case certification.FieldArtifactID:
		return m.ArtifactID()
	case certification.FieldType:
		return m.GetType()
	case certification.FieldJustification:
		return m.Justification()
	case certification.FieldOrigin:
		return m.Origin()
	case certification.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certification.FieldSourceID:
		return m.OldSourceID(ctx)
	case certification.FieldPackageVersionID:
		return m.OldPackageVersionID(ctx)
	case certification.FieldPackageNameID:
		return m.OldPackageNameID(ctx)
	case certification.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case certification.FieldType:
		return m.OldType(ctx)
	case certification.FieldJustification:
		return m.OldJustification(ctx)
	case certification.FieldOrigin:
		return m.OldOrigin(ctx)
	case certification.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown Certification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certification.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case certification.FieldPackageVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageVersionID(v)
		return nil
	case certification.FieldPackageNameID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageNameID(v)
		return nil
	case certification.FieldArtifactID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case certification.FieldType:
		v, ok := value.(certification.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case certification.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case certification.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case certification.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown Certification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertificationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Certification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certification.FieldSourceID) {
		fields = append(fields, certification.FieldSourceID)
	}
	if m.FieldCleared(certification.FieldPackageVersionID) {
		fields = append(fields, certification.FieldPackageVersionID)
	}
	if m.FieldCleared(certification.FieldPackageNameID) {
		fields = append(fields, certification.FieldPackageNameID)
	}
	if m.FieldCleared(certification.FieldArtifactID) {
		fields = append(fields, certification.FieldArtifactID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificationMutation) ClearField(name string) error {
	switch name {
	case certification.FieldSourceID:
		m.ClearSourceID()
		return nil
	case certification.FieldPackageVersionID:
		m.ClearPackageVersionID()
		return nil
	case certification.FieldPackageNameID:
		m.ClearPackageNameID()
		return nil
	case certification.FieldArtifactID:
		m.ClearArtifactID()
		return nil
	}
	return fmt.Errorf("unknown Certification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertificationMutation) ResetField(name string) error {
	switch name {
	case certification.FieldSourceID:
		m.ResetSourceID()
		return nil
	case certification.FieldPackageVersionID:
		m.ResetPackageVersionID()
		return nil
	case certification.FieldPackageNameID:
		m.ResetPackageNameID()
		return nil
	case certification.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case certification.FieldType:
		m.ResetType()
		return nil
	case certification.FieldJustification:
		m.ResetJustification()
		return nil
	case certification.FieldOrigin:
		m.ResetOrigin()
		return nil
	case certification.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown Certification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.source != nil {
		edges = append(edges, certification.EdgeSource)
	}
	if m.package_version != nil {
		edges = append(edges, certification.EdgePackageVersion)
	}
	if m.all_versions != nil {
		edges = append(edges, certification.EdgeAllVersions)
	}
	if m.artifact != nil {
		edges = append(edges, certification.EdgeArtifact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certification.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	case certification.EdgePackageVersion:
		if id := m.package_version; id != nil {
			return []ent.Value{*id}
		}
	case certification.EdgeAllVersions:
		if id := m.all_versions; id != nil {
			return []ent.Value{*id}
		}
	case certification.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsource {
		edges = append(edges, certification.EdgeSource)
	}
	if m.clearedpackage_version {
		edges = append(edges, certification.EdgePackageVersion)
	}
	if m.clearedall_versions {
		edges = append(edges, certification.EdgeAllVersions)
	}
	if m.clearedartifact {
		edges = append(edges, certification.EdgeArtifact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertificationMutation) EdgeCleared(name string) bool {
	switch name {
	case certification.EdgeSource:
		return m.clearedsource
	case certification.EdgePackageVersion:
		return m.clearedpackage_version
	case certification.EdgeAllVersions:
		return m.clearedall_versions
	case certification.EdgeArtifact:
		return m.clearedartifact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertificationMutation) ClearEdge(name string) error {
	switch name {
	case certification.EdgeSource:
		m.ClearSource()
		return nil
	case certification.EdgePackageVersion:
		m.ClearPackageVersion()
		return nil
	case certification.EdgeAllVersions:
		m.ClearAllVersions()
		return nil
	case certification.EdgeArtifact:
		m.ClearArtifact()
		return nil
	}
	return fmt.Errorf("unknown Certification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertificationMutation) ResetEdge(name string) error {
	switch name {
	case certification.EdgeSource:
		m.ResetSource()
		return nil
	case certification.EdgePackageVersion:
		m.ResetPackageVersion()
		return nil
	case certification.EdgeAllVersions:
		m.ResetAllVersions()
		return nil
	case certification.EdgeArtifact:
		m.ResetArtifact()
		return nil
	}
	return fmt.Errorf("unknown Certification edge %s", name)
}

// CertifyLegalMutation represents an operation that mutates the CertifyLegal nodes in the graph.
type CertifyLegalMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	declared_license           *string
	discovered_license         *string
	attribution                *string
	justification              *string
	time_scanned               *time.Time
	origin                     *string
	collector                  *string
	declared_licenses_hash     *string
	discovered_licenses_hash   *string
	clearedFields              map[string]struct{}
	_package                   *int
	cleared_package            bool
	source                     *int
	clearedsource              bool
	declared_licenses          map[int]struct{}
	removeddeclared_licenses   map[int]struct{}
	cleareddeclared_licenses   bool
	discovered_licenses        map[int]struct{}
	removeddiscovered_licenses map[int]struct{}
	cleareddiscovered_licenses bool
	done                       bool
	oldValue                   func(context.Context) (*CertifyLegal, error)
	predicates                 []predicate.CertifyLegal
}

var _ ent.Mutation = (*CertifyLegalMutation)(nil)

// certifylegalOption allows management of the mutation configuration using functional options.
type certifylegalOption func(*CertifyLegalMutation)

// newCertifyLegalMutation creates new mutation for the CertifyLegal entity.
func newCertifyLegalMutation(c config, op Op, opts ...certifylegalOption) *CertifyLegalMutation {
	m := &CertifyLegalMutation{
		config:        c,
		op:            op,
		typ:           TypeCertifyLegal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertifyLegalID sets the ID field of the mutation.
func withCertifyLegalID(id int) certifylegalOption {
	return func(m *CertifyLegalMutation) {
		var (
			err   error
			once  sync.Once
			value *CertifyLegal
		)
		m.oldValue = func(ctx context.Context) (*CertifyLegal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertifyLegal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertifyLegal sets the old CertifyLegal of the mutation.
func withCertifyLegal(node *CertifyLegal) certifylegalOption {
	return func(m *CertifyLegalMutation) {
		m.oldValue = func(context.Context) (*CertifyLegal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertifyLegalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertifyLegalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertifyLegalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertifyLegalMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertifyLegal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *CertifyLegalMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *CertifyLegalMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldPackageID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *CertifyLegalMutation) ClearPackageID() {
	m._package = nil
	m.clearedFields[certifylegal.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *CertifyLegalMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[certifylegal.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *CertifyLegalMutation) ResetPackageID() {
	m._package = nil
	delete(m.clearedFields, certifylegal.FieldPackageID)
}

// SetSourceID sets the "source_id" field.
func (m *CertifyLegalMutation) SetSourceID(i int) {
	m.source = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *CertifyLegalMutation) SourceID() (r int, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldSourceID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *CertifyLegalMutation) ClearSourceID() {
	m.source = nil
	m.clearedFields[certifylegal.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *CertifyLegalMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[certifylegal.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *CertifyLegalMutation) ResetSourceID() {
	m.source = nil
	delete(m.clearedFields, certifylegal.FieldSourceID)
}

// SetDeclaredLicense sets the "declared_license" field.
func (m *CertifyLegalMutation) SetDeclaredLicense(s string) {
	m.declared_license = &s
}

// DeclaredLicense returns the value of the "declared_license" field in the mutation.
func (m *CertifyLegalMutation) DeclaredLicense() (r string, exists bool) {
	v := m.declared_license
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredLicense returns the old "declared_license" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldDeclaredLicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredLicense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredLicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredLicense: %w", err)
	}
	return oldValue.DeclaredLicense, nil
}

// ResetDeclaredLicense resets all changes to the "declared_license" field.
func (m *CertifyLegalMutation) ResetDeclaredLicense() {
	m.declared_license = nil
}

// SetDiscoveredLicense sets the "discovered_license" field.
func (m *CertifyLegalMutation) SetDiscoveredLicense(s string) {
	m.discovered_license = &s
}

// DiscoveredLicense returns the value of the "discovered_license" field in the mutation.
func (m *CertifyLegalMutation) DiscoveredLicense() (r string, exists bool) {
	v := m.discovered_license
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveredLicense returns the old "discovered_license" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldDiscoveredLicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveredLicense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveredLicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveredLicense: %w", err)
	}
	return oldValue.DiscoveredLicense, nil
}

// ResetDiscoveredLicense resets all changes to the "discovered_license" field.
func (m *CertifyLegalMutation) ResetDiscoveredLicense() {
	m.discovered_license = nil
}

// SetAttribution sets the "attribution" field.
func (m *CertifyLegalMutation) SetAttribution(s string) {
	m.attribution = &s
}

// Attribution returns the value of the "attribution" field in the mutation.
func (m *CertifyLegalMutation) Attribution() (r string, exists bool) {
	v := m.attribution
	if v == nil {
		return
	}
	return *v, true
}

// OldAttribution returns the old "attribution" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldAttribution(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttribution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttribution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttribution: %w", err)
	}
	return oldValue.Attribution, nil
}

// ResetAttribution resets all changes to the "attribution" field.
func (m *CertifyLegalMutation) ResetAttribution() {
	m.attribution = nil
}

// SetJustification sets the "justification" field.
func (m *CertifyLegalMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *CertifyLegalMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *CertifyLegalMutation) ResetJustification() {
	m.justification = nil
}

// SetTimeScanned sets the "time_scanned" field.
func (m *CertifyLegalMutation) SetTimeScanned(t time.Time) {
	m.time_scanned = &t
}

// TimeScanned returns the value of the "time_scanned" field in the mutation.
func (m *CertifyLegalMutation) TimeScanned() (r time.Time, exists bool) {
	v := m.time_scanned
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeScanned returns the old "time_scanned" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldTimeScanned(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeScanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeScanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeScanned: %w", err)
	}
	return oldValue.TimeScanned, nil
}

// ResetTimeScanned resets all changes to the "time_scanned" field.
func (m *CertifyLegalMutation) ResetTimeScanned() {
	m.time_scanned = nil
}

// SetOrigin sets the "origin" field.
func (m *CertifyLegalMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *CertifyLegalMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *CertifyLegalMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *CertifyLegalMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *CertifyLegalMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *CertifyLegalMutation) ResetCollector() {
	m.collector = nil
}

// SetDeclaredLicensesHash sets the "declared_licenses_hash" field.
func (m *CertifyLegalMutation) SetDeclaredLicensesHash(s string) {
	m.declared_licenses_hash = &s
}

// DeclaredLicensesHash returns the value of the "declared_licenses_hash" field in the mutation.
func (m *CertifyLegalMutation) DeclaredLicensesHash() (r string, exists bool) {
	v := m.declared_licenses_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredLicensesHash returns the old "declared_licenses_hash" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldDeclaredLicensesHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredLicensesHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredLicensesHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredLicensesHash: %w", err)
	}
	return oldValue.DeclaredLicensesHash, nil
}

// ResetDeclaredLicensesHash resets all changes to the "declared_licenses_hash" field.
func (m *CertifyLegalMutation) ResetDeclaredLicensesHash() {
	m.declared_licenses_hash = nil
}

// SetDiscoveredLicensesHash sets the "discovered_licenses_hash" field.
func (m *CertifyLegalMutation) SetDiscoveredLicensesHash(s string) {
	m.discovered_licenses_hash = &s
}

// DiscoveredLicensesHash returns the value of the "discovered_licenses_hash" field in the mutation.
func (m *CertifyLegalMutation) DiscoveredLicensesHash() (r string, exists bool) {
	v := m.discovered_licenses_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveredLicensesHash returns the old "discovered_licenses_hash" field's value of the CertifyLegal entity.
// If the CertifyLegal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyLegalMutation) OldDiscoveredLicensesHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveredLicensesHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveredLicensesHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveredLicensesHash: %w", err)
	}
	return oldValue.DiscoveredLicensesHash, nil
}

// ResetDiscoveredLicensesHash resets all changes to the "discovered_licenses_hash" field.
func (m *CertifyLegalMutation) ResetDiscoveredLicensesHash() {
	m.discovered_licenses_hash = nil
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *CertifyLegalMutation) ClearPackage() {
	m.cleared_package = true
	m.clearedFields[certifylegal.FieldPackageID] = struct{}{}
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *CertifyLegalMutation) PackageCleared() bool {
	return m.PackageIDCleared() || m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *CertifyLegalMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *CertifyLegalMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *CertifyLegalMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[certifylegal.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *CertifyLegalMutation) SourceCleared() bool {
	return m.SourceIDCleared() || m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *CertifyLegalMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *CertifyLegalMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// AddDeclaredLicenseIDs adds the "declared_licenses" edge to the License entity by ids.
func (m *CertifyLegalMutation) AddDeclaredLicenseIDs(ids ...int) {
	if m.declared_licenses == nil {
		m.declared_licenses = make(map[int]struct{})
	}
	for i := range ids {
		m.declared_licenses[ids[i]] = struct{}{}
	}
}

// ClearDeclaredLicenses clears the "declared_licenses" edge to the License entity.
func (m *CertifyLegalMutation) ClearDeclaredLicenses() {
	m.cleareddeclared_licenses = true
}

// DeclaredLicensesCleared reports if the "declared_licenses" edge to the License entity was cleared.
func (m *CertifyLegalMutation) DeclaredLicensesCleared() bool {
	return m.cleareddeclared_licenses
}

// RemoveDeclaredLicenseIDs removes the "declared_licenses" edge to the License entity by IDs.
func (m *CertifyLegalMutation) RemoveDeclaredLicenseIDs(ids ...int) {
	if m.removeddeclared_licenses == nil {
		m.removeddeclared_licenses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.declared_licenses, ids[i])
		m.removeddeclared_licenses[ids[i]] = struct{}{}
	}
}

// RemovedDeclaredLicenses returns the removed IDs of the "declared_licenses" edge to the License entity.
func (m *CertifyLegalMutation) RemovedDeclaredLicensesIDs() (ids []int) {
	for id := range m.removeddeclared_licenses {
		ids = append(ids, id)
	}
	return
}

// DeclaredLicensesIDs returns the "declared_licenses" edge IDs in the mutation.
func (m *CertifyLegalMutation) DeclaredLicensesIDs() (ids []int) {
	for id := range m.declared_licenses {
		ids = append(ids, id)
	}
	return
}

// ResetDeclaredLicenses resets all changes to the "declared_licenses" edge.
func (m *CertifyLegalMutation) ResetDeclaredLicenses() {
	m.declared_licenses = nil
	m.cleareddeclared_licenses = false
	m.removeddeclared_licenses = nil
}

// AddDiscoveredLicenseIDs adds the "discovered_licenses" edge to the License entity by ids.
func (m *CertifyLegalMutation) AddDiscoveredLicenseIDs(ids ...int) {
	if m.discovered_licenses == nil {
		m.discovered_licenses = make(map[int]struct{})
	}
	for i := range ids {
		m.discovered_licenses[ids[i]] = struct{}{}
	}
}

// ClearDiscoveredLicenses clears the "discovered_licenses" edge to the License entity.
func (m *CertifyLegalMutation) ClearDiscoveredLicenses() {
	m.cleareddiscovered_licenses = true
}

// DiscoveredLicensesCleared reports if the "discovered_licenses" edge to the License entity was cleared.
func (m *CertifyLegalMutation) DiscoveredLicensesCleared() bool {
	return m.cleareddiscovered_licenses
}

// RemoveDiscoveredLicenseIDs removes the "discovered_licenses" edge to the License entity by IDs.
func (m *CertifyLegalMutation) RemoveDiscoveredLicenseIDs(ids ...int) {
	if m.removeddiscovered_licenses == nil {
		m.removeddiscovered_licenses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.discovered_licenses, ids[i])
		m.removeddiscovered_licenses[ids[i]] = struct{}{}
	}
}

// RemovedDiscoveredLicenses returns the removed IDs of the "discovered_licenses" edge to the License entity.
func (m *CertifyLegalMutation) RemovedDiscoveredLicensesIDs() (ids []int) {
	for id := range m.removeddiscovered_licenses {
		ids = append(ids, id)
	}
	return
}

// DiscoveredLicensesIDs returns the "discovered_licenses" edge IDs in the mutation.
func (m *CertifyLegalMutation) DiscoveredLicensesIDs() (ids []int) {
	for id := range m.discovered_licenses {
		ids = append(ids, id)
	}
	return
}

// ResetDiscoveredLicenses resets all changes to the "discovered_licenses" edge.
func (m *CertifyLegalMutation) ResetDiscoveredLicenses() {
	m.discovered_licenses = nil
	m.cleareddiscovered_licenses = false
	m.removeddiscovered_licenses = nil
}

// Where appends a list predicates to the CertifyLegalMutation builder.
func (m *CertifyLegalMutation) Where(ps ...predicate.CertifyLegal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertifyLegalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertifyLegalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CertifyLegal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertifyLegalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertifyLegalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CertifyLegal).
func (m *CertifyLegalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertifyLegalMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m._package != nil {
		fields = append(fields, certifylegal.FieldPackageID)
	}
	if m.source != nil {
		fields = append(fields, certifylegal.FieldSourceID)
	}
	if m.declared_license != nil {
		fields = append(fields, certifylegal.FieldDeclaredLicense)
	}
	if m.discovered_license != nil {
		fields = append(fields, certifylegal.FieldDiscoveredLicense)
	}
	if m.attribution != nil {
		fields = append(fields, certifylegal.FieldAttribution)
	}
	if m.justification != nil {
		fields = append(fields, certifylegal.FieldJustification)
	}
	if m.time_scanned != nil {
		fields = append(fields, certifylegal.FieldTimeScanned)
	}
	if m.origin != nil {
		fields = append(fields, certifylegal.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, certifylegal.FieldCollector)
	}
	if m.declared_licenses_hash != nil {
		fields = append(fields, certifylegal.FieldDeclaredLicensesHash)
	}
	if m.discovered_licenses_hash != nil {
		fields = append(fields, certifylegal.FieldDiscoveredLicensesHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertifyLegalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certifylegal.FieldPackageID:
		return m.PackageID()
	case certifylegal.FieldSourceID:
		return m.SourceID()
	case certifylegal.FieldDeclaredLicense:
		return m.DeclaredLicense()
	case certifylegal.FieldDiscoveredLicense:
		return m.DiscoveredLicense()
	case certifylegal.FieldAttribution:
		return m.Attribution()
	case certifylegal.FieldJustification:
		return m.Justification()
	case certifylegal.FieldTimeScanned:
		return m.TimeScanned()
	case certifylegal.FieldOrigin:
		return m.Origin()
	case certifylegal.FieldCollector:
		return m.Collector()
	case certifylegal.FieldDeclaredLicensesHash:
		return m.DeclaredLicensesHash()
	case certifylegal.FieldDiscoveredLicensesHash:
		return m.DiscoveredLicensesHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertifyLegalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certifylegal.FieldPackageID:
		return m.OldPackageID(ctx)
	case certifylegal.FieldSourceID:
		return m.OldSourceID(ctx)
	case certifylegal.FieldDeclaredLicense:
		return m.OldDeclaredLicense(ctx)
	case certifylegal.FieldDiscoveredLicense:
		return m.OldDiscoveredLicense(ctx)
	case certifylegal.FieldAttribution:
		return m.OldAttribution(ctx)
	case certifylegal.FieldJustification:
		return m.OldJustification(ctx)
	case certifylegal.FieldTimeScanned:
		return m.OldTimeScanned(ctx)
	case certifylegal.FieldOrigin:
		return m.OldOrigin(ctx)
	case certifylegal.FieldCollector:
		return m.OldCollector(ctx)
	case certifylegal.FieldDeclaredLicensesHash:
		return m.OldDeclaredLicensesHash(ctx)
	case certifylegal.FieldDiscoveredLicensesHash:
		return m.OldDiscoveredLicensesHash(ctx)
	}
	return nil, fmt.Errorf("unknown CertifyLegal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyLegalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certifylegal.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case certifylegal.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case certifylegal.FieldDeclaredLicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredLicense(v)
		return nil
	case certifylegal.FieldDiscoveredLicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveredLicense(v)
		return nil
	case certifylegal.FieldAttribution:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttribution(v)
		return nil
	case certifylegal.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case certifylegal.FieldTimeScanned:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeScanned(v)
		return nil
	case certifylegal.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case certifylegal.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case certifylegal.FieldDeclaredLicensesHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredLicensesHash(v)
		return nil
	case certifylegal.FieldDiscoveredLicensesHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveredLicensesHash(v)
		return nil
	}
	return fmt.Errorf("unknown CertifyLegal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertifyLegalMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertifyLegalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyLegalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CertifyLegal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertifyLegalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certifylegal.FieldPackageID) {
		fields = append(fields, certifylegal.FieldPackageID)
	}
	if m.FieldCleared(certifylegal.FieldSourceID) {
		fields = append(fields, certifylegal.FieldSourceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertifyLegalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertifyLegalMutation) ClearField(name string) error {
	switch name {
	case certifylegal.FieldPackageID:
		m.ClearPackageID()
		return nil
	case certifylegal.FieldSourceID:
		m.ClearSourceID()
		return nil
	}
	return fmt.Errorf("unknown CertifyLegal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertifyLegalMutation) ResetField(name string) error {
	switch name {
	case certifylegal.FieldPackageID:
		m.ResetPackageID()
		return nil
	case certifylegal.FieldSourceID:
		m.ResetSourceID()
		return nil
	case certifylegal.FieldDeclaredLicense:
		m.ResetDeclaredLicense()
		return nil
	case certifylegal.FieldDiscoveredLicense:
		m.ResetDiscoveredLicense()
		return nil
	case certifylegal.FieldAttribution:
		m.ResetAttribution()
		return nil
	case certifylegal.FieldJustification:
		m.ResetJustification()
		return nil
	case certifylegal.FieldTimeScanned:
		m.ResetTimeScanned()
		return nil
	case certifylegal.FieldOrigin:
		m.ResetOrigin()
		return nil
	case certifylegal.FieldCollector:
		m.ResetCollector()
		return nil
	case certifylegal.FieldDeclaredLicensesHash:
		m.ResetDeclaredLicensesHash()
		return nil
	case certifylegal.FieldDiscoveredLicensesHash:
		m.ResetDiscoveredLicensesHash()
		return nil
	}
	return fmt.Errorf("unknown CertifyLegal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertifyLegalMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._package != nil {
		edges = append(edges, certifylegal.EdgePackage)
	}
	if m.source != nil {
		edges = append(edges, certifylegal.EdgeSource)
	}
	if m.declared_licenses != nil {
		edges = append(edges, certifylegal.EdgeDeclaredLicenses)
	}
	if m.discovered_licenses != nil {
		edges = append(edges, certifylegal.EdgeDiscoveredLicenses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertifyLegalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certifylegal.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case certifylegal.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	case certifylegal.EdgeDeclaredLicenses:
		ids := make([]ent.Value, 0, len(m.declared_licenses))
		for id := range m.declared_licenses {
			ids = append(ids, id)
		}
		return ids
	case certifylegal.EdgeDiscoveredLicenses:
		ids := make([]ent.Value, 0, len(m.discovered_licenses))
		for id := range m.discovered_licenses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertifyLegalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddeclared_licenses != nil {
		edges = append(edges, certifylegal.EdgeDeclaredLicenses)
	}
	if m.removeddiscovered_licenses != nil {
		edges = append(edges, certifylegal.EdgeDiscoveredLicenses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertifyLegalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case certifylegal.EdgeDeclaredLicenses:
		ids := make([]ent.Value, 0, len(m.removeddeclared_licenses))
		for id := range m.removeddeclared_licenses {
			ids = append(ids, id)
		}
		return ids
	case certifylegal.EdgeDiscoveredLicenses:
		ids := make([]ent.Value, 0, len(m.removeddiscovered_licenses))
		for id := range m.removeddiscovered_licenses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertifyLegalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_package {
		edges = append(edges, certifylegal.EdgePackage)
	}
	if m.clearedsource {
		edges = append(edges, certifylegal.EdgeSource)
	}
	if m.cleareddeclared_licenses {
		edges = append(edges, certifylegal.EdgeDeclaredLicenses)
	}
	if m.cleareddiscovered_licenses {
		edges = append(edges, certifylegal.EdgeDiscoveredLicenses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertifyLegalMutation) EdgeCleared(name string) bool {
	switch name {
	case certifylegal.EdgePackage:
		return m.cleared_package
	case certifylegal.EdgeSource:
		return m.clearedsource
	case certifylegal.EdgeDeclaredLicenses:
		return m.cleareddeclared_licenses
	case certifylegal.EdgeDiscoveredLicenses:
		return m.cleareddiscovered_licenses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertifyLegalMutation) ClearEdge(name string) error {
	switch name {
	case certifylegal.EdgePackage:
		m.ClearPackage()
		return nil
	case certifylegal.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown CertifyLegal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertifyLegalMutation) ResetEdge(name string) error {
	switch name {
	case certifylegal.EdgePackage:
		m.ResetPackage()
		return nil
	case certifylegal.EdgeSource:
		m.ResetSource()
		return nil
	case certifylegal.EdgeDeclaredLicenses:
		m.ResetDeclaredLicenses()
		return nil
	case certifylegal.EdgeDiscoveredLicenses:
		m.ResetDiscoveredLicenses()
		return nil
	}
	return fmt.Errorf("unknown CertifyLegal edge %s", name)
}

// CertifyScorecardMutation represents an operation that mutates the CertifyScorecard nodes in the graph.
type CertifyScorecardMutation struct {
	config
	op               Op
	typ              string
	id               *int
	clearedFields    map[string]struct{}
	scorecard        *int
	clearedscorecard bool
	source           *int
	clearedsource    bool
	done             bool
	oldValue         func(context.Context) (*CertifyScorecard, error)
	predicates       []predicate.CertifyScorecard
}

var _ ent.Mutation = (*CertifyScorecardMutation)(nil)

// certifyscorecardOption allows management of the mutation configuration using functional options.
type certifyscorecardOption func(*CertifyScorecardMutation)

// newCertifyScorecardMutation creates new mutation for the CertifyScorecard entity.
func newCertifyScorecardMutation(c config, op Op, opts ...certifyscorecardOption) *CertifyScorecardMutation {
	m := &CertifyScorecardMutation{
		config:        c,
		op:            op,
		typ:           TypeCertifyScorecard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertifyScorecardID sets the ID field of the mutation.
func withCertifyScorecardID(id int) certifyscorecardOption {
	return func(m *CertifyScorecardMutation) {
		var (
			err   error
			once  sync.Once
			value *CertifyScorecard
		)
		m.oldValue = func(ctx context.Context) (*CertifyScorecard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertifyScorecard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertifyScorecard sets the old CertifyScorecard of the mutation.
func withCertifyScorecard(node *CertifyScorecard) certifyscorecardOption {
	return func(m *CertifyScorecardMutation) {
		m.oldValue = func(context.Context) (*CertifyScorecard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertifyScorecardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertifyScorecardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertifyScorecardMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertifyScorecardMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertifyScorecard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceID sets the "source_id" field.
func (m *CertifyScorecardMutation) SetSourceID(i int) {
	m.source = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *CertifyScorecardMutation) SourceID() (r int, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the CertifyScorecard entity.
// If the CertifyScorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyScorecardMutation) OldSourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *CertifyScorecardMutation) ResetSourceID() {
	m.source = nil
}

// SetScorecardID sets the "scorecard_id" field.
func (m *CertifyScorecardMutation) SetScorecardID(i int) {
	m.scorecard = &i
}

// ScorecardID returns the value of the "scorecard_id" field in the mutation.
func (m *CertifyScorecardMutation) ScorecardID() (r int, exists bool) {
	v := m.scorecard
	if v == nil {
		return
	}
	return *v, true
}

// OldScorecardID returns the old "scorecard_id" field's value of the CertifyScorecard entity.
// If the CertifyScorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyScorecardMutation) OldScorecardID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScorecardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScorecardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScorecardID: %w", err)
	}
	return oldValue.ScorecardID, nil
}

// ResetScorecardID resets all changes to the "scorecard_id" field.
func (m *CertifyScorecardMutation) ResetScorecardID() {
	m.scorecard = nil
}

// ClearScorecard clears the "scorecard" edge to the Scorecard entity.
func (m *CertifyScorecardMutation) ClearScorecard() {
	m.clearedscorecard = true
	m.clearedFields[certifyscorecard.FieldScorecardID] = struct{}{}
}

// ScorecardCleared reports if the "scorecard" edge to the Scorecard entity was cleared.
func (m *CertifyScorecardMutation) ScorecardCleared() bool {
	return m.clearedscorecard
}

// ScorecardIDs returns the "scorecard" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScorecardID instead. It exists only for internal usage by the builders.
func (m *CertifyScorecardMutation) ScorecardIDs() (ids []int) {
	if id := m.scorecard; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScorecard resets all changes to the "scorecard" edge.
func (m *CertifyScorecardMutation) ResetScorecard() {
	m.scorecard = nil
	m.clearedscorecard = false
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *CertifyScorecardMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[certifyscorecard.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *CertifyScorecardMutation) SourceCleared() bool {
	return m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *CertifyScorecardMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *CertifyScorecardMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Where appends a list predicates to the CertifyScorecardMutation builder.
func (m *CertifyScorecardMutation) Where(ps ...predicate.CertifyScorecard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertifyScorecardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertifyScorecardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CertifyScorecard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertifyScorecardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertifyScorecardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CertifyScorecard).
func (m *CertifyScorecardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertifyScorecardMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.source != nil {
		fields = append(fields, certifyscorecard.FieldSourceID)
	}
	if m.scorecard != nil {
		fields = append(fields, certifyscorecard.FieldScorecardID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertifyScorecardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certifyscorecard.FieldSourceID:
		return m.SourceID()
	case certifyscorecard.FieldScorecardID:
		return m.ScorecardID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertifyScorecardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certifyscorecard.FieldSourceID:
		return m.OldSourceID(ctx)
	case certifyscorecard.FieldScorecardID:
		return m.OldScorecardID(ctx)
	}
	return nil, fmt.Errorf("unknown CertifyScorecard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyScorecardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certifyscorecard.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case certifyscorecard.FieldScorecardID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScorecardID(v)
		return nil
	}
	return fmt.Errorf("unknown CertifyScorecard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertifyScorecardMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertifyScorecardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyScorecardMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CertifyScorecard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertifyScorecardMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertifyScorecardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertifyScorecardMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CertifyScorecard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertifyScorecardMutation) ResetField(name string) error {
	switch name {
	case certifyscorecard.FieldSourceID:
		m.ResetSourceID()
		return nil
	case certifyscorecard.FieldScorecardID:
		m.ResetScorecardID()
		return nil
	}
	return fmt.Errorf("unknown CertifyScorecard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertifyScorecardMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.scorecard != nil {
		edges = append(edges, certifyscorecard.EdgeScorecard)
	}
	if m.source != nil {
		edges = append(edges, certifyscorecard.EdgeSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertifyScorecardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certifyscorecard.EdgeScorecard:
		if id := m.scorecard; id != nil {
			return []ent.Value{*id}
		}
	case certifyscorecard.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertifyScorecardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertifyScorecardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertifyScorecardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedscorecard {
		edges = append(edges, certifyscorecard.EdgeScorecard)
	}
	if m.clearedsource {
		edges = append(edges, certifyscorecard.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertifyScorecardMutation) EdgeCleared(name string) bool {
	switch name {
	case certifyscorecard.EdgeScorecard:
		return m.clearedscorecard
	case certifyscorecard.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertifyScorecardMutation) ClearEdge(name string) error {
	switch name {
	case certifyscorecard.EdgeScorecard:
		m.ClearScorecard()
		return nil
	case certifyscorecard.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown CertifyScorecard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertifyScorecardMutation) ResetEdge(name string) error {
	switch name {
	case certifyscorecard.EdgeScorecard:
		m.ResetScorecard()
		return nil
	case certifyscorecard.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown CertifyScorecard edge %s", name)
}

// CertifyVexMutation represents an operation that mutates the CertifyVex nodes in the graph.
type CertifyVexMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	known_since          *time.Time
	status               *string
	statement            *string
	status_notes         *string
	justification        *string
	origin               *string
	collector            *string
	clearedFields        map[string]struct{}
	_package             *int
	cleared_package      bool
	artifact             *int
	clearedartifact      bool
	vulnerability        *int
	clearedvulnerability bool
	done                 bool
	oldValue             func(context.Context) (*CertifyVex, error)
	predicates           []predicate.CertifyVex
}

var _ ent.Mutation = (*CertifyVexMutation)(nil)

// certifyvexOption allows management of the mutation configuration using functional options.
type certifyvexOption func(*CertifyVexMutation)

// newCertifyVexMutation creates new mutation for the CertifyVex entity.
func newCertifyVexMutation(c config, op Op, opts ...certifyvexOption) *CertifyVexMutation {
	m := &CertifyVexMutation{
		config:        c,
		op:            op,
		typ:           TypeCertifyVex,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertifyVexID sets the ID field of the mutation.
func withCertifyVexID(id int) certifyvexOption {
	return func(m *CertifyVexMutation) {
		var (
			err   error
			once  sync.Once
			value *CertifyVex
		)
		m.oldValue = func(ctx context.Context) (*CertifyVex, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertifyVex.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertifyVex sets the old CertifyVex of the mutation.
func withCertifyVex(node *CertifyVex) certifyvexOption {
	return func(m *CertifyVexMutation) {
		m.oldValue = func(context.Context) (*CertifyVex, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertifyVexMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertifyVexMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertifyVexMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertifyVexMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertifyVex.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *CertifyVexMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *CertifyVexMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldPackageID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *CertifyVexMutation) ClearPackageID() {
	m._package = nil
	m.clearedFields[certifyvex.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *CertifyVexMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[certifyvex.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *CertifyVexMutation) ResetPackageID() {
	m._package = nil
	delete(m.clearedFields, certifyvex.FieldPackageID)
}

// SetArtifactID sets the "artifact_id" field.
func (m *CertifyVexMutation) SetArtifactID(i int) {
	m.artifact = &i
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *CertifyVexMutation) ArtifactID() (r int, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldArtifactID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ClearArtifactID clears the value of the "artifact_id" field.
func (m *CertifyVexMutation) ClearArtifactID() {
	m.artifact = nil
	m.clearedFields[certifyvex.FieldArtifactID] = struct{}{}
}

// ArtifactIDCleared returns if the "artifact_id" field was cleared in this mutation.
func (m *CertifyVexMutation) ArtifactIDCleared() bool {
	_, ok := m.clearedFields[certifyvex.FieldArtifactID]
	return ok
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *CertifyVexMutation) ResetArtifactID() {
	m.artifact = nil
	delete(m.clearedFields, certifyvex.FieldArtifactID)
}

// SetVulnerabilityID sets the "vulnerability_id" field.
func (m *CertifyVexMutation) SetVulnerabilityID(i int) {
	m.vulnerability = &i
}

// VulnerabilityID returns the value of the "vulnerability_id" field in the mutation.
func (m *CertifyVexMutation) VulnerabilityID() (r int, exists bool) {
	v := m.vulnerability
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnerabilityID returns the old "vulnerability_id" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldVulnerabilityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVulnerabilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVulnerabilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnerabilityID: %w", err)
	}
	return oldValue.VulnerabilityID, nil
}

// ResetVulnerabilityID resets all changes to the "vulnerability_id" field.
func (m *CertifyVexMutation) ResetVulnerabilityID() {
	m.vulnerability = nil
}

// SetKnownSince sets the "known_since" field.
func (m *CertifyVexMutation) SetKnownSince(t time.Time) {
	m.known_since = &t
}

// KnownSince returns the value of the "known_since" field in the mutation.
func (m *CertifyVexMutation) KnownSince() (r time.Time, exists bool) {
	v := m.known_since
	if v == nil {
		return
	}
	return *v, true
}

// OldKnownSince returns the old "known_since" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldKnownSince(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnownSince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnownSince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnownSince: %w", err)
	}
	return oldValue.KnownSince, nil
}

// ResetKnownSince resets all changes to the "known_since" field.
func (m *CertifyVexMutation) ResetKnownSince() {
	m.known_since = nil
}

// SetStatus sets the "status" field.
func (m *CertifyVexMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CertifyVexMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CertifyVexMutation) ResetStatus() {
	m.status = nil
}

// SetStatement sets the "statement" field.
func (m *CertifyVexMutation) SetStatement(s string) {
	m.statement = &s
}

// Statement returns the value of the "statement" field in the mutation.
func (m *CertifyVexMutation) Statement() (r string, exists bool) {
	v := m.statement
	if v == nil {
		return
	}
	return *v, true
}

// OldStatement returns the old "statement" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldStatement(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatement: %w", err)
	}
	return oldValue.Statement, nil
}

// ResetStatement resets all changes to the "statement" field.
func (m *CertifyVexMutation) ResetStatement() {
	m.statement = nil
}

// SetStatusNotes sets the "status_notes" field.
func (m *CertifyVexMutation) SetStatusNotes(s string) {
	m.status_notes = &s
}

// StatusNotes returns the value of the "status_notes" field in the mutation.
func (m *CertifyVexMutation) StatusNotes() (r string, exists bool) {
	v := m.status_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusNotes returns the old "status_notes" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldStatusNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusNotes: %w", err)
	}
	return oldValue.StatusNotes, nil
}

// ResetStatusNotes resets all changes to the "status_notes" field.
func (m *CertifyVexMutation) ResetStatusNotes() {
	m.status_notes = nil
}

// SetJustification sets the "justification" field.
func (m *CertifyVexMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *CertifyVexMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *CertifyVexMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *CertifyVexMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *CertifyVexMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *CertifyVexMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *CertifyVexMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *CertifyVexMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the CertifyVex entity.
// If the CertifyVex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVexMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *CertifyVexMutation) ResetCollector() {
	m.collector = nil
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *CertifyVexMutation) ClearPackage() {
	m.cleared_package = true
	m.clearedFields[certifyvex.FieldPackageID] = struct{}{}
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *CertifyVexMutation) PackageCleared() bool {
	return m.PackageIDCleared() || m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *CertifyVexMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *CertifyVexMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *CertifyVexMutation) ClearArtifact() {
	m.clearedartifact = true
	m.clearedFields[certifyvex.FieldArtifactID] = struct{}{}
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *CertifyVexMutation) ArtifactCleared() bool {
	return m.ArtifactIDCleared() || m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *CertifyVexMutation) ArtifactIDs() (ids []int) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *CertifyVexMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// ClearVulnerability clears the "vulnerability" edge to the VulnerabilityID entity.
func (m *CertifyVexMutation) ClearVulnerability() {
	m.clearedvulnerability = true
	m.clearedFields[certifyvex.FieldVulnerabilityID] = struct{}{}
}

// VulnerabilityCleared reports if the "vulnerability" edge to the VulnerabilityID entity was cleared.
func (m *CertifyVexMutation) VulnerabilityCleared() bool {
	return m.clearedvulnerability
}

// VulnerabilityIDs returns the "vulnerability" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityID instead. It exists only for internal usage by the builders.
func (m *CertifyVexMutation) VulnerabilityIDs() (ids []int) {
	if id := m.vulnerability; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerability resets all changes to the "vulnerability" edge.
func (m *CertifyVexMutation) ResetVulnerability() {
	m.vulnerability = nil
	m.clearedvulnerability = false
}

// Where appends a list predicates to the CertifyVexMutation builder.
func (m *CertifyVexMutation) Where(ps ...predicate.CertifyVex) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertifyVexMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertifyVexMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CertifyVex, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertifyVexMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertifyVexMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CertifyVex).
func (m *CertifyVexMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertifyVexMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m._package != nil {
		fields = append(fields, certifyvex.FieldPackageID)
	}
	if m.artifact != nil {
		fields = append(fields, certifyvex.FieldArtifactID)
	}
	if m.vulnerability != nil {
		fields = append(fields, certifyvex.FieldVulnerabilityID)
	}
	if m.known_since != nil {
		fields = append(fields, certifyvex.FieldKnownSince)
	}
	if m.status != nil {
		fields = append(fields, certifyvex.FieldStatus)
	}
	if m.statement != nil {
		fields = append(fields, certifyvex.FieldStatement)
	}
	if m.status_notes != nil {
		fields = append(fields, certifyvex.FieldStatusNotes)
	}
	if m.justification != nil {
		fields = append(fields, certifyvex.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, certifyvex.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, certifyvex.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertifyVexMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certifyvex.FieldPackageID:
		return m.PackageID()
	case certifyvex.FieldArtifactID:
		return m.ArtifactID()
	case certifyvex.FieldVulnerabilityID:
		return m.VulnerabilityID()
	case certifyvex.FieldKnownSince:
		return m.KnownSince()
	case certifyvex.FieldStatus:
		return m.Status()
	case certifyvex.FieldStatement:
		return m.Statement()
	case certifyvex.FieldStatusNotes:
		return m.StatusNotes()
	case certifyvex.FieldJustification:
		return m.Justification()
	case certifyvex.FieldOrigin:
		return m.Origin()
	case certifyvex.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertifyVexMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certifyvex.FieldPackageID:
		return m.OldPackageID(ctx)
	case certifyvex.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case certifyvex.FieldVulnerabilityID:
		return m.OldVulnerabilityID(ctx)
	case certifyvex.FieldKnownSince:
		return m.OldKnownSince(ctx)
	case certifyvex.FieldStatus:
		return m.OldStatus(ctx)
	case certifyvex.FieldStatement:
		return m.OldStatement(ctx)
	case certifyvex.FieldStatusNotes:
		return m.OldStatusNotes(ctx)
	case certifyvex.FieldJustification:
		return m.OldJustification(ctx)
	case certifyvex.FieldOrigin:
		return m.OldOrigin(ctx)
	case certifyvex.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown CertifyVex field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyVexMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certifyvex.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case certifyvex.FieldArtifactID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case certifyvex.FieldVulnerabilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnerabilityID(v)
		return nil
	case certifyvex.FieldKnownSince:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnownSince(v)
		return nil
	case certifyvex.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case certifyvex.FieldStatement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatement(v)
		return nil
	case certifyvex.FieldStatusNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusNotes(v)
		return nil
	case certifyvex.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case certifyvex.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case certifyvex.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown CertifyVex field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertifyVexMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertifyVexMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyVexMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CertifyVex numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertifyVexMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certifyvex.FieldPackageID) {
		fields = append(fields, certifyvex.FieldPackageID)
	}
	if m.FieldCleared(certifyvex.FieldArtifactID) {
		fields = append(fields, certifyvex.FieldArtifactID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertifyVexMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertifyVexMutation) ClearField(name string) error {
	switch name {
	case certifyvex.FieldPackageID:
		m.ClearPackageID()
		return nil
	case certifyvex.FieldArtifactID:
		m.ClearArtifactID()
		return nil
	}
	return fmt.Errorf("unknown CertifyVex nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertifyVexMutation) ResetField(name string) error {
	switch name {
	case certifyvex.FieldPackageID:
		m.ResetPackageID()
		return nil
	case certifyvex.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case certifyvex.FieldVulnerabilityID:
		m.ResetVulnerabilityID()
		return nil
	case certifyvex.FieldKnownSince:
		m.ResetKnownSince()
		return nil
	case certifyvex.FieldStatus:
		m.ResetStatus()
		return nil
	case certifyvex.FieldStatement:
		m.ResetStatement()
		return nil
	case certifyvex.FieldStatusNotes:
		m.ResetStatusNotes()
		return nil
	case certifyvex.FieldJustification:
		m.ResetJustification()
		return nil
	case certifyvex.FieldOrigin:
		m.ResetOrigin()
		return nil
	case certifyvex.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown CertifyVex field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertifyVexMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._package != nil {
		edges = append(edges, certifyvex.EdgePackage)
	}
	if m.artifact != nil {
		edges = append(edges, certifyvex.EdgeArtifact)
	}
	if m.vulnerability != nil {
		edges = append(edges, certifyvex.EdgeVulnerability)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertifyVexMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certifyvex.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case certifyvex.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	case certifyvex.EdgeVulnerability:
		if id := m.vulnerability; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertifyVexMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertifyVexMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertifyVexMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_package {
		edges = append(edges, certifyvex.EdgePackage)
	}
	if m.clearedartifact {
		edges = append(edges, certifyvex.EdgeArtifact)
	}
	if m.clearedvulnerability {
		edges = append(edges, certifyvex.EdgeVulnerability)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertifyVexMutation) EdgeCleared(name string) bool {
	switch name {
	case certifyvex.EdgePackage:
		return m.cleared_package
	case certifyvex.EdgeArtifact:
		return m.clearedartifact
	case certifyvex.EdgeVulnerability:
		return m.clearedvulnerability
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertifyVexMutation) ClearEdge(name string) error {
	switch name {
	case certifyvex.EdgePackage:
		m.ClearPackage()
		return nil
	case certifyvex.EdgeArtifact:
		m.ClearArtifact()
		return nil
	case certifyvex.EdgeVulnerability:
		m.ClearVulnerability()
		return nil
	}
	return fmt.Errorf("unknown CertifyVex unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertifyVexMutation) ResetEdge(name string) error {
	switch name {
	case certifyvex.EdgePackage:
		m.ResetPackage()
		return nil
	case certifyvex.EdgeArtifact:
		m.ResetArtifact()
		return nil
	case certifyvex.EdgeVulnerability:
		m.ResetVulnerability()
		return nil
	}
	return fmt.Errorf("unknown CertifyVex edge %s", name)
}

// CertifyVulnMutation represents an operation that mutates the CertifyVuln nodes in the graph.
type CertifyVulnMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	time_scanned         *time.Time
	db_uri               *string
	db_version           *string
	scanner_uri          *string
	scanner_version      *string
	origin               *string
	collector            *string
	clearedFields        map[string]struct{}
	vulnerability        *int
	clearedvulnerability bool
	_package             *int
	cleared_package      bool
	done                 bool
	oldValue             func(context.Context) (*CertifyVuln, error)
	predicates           []predicate.CertifyVuln
}

var _ ent.Mutation = (*CertifyVulnMutation)(nil)

// certifyvulnOption allows management of the mutation configuration using functional options.
type certifyvulnOption func(*CertifyVulnMutation)

// newCertifyVulnMutation creates new mutation for the CertifyVuln entity.
func newCertifyVulnMutation(c config, op Op, opts ...certifyvulnOption) *CertifyVulnMutation {
	m := &CertifyVulnMutation{
		config:        c,
		op:            op,
		typ:           TypeCertifyVuln,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertifyVulnID sets the ID field of the mutation.
func withCertifyVulnID(id int) certifyvulnOption {
	return func(m *CertifyVulnMutation) {
		var (
			err   error
			once  sync.Once
			value *CertifyVuln
		)
		m.oldValue = func(ctx context.Context) (*CertifyVuln, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertifyVuln.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertifyVuln sets the old CertifyVuln of the mutation.
func withCertifyVuln(node *CertifyVuln) certifyvulnOption {
	return func(m *CertifyVulnMutation) {
		m.oldValue = func(context.Context) (*CertifyVuln, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertifyVulnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertifyVulnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertifyVulnMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertifyVulnMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertifyVuln.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVulnerabilityID sets the "vulnerability_id" field.
func (m *CertifyVulnMutation) SetVulnerabilityID(i int) {
	m.vulnerability = &i
}

// VulnerabilityID returns the value of the "vulnerability_id" field in the mutation.
func (m *CertifyVulnMutation) VulnerabilityID() (r int, exists bool) {
	v := m.vulnerability
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnerabilityID returns the old "vulnerability_id" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldVulnerabilityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVulnerabilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVulnerabilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnerabilityID: %w", err)
	}
	return oldValue.VulnerabilityID, nil
}

// ResetVulnerabilityID resets all changes to the "vulnerability_id" field.
func (m *CertifyVulnMutation) ResetVulnerabilityID() {
	m.vulnerability = nil
}

// SetPackageID sets the "package_id" field.
func (m *CertifyVulnMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *CertifyVulnMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldPackageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *CertifyVulnMutation) ResetPackageID() {
	m._package = nil
}

// SetTimeScanned sets the "time_scanned" field.
func (m *CertifyVulnMutation) SetTimeScanned(t time.Time) {
	m.time_scanned = &t
}

// TimeScanned returns the value of the "time_scanned" field in the mutation.
func (m *CertifyVulnMutation) TimeScanned() (r time.Time, exists bool) {
	v := m.time_scanned
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeScanned returns the old "time_scanned" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldTimeScanned(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeScanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeScanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeScanned: %w", err)
	}
	return oldValue.TimeScanned, nil
}

// ResetTimeScanned resets all changes to the "time_scanned" field.
func (m *CertifyVulnMutation) ResetTimeScanned() {
	m.time_scanned = nil
}

// SetDbURI sets the "db_uri" field.
func (m *CertifyVulnMutation) SetDbURI(s string) {
	m.db_uri = &s
}

// DbURI returns the value of the "db_uri" field in the mutation.
func (m *CertifyVulnMutation) DbURI() (r string, exists bool) {
	v := m.db_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldDbURI returns the old "db_uri" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldDbURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDbURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDbURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDbURI: %w", err)
	}
	return oldValue.DbURI, nil
}

// ResetDbURI resets all changes to the "db_uri" field.
func (m *CertifyVulnMutation) ResetDbURI() {
	m.db_uri = nil
}

// SetDbVersion sets the "db_version" field.
func (m *CertifyVulnMutation) SetDbVersion(s string) {
	m.db_version = &s
}

// DbVersion returns the value of the "db_version" field in the mutation.
func (m *CertifyVulnMutation) DbVersion() (r string, exists bool) {
	v := m.db_version
	if v == nil {
		return
	}
	return *v, true
}

// OldDbVersion returns the old "db_version" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldDbVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDbVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDbVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDbVersion: %w", err)
	}
	return oldValue.DbVersion, nil
}

// ResetDbVersion resets all changes to the "db_version" field.
func (m *CertifyVulnMutation) ResetDbVersion() {
	m.db_version = nil
}

// SetScannerURI sets the "scanner_uri" field.
func (m *CertifyVulnMutation) SetScannerURI(s string) {
	m.scanner_uri = &s
}

// ScannerURI returns the value of the "scanner_uri" field in the mutation.
func (m *CertifyVulnMutation) ScannerURI() (r string, exists bool) {
	v := m.scanner_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldScannerURI returns the old "scanner_uri" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldScannerURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScannerURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScannerURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScannerURI: %w", err)
	}
	return oldValue.ScannerURI, nil
}

// ResetScannerURI resets all changes to the "scanner_uri" field.
func (m *CertifyVulnMutation) ResetScannerURI() {
	m.scanner_uri = nil
}

// SetScannerVersion sets the "scanner_version" field.
func (m *CertifyVulnMutation) SetScannerVersion(s string) {
	m.scanner_version = &s
}

// ScannerVersion returns the value of the "scanner_version" field in the mutation.
func (m *CertifyVulnMutation) ScannerVersion() (r string, exists bool) {
	v := m.scanner_version
	if v == nil {
		return
	}
	return *v, true
}

// OldScannerVersion returns the old "scanner_version" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldScannerVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScannerVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScannerVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScannerVersion: %w", err)
	}
	return oldValue.ScannerVersion, nil
}

// ResetScannerVersion resets all changes to the "scanner_version" field.
func (m *CertifyVulnMutation) ResetScannerVersion() {
	m.scanner_version = nil
}

// SetOrigin sets the "origin" field.
func (m *CertifyVulnMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *CertifyVulnMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *CertifyVulnMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *CertifyVulnMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *CertifyVulnMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the CertifyVuln entity.
// If the CertifyVuln object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertifyVulnMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *CertifyVulnMutation) ResetCollector() {
	m.collector = nil
}

// ClearVulnerability clears the "vulnerability" edge to the VulnerabilityID entity.
func (m *CertifyVulnMutation) ClearVulnerability() {
	m.clearedvulnerability = true
	m.clearedFields[certifyvuln.FieldVulnerabilityID] = struct{}{}
}

// VulnerabilityCleared reports if the "vulnerability" edge to the VulnerabilityID entity was cleared.
func (m *CertifyVulnMutation) VulnerabilityCleared() bool {
	return m.clearedvulnerability
}

// VulnerabilityIDs returns the "vulnerability" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityID instead. It exists only for internal usage by the builders.
func (m *CertifyVulnMutation) VulnerabilityIDs() (ids []int) {
	if id := m.vulnerability; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerability resets all changes to the "vulnerability" edge.
func (m *CertifyVulnMutation) ResetVulnerability() {
	m.vulnerability = nil
	m.clearedvulnerability = false
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *CertifyVulnMutation) ClearPackage() {
	m.cleared_package = true
	m.clearedFields[certifyvuln.FieldPackageID] = struct{}{}
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *CertifyVulnMutation) PackageCleared() bool {
	return m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *CertifyVulnMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *CertifyVulnMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// Where appends a list predicates to the CertifyVulnMutation builder.
func (m *CertifyVulnMutation) Where(ps ...predicate.CertifyVuln) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertifyVulnMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertifyVulnMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CertifyVuln, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertifyVulnMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertifyVulnMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CertifyVuln).
func (m *CertifyVulnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertifyVulnMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.vulnerability != nil {
		fields = append(fields, certifyvuln.FieldVulnerabilityID)
	}
	if m._package != nil {
		fields = append(fields, certifyvuln.FieldPackageID)
	}
	if m.time_scanned != nil {
		fields = append(fields, certifyvuln.FieldTimeScanned)
	}
	if m.db_uri != nil {
		fields = append(fields, certifyvuln.FieldDbURI)
	}
	if m.db_version != nil {
		fields = append(fields, certifyvuln.FieldDbVersion)
	}
	if m.scanner_uri != nil {
		fields = append(fields, certifyvuln.FieldScannerURI)
	}
	if m.scanner_version != nil {
		fields = append(fields, certifyvuln.FieldScannerVersion)
	}
	if m.origin != nil {
		fields = append(fields, certifyvuln.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, certifyvuln.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertifyVulnMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certifyvuln.FieldVulnerabilityID:
		return m.VulnerabilityID()
	case certifyvuln.FieldPackageID:
		return m.PackageID()
	case certifyvuln.FieldTimeScanned:
		return m.TimeScanned()
	case certifyvuln.FieldDbURI:
		return m.DbURI()
	case certifyvuln.FieldDbVersion:
		return m.DbVersion()
	case certifyvuln.FieldScannerURI:
		return m.ScannerURI()
	case certifyvuln.FieldScannerVersion:
		return m.ScannerVersion()
	case certifyvuln.FieldOrigin:
		return m.Origin()
	case certifyvuln.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertifyVulnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certifyvuln.FieldVulnerabilityID:
		return m.OldVulnerabilityID(ctx)
	case certifyvuln.FieldPackageID:
		return m.OldPackageID(ctx)
	case certifyvuln.FieldTimeScanned:
		return m.OldTimeScanned(ctx)
	case certifyvuln.FieldDbURI:
		return m.OldDbURI(ctx)
	case certifyvuln.FieldDbVersion:
		return m.OldDbVersion(ctx)
	case certifyvuln.FieldScannerURI:
		return m.OldScannerURI(ctx)
	case certifyvuln.FieldScannerVersion:
		return m.OldScannerVersion(ctx)
	case certifyvuln.FieldOrigin:
		return m.OldOrigin(ctx)
	case certifyvuln.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown CertifyVuln field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyVulnMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certifyvuln.FieldVulnerabilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnerabilityID(v)
		return nil
	case certifyvuln.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case certifyvuln.FieldTimeScanned:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeScanned(v)
		return nil
	case certifyvuln.FieldDbURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDbURI(v)
		return nil
	case certifyvuln.FieldDbVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDbVersion(v)
		return nil
	case certifyvuln.FieldScannerURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScannerURI(v)
		return nil
	case certifyvuln.FieldScannerVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScannerVersion(v)
		return nil
	case certifyvuln.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case certifyvuln.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown CertifyVuln field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertifyVulnMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertifyVulnMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertifyVulnMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CertifyVuln numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertifyVulnMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertifyVulnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertifyVulnMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CertifyVuln nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertifyVulnMutation) ResetField(name string) error {
	switch name {
	case certifyvuln.FieldVulnerabilityID:
		m.ResetVulnerabilityID()
		return nil
	case certifyvuln.FieldPackageID:
		m.ResetPackageID()
		return nil
	case certifyvuln.FieldTimeScanned:
		m.ResetTimeScanned()
		return nil
	case certifyvuln.FieldDbURI:
		m.ResetDbURI()
		return nil
	case certifyvuln.FieldDbVersion:
		m.ResetDbVersion()
		return nil
	case certifyvuln.FieldScannerURI:
		m.ResetScannerURI()
		return nil
	case certifyvuln.FieldScannerVersion:
		m.ResetScannerVersion()
		return nil
	case certifyvuln.FieldOrigin:
		m.ResetOrigin()
		return nil
	case certifyvuln.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown CertifyVuln field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertifyVulnMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.vulnerability != nil {
		edges = append(edges, certifyvuln.EdgeVulnerability)
	}
	if m._package != nil {
		edges = append(edges, certifyvuln.EdgePackage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertifyVulnMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certifyvuln.EdgeVulnerability:
		if id := m.vulnerability; id != nil {
			return []ent.Value{*id}
		}
	case certifyvuln.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertifyVulnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertifyVulnMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertifyVulnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvulnerability {
		edges = append(edges, certifyvuln.EdgeVulnerability)
	}
	if m.cleared_package {
		edges = append(edges, certifyvuln.EdgePackage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertifyVulnMutation) EdgeCleared(name string) bool {
	switch name {
	case certifyvuln.EdgeVulnerability:
		return m.clearedvulnerability
	case certifyvuln.EdgePackage:
		return m.cleared_package
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertifyVulnMutation) ClearEdge(name string) error {
	switch name {
	case certifyvuln.EdgeVulnerability:
		m.ClearVulnerability()
		return nil
	case certifyvuln.EdgePackage:
		m.ClearPackage()
		return nil
	}
	return fmt.Errorf("unknown CertifyVuln unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertifyVulnMutation) ResetEdge(name string) error {
	switch name {
	case certifyvuln.EdgeVulnerability:
		m.ResetVulnerability()
		return nil
	case certifyvuln.EdgePackage:
		m.ResetPackage()
		return nil
	}
	return fmt.Errorf("unknown CertifyVuln edge %s", name)
}

// DependencyMutation represents an operation that mutates the Dependency nodes in the graph.
type DependencyMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	version_range                    *string
	dependency_type                  *dependency.DependencyType
	justification                    *string
	origin                           *string
	collector                        *string
	clearedFields                    map[string]struct{}
	_package                         *int
	cleared_package                  bool
	dependent_package_name           *int
	cleareddependent_package_name    bool
	dependent_package_version        *int
	cleareddependent_package_version bool
	done                             bool
	oldValue                         func(context.Context) (*Dependency, error)
	predicates                       []predicate.Dependency
}

var _ ent.Mutation = (*DependencyMutation)(nil)

// dependencyOption allows management of the mutation configuration using functional options.
type dependencyOption func(*DependencyMutation)

// newDependencyMutation creates new mutation for the Dependency entity.
func newDependencyMutation(c config, op Op, opts ...dependencyOption) *DependencyMutation {
	m := &DependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDependencyID sets the ID field of the mutation.
func withDependencyID(id int) dependencyOption {
	return func(m *DependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Dependency
		)
		m.oldValue = func(ctx context.Context) (*Dependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDependency sets the old Dependency of the mutation.
func withDependency(node *Dependency) dependencyOption {
	return func(m *DependencyMutation) {
		m.oldValue = func(context.Context) (*Dependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DependencyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DependencyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *DependencyMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *DependencyMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldPackageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *DependencyMutation) ResetPackageID() {
	m._package = nil
}

// SetDependentPackageNameID sets the "dependent_package_name_id" field.
func (m *DependencyMutation) SetDependentPackageNameID(i int) {
	m.dependent_package_name = &i
}

// DependentPackageNameID returns the value of the "dependent_package_name_id" field in the mutation.
func (m *DependencyMutation) DependentPackageNameID() (r int, exists bool) {
	v := m.dependent_package_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDependentPackageNameID returns the old "dependent_package_name_id" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldDependentPackageNameID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependentPackageNameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependentPackageNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependentPackageNameID: %w", err)
	}
	return oldValue.DependentPackageNameID, nil
}

// ClearDependentPackageNameID clears the value of the "dependent_package_name_id" field.
func (m *DependencyMutation) ClearDependentPackageNameID() {
	m.dependent_package_name = nil
	m.clearedFields[dependency.FieldDependentPackageNameID] = struct{}{}
}

// DependentPackageNameIDCleared returns if the "dependent_package_name_id" field was cleared in this mutation.
func (m *DependencyMutation) DependentPackageNameIDCleared() bool {
	_, ok := m.clearedFields[dependency.FieldDependentPackageNameID]
	return ok
}

// ResetDependentPackageNameID resets all changes to the "dependent_package_name_id" field.
func (m *DependencyMutation) ResetDependentPackageNameID() {
	m.dependent_package_name = nil
	delete(m.clearedFields, dependency.FieldDependentPackageNameID)
}

// SetDependentPackageVersionID sets the "dependent_package_version_id" field.
func (m *DependencyMutation) SetDependentPackageVersionID(i int) {
	m.dependent_package_version = &i
}

// DependentPackageVersionID returns the value of the "dependent_package_version_id" field in the mutation.
func (m *DependencyMutation) DependentPackageVersionID() (r int, exists bool) {
	v := m.dependent_package_version
	if v == nil {
		return
	}
	return *v, true
}

// OldDependentPackageVersionID returns the old "dependent_package_version_id" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldDependentPackageVersionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependentPackageVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependentPackageVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependentPackageVersionID: %w", err)
	}
	return oldValue.DependentPackageVersionID, nil
}

// ClearDependentPackageVersionID clears the value of the "dependent_package_version_id" field.
func (m *DependencyMutation) ClearDependentPackageVersionID() {
	m.dependent_package_version = nil
	m.clearedFields[dependency.FieldDependentPackageVersionID] = struct{}{}
}

// DependentPackageVersionIDCleared returns if the "dependent_package_version_id" field was cleared in this mutation.
func (m *DependencyMutation) DependentPackageVersionIDCleared() bool {
	_, ok := m.clearedFields[dependency.FieldDependentPackageVersionID]
	return ok
}

// ResetDependentPackageVersionID resets all changes to the "dependent_package_version_id" field.
func (m *DependencyMutation) ResetDependentPackageVersionID() {
	m.dependent_package_version = nil
	delete(m.clearedFields, dependency.FieldDependentPackageVersionID)
}

// SetVersionRange sets the "version_range" field.
func (m *DependencyMutation) SetVersionRange(s string) {
	m.version_range = &s
}

// VersionRange returns the value of the "version_range" field in the mutation.
func (m *DependencyMutation) VersionRange() (r string, exists bool) {
	v := m.version_range
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionRange returns the old "version_range" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldVersionRange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionRange: %w", err)
	}
	return oldValue.VersionRange, nil
}

// ResetVersionRange resets all changes to the "version_range" field.
func (m *DependencyMutation) ResetVersionRange() {
	m.version_range = nil
}

// SetDependencyType sets the "dependency_type" field.
func (m *DependencyMutation) SetDependencyType(dt dependency.DependencyType) {
	m.dependency_type = &dt
}

// DependencyType returns the value of the "dependency_type" field in the mutation.
func (m *DependencyMutation) DependencyType() (r dependency.DependencyType, exists bool) {
	v := m.dependency_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyType returns the old "dependency_type" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldDependencyType(ctx context.Context) (v dependency.DependencyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyType: %w", err)
	}
	return oldValue.DependencyType, nil
}

// ResetDependencyType resets all changes to the "dependency_type" field.
func (m *DependencyMutation) ResetDependencyType() {
	m.dependency_type = nil
}

// SetJustification sets the "justification" field.
func (m *DependencyMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *DependencyMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *DependencyMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *DependencyMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *DependencyMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *DependencyMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *DependencyMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *DependencyMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *DependencyMutation) ResetCollector() {
	m.collector = nil
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *DependencyMutation) ClearPackage() {
	m.cleared_package = true
	m.clearedFields[dependency.FieldPackageID] = struct{}{}
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *DependencyMutation) PackageCleared() bool {
	return m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *DependencyMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *DependencyMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearDependentPackageName clears the "dependent_package_name" edge to the PackageName entity.
func (m *DependencyMutation) ClearDependentPackageName() {
	m.cleareddependent_package_name = true
	m.clearedFields[dependency.FieldDependentPackageNameID] = struct{}{}
}

// DependentPackageNameCleared reports if the "dependent_package_name" edge to the PackageName entity was cleared.
func (m *DependencyMutation) DependentPackageNameCleared() bool {
	return m.DependentPackageNameIDCleared() || m.cleareddependent_package_name
}

// DependentPackageNameIDs returns the "dependent_package_name" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DependentPackageNameID instead. It exists only for internal usage by the builders.
func (m *DependencyMutation) DependentPackageNameIDs() (ids []int) {
	if id := m.dependent_package_name; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDependentPackageName resets all changes to the "dependent_package_name" edge.
func (m *DependencyMutation) ResetDependentPackageName() {
	m.dependent_package_name = nil
	m.cleareddependent_package_name = false
}

// ClearDependentPackageVersion clears the "dependent_package_version" edge to the PackageVersion entity.
func (m *DependencyMutation) ClearDependentPackageVersion() {
	m.cleareddependent_package_version = true
	m.clearedFields[dependency.FieldDependentPackageVersionID] = struct{}{}
}

// DependentPackageVersionCleared reports if the "dependent_package_version" edge to the PackageVersion entity was cleared.
func (m *DependencyMutation) DependentPackageVersionCleared() bool {
	return m.DependentPackageVersionIDCleared() || m.cleareddependent_package_version
}

// DependentPackageVersionIDs returns the "dependent_package_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DependentPackageVersionID instead. It exists only for internal usage by the builders.
func (m *DependencyMutation) DependentPackageVersionIDs() (ids []int) {
	if id := m.dependent_package_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDependentPackageVersion resets all changes to the "dependent_package_version" edge.
func (m *DependencyMutation) ResetDependentPackageVersion() {
	m.dependent_package_version = nil
	m.cleareddependent_package_version = false
}

// Where appends a list predicates to the DependencyMutation builder.
func (m *DependencyMutation) Where(ps ...predicate.Dependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dependency).
func (m *DependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DependencyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._package != nil {
		fields = append(fields, dependency.FieldPackageID)
	}
	if m.dependent_package_name != nil {
		fields = append(fields, dependency.FieldDependentPackageNameID)
	}
	if m.dependent_package_version != nil {
		fields = append(fields, dependency.FieldDependentPackageVersionID)
	}
	if m.version_range != nil {
		fields = append(fields, dependency.FieldVersionRange)
	}
	if m.dependency_type != nil {
		fields = append(fields, dependency.FieldDependencyType)
	}
	if m.justification != nil {
		fields = append(fields, dependency.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, dependency.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, dependency.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dependency.FieldPackageID:
		return m.PackageID()
	case dependency.FieldDependentPackageNameID:
		return m.DependentPackageNameID()
	case dependency.FieldDependentPackageVersionID:
		return m.DependentPackageVersionID()
	case dependency.FieldVersionRange:
		return m.VersionRange()
	case dependency.FieldDependencyType:
		return m.DependencyType()
	case dependency.FieldJustification:
		return m.Justification()
	case dependency.FieldOrigin:
		return m.Origin()
	case dependency.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dependency.FieldPackageID:
		return m.OldPackageID(ctx)
	case dependency.FieldDependentPackageNameID:
		return m.OldDependentPackageNameID(ctx)
	case dependency.FieldDependentPackageVersionID:
		return m.OldDependentPackageVersionID(ctx)
	case dependency.FieldVersionRange:
		return m.OldVersionRange(ctx)
	case dependency.FieldDependencyType:
		return m.OldDependencyType(ctx)
	case dependency.FieldJustification:
		return m.OldJustification(ctx)
	case dependency.FieldOrigin:
		return m.OldOrigin(ctx)
	case dependency.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown Dependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dependency.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case dependency.FieldDependentPackageNameID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependentPackageNameID(v)
		return nil
	case dependency.FieldDependentPackageVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependentPackageVersionID(v)
		return nil
	case dependency.FieldVersionRange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionRange(v)
		return nil
	case dependency.FieldDependencyType:
		v, ok := value.(dependency.DependencyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyType(v)
		return nil
	case dependency.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case dependency.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case dependency.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown Dependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DependencyMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DependencyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Dependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DependencyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dependency.FieldDependentPackageNameID) {
		fields = append(fields, dependency.FieldDependentPackageNameID)
	}
	if m.FieldCleared(dependency.FieldDependentPackageVersionID) {
		fields = append(fields, dependency.FieldDependentPackageVersionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DependencyMutation) ClearField(name string) error {
	switch name {
	case dependency.FieldDependentPackageNameID:
		m.ClearDependentPackageNameID()
		return nil
	case dependency.FieldDependentPackageVersionID:
		m.ClearDependentPackageVersionID()
		return nil
	}
	return fmt.Errorf("unknown Dependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DependencyMutation) ResetField(name string) error {
	switch name {
	case dependency.FieldPackageID:
		m.ResetPackageID()
		return nil
	case dependency.FieldDependentPackageNameID:
		m.ResetDependentPackageNameID()
		return nil
	case dependency.FieldDependentPackageVersionID:
		m.ResetDependentPackageVersionID()
		return nil
	case dependency.FieldVersionRange:
		m.ResetVersionRange()
		return nil
	case dependency.FieldDependencyType:
		m.ResetDependencyType()
		return nil
	case dependency.FieldJustification:
		m.ResetJustification()
		return nil
	case dependency.FieldOrigin:
		m.ResetOrigin()
		return nil
	case dependency.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown Dependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._package != nil {
		edges = append(edges, dependency.EdgePackage)
	}
	if m.dependent_package_name != nil {
		edges = append(edges, dependency.EdgeDependentPackageName)
	}
	if m.dependent_package_version != nil {
		edges = append(edges, dependency.EdgeDependentPackageVersion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dependency.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case dependency.EdgeDependentPackageName:
		if id := m.dependent_package_name; id != nil {
			return []ent.Value{*id}
		}
	case dependency.EdgeDependentPackageVersion:
		if id := m.dependent_package_version; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_package {
		edges = append(edges, dependency.EdgePackage)
	}
	if m.cleareddependent_package_name {
		edges = append(edges, dependency.EdgeDependentPackageName)
	}
	if m.cleareddependent_package_version {
		edges = append(edges, dependency.EdgeDependentPackageVersion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case dependency.EdgePackage:
		return m.cleared_package
	case dependency.EdgeDependentPackageName:
		return m.cleareddependent_package_name
	case dependency.EdgeDependentPackageVersion:
		return m.cleareddependent_package_version
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DependencyMutation) ClearEdge(name string) error {
	switch name {
	case dependency.EdgePackage:
		m.ClearPackage()
		return nil
	case dependency.EdgeDependentPackageName:
		m.ClearDependentPackageName()
		return nil
	case dependency.EdgeDependentPackageVersion:
		m.ClearDependentPackageVersion()
		return nil
	}
	return fmt.Errorf("unknown Dependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DependencyMutation) ResetEdge(name string) error {
	switch name {
	case dependency.EdgePackage:
		m.ResetPackage()
		return nil
	case dependency.EdgeDependentPackageName:
		m.ResetDependentPackageName()
		return nil
	case dependency.EdgeDependentPackageVersion:
		m.ResetDependentPackageVersion()
		return nil
	}
	return fmt.Errorf("unknown Dependency edge %s", name)
}

// HasSourceAtMutation represents an operation that mutates the HasSourceAt nodes in the graph.
type HasSourceAtMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	known_since            *time.Time
	justification          *string
	origin                 *string
	collector              *string
	clearedFields          map[string]struct{}
	package_version        *int
	clearedpackage_version bool
	all_versions           *int
	clearedall_versions    bool
	source                 *int
	clearedsource          bool
	done                   bool
	oldValue               func(context.Context) (*HasSourceAt, error)
	predicates             []predicate.HasSourceAt
}

var _ ent.Mutation = (*HasSourceAtMutation)(nil)

// hassourceatOption allows management of the mutation configuration using functional options.
type hassourceatOption func(*HasSourceAtMutation)

// newHasSourceAtMutation creates new mutation for the HasSourceAt entity.
func newHasSourceAtMutation(c config, op Op, opts ...hassourceatOption) *HasSourceAtMutation {
	m := &HasSourceAtMutation{
		config:        c,
		op:            op,
		typ:           TypeHasSourceAt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHasSourceAtID sets the ID field of the mutation.
func withHasSourceAtID(id int) hassourceatOption {
	return func(m *HasSourceAtMutation) {
		var (
			err   error
			once  sync.Once
			value *HasSourceAt
		)
		m.oldValue = func(ctx context.Context) (*HasSourceAt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HasSourceAt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHasSourceAt sets the old HasSourceAt of the mutation.
func withHasSourceAt(node *HasSourceAt) hassourceatOption {
	return func(m *HasSourceAtMutation) {
		m.oldValue = func(context.Context) (*HasSourceAt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HasSourceAtMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HasSourceAtMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HasSourceAtMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HasSourceAtMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HasSourceAt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageVersionID sets the "package_version_id" field.
func (m *HasSourceAtMutation) SetPackageVersionID(i int) {
	m.package_version = &i
}

// PackageVersionID returns the value of the "package_version_id" field in the mutation.
func (m *HasSourceAtMutation) PackageVersionID() (r int, exists bool) {
	v := m.package_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageVersionID returns the old "package_version_id" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldPackageVersionID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageVersionID: %w", err)
	}
	return oldValue.PackageVersionID, nil
}

// ClearPackageVersionID clears the value of the "package_version_id" field.
func (m *HasSourceAtMutation) ClearPackageVersionID() {
	m.package_version = nil
	m.clearedFields[hassourceat.FieldPackageVersionID] = struct{}{}
}

// PackageVersionIDCleared returns if the "package_version_id" field was cleared in this mutation.
func (m *HasSourceAtMutation) PackageVersionIDCleared() bool {
	_, ok := m.clearedFields[hassourceat.FieldPackageVersionID]
	return ok
}

// ResetPackageVersionID resets all changes to the "package_version_id" field.
func (m *HasSourceAtMutation) ResetPackageVersionID() {
	m.package_version = nil
	delete(m.clearedFields, hassourceat.FieldPackageVersionID)
}

// SetPackageNameID sets the "package_name_id" field.
func (m *HasSourceAtMutation) SetPackageNameID(i int) {
	m.all_versions = &i
}

// PackageNameID returns the value of the "package_name_id" field in the mutation.
func (m *HasSourceAtMutation) PackageNameID() (r int, exists bool) {
	v := m.all_versions
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageNameID returns the old "package_name_id" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldPackageNameID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageNameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageNameID: %w", err)
	}
	return oldValue.PackageNameID, nil
}

// ClearPackageNameID clears the value of the "package_name_id" field.
func (m *HasSourceAtMutation) ClearPackageNameID() {
	m.all_versions = nil
	m.clearedFields[hassourceat.FieldPackageNameID] = struct{}{}
}

// PackageNameIDCleared returns if the "package_name_id" field was cleared in this mutation.
func (m *HasSourceAtMutation) PackageNameIDCleared() bool {
	_, ok := m.clearedFields[hassourceat.FieldPackageNameID]
	return ok
}

// ResetPackageNameID resets all changes to the "package_name_id" field.
func (m *HasSourceAtMutation) ResetPackageNameID() {
	m.all_versions = nil
	delete(m.clearedFields, hassourceat.FieldPackageNameID)
}

// SetSourceID sets the "source_id" field.
func (m *HasSourceAtMutation) SetSourceID(i int) {
	m.source = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *HasSourceAtMutation) SourceID() (r int, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldSourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *HasSourceAtMutation) ResetSourceID() {
	m.source = nil
}

// SetKnownSince sets the "known_since" field.
func (m *HasSourceAtMutation) SetKnownSince(t time.Time) {
	m.known_since = &t
}

// KnownSince returns the value of the "known_since" field in the mutation.
func (m *HasSourceAtMutation) KnownSince() (r time.Time, exists bool) {
	v := m.known_since
	if v == nil {
		return
	}
	return *v, true
}

// OldKnownSince returns the old "known_since" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldKnownSince(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnownSince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnownSince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnownSince: %w", err)
	}
	return oldValue.KnownSince, nil
}

// ResetKnownSince resets all changes to the "known_since" field.
func (m *HasSourceAtMutation) ResetKnownSince() {
	m.known_since = nil
}

// SetJustification sets the "justification" field.
func (m *HasSourceAtMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *HasSourceAtMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *HasSourceAtMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *HasSourceAtMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *HasSourceAtMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *HasSourceAtMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *HasSourceAtMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *HasSourceAtMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the HasSourceAt entity.
// If the HasSourceAt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HasSourceAtMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *HasSourceAtMutation) ResetCollector() {
	m.collector = nil
}

// ClearPackageVersion clears the "package_version" edge to the PackageVersion entity.
func (m *HasSourceAtMutation) ClearPackageVersion() {
	m.clearedpackage_version = true
	m.clearedFields[hassourceat.FieldPackageVersionID] = struct{}{}
}

// PackageVersionCleared reports if the "package_version" edge to the PackageVersion entity was cleared.
func (m *HasSourceAtMutation) PackageVersionCleared() bool {
	return m.PackageVersionIDCleared() || m.clearedpackage_version
}

// PackageVersionIDs returns the "package_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageVersionID instead. It exists only for internal usage by the builders.
func (m *HasSourceAtMutation) PackageVersionIDs() (ids []int) {
	if id := m.package_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackageVersion resets all changes to the "package_version" edge.
func (m *HasSourceAtMutation) ResetPackageVersion() {
	m.package_version = nil
	m.clearedpackage_version = false
}

// SetAllVersionsID sets the "all_versions" edge to the PackageName entity by id.
func (m *HasSourceAtMutation) SetAllVersionsID(id int) {
	m.all_versions = &id
}

// ClearAllVersions clears the "all_versions" edge to the PackageName entity.
func (m *HasSourceAtMutation) ClearAllVersions() {
	m.clearedall_versions = true
	m.clearedFields[hassourceat.FieldPackageNameID] = struct{}{}
}

// AllVersionsCleared reports if the "all_versions" edge to the PackageName entity was cleared.
func (m *HasSourceAtMutation) AllVersionsCleared() bool {
	return m.PackageNameIDCleared() || m.clearedall_versions
}

// AllVersionsID returns the "all_versions" edge ID in the mutation.
func (m *HasSourceAtMutation) AllVersionsID() (id int, exists bool) {
	if m.all_versions != nil {
		return *m.all_versions, true
	}
	return
}

// AllVersionsIDs returns the "all_versions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AllVersionsID instead. It exists only for internal usage by the builders.
func (m *HasSourceAtMutation) AllVersionsIDs() (ids []int) {
	if id := m.all_versions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAllVersions resets all changes to the "all_versions" edge.
func (m *HasSourceAtMutation) ResetAllVersions() {
	m.all_versions = nil
	m.clearedall_versions = false
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *HasSourceAtMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[hassourceat.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *HasSourceAtMutation) SourceCleared() bool {
	return m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *HasSourceAtMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *HasSourceAtMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Where appends a list predicates to the HasSourceAtMutation builder.
func (m *HasSourceAtMutation) Where(ps ...predicate.HasSourceAt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HasSourceAtMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HasSourceAtMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HasSourceAt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HasSourceAtMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HasSourceAtMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HasSourceAt).
func (m *HasSourceAtMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HasSourceAtMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.package_version != nil {
		fields = append(fields, hassourceat.FieldPackageVersionID)
	}
	if m.all_versions != nil {
		fields = append(fields, hassourceat.FieldPackageNameID)
	}
	if m.source != nil {
		fields = append(fields, hassourceat.FieldSourceID)
	}
	if m.known_since != nil {
		fields = append(fields, hassourceat.FieldKnownSince)
	}
	if m.justification != nil {
		fields = append(fields, hassourceat.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, hassourceat.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, hassourceat.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HasSourceAtMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hassourceat.FieldPackageVersionID:
		return m.PackageVersionID()
	case hassourceat.FieldPackageNameID:
		return m.PackageNameID()
	case hassourceat.FieldSourceID:
		return m.SourceID()
	case hassourceat.FieldKnownSince:
		return m.KnownSince()
	case hassourceat.FieldJustification:
		return m.Justification()
	case hassourceat.FieldOrigin:
		return m.Origin()
	case hassourceat.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HasSourceAtMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hassourceat.FieldPackageVersionID:
		return m.OldPackageVersionID(ctx)
	case hassourceat.FieldPackageNameID:
		return m.OldPackageNameID(ctx)
	case hassourceat.FieldSourceID:
		return m.OldSourceID(ctx)
	case hassourceat.FieldKnownSince:
		return m.OldKnownSince(ctx)
	case hassourceat.FieldJustification:
		return m.OldJustification(ctx)
	case hassourceat.FieldOrigin:
		return m.OldOrigin(ctx)
	case hassourceat.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown HasSourceAt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HasSourceAtMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hassourceat.FieldPackageVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageVersionID(v)
		return nil
	case hassourceat.FieldPackageNameID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageNameID(v)
		return nil
	case hassourceat.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case hassourceat.FieldKnownSince:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnownSince(v)
		return nil
	case hassourceat.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case hassourceat.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case hassourceat.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HasSourceAtMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HasSourceAtMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HasSourceAtMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HasSourceAt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HasSourceAtMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hassourceat.FieldPackageVersionID) {
		fields = append(fields, hassourceat.FieldPackageVersionID)
	}
	if m.FieldCleared(hassourceat.FieldPackageNameID) {
		fields = append(fields, hassourceat.FieldPackageNameID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HasSourceAtMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HasSourceAtMutation) ClearField(name string) error {
	switch name {
	case hassourceat.FieldPackageVersionID:
		m.ClearPackageVersionID()
		return nil
	case hassourceat.FieldPackageNameID:
		m.ClearPackageNameID()
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HasSourceAtMutation) ResetField(name string) error {
	switch name {
	case hassourceat.FieldPackageVersionID:
		m.ResetPackageVersionID()
		return nil
	case hassourceat.FieldPackageNameID:
		m.ResetPackageNameID()
		return nil
	case hassourceat.FieldSourceID:
		m.ResetSourceID()
		return nil
	case hassourceat.FieldKnownSince:
		m.ResetKnownSince()
		return nil
	case hassourceat.FieldJustification:
		m.ResetJustification()
		return nil
	case hassourceat.FieldOrigin:
		m.ResetOrigin()
		return nil
	case hassourceat.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HasSourceAtMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.package_version != nil {
		edges = append(edges, hassourceat.EdgePackageVersion)
	}
	if m.all_versions != nil {
		edges = append(edges, hassourceat.EdgeAllVersions)
	}
	if m.source != nil {
		edges = append(edges, hassourceat.EdgeSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HasSourceAtMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hassourceat.EdgePackageVersion:
		if id := m.package_version; id != nil {
			return []ent.Value{*id}
		}
	case hassourceat.EdgeAllVersions:
		if id := m.all_versions; id != nil {
			return []ent.Value{*id}
		}
	case hassourceat.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HasSourceAtMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HasSourceAtMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HasSourceAtMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpackage_version {
		edges = append(edges, hassourceat.EdgePackageVersion)
	}
	if m.clearedall_versions {
		edges = append(edges, hassourceat.EdgeAllVersions)
	}
	if m.clearedsource {
		edges = append(edges, hassourceat.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HasSourceAtMutation) EdgeCleared(name string) bool {
	switch name {
	case hassourceat.EdgePackageVersion:
		return m.clearedpackage_version
	case hassourceat.EdgeAllVersions:
		return m.clearedall_versions
	case hassourceat.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HasSourceAtMutation) ClearEdge(name string) error {
	switch name {
	case hassourceat.EdgePackageVersion:
		m.ClearPackageVersion()
		return nil
	case hassourceat.EdgeAllVersions:
		m.ClearAllVersions()
		return nil
	case hassourceat.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HasSourceAtMutation) ResetEdge(name string) error {
	switch name {
	case hassourceat.EdgePackageVersion:
		m.ResetPackageVersion()
		return nil
	case hassourceat.EdgeAllVersions:
		m.ResetAllVersions()
		return nil
	case hassourceat.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown HasSourceAt edge %s", name)
}

// HashEqualMutation represents an operation that mutates the HashEqual nodes in the graph.
type HashEqualMutation struct {
	config
	op               Op
	typ              string
	id               *int
	origin           *string
	collector        *string
	justification    *string
	clearedFields    map[string]struct{}
	artifacts        map[int]struct{}
	removedartifacts map[int]struct{}
	clearedartifacts bool
	done             bool
	oldValue         func(context.Context) (*HashEqual, error)
	predicates       []predicate.HashEqual
}

var _ ent.Mutation = (*HashEqualMutation)(nil)

// hashequalOption allows management of the mutation configuration using functional options.
type hashequalOption func(*HashEqualMutation)

// newHashEqualMutation creates new mutation for the HashEqual entity.
func newHashEqualMutation(c config, op Op, opts ...hashequalOption) *HashEqualMutation {
	m := &HashEqualMutation{
		config:        c,
		op:            op,
		typ:           TypeHashEqual,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHashEqualID sets the ID field of the mutation.
func withHashEqualID(id int) hashequalOption {
	return func(m *HashEqualMutation) {
		var (
			err   error
			once  sync.Once
			value *HashEqual
		)
		m.oldValue = func(ctx context.Context) (*HashEqual, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HashEqual.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHashEqual sets the old HashEqual of the mutation.
func withHashEqual(node *HashEqual) hashequalOption {
	return func(m *HashEqualMutation) {
		m.oldValue = func(context.Context) (*HashEqual, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HashEqualMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HashEqualMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HashEqualMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HashEqualMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HashEqual.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrigin sets the "origin" field.
func (m *HashEqualMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *HashEqualMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the HashEqual entity.
// If the HashEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashEqualMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *HashEqualMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *HashEqualMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *HashEqualMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the HashEqual entity.
// If the HashEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashEqualMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *HashEqualMutation) ResetCollector() {
	m.collector = nil
}

// SetJustification sets the "justification" field.
func (m *HashEqualMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *HashEqualMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the HashEqual entity.
// If the HashEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HashEqualMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *HashEqualMutation) ResetJustification() {
	m.justification = nil
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *HashEqualMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *HashEqualMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *HashEqualMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *HashEqualMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *HashEqualMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *HashEqualMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *HashEqualMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// Where appends a list predicates to the HashEqualMutation builder.
func (m *HashEqualMutation) Where(ps ...predicate.HashEqual) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HashEqualMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HashEqualMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HashEqual, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HashEqualMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HashEqualMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HashEqual).
func (m *HashEqualMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HashEqualMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.origin != nil {
		fields = append(fields, hashequal.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, hashequal.FieldCollector)
	}
	if m.justification != nil {
		fields = append(fields, hashequal.FieldJustification)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HashEqualMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hashequal.FieldOrigin:
		return m.Origin()
	case hashequal.FieldCollector:
		return m.Collector()
	case hashequal.FieldJustification:
		return m.Justification()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HashEqualMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hashequal.FieldOrigin:
		return m.OldOrigin(ctx)
	case hashequal.FieldCollector:
		return m.OldCollector(ctx)
	case hashequal.FieldJustification:
		return m.OldJustification(ctx)
	}
	return nil, fmt.Errorf("unknown HashEqual field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HashEqualMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hashequal.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case hashequal.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case hashequal.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	}
	return fmt.Errorf("unknown HashEqual field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HashEqualMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HashEqualMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HashEqualMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HashEqual numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HashEqualMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HashEqualMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HashEqualMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HashEqual nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HashEqualMutation) ResetField(name string) error {
	switch name {
	case hashequal.FieldOrigin:
		m.ResetOrigin()
		return nil
	case hashequal.FieldCollector:
		m.ResetCollector()
		return nil
	case hashequal.FieldJustification:
		m.ResetJustification()
		return nil
	}
	return fmt.Errorf("unknown HashEqual field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HashEqualMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.artifacts != nil {
		edges = append(edges, hashequal.EdgeArtifacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HashEqualMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hashequal.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HashEqualMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedartifacts != nil {
		edges = append(edges, hashequal.EdgeArtifacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HashEqualMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hashequal.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HashEqualMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedartifacts {
		edges = append(edges, hashequal.EdgeArtifacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HashEqualMutation) EdgeCleared(name string) bool {
	switch name {
	case hashequal.EdgeArtifacts:
		return m.clearedartifacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HashEqualMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HashEqual unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HashEqualMutation) ResetEdge(name string) error {
	switch name {
	case hashequal.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	}
	return fmt.Errorf("unknown HashEqual edge %s", name)
}

// IsVulnerabilityMutation represents an operation that mutates the IsVulnerability nodes in the graph.
type IsVulnerabilityMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	justification        *string
	origin               *string
	collector            *string
	clearedFields        map[string]struct{}
	osv                  *int
	clearedosv           bool
	vulnerability        *int
	clearedvulnerability bool
	done                 bool
	oldValue             func(context.Context) (*IsVulnerability, error)
	predicates           []predicate.IsVulnerability
}

var _ ent.Mutation = (*IsVulnerabilityMutation)(nil)

// isvulnerabilityOption allows management of the mutation configuration using functional options.
type isvulnerabilityOption func(*IsVulnerabilityMutation)

// newIsVulnerabilityMutation creates new mutation for the IsVulnerability entity.
func newIsVulnerabilityMutation(c config, op Op, opts ...isvulnerabilityOption) *IsVulnerabilityMutation {
	m := &IsVulnerabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeIsVulnerability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIsVulnerabilityID sets the ID field of the mutation.
func withIsVulnerabilityID(id int) isvulnerabilityOption {
	return func(m *IsVulnerabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *IsVulnerability
		)
		m.oldValue = func(ctx context.Context) (*IsVulnerability, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IsVulnerability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIsVulnerability sets the old IsVulnerability of the mutation.
func withIsVulnerability(node *IsVulnerability) isvulnerabilityOption {
	return func(m *IsVulnerabilityMutation) {
		m.oldValue = func(context.Context) (*IsVulnerability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IsVulnerabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IsVulnerabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IsVulnerabilityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IsVulnerabilityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IsVulnerability.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOsvID sets the "osv_id" field.
func (m *IsVulnerabilityMutation) SetOsvID(i int) {
	m.osv = &i
}

// OsvID returns the value of the "osv_id" field in the mutation.
func (m *IsVulnerabilityMutation) OsvID() (r int, exists bool) {
	v := m.osv
	if v == nil {
		return
	}
	return *v, true
}

// OldOsvID returns the old "osv_id" field's value of the IsVulnerability entity.
// If the IsVulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IsVulnerabilityMutation) OldOsvID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsvID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsvID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsvID: %w", err)
	}
	return oldValue.OsvID, nil
}

// ResetOsvID resets all changes to the "osv_id" field.
func (m *IsVulnerabilityMutation) ResetOsvID() {
	m.osv = nil
}

// SetVulnerabilityID sets the "vulnerability_id" field.
func (m *IsVulnerabilityMutation) SetVulnerabilityID(i int) {
	m.vulnerability = &i
}

// VulnerabilityID returns the value of the "vulnerability_id" field in the mutation.
func (m *IsVulnerabilityMutation) VulnerabilityID() (r int, exists bool) {
	v := m.vulnerability
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnerabilityID returns the old "vulnerability_id" field's value of the IsVulnerability entity.
// If the IsVulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IsVulnerabilityMutation) OldVulnerabilityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVulnerabilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVulnerabilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnerabilityID: %w", err)
	}
	return oldValue.VulnerabilityID, nil
}

// ResetVulnerabilityID resets all changes to the "vulnerability_id" field.
func (m *IsVulnerabilityMutation) ResetVulnerabilityID() {
	m.vulnerability = nil
}

// SetJustification sets the "justification" field.
func (m *IsVulnerabilityMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *IsVulnerabilityMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the IsVulnerability entity.
// If the IsVulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IsVulnerabilityMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *IsVulnerabilityMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *IsVulnerabilityMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *IsVulnerabilityMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the IsVulnerability entity.
// If the IsVulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IsVulnerabilityMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *IsVulnerabilityMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *IsVulnerabilityMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *IsVulnerabilityMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the IsVulnerability entity.
// If the IsVulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IsVulnerabilityMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *IsVulnerabilityMutation) ResetCollector() {
	m.collector = nil
}

// ClearOsv clears the "osv" edge to the VulnerabilityType entity.
func (m *IsVulnerabilityMutation) ClearOsv() {
	m.clearedosv = true
	m.clearedFields[isvulnerability.FieldOsvID] = struct{}{}
}

// OsvCleared reports if the "osv" edge to the VulnerabilityType entity was cleared.
func (m *IsVulnerabilityMutation) OsvCleared() bool {
	return m.clearedosv
}

// OsvIDs returns the "osv" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OsvID instead. It exists only for internal usage by the builders.
func (m *IsVulnerabilityMutation) OsvIDs() (ids []int) {
	if id := m.osv; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOsv resets all changes to the "osv" edge.
func (m *IsVulnerabilityMutation) ResetOsv() {
	m.osv = nil
	m.clearedosv = false
}

// ClearVulnerability clears the "vulnerability" edge to the VulnerabilityType entity.
func (m *IsVulnerabilityMutation) ClearVulnerability() {
	m.clearedvulnerability = true
	m.clearedFields[isvulnerability.FieldVulnerabilityID] = struct{}{}
}

// VulnerabilityCleared reports if the "vulnerability" edge to the VulnerabilityType entity was cleared.
func (m *IsVulnerabilityMutation) VulnerabilityCleared() bool {
	return m.clearedvulnerability
}

// VulnerabilityIDs returns the "vulnerability" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityID instead. It exists only for internal usage by the builders.
func (m *IsVulnerabilityMutation) VulnerabilityIDs() (ids []int) {
	if id := m.vulnerability; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerability resets all changes to the "vulnerability" edge.
func (m *IsVulnerabilityMutation) ResetVulnerability() {
	m.vulnerability = nil
	m.clearedvulnerability = false
}

// Where appends a list predicates to the IsVulnerabilityMutation builder.
func (m *IsVulnerabilityMutation) Where(ps ...predicate.IsVulnerability) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IsVulnerabilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IsVulnerabilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IsVulnerability, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IsVulnerabilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IsVulnerabilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IsVulnerability).
func (m *IsVulnerabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IsVulnerabilityMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.osv != nil {
		fields = append(fields, isvulnerability.FieldOsvID)
	}
	if m.vulnerability != nil {
		fields = append(fields, isvulnerability.FieldVulnerabilityID)
	}
	if m.justification != nil {
		fields = append(fields, isvulnerability.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, isvulnerability.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, isvulnerability.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IsVulnerabilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case isvulnerability.FieldOsvID:
		return m.OsvID()
	case isvulnerability.FieldVulnerabilityID:
		return m.VulnerabilityID()
	case isvulnerability.FieldJustification:
		return m.Justification()
	case isvulnerability.FieldOrigin:
		return m.Origin()
	case isvulnerability.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IsVulnerabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case isvulnerability.FieldOsvID:
		return m.OldOsvID(ctx)
	case isvulnerability.FieldVulnerabilityID:
		return m.OldVulnerabilityID(ctx)
	case isvulnerability.FieldJustification:
		return m.OldJustification(ctx)
	case isvulnerability.FieldOrigin:
		return m.OldOrigin(ctx)
	case isvulnerability.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown IsVulnerability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IsVulnerabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case isvulnerability.FieldOsvID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsvID(v)
		return nil
	case isvulnerability.FieldVulnerabilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnerabilityID(v)
		return nil
	case isvulnerability.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case isvulnerability.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case isvulnerability.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown IsVulnerability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IsVulnerabilityMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IsVulnerabilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IsVulnerabilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IsVulnerability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IsVulnerabilityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IsVulnerabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IsVulnerabilityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IsVulnerability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IsVulnerabilityMutation) ResetField(name string) error {
	switch name {
	case isvulnerability.FieldOsvID:
		m.ResetOsvID()
		return nil
	case isvulnerability.FieldVulnerabilityID:
		m.ResetVulnerabilityID()
		return nil
	case isvulnerability.FieldJustification:
		m.ResetJustification()
		return nil
	case isvulnerability.FieldOrigin:
		m.ResetOrigin()
		return nil
	case isvulnerability.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown IsVulnerability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IsVulnerabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.osv != nil {
		edges = append(edges, isvulnerability.EdgeOsv)
	}
	if m.vulnerability != nil {
		edges = append(edges, isvulnerability.EdgeVulnerability)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IsVulnerabilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case isvulnerability.EdgeOsv:
		if id := m.osv; id != nil {
			return []ent.Value{*id}
		}
	case isvulnerability.EdgeVulnerability:
		if id := m.vulnerability; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IsVulnerabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IsVulnerabilityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IsVulnerabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedosv {
		edges = append(edges, isvulnerability.EdgeOsv)
	}
	if m.clearedvulnerability {
		edges = append(edges, isvulnerability.EdgeVulnerability)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IsVulnerabilityMutation) EdgeCleared(name string) bool {
	switch name {
	case isvulnerability.EdgeOsv:
		return m.clearedosv
	case isvulnerability.EdgeVulnerability:
		return m.clearedvulnerability
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IsVulnerabilityMutation) ClearEdge(name string) error {
	switch name {
	case isvulnerability.EdgeOsv:
		m.ClearOsv()
		return nil
	case isvulnerability.EdgeVulnerability:
		m.ClearVulnerability()
		return nil
	}
	return fmt.Errorf("unknown IsVulnerability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IsVulnerabilityMutation) ResetEdge(name string) error {
	switch name {
	case isvulnerability.EdgeOsv:
		m.ResetOsv()
		return nil
	case isvulnerability.EdgeVulnerability:
		m.ResetVulnerability()
		return nil
	}
	return fmt.Errorf("unknown IsVulnerability edge %s", name)
}

// LicenseMutation represents an operation that mutates the License nodes in the graph.
type LicenseMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	name                                *string
	inline                              *string
	list_version                        *string
	clearedFields                       map[string]struct{}
	declared_in_certify_legals          map[int]struct{}
	removeddeclared_in_certify_legals   map[int]struct{}
	cleareddeclared_in_certify_legals   bool
	discovered_in_certify_legals        map[int]struct{}
	removeddiscovered_in_certify_legals map[int]struct{}
	cleareddiscovered_in_certify_legals bool
	done                                bool
	oldValue                            func(context.Context) (*License, error)
	predicates                          []predicate.License
}

var _ ent.Mutation = (*LicenseMutation)(nil)

// licenseOption allows management of the mutation configuration using functional options.
type licenseOption func(*LicenseMutation)

// newLicenseMutation creates new mutation for the License entity.
func newLicenseMutation(c config, op Op, opts ...licenseOption) *LicenseMutation {
	m := &LicenseMutation{
		config:        c,
		op:            op,
		typ:           TypeLicense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLicenseID sets the ID field of the mutation.
func withLicenseID(id int) licenseOption {
	return func(m *LicenseMutation) {
		var (
			err   error
			once  sync.Once
			value *License
		)
		m.oldValue = func(ctx context.Context) (*License, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().License.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLicense sets the old License of the mutation.
func withLicense(node *License) licenseOption {
	return func(m *LicenseMutation) {
		m.oldValue = func(context.Context) (*License, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LicenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LicenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LicenseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LicenseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().License.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LicenseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LicenseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LicenseMutation) ResetName() {
	m.name = nil
}

// SetInline sets the "inline" field.
func (m *LicenseMutation) SetInline(s string) {
	m.inline = &s
}

// Inline returns the value of the "inline" field in the mutation.
func (m *LicenseMutation) Inline() (r string, exists bool) {
	v := m.inline
	if v == nil {
		return
	}
	return *v, true
}

// OldInline returns the old "inline" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldInline(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInline: %w", err)
	}
	return oldValue.Inline, nil
}

// ClearInline clears the value of the "inline" field.
func (m *LicenseMutation) ClearInline() {
	m.inline = nil
	m.clearedFields[license.FieldInline] = struct{}{}
}

// InlineCleared returns if the "inline" field was cleared in this mutation.
func (m *LicenseMutation) InlineCleared() bool {
	_, ok := m.clearedFields[license.FieldInline]
	return ok
}

// ResetInline resets all changes to the "inline" field.
func (m *LicenseMutation) ResetInline() {
	m.inline = nil
	delete(m.clearedFields, license.FieldInline)
}

// SetListVersion sets the "list_version" field.
func (m *LicenseMutation) SetListVersion(s string) {
	m.list_version = &s
}

// ListVersion returns the value of the "list_version" field in the mutation.
func (m *LicenseMutation) ListVersion() (r string, exists bool) {
	v := m.list_version
	if v == nil {
		return
	}
	return *v, true
}

// OldListVersion returns the old "list_version" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldListVersion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListVersion: %w", err)
	}
	return oldValue.ListVersion, nil
}

// ClearListVersion clears the value of the "list_version" field.
func (m *LicenseMutation) ClearListVersion() {
	m.list_version = nil
	m.clearedFields[license.FieldListVersion] = struct{}{}
}

// ListVersionCleared returns if the "list_version" field was cleared in this mutation.
func (m *LicenseMutation) ListVersionCleared() bool {
	_, ok := m.clearedFields[license.FieldListVersion]
	return ok
}

// ResetListVersion resets all changes to the "list_version" field.
func (m *LicenseMutation) ResetListVersion() {
	m.list_version = nil
	delete(m.clearedFields, license.FieldListVersion)
}

// AddDeclaredInCertifyLegalIDs adds the "declared_in_certify_legals" edge to the CertifyLegal entity by ids.
func (m *LicenseMutation) AddDeclaredInCertifyLegalIDs(ids ...int) {
	if m.declared_in_certify_legals == nil {
		m.declared_in_certify_legals = make(map[int]struct{})
	}
	for i := range ids {
		m.declared_in_certify_legals[ids[i]] = struct{}{}
	}
}

// ClearDeclaredInCertifyLegals clears the "declared_in_certify_legals" edge to the CertifyLegal entity.
func (m *LicenseMutation) ClearDeclaredInCertifyLegals() {
	m.cleareddeclared_in_certify_legals = true
}

// DeclaredInCertifyLegalsCleared reports if the "declared_in_certify_legals" edge to the CertifyLegal entity was cleared.
func (m *LicenseMutation) DeclaredInCertifyLegalsCleared() bool {
	return m.cleareddeclared_in_certify_legals
}

// RemoveDeclaredInCertifyLegalIDs removes the "declared_in_certify_legals" edge to the CertifyLegal entity by IDs.
func (m *LicenseMutation) RemoveDeclaredInCertifyLegalIDs(ids ...int) {
	if m.removeddeclared_in_certify_legals == nil {
		m.removeddeclared_in_certify_legals = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.declared_in_certify_legals, ids[i])
		m.removeddeclared_in_certify_legals[ids[i]] = struct{}{}
	}
}

// RemovedDeclaredInCertifyLegals returns the removed IDs of the "declared_in_certify_legals" edge to the CertifyLegal entity.
func (m *LicenseMutation) RemovedDeclaredInCertifyLegalsIDs() (ids []int) {
	for id := range m.removeddeclared_in_certify_legals {
		ids = append(ids, id)
	}
	return
}

// DeclaredInCertifyLegalsIDs returns the "declared_in_certify_legals" edge IDs in the mutation.
func (m *LicenseMutation) DeclaredInCertifyLegalsIDs() (ids []int) {
	for id := range m.declared_in_certify_legals {
		ids = append(ids, id)
	}
	return
}

// ResetDeclaredInCertifyLegals resets all changes to the "declared_in_certify_legals" edge.
func (m *LicenseMutation) ResetDeclaredInCertifyLegals() {
	m.declared_in_certify_legals = nil
	m.cleareddeclared_in_certify_legals = false
	m.removeddeclared_in_certify_legals = nil
}

// AddDiscoveredInCertifyLegalIDs adds the "discovered_in_certify_legals" edge to the CertifyLegal entity by ids.
func (m *LicenseMutation) AddDiscoveredInCertifyLegalIDs(ids ...int) {
	if m.discovered_in_certify_legals == nil {
		m.discovered_in_certify_legals = make(map[int]struct{})
	}
	for i := range ids {
		m.discovered_in_certify_legals[ids[i]] = struct{}{}
	}
}

// ClearDiscoveredInCertifyLegals clears the "discovered_in_certify_legals" edge to the CertifyLegal entity.
func (m *LicenseMutation) ClearDiscoveredInCertifyLegals() {
	m.cleareddiscovered_in_certify_legals = true
}

// DiscoveredInCertifyLegalsCleared reports if the "discovered_in_certify_legals" edge to the CertifyLegal entity was cleared.
func (m *LicenseMutation) DiscoveredInCertifyLegalsCleared() bool {
	return m.cleareddiscovered_in_certify_legals
}

// RemoveDiscoveredInCertifyLegalIDs removes the "discovered_in_certify_legals" edge to the CertifyLegal entity by IDs.
func (m *LicenseMutation) RemoveDiscoveredInCertifyLegalIDs(ids ...int) {
	if m.removeddiscovered_in_certify_legals == nil {
		m.removeddiscovered_in_certify_legals = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.discovered_in_certify_legals, ids[i])
		m.removeddiscovered_in_certify_legals[ids[i]] = struct{}{}
	}
}

// RemovedDiscoveredInCertifyLegals returns the removed IDs of the "discovered_in_certify_legals" edge to the CertifyLegal entity.
func (m *LicenseMutation) RemovedDiscoveredInCertifyLegalsIDs() (ids []int) {
	for id := range m.removeddiscovered_in_certify_legals {
		ids = append(ids, id)
	}
	return
}

// DiscoveredInCertifyLegalsIDs returns the "discovered_in_certify_legals" edge IDs in the mutation.
func (m *LicenseMutation) DiscoveredInCertifyLegalsIDs() (ids []int) {
	for id := range m.discovered_in_certify_legals {
		ids = append(ids, id)
	}
	return
}

// ResetDiscoveredInCertifyLegals resets all changes to the "discovered_in_certify_legals" edge.
func (m *LicenseMutation) ResetDiscoveredInCertifyLegals() {
	m.discovered_in_certify_legals = nil
	m.cleareddiscovered_in_certify_legals = false
	m.removeddiscovered_in_certify_legals = nil
}

// Where appends a list predicates to the LicenseMutation builder.
func (m *LicenseMutation) Where(ps ...predicate.License) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LicenseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LicenseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.License, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LicenseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LicenseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (License).
func (m *LicenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LicenseMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, license.FieldName)
	}
	if m.inline != nil {
		fields = append(fields, license.FieldInline)
	}
	if m.list_version != nil {
		fields = append(fields, license.FieldListVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LicenseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case license.FieldName:
		return m.Name()
	case license.FieldInline:
		return m.Inline()
	case license.FieldListVersion:
		return m.ListVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LicenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case license.FieldName:
		return m.OldName(ctx)
	case license.FieldInline:
		return m.OldInline(ctx)
	case license.FieldListVersion:
		return m.OldListVersion(ctx)
	}
	return nil, fmt.Errorf("unknown License field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case license.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case license.FieldInline:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInline(v)
		return nil
	case license.FieldListVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListVersion(v)
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LicenseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LicenseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown License numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LicenseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(license.FieldInline) {
		fields = append(fields, license.FieldInline)
	}
	if m.FieldCleared(license.FieldListVersion) {
		fields = append(fields, license.FieldListVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LicenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LicenseMutation) ClearField(name string) error {
	switch name {
	case license.FieldInline:
		m.ClearInline()
		return nil
	case license.FieldListVersion:
		m.ClearListVersion()
		return nil
	}
	return fmt.Errorf("unknown License nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LicenseMutation) ResetField(name string) error {
	switch name {
	case license.FieldName:
		m.ResetName()
		return nil
	case license.FieldInline:
		m.ResetInline()
		return nil
	case license.FieldListVersion:
		m.ResetListVersion()
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LicenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.declared_in_certify_legals != nil {
		edges = append(edges, license.EdgeDeclaredInCertifyLegals)
	}
	if m.discovered_in_certify_legals != nil {
		edges = append(edges, license.EdgeDiscoveredInCertifyLegals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LicenseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeDeclaredInCertifyLegals:
		ids := make([]ent.Value, 0, len(m.declared_in_certify_legals))
		for id := range m.declared_in_certify_legals {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeDiscoveredInCertifyLegals:
		ids := make([]ent.Value, 0, len(m.discovered_in_certify_legals))
		for id := range m.discovered_in_certify_legals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LicenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddeclared_in_certify_legals != nil {
		edges = append(edges, license.EdgeDeclaredInCertifyLegals)
	}
	if m.removeddiscovered_in_certify_legals != nil {
		edges = append(edges, license.EdgeDiscoveredInCertifyLegals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LicenseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeDeclaredInCertifyLegals:
		ids := make([]ent.Value, 0, len(m.removeddeclared_in_certify_legals))
		for id := range m.removeddeclared_in_certify_legals {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeDiscoveredInCertifyLegals:
		ids := make([]ent.Value, 0, len(m.removeddiscovered_in_certify_legals))
		for id := range m.removeddiscovered_in_certify_legals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LicenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddeclared_in_certify_legals {
		edges = append(edges, license.EdgeDeclaredInCertifyLegals)
	}
	if m.cleareddiscovered_in_certify_legals {
		edges = append(edges, license.EdgeDiscoveredInCertifyLegals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LicenseMutation) EdgeCleared(name string) bool {
	switch name {
	case license.EdgeDeclaredInCertifyLegals:
		return m.cleareddeclared_in_certify_legals
	case license.EdgeDiscoveredInCertifyLegals:
		return m.cleareddiscovered_in_certify_legals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LicenseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown License unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LicenseMutation) ResetEdge(name string) error {
	switch name {
	case license.EdgeDeclaredInCertifyLegals:
		m.ResetDeclaredInCertifyLegals()
		return nil
	case license.EdgeDiscoveredInCertifyLegals:
		m.ResetDiscoveredInCertifyLegals()
		return nil
	}
	return fmt.Errorf("unknown License edge %s", name)
}

// OccurrenceMutation represents an operation that mutates the Occurrence nodes in the graph.
type OccurrenceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	justification   *string
	origin          *string
	collector       *string
	clearedFields   map[string]struct{}
	artifact        *int
	clearedartifact bool
	_package        *int
	cleared_package bool
	source          *int
	clearedsource   bool
	done            bool
	oldValue        func(context.Context) (*Occurrence, error)
	predicates      []predicate.Occurrence
}

var _ ent.Mutation = (*OccurrenceMutation)(nil)

// occurrenceOption allows management of the mutation configuration using functional options.
type occurrenceOption func(*OccurrenceMutation)

// newOccurrenceMutation creates new mutation for the Occurrence entity.
func newOccurrenceMutation(c config, op Op, opts ...occurrenceOption) *OccurrenceMutation {
	m := &OccurrenceMutation{
		config:        c,
		op:            op,
		typ:           TypeOccurrence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOccurrenceID sets the ID field of the mutation.
func withOccurrenceID(id int) occurrenceOption {
	return func(m *OccurrenceMutation) {
		var (
			err   error
			once  sync.Once
			value *Occurrence
		)
		m.oldValue = func(ctx context.Context) (*Occurrence, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Occurrence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOccurrence sets the old Occurrence of the mutation.
func withOccurrence(node *Occurrence) occurrenceOption {
	return func(m *OccurrenceMutation) {
		m.oldValue = func(context.Context) (*Occurrence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OccurrenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OccurrenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OccurrenceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OccurrenceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Occurrence.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArtifactID sets the "artifact_id" field.
func (m *OccurrenceMutation) SetArtifactID(i int) {
	m.artifact = &i
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *OccurrenceMutation) ArtifactID() (r int, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldArtifactID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *OccurrenceMutation) ResetArtifactID() {
	m.artifact = nil
}

// SetJustification sets the "justification" field.
func (m *OccurrenceMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *OccurrenceMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *OccurrenceMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *OccurrenceMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *OccurrenceMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *OccurrenceMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *OccurrenceMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *OccurrenceMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *OccurrenceMutation) ResetCollector() {
	m.collector = nil
}

// SetSourceID sets the "source_id" field.
func (m *OccurrenceMutation) SetSourceID(i int) {
	m.source = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *OccurrenceMutation) SourceID() (r int, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldSourceID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *OccurrenceMutation) ClearSourceID() {
	m.source = nil
	m.clearedFields[occurrence.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *OccurrenceMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *OccurrenceMutation) ResetSourceID() {
	m.source = nil
	delete(m.clearedFields, occurrence.FieldSourceID)
}

// SetPackageID sets the "package_id" field.
func (m *OccurrenceMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *OccurrenceMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldPackageID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *OccurrenceMutation) ClearPackageID() {
	m._package = nil
	m.clearedFields[occurrence.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *OccurrenceMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[occurrence.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *OccurrenceMutation) ResetPackageID() {
	m._package = nil
	delete(m.clearedFields, occurrence.FieldPackageID)
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *OccurrenceMutation) ClearArtifact() {
	m.clearedartifact = true
	m.clearedFields[occurrence.FieldArtifactID] = struct{}{}
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *OccurrenceMutation) ArtifactCleared() bool {
	return m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *OccurrenceMutation) ArtifactIDs() (ids []int) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *OccurrenceMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *OccurrenceMutation) ClearPackage() {
	m.cleared_package = true
	m.clearedFields[occurrence.FieldPackageID] = struct{}{}
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *OccurrenceMutation) PackageCleared() bool {
	return m.PackageIDCleared() || m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *OccurrenceMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *OccurrenceMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *OccurrenceMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[occurrence.FieldSourceID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *OccurrenceMutation) SourceCleared() bool {
	return m.SourceIDCleared() || m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *OccurrenceMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *OccurrenceMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Where appends a list predicates to the OccurrenceMutation builder.
func (m *OccurrenceMutation) Where(ps ...predicate.Occurrence) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OccurrenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OccurrenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Occurrence, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OccurrenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OccurrenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Occurrence).
func (m *OccurrenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OccurrenceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.artifact != nil {
		fields = append(fields, occurrence.FieldArtifactID)
	}
	if m.justification != nil {
		fields = append(fields, occurrence.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, occurrence.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, occurrence.FieldCollector)
	}
	if m.source != nil {
		fields = append(fields, occurrence.FieldSourceID)
	}
	if m._package != nil {
		fields = append(fields, occurrence.FieldPackageID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OccurrenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case occurrence.FieldArtifactID:
		return m.ArtifactID()
	case occurrence.FieldJustification:
		return m.Justification()
	case occurrence.FieldOrigin:
		return m.Origin()
	case occurrence.FieldCollector:
		return m.Collector()
	case occurrence.FieldSourceID:
		return m.SourceID()
	case occurrence.FieldPackageID:
		return m.PackageID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OccurrenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case occurrence.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case occurrence.FieldJustification:
		return m.OldJustification(ctx)
	case occurrence.FieldOrigin:
		return m.OldOrigin(ctx)
	case occurrence.FieldCollector:
		return m.OldCollector(ctx)
	case occurrence.FieldSourceID:
		return m.OldSourceID(ctx)
	case occurrence.FieldPackageID:
		return m.OldPackageID(ctx)
	}
	return nil, fmt.Errorf("unknown Occurrence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurrenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case occurrence.FieldArtifactID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case occurrence.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case occurrence.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case occurrence.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case occurrence.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case occurrence.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	}
	return fmt.Errorf("unknown Occurrence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OccurrenceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OccurrenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurrenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Occurrence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OccurrenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(occurrence.FieldSourceID) {
		fields = append(fields, occurrence.FieldSourceID)
	}
	if m.FieldCleared(occurrence.FieldPackageID) {
		fields = append(fields, occurrence.FieldPackageID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OccurrenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OccurrenceMutation) ClearField(name string) error {
	switch name {
	case occurrence.FieldSourceID:
		m.ClearSourceID()
		return nil
	case occurrence.FieldPackageID:
		m.ClearPackageID()
		return nil
	}
	return fmt.Errorf("unknown Occurrence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OccurrenceMutation) ResetField(name string) error {
	switch name {
	case occurrence.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case occurrence.FieldJustification:
		m.ResetJustification()
		return nil
	case occurrence.FieldOrigin:
		m.ResetOrigin()
		return nil
	case occurrence.FieldCollector:
		m.ResetCollector()
		return nil
	case occurrence.FieldSourceID:
		m.ResetSourceID()
		return nil
	case occurrence.FieldPackageID:
		m.ResetPackageID()
		return nil
	}
	return fmt.Errorf("unknown Occurrence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OccurrenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.artifact != nil {
		edges = append(edges, occurrence.EdgeArtifact)
	}
	if m._package != nil {
		edges = append(edges, occurrence.EdgePackage)
	}
	if m.source != nil {
		edges = append(edges, occurrence.EdgeSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OccurrenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case occurrence.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	case occurrence.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case occurrence.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OccurrenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OccurrenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OccurrenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedartifact {
		edges = append(edges, occurrence.EdgeArtifact)
	}
	if m.cleared_package {
		edges = append(edges, occurrence.EdgePackage)
	}
	if m.clearedsource {
		edges = append(edges, occurrence.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OccurrenceMutation) EdgeCleared(name string) bool {
	switch name {
	case occurrence.EdgeArtifact:
		return m.clearedartifact
	case occurrence.EdgePackage:
		return m.cleared_package
	case occurrence.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OccurrenceMutation) ClearEdge(name string) error {
	switch name {
	case occurrence.EdgeArtifact:
		m.ClearArtifact()
		return nil
	case occurrence.EdgePackage:
		m.ClearPackage()
		return nil
	case occurrence.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown Occurrence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OccurrenceMutation) ResetEdge(name string) error {
	switch name {
	case occurrence.EdgeArtifact:
		m.ResetArtifact()
		return nil
	case occurrence.EdgePackage:
		m.ResetPackage()
		return nil
	case occurrence.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown Occurrence edge %s", name)
}

// PackageNameMutation represents an operation that mutates the PackageName nodes in the graph.
type PackageNameMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	namespace        *int
	clearednamespace bool
	versions         map[int]struct{}
	removedversions  map[int]struct{}
	clearedversions  bool
	done             bool
	oldValue         func(context.Context) (*PackageName, error)
	predicates       []predicate.PackageName
}

var _ ent.Mutation = (*PackageNameMutation)(nil)

// packagenameOption allows management of the mutation configuration using functional options.
type packagenameOption func(*PackageNameMutation)

// newPackageNameMutation creates new mutation for the PackageName entity.
func newPackageNameMutation(c config, op Op, opts ...packagenameOption) *PackageNameMutation {
	m := &PackageNameMutation{
		config:        c,
		op:            op,
		typ:           TypePackageName,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageNameID sets the ID field of the mutation.
func withPackageNameID(id int) packagenameOption {
	return func(m *PackageNameMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageName
		)
		m.oldValue = func(ctx context.Context) (*PackageName, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageName.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageName sets the old PackageName of the mutation.
func withPackageName(node *PackageName) packagenameOption {
	return func(m *PackageNameMutation) {
		m.oldValue = func(context.Context) (*PackageName, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageNameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageNameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageNameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageNameMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageName.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespaceID sets the "namespace_id" field.
func (m *PackageNameMutation) SetNamespaceID(i int) {
	m.namespace = &i
}

// NamespaceID returns the value of the "namespace_id" field in the mutation.
func (m *PackageNameMutation) NamespaceID() (r int, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespaceID returns the old "namespace_id" field's value of the PackageName entity.
// If the PackageName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNameMutation) OldNamespaceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespaceID: %w", err)
	}
	return oldValue.NamespaceID, nil
}

// ResetNamespaceID resets all changes to the "namespace_id" field.
func (m *PackageNameMutation) ResetNamespaceID() {
	m.namespace = nil
}

// SetName sets the "name" field.
func (m *PackageNameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PackageNameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PackageName entity.
// If the PackageName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PackageNameMutation) ResetName() {
	m.name = nil
}

// ClearNamespace clears the "namespace" edge to the PackageNamespace entity.
func (m *PackageNameMutation) ClearNamespace() {
	m.clearednamespace = true
	m.clearedFields[packagename.FieldNamespaceID] = struct{}{}
}

// NamespaceCleared reports if the "namespace" edge to the PackageNamespace entity was cleared.
func (m *PackageNameMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *PackageNameMutation) NamespaceIDs() (ids []int) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *PackageNameMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// AddVersionIDs adds the "versions" edge to the PackageVersion entity by ids.
func (m *PackageNameMutation) AddVersionIDs(ids ...int) {
	if m.versions == nil {
		m.versions = make(map[int]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the PackageVersion entity.
func (m *PackageNameMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the PackageVersion entity was cleared.
func (m *PackageNameMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the PackageVersion entity by IDs.
func (m *PackageNameMutation) RemoveVersionIDs(ids ...int) {
	if m.removedversions == nil {
		m.removedversions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the PackageVersion entity.
func (m *PackageNameMutation) RemovedVersionsIDs() (ids []int) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *PackageNameMutation) VersionsIDs() (ids []int) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *PackageNameMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// Where appends a list predicates to the PackageNameMutation builder.
func (m *PackageNameMutation) Where(ps ...predicate.PackageName) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageNameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageNameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageName, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageNameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageNameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageName).
func (m *PackageNameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageNameMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.namespace != nil {
		fields = append(fields, packagename.FieldNamespaceID)
	}
	if m.name != nil {
		fields = append(fields, packagename.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageNameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagename.FieldNamespaceID:
		return m.NamespaceID()
	case packagename.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageNameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagename.FieldNamespaceID:
		return m.OldNamespaceID(ctx)
	case packagename.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown PackageName field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagename.FieldNamespaceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespaceID(v)
		return nil
	case packagename.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown PackageName field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageNameMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageNameMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageName numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageNameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageNameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageNameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackageName nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageNameMutation) ResetField(name string) error {
	switch name {
	case packagename.FieldNamespaceID:
		m.ResetNamespaceID()
		return nil
	case packagename.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PackageName field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageNameMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.namespace != nil {
		edges = append(edges, packagename.EdgeNamespace)
	}
	if m.versions != nil {
		edges = append(edges, packagename.EdgeVersions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageNameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagename.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case packagename.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageNameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedversions != nil {
		edges = append(edges, packagename.EdgeVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageNameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packagename.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageNameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednamespace {
		edges = append(edges, packagename.EdgeNamespace)
	}
	if m.clearedversions {
		edges = append(edges, packagename.EdgeVersions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageNameMutation) EdgeCleared(name string) bool {
	switch name {
	case packagename.EdgeNamespace:
		return m.clearednamespace
	case packagename.EdgeVersions:
		return m.clearedversions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageNameMutation) ClearEdge(name string) error {
	switch name {
	case packagename.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown PackageName unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageNameMutation) ResetEdge(name string) error {
	switch name {
	case packagename.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case packagename.EdgeVersions:
		m.ResetVersions()
		return nil
	}
	return fmt.Errorf("unknown PackageName edge %s", name)
}

// PackageNamespaceMutation represents an operation that mutates the PackageNamespace nodes in the graph.
type PackageNamespaceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	namespace       *string
	clearedFields   map[string]struct{}
	_package        *int
	cleared_package bool
	names           map[int]struct{}
	removednames    map[int]struct{}
	clearednames    bool
	done            bool
	oldValue        func(context.Context) (*PackageNamespace, error)
	predicates      []predicate.PackageNamespace
}

var _ ent.Mutation = (*PackageNamespaceMutation)(nil)

// packagenamespaceOption allows management of the mutation configuration using functional options.
type packagenamespaceOption func(*PackageNamespaceMutation)

// newPackageNamespaceMutation creates new mutation for the PackageNamespace entity.
func newPackageNamespaceMutation(c config, op Op, opts ...packagenamespaceOption) *PackageNamespaceMutation {
	m := &PackageNamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypePackageNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageNamespaceID sets the ID field of the mutation.
func withPackageNamespaceID(id int) packagenamespaceOption {
	return func(m *PackageNamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageNamespace
		)
		m.oldValue = func(ctx context.Context) (*PackageNamespace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageNamespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageNamespace sets the old PackageNamespace of the mutation.
func withPackageNamespace(node *PackageNamespace) packagenamespaceOption {
	return func(m *PackageNamespaceMutation) {
		m.oldValue = func(context.Context) (*PackageNamespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageNamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageNamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageNamespaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageNamespaceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageNamespace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *PackageNamespaceMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *PackageNamespaceMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the PackageNamespace entity.
// If the PackageNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNamespaceMutation) OldPackageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *PackageNamespaceMutation) ResetPackageID() {
	m._package = nil
}

// SetNamespace sets the "namespace" field.
func (m *PackageNamespaceMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PackageNamespaceMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the PackageNamespace entity.
// If the PackageNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNamespaceMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PackageNamespaceMutation) ResetNamespace() {
	m.namespace = nil
}

// ClearPackage clears the "package" edge to the PackageType entity.
func (m *PackageNamespaceMutation) ClearPackage() {
	m.cleared_package = true
	m.clearedFields[packagenamespace.FieldPackageID] = struct{}{}
}

// PackageCleared reports if the "package" edge to the PackageType entity was cleared.
func (m *PackageNamespaceMutation) PackageCleared() bool {
	return m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *PackageNamespaceMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *PackageNamespaceMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// AddNameIDs adds the "names" edge to the PackageName entity by ids.
func (m *PackageNamespaceMutation) AddNameIDs(ids ...int) {
	if m.names == nil {
		m.names = make(map[int]struct{})
	}
	for i := range ids {
		m.names[ids[i]] = struct{}{}
	}
}

// ClearNames clears the "names" edge to the PackageName entity.
func (m *PackageNamespaceMutation) ClearNames() {
	m.clearednames = true
}

// NamesCleared reports if the "names" edge to the PackageName entity was cleared.
func (m *PackageNamespaceMutation) NamesCleared() bool {
	return m.clearednames
}

// RemoveNameIDs removes the "names" edge to the PackageName entity by IDs.
func (m *PackageNamespaceMutation) RemoveNameIDs(ids ...int) {
	if m.removednames == nil {
		m.removednames = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.names, ids[i])
		m.removednames[ids[i]] = struct{}{}
	}
}

// RemovedNames returns the removed IDs of the "names" edge to the PackageName entity.
func (m *PackageNamespaceMutation) RemovedNamesIDs() (ids []int) {
	for id := range m.removednames {
		ids = append(ids, id)
	}
	return
}

// NamesIDs returns the "names" edge IDs in the mutation.
func (m *PackageNamespaceMutation) NamesIDs() (ids []int) {
	for id := range m.names {
		ids = append(ids, id)
	}
	return
}

// ResetNames resets all changes to the "names" edge.
func (m *PackageNamespaceMutation) ResetNames() {
	m.names = nil
	m.clearednames = false
	m.removednames = nil
}

// Where appends a list predicates to the PackageNamespaceMutation builder.
func (m *PackageNamespaceMutation) Where(ps ...predicate.PackageNamespace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageNamespaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageNamespaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageNamespace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageNamespaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageNamespaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageNamespace).
func (m *PackageNamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageNamespaceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._package != nil {
		fields = append(fields, packagenamespace.FieldPackageID)
	}
	if m.namespace != nil {
		fields = append(fields, packagenamespace.FieldNamespace)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageNamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagenamespace.FieldPackageID:
		return m.PackageID()
	case packagenamespace.FieldNamespace:
		return m.Namespace()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageNamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagenamespace.FieldPackageID:
		return m.OldPackageID(ctx)
	case packagenamespace.FieldNamespace:
		return m.OldNamespace(ctx)
	}
	return nil, fmt.Errorf("unknown PackageNamespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagenamespace.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case packagenamespace.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	}
	return fmt.Errorf("unknown PackageNamespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageNamespaceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageNamespaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageNamespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageNamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageNamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageNamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackageNamespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageNamespaceMutation) ResetField(name string) error {
	switch name {
	case packagenamespace.FieldPackageID:
		m.ResetPackageID()
		return nil
	case packagenamespace.FieldNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown PackageNamespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageNamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._package != nil {
		edges = append(edges, packagenamespace.EdgePackage)
	}
	if m.names != nil {
		edges = append(edges, packagenamespace.EdgeNames)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageNamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagenamespace.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case packagenamespace.EdgeNames:
		ids := make([]ent.Value, 0, len(m.names))
		for id := range m.names {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageNamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednames != nil {
		edges = append(edges, packagenamespace.EdgeNames)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageNamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packagenamespace.EdgeNames:
		ids := make([]ent.Value, 0, len(m.removednames))
		for id := range m.removednames {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageNamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_package {
		edges = append(edges, packagenamespace.EdgePackage)
	}
	if m.clearednames {
		edges = append(edges, packagenamespace.EdgeNames)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageNamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case packagenamespace.EdgePackage:
		return m.cleared_package
	case packagenamespace.EdgeNames:
		return m.clearednames
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageNamespaceMutation) ClearEdge(name string) error {
	switch name {
	case packagenamespace.EdgePackage:
		m.ClearPackage()
		return nil
	}
	return fmt.Errorf("unknown PackageNamespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageNamespaceMutation) ResetEdge(name string) error {
	switch name {
	case packagenamespace.EdgePackage:
		m.ResetPackage()
		return nil
	case packagenamespace.EdgeNames:
		m.ResetNames()
		return nil
	}
	return fmt.Errorf("unknown PackageNamespace edge %s", name)
}

// PackageTypeMutation represents an operation that mutates the PackageType nodes in the graph.
type PackageTypeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_type             *string
	clearedFields     map[string]struct{}
	namespaces        map[int]struct{}
	removednamespaces map[int]struct{}
	clearednamespaces bool
	done              bool
	oldValue          func(context.Context) (*PackageType, error)
	predicates        []predicate.PackageType
}

var _ ent.Mutation = (*PackageTypeMutation)(nil)

// packagetypeOption allows management of the mutation configuration using functional options.
type packagetypeOption func(*PackageTypeMutation)

// newPackageTypeMutation creates new mutation for the PackageType entity.
func newPackageTypeMutation(c config, op Op, opts ...packagetypeOption) *PackageTypeMutation {
	m := &PackageTypeMutation{
		config:        c,
		op:            op,
		typ:           TypePackageType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageTypeID sets the ID field of the mutation.
func withPackageTypeID(id int) packagetypeOption {
	return func(m *PackageTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageType
		)
		m.oldValue = func(ctx context.Context) (*PackageType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageType sets the old PackageType of the mutation.
func withPackageType(node *PackageType) packagetypeOption {
	return func(m *PackageTypeMutation) {
		m.oldValue = func(context.Context) (*PackageType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *PackageTypeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PackageTypeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PackageType entity.
// If the PackageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageTypeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PackageTypeMutation) ResetType() {
	m._type = nil
}

// AddNamespaceIDs adds the "namespaces" edge to the PackageNamespace entity by ids.
func (m *PackageTypeMutation) AddNamespaceIDs(ids ...int) {
	if m.namespaces == nil {
		m.namespaces = make(map[int]struct{})
	}
	for i := range ids {
		m.namespaces[ids[i]] = struct{}{}
	}
}

// ClearNamespaces clears the "namespaces" edge to the PackageNamespace entity.
func (m *PackageTypeMutation) ClearNamespaces() {
	m.clearednamespaces = true
}

// NamespacesCleared reports if the "namespaces" edge to the PackageNamespace entity was cleared.
func (m *PackageTypeMutation) NamespacesCleared() bool {
	return m.clearednamespaces
}

// RemoveNamespaceIDs removes the "namespaces" edge to the PackageNamespace entity by IDs.
func (m *PackageTypeMutation) RemoveNamespaceIDs(ids ...int) {
	if m.removednamespaces == nil {
		m.removednamespaces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.namespaces, ids[i])
		m.removednamespaces[ids[i]] = struct{}{}
	}
}

// RemovedNamespaces returns the removed IDs of the "namespaces" edge to the PackageNamespace entity.
func (m *PackageTypeMutation) RemovedNamespacesIDs() (ids []int) {
	for id := range m.removednamespaces {
		ids = append(ids, id)
	}
	return
}

// NamespacesIDs returns the "namespaces" edge IDs in the mutation.
func (m *PackageTypeMutation) NamespacesIDs() (ids []int) {
	for id := range m.namespaces {
		ids = append(ids, id)
	}
	return
}

// ResetNamespaces resets all changes to the "namespaces" edge.
func (m *PackageTypeMutation) ResetNamespaces() {
	m.namespaces = nil
	m.clearednamespaces = false
	m.removednamespaces = nil
}

// Where appends a list predicates to the PackageTypeMutation builder.
func (m *PackageTypeMutation) Where(ps ...predicate.PackageType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageType).
func (m *PackageTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._type != nil {
		fields = append(fields, packagetype.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagetype.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagetype.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown PackageType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagetype.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown PackageType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackageType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageTypeMutation) ResetField(name string) error {
	switch name {
	case packagetype.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown PackageType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespaces != nil {
		edges = append(edges, packagetype.EdgeNamespaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagetype.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.namespaces))
		for id := range m.namespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednamespaces != nil {
		edges = append(edges, packagetype.EdgeNamespaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packagetype.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.removednamespaces))
		for id := range m.removednamespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespaces {
		edges = append(edges, packagetype.EdgeNamespaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case packagetype.EdgeNamespaces:
		return m.clearednamespaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageTypeMutation) ResetEdge(name string) error {
	switch name {
	case packagetype.EdgeNamespaces:
		m.ResetNamespaces()
		return nil
	}
	return fmt.Errorf("unknown PackageType edge %s", name)
}

// PackageVersionMutation represents an operation that mutates the PackageVersion nodes in the graph.
type PackageVersionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	version               *string
	subpath               *string
	qualifiers            *[]model.PackageQualifier
	appendqualifiers      []model.PackageQualifier
	hash                  *string
	clearedFields         map[string]struct{}
	name                  *int
	clearedname           bool
	occurrences           map[int]struct{}
	removedoccurrences    map[int]struct{}
	clearedoccurrences    bool
	sbom                  map[int]struct{}
	removedsbom           map[int]struct{}
	clearedsbom           bool
	equal_packages        map[int]struct{}
	removedequal_packages map[int]struct{}
	clearedequal_packages bool
	done                  bool
	oldValue              func(context.Context) (*PackageVersion, error)
	predicates            []predicate.PackageVersion
}

var _ ent.Mutation = (*PackageVersionMutation)(nil)

// packageversionOption allows management of the mutation configuration using functional options.
type packageversionOption func(*PackageVersionMutation)

// newPackageVersionMutation creates new mutation for the PackageVersion entity.
func newPackageVersionMutation(c config, op Op, opts ...packageversionOption) *PackageVersionMutation {
	m := &PackageVersionMutation{
		config:        c,
		op:            op,
		typ:           TypePackageVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageVersionID sets the ID field of the mutation.
func withPackageVersionID(id int) packageversionOption {
	return func(m *PackageVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageVersion
		)
		m.oldValue = func(ctx context.Context) (*PackageVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageVersion sets the old PackageVersion of the mutation.
func withPackageVersion(node *PackageVersion) packageversionOption {
	return func(m *PackageVersionMutation) {
		m.oldValue = func(context.Context) (*PackageVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameID sets the "name_id" field.
func (m *PackageVersionMutation) SetNameID(i int) {
	m.name = &i
}

// NameID returns the value of the "name_id" field in the mutation.
func (m *PackageVersionMutation) NameID() (r int, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldNameID returns the old "name_id" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldNameID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameID: %w", err)
	}
	return oldValue.NameID, nil
}

// ResetNameID resets all changes to the "name_id" field.
func (m *PackageVersionMutation) ResetNameID() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *PackageVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PackageVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PackageVersionMutation) ResetVersion() {
	m.version = nil
}

// SetSubpath sets the "subpath" field.
func (m *PackageVersionMutation) SetSubpath(s string) {
	m.subpath = &s
}

// Subpath returns the value of the "subpath" field in the mutation.
func (m *PackageVersionMutation) Subpath() (r string, exists bool) {
	v := m.subpath
	if v == nil {
		return
	}
	return *v, true
}

// OldSubpath returns the old "subpath" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldSubpath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubpath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubpath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubpath: %w", err)
	}
	return oldValue.Subpath, nil
}

// ResetSubpath resets all changes to the "subpath" field.
func (m *PackageVersionMutation) ResetSubpath() {
	m.subpath = nil
}

// SetQualifiers sets the "qualifiers" field.
func (m *PackageVersionMutation) SetQualifiers(mq []model.PackageQualifier) {
	m.qualifiers = &mq
	m.appendqualifiers = nil
}

// Qualifiers returns the value of the "qualifiers" field in the mutation.
func (m *PackageVersionMutation) Qualifiers() (r []model.PackageQualifier, exists bool) {
	v := m.qualifiers
	if v == nil {
		return
	}
	return *v, true
}

// OldQualifiers returns the old "qualifiers" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldQualifiers(ctx context.Context) (v []model.PackageQualifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualifiers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualifiers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualifiers: %w", err)
	}
	return oldValue.Qualifiers, nil
}

// AppendQualifiers adds mq to the "qualifiers" field.
func (m *PackageVersionMutation) AppendQualifiers(mq []model.PackageQualifier) {
	m.appendqualifiers = append(m.appendqualifiers, mq...)
}

// AppendedQualifiers returns the list of values that were appended to the "qualifiers" field in this mutation.
func (m *PackageVersionMutation) AppendedQualifiers() ([]model.PackageQualifier, bool) {
	if len(m.appendqualifiers) == 0 {
		return nil, false
	}
	return m.appendqualifiers, true
}

// ClearQualifiers clears the value of the "qualifiers" field.
func (m *PackageVersionMutation) ClearQualifiers() {
	m.qualifiers = nil
	m.appendqualifiers = nil
	m.clearedFields[packageversion.FieldQualifiers] = struct{}{}
}

// QualifiersCleared returns if the "qualifiers" field was cleared in this mutation.
func (m *PackageVersionMutation) QualifiersCleared() bool {
	_, ok := m.clearedFields[packageversion.FieldQualifiers]
	return ok
}

// ResetQualifiers resets all changes to the "qualifiers" field.
func (m *PackageVersionMutation) ResetQualifiers() {
	m.qualifiers = nil
	m.appendqualifiers = nil
	delete(m.clearedFields, packageversion.FieldQualifiers)
}

// SetHash sets the "hash" field.
func (m *PackageVersionMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *PackageVersionMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *PackageVersionMutation) ResetHash() {
	m.hash = nil
}

// ClearName clears the "name" edge to the PackageName entity.
func (m *PackageVersionMutation) ClearName() {
	m.clearedname = true
	m.clearedFields[packageversion.FieldNameID] = struct{}{}
}

// NameCleared reports if the "name" edge to the PackageName entity was cleared.
func (m *PackageVersionMutation) NameCleared() bool {
	return m.clearedname
}

// NameIDs returns the "name" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NameID instead. It exists only for internal usage by the builders.
func (m *PackageVersionMutation) NameIDs() (ids []int) {
	if id := m.name; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetName resets all changes to the "name" edge.
func (m *PackageVersionMutation) ResetName() {
	m.name = nil
	m.clearedname = false
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by ids.
func (m *PackageVersionMutation) AddOccurrenceIDs(ids ...int) {
	if m.occurrences == nil {
		m.occurrences = make(map[int]struct{})
	}
	for i := range ids {
		m.occurrences[ids[i]] = struct{}{}
	}
}

// ClearOccurrences clears the "occurrences" edge to the Occurrence entity.
func (m *PackageVersionMutation) ClearOccurrences() {
	m.clearedoccurrences = true
}

// OccurrencesCleared reports if the "occurrences" edge to the Occurrence entity was cleared.
func (m *PackageVersionMutation) OccurrencesCleared() bool {
	return m.clearedoccurrences
}

// RemoveOccurrenceIDs removes the "occurrences" edge to the Occurrence entity by IDs.
func (m *PackageVersionMutation) RemoveOccurrenceIDs(ids ...int) {
	if m.removedoccurrences == nil {
		m.removedoccurrences = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occurrences, ids[i])
		m.removedoccurrences[ids[i]] = struct{}{}
	}
}

// RemovedOccurrences returns the removed IDs of the "occurrences" edge to the Occurrence entity.
func (m *PackageVersionMutation) RemovedOccurrencesIDs() (ids []int) {
	for id := range m.removedoccurrences {
		ids = append(ids, id)
	}
	return
}

// OccurrencesIDs returns the "occurrences" edge IDs in the mutation.
func (m *PackageVersionMutation) OccurrencesIDs() (ids []int) {
	for id := range m.occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetOccurrences resets all changes to the "occurrences" edge.
func (m *PackageVersionMutation) ResetOccurrences() {
	m.occurrences = nil
	m.clearedoccurrences = false
	m.removedoccurrences = nil
}

// AddSbomIDs adds the "sbom" edge to the BillOfMaterials entity by ids.
func (m *PackageVersionMutation) AddSbomIDs(ids ...int) {
	if m.sbom == nil {
		m.sbom = make(map[int]struct{})
	}
	for i := range ids {
		m.sbom[ids[i]] = struct{}{}
	}
}

// ClearSbom clears the "sbom" edge to the BillOfMaterials entity.
func (m *PackageVersionMutation) ClearSbom() {
	m.clearedsbom = true
}

// SbomCleared reports if the "sbom" edge to the BillOfMaterials entity was cleared.
func (m *PackageVersionMutation) SbomCleared() bool {
	return m.clearedsbom
}

// RemoveSbomIDs removes the "sbom" edge to the BillOfMaterials entity by IDs.
func (m *PackageVersionMutation) RemoveSbomIDs(ids ...int) {
	if m.removedsbom == nil {
		m.removedsbom = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sbom, ids[i])
		m.removedsbom[ids[i]] = struct{}{}
	}
}

// RemovedSbom returns the removed IDs of the "sbom" edge to the BillOfMaterials entity.
func (m *PackageVersionMutation) RemovedSbomIDs() (ids []int) {
	for id := range m.removedsbom {
		ids = append(ids, id)
	}
	return
}

// SbomIDs returns the "sbom" edge IDs in the mutation.
func (m *PackageVersionMutation) SbomIDs() (ids []int) {
	for id := range m.sbom {
		ids = append(ids, id)
	}
	return
}

// ResetSbom resets all changes to the "sbom" edge.
func (m *PackageVersionMutation) ResetSbom() {
	m.sbom = nil
	m.clearedsbom = false
	m.removedsbom = nil
}

// AddEqualPackageIDs adds the "equal_packages" edge to the PkgEqual entity by ids.
func (m *PackageVersionMutation) AddEqualPackageIDs(ids ...int) {
	if m.equal_packages == nil {
		m.equal_packages = make(map[int]struct{})
	}
	for i := range ids {
		m.equal_packages[ids[i]] = struct{}{}
	}
}

// ClearEqualPackages clears the "equal_packages" edge to the PkgEqual entity.
func (m *PackageVersionMutation) ClearEqualPackages() {
	m.clearedequal_packages = true
}

// EqualPackagesCleared reports if the "equal_packages" edge to the PkgEqual entity was cleared.
func (m *PackageVersionMutation) EqualPackagesCleared() bool {
	return m.clearedequal_packages
}

// RemoveEqualPackageIDs removes the "equal_packages" edge to the PkgEqual entity by IDs.
func (m *PackageVersionMutation) RemoveEqualPackageIDs(ids ...int) {
	if m.removedequal_packages == nil {
		m.removedequal_packages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.equal_packages, ids[i])
		m.removedequal_packages[ids[i]] = struct{}{}
	}
}

// RemovedEqualPackages returns the removed IDs of the "equal_packages" edge to the PkgEqual entity.
func (m *PackageVersionMutation) RemovedEqualPackagesIDs() (ids []int) {
	for id := range m.removedequal_packages {
		ids = append(ids, id)
	}
	return
}

// EqualPackagesIDs returns the "equal_packages" edge IDs in the mutation.
func (m *PackageVersionMutation) EqualPackagesIDs() (ids []int) {
	for id := range m.equal_packages {
		ids = append(ids, id)
	}
	return
}

// ResetEqualPackages resets all changes to the "equal_packages" edge.
func (m *PackageVersionMutation) ResetEqualPackages() {
	m.equal_packages = nil
	m.clearedequal_packages = false
	m.removedequal_packages = nil
}

// Where appends a list predicates to the PackageVersionMutation builder.
func (m *PackageVersionMutation) Where(ps ...predicate.PackageVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageVersion).
func (m *PackageVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageVersionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, packageversion.FieldNameID)
	}
	if m.version != nil {
		fields = append(fields, packageversion.FieldVersion)
	}
	if m.subpath != nil {
		fields = append(fields, packageversion.FieldSubpath)
	}
	if m.qualifiers != nil {
		fields = append(fields, packageversion.FieldQualifiers)
	}
	if m.hash != nil {
		fields = append(fields, packageversion.FieldHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packageversion.FieldNameID:
		return m.NameID()
	case packageversion.FieldVersion:
		return m.Version()
	case packageversion.FieldSubpath:
		return m.Subpath()
	case packageversion.FieldQualifiers:
		return m.Qualifiers()
	case packageversion.FieldHash:
		return m.Hash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packageversion.FieldNameID:
		return m.OldNameID(ctx)
	case packageversion.FieldVersion:
		return m.OldVersion(ctx)
	case packageversion.FieldSubpath:
		return m.OldSubpath(ctx)
	case packageversion.FieldQualifiers:
		return m.OldQualifiers(ctx)
	case packageversion.FieldHash:
		return m.OldHash(ctx)
	}
	return nil, fmt.Errorf("unknown PackageVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packageversion.FieldNameID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameID(v)
		return nil
	case packageversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case packageversion.FieldSubpath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubpath(v)
		return nil
	case packageversion.FieldQualifiers:
		v, ok := value.([]model.PackageQualifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualifiers(v)
		return nil
	case packageversion.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	}
	return fmt.Errorf("unknown PackageVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageVersionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(packageversion.FieldQualifiers) {
		fields = append(fields, packageversion.FieldQualifiers)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageVersionMutation) ClearField(name string) error {
	switch name {
	case packageversion.FieldQualifiers:
		m.ClearQualifiers()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageVersionMutation) ResetField(name string) error {
	switch name {
	case packageversion.FieldNameID:
		m.ResetNameID()
		return nil
	case packageversion.FieldVersion:
		m.ResetVersion()
		return nil
	case packageversion.FieldSubpath:
		m.ResetSubpath()
		return nil
	case packageversion.FieldQualifiers:
		m.ResetQualifiers()
		return nil
	case packageversion.FieldHash:
		m.ResetHash()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.name != nil {
		edges = append(edges, packageversion.EdgeName)
	}
	if m.occurrences != nil {
		edges = append(edges, packageversion.EdgeOccurrences)
	}
	if m.sbom != nil {
		edges = append(edges, packageversion.EdgeSbom)
	}
	if m.equal_packages != nil {
		edges = append(edges, packageversion.EdgeEqualPackages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packageversion.EdgeName:
		if id := m.name; id != nil {
			return []ent.Value{*id}
		}
	case packageversion.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.occurrences))
		for id := range m.occurrences {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeSbom:
		ids := make([]ent.Value, 0, len(m.sbom))
		for id := range m.sbom {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeEqualPackages:
		ids := make([]ent.Value, 0, len(m.equal_packages))
		for id := range m.equal_packages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedoccurrences != nil {
		edges = append(edges, packageversion.EdgeOccurrences)
	}
	if m.removedsbom != nil {
		edges = append(edges, packageversion.EdgeSbom)
	}
	if m.removedequal_packages != nil {
		edges = append(edges, packageversion.EdgeEqualPackages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageVersionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packageversion.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.removedoccurrences))
		for id := range m.removedoccurrences {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeSbom:
		ids := make([]ent.Value, 0, len(m.removedsbom))
		for id := range m.removedsbom {
			ids = append(ids, id)
		}
		return ids
	case packageversion.EdgeEqualPackages:
		ids := make([]ent.Value, 0, len(m.removedequal_packages))
		for id := range m.removedequal_packages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedname {
		edges = append(edges, packageversion.EdgeName)
	}
	if m.clearedoccurrences {
		edges = append(edges, packageversion.EdgeOccurrences)
	}
	if m.clearedsbom {
		edges = append(edges, packageversion.EdgeSbom)
	}
	if m.clearedequal_packages {
		edges = append(edges, packageversion.EdgeEqualPackages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case packageversion.EdgeName:
		return m.clearedname
	case packageversion.EdgeOccurrences:
		return m.clearedoccurrences
	case packageversion.EdgeSbom:
		return m.clearedsbom
	case packageversion.EdgeEqualPackages:
		return m.clearedequal_packages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageVersionMutation) ClearEdge(name string) error {
	switch name {
	case packageversion.EdgeName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageVersionMutation) ResetEdge(name string) error {
	switch name {
	case packageversion.EdgeName:
		m.ResetName()
		return nil
	case packageversion.EdgeOccurrences:
		m.ResetOccurrences()
		return nil
	case packageversion.EdgeSbom:
		m.ResetSbom()
		return nil
	case packageversion.EdgeEqualPackages:
		m.ResetEqualPackages()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion edge %s", name)
}

// PkgEqualMutation represents an operation that mutates the PkgEqual nodes in the graph.
type PkgEqualMutation struct {
	config
	op              Op
	typ             string
	id              *int
	origin          *string
	collector       *string
	justification   *string
	packages_hash   *string
	clearedFields   map[string]struct{}
	packages        map[int]struct{}
	removedpackages map[int]struct{}
	clearedpackages bool
	done            bool
	oldValue        func(context.Context) (*PkgEqual, error)
	predicates      []predicate.PkgEqual
}

var _ ent.Mutation = (*PkgEqualMutation)(nil)

// pkgequalOption allows management of the mutation configuration using functional options.
type pkgequalOption func(*PkgEqualMutation)

// newPkgEqualMutation creates new mutation for the PkgEqual entity.
func newPkgEqualMutation(c config, op Op, opts ...pkgequalOption) *PkgEqualMutation {
	m := &PkgEqualMutation{
		config:        c,
		op:            op,
		typ:           TypePkgEqual,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPkgEqualID sets the ID field of the mutation.
func withPkgEqualID(id int) pkgequalOption {
	return func(m *PkgEqualMutation) {
		var (
			err   error
			once  sync.Once
			value *PkgEqual
		)
		m.oldValue = func(ctx context.Context) (*PkgEqual, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PkgEqual.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPkgEqual sets the old PkgEqual of the mutation.
func withPkgEqual(node *PkgEqual) pkgequalOption {
	return func(m *PkgEqualMutation) {
		m.oldValue = func(context.Context) (*PkgEqual, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PkgEqualMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PkgEqualMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PkgEqualMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PkgEqualMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PkgEqual.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrigin sets the "origin" field.
func (m *PkgEqualMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *PkgEqualMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *PkgEqualMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *PkgEqualMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *PkgEqualMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *PkgEqualMutation) ResetCollector() {
	m.collector = nil
}

// SetJustification sets the "justification" field.
func (m *PkgEqualMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *PkgEqualMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *PkgEqualMutation) ResetJustification() {
	m.justification = nil
}

// SetPackagesHash sets the "packages_hash" field.
func (m *PkgEqualMutation) SetPackagesHash(s string) {
	m.packages_hash = &s
}

// PackagesHash returns the value of the "packages_hash" field in the mutation.
func (m *PkgEqualMutation) PackagesHash() (r string, exists bool) {
	v := m.packages_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPackagesHash returns the old "packages_hash" field's value of the PkgEqual entity.
// If the PkgEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkgEqualMutation) OldPackagesHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackagesHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackagesHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackagesHash: %w", err)
	}
	return oldValue.PackagesHash, nil
}

// ResetPackagesHash resets all changes to the "packages_hash" field.
func (m *PkgEqualMutation) ResetPackagesHash() {
	m.packages_hash = nil
}

// AddPackageIDs adds the "packages" edge to the PackageVersion entity by ids.
func (m *PkgEqualMutation) AddPackageIDs(ids ...int) {
	if m.packages == nil {
		m.packages = make(map[int]struct{})
	}
	for i := range ids {
		m.packages[ids[i]] = struct{}{}
	}
}

// ClearPackages clears the "packages" edge to the PackageVersion entity.
func (m *PkgEqualMutation) ClearPackages() {
	m.clearedpackages = true
}

// PackagesCleared reports if the "packages" edge to the PackageVersion entity was cleared.
func (m *PkgEqualMutation) PackagesCleared() bool {
	return m.clearedpackages
}

// RemovePackageIDs removes the "packages" edge to the PackageVersion entity by IDs.
func (m *PkgEqualMutation) RemovePackageIDs(ids ...int) {
	if m.removedpackages == nil {
		m.removedpackages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.packages, ids[i])
		m.removedpackages[ids[i]] = struct{}{}
	}
}

// RemovedPackages returns the removed IDs of the "packages" edge to the PackageVersion entity.
func (m *PkgEqualMutation) RemovedPackagesIDs() (ids []int) {
	for id := range m.removedpackages {
		ids = append(ids, id)
	}
	return
}

// PackagesIDs returns the "packages" edge IDs in the mutation.
func (m *PkgEqualMutation) PackagesIDs() (ids []int) {
	for id := range m.packages {
		ids = append(ids, id)
	}
	return
}

// ResetPackages resets all changes to the "packages" edge.
func (m *PkgEqualMutation) ResetPackages() {
	m.packages = nil
	m.clearedpackages = false
	m.removedpackages = nil
}

// Where appends a list predicates to the PkgEqualMutation builder.
func (m *PkgEqualMutation) Where(ps ...predicate.PkgEqual) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PkgEqualMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PkgEqualMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PkgEqual, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PkgEqualMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PkgEqualMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PkgEqual).
func (m *PkgEqualMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PkgEqualMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.origin != nil {
		fields = append(fields, pkgequal.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, pkgequal.FieldCollector)
	}
	if m.justification != nil {
		fields = append(fields, pkgequal.FieldJustification)
	}
	if m.packages_hash != nil {
		fields = append(fields, pkgequal.FieldPackagesHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PkgEqualMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pkgequal.FieldOrigin:
		return m.Origin()
	case pkgequal.FieldCollector:
		return m.Collector()
	case pkgequal.FieldJustification:
		return m.Justification()
	case pkgequal.FieldPackagesHash:
		return m.PackagesHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PkgEqualMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pkgequal.FieldOrigin:
		return m.OldOrigin(ctx)
	case pkgequal.FieldCollector:
		return m.OldCollector(ctx)
	case pkgequal.FieldJustification:
		return m.OldJustification(ctx)
	case pkgequal.FieldPackagesHash:
		return m.OldPackagesHash(ctx)
	}
	return nil, fmt.Errorf("unknown PkgEqual field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PkgEqualMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pkgequal.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case pkgequal.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case pkgequal.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case pkgequal.FieldPackagesHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackagesHash(v)
		return nil
	}
	return fmt.Errorf("unknown PkgEqual field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PkgEqualMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PkgEqualMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PkgEqualMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PkgEqual numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PkgEqualMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PkgEqualMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PkgEqualMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PkgEqual nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PkgEqualMutation) ResetField(name string) error {
	switch name {
	case pkgequal.FieldOrigin:
		m.ResetOrigin()
		return nil
	case pkgequal.FieldCollector:
		m.ResetCollector()
		return nil
	case pkgequal.FieldJustification:
		m.ResetJustification()
		return nil
	case pkgequal.FieldPackagesHash:
		m.ResetPackagesHash()
		return nil
	}
	return fmt.Errorf("unknown PkgEqual field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PkgEqualMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.packages != nil {
		edges = append(edges, pkgequal.EdgePackages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PkgEqualMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pkgequal.EdgePackages:
		ids := make([]ent.Value, 0, len(m.packages))
		for id := range m.packages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PkgEqualMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpackages != nil {
		edges = append(edges, pkgequal.EdgePackages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PkgEqualMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pkgequal.EdgePackages:
		ids := make([]ent.Value, 0, len(m.removedpackages))
		for id := range m.removedpackages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PkgEqualMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpackages {
		edges = append(edges, pkgequal.EdgePackages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PkgEqualMutation) EdgeCleared(name string) bool {
	switch name {
	case pkgequal.EdgePackages:
		return m.clearedpackages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PkgEqualMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PkgEqual unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PkgEqualMutation) ResetEdge(name string) error {
	switch name {
	case pkgequal.EdgePackages:
		m.ResetPackages()
		return nil
	}
	return fmt.Errorf("unknown PkgEqual edge %s", name)
}

// SLSAAttestationMutation represents an operation that mutates the SLSAAttestation nodes in the graph.
type SLSAAttestationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	build_type           *string
	slsa_predicate       *[]*model.SLSAPredicate
	appendslsa_predicate []*model.SLSAPredicate
	slsa_version         *string
	started_on           *time.Time
	finished_on          *time.Time
	origin               *string
	collector            *string
	built_from_hash      *string
	clearedFields        map[string]struct{}
	built_from           map[int]struct{}
	removedbuilt_from    map[int]struct{}
	clearedbuilt_from    bool
	built_by             *int
	clearedbuilt_by      bool
	subject              *int
	clearedsubject       bool
	done                 bool
	oldValue             func(context.Context) (*SLSAAttestation, error)
	predicates           []predicate.SLSAAttestation
}

var _ ent.Mutation = (*SLSAAttestationMutation)(nil)

// slsaattestationOption allows management of the mutation configuration using functional options.
type slsaattestationOption func(*SLSAAttestationMutation)

// newSLSAAttestationMutation creates new mutation for the SLSAAttestation entity.
func newSLSAAttestationMutation(c config, op Op, opts ...slsaattestationOption) *SLSAAttestationMutation {
	m := &SLSAAttestationMutation{
		config:        c,
		op:            op,
		typ:           TypeSLSAAttestation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSLSAAttestationID sets the ID field of the mutation.
func withSLSAAttestationID(id int) slsaattestationOption {
	return func(m *SLSAAttestationMutation) {
		var (
			err   error
			once  sync.Once
			value *SLSAAttestation
		)
		m.oldValue = func(ctx context.Context) (*SLSAAttestation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SLSAAttestation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSLSAAttestation sets the old SLSAAttestation of the mutation.
func withSLSAAttestation(node *SLSAAttestation) slsaattestationOption {
	return func(m *SLSAAttestationMutation) {
		m.oldValue = func(context.Context) (*SLSAAttestation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SLSAAttestationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SLSAAttestationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SLSAAttestationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SLSAAttestationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SLSAAttestation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBuildType sets the "build_type" field.
func (m *SLSAAttestationMutation) SetBuildType(s string) {
	m.build_type = &s
}

// BuildType returns the value of the "build_type" field in the mutation.
func (m *SLSAAttestationMutation) BuildType() (r string, exists bool) {
	v := m.build_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildType returns the old "build_type" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldBuildType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildType: %w", err)
	}
	return oldValue.BuildType, nil
}

// ResetBuildType resets all changes to the "build_type" field.
func (m *SLSAAttestationMutation) ResetBuildType() {
	m.build_type = nil
}

// SetBuiltByID sets the "built_by_id" field.
func (m *SLSAAttestationMutation) SetBuiltByID(i int) {
	m.built_by = &i
}

// BuiltByID returns the value of the "built_by_id" field in the mutation.
func (m *SLSAAttestationMutation) BuiltByID() (r int, exists bool) {
	v := m.built_by
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltByID returns the old "built_by_id" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldBuiltByID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltByID: %w", err)
	}
	return oldValue.BuiltByID, nil
}

// ResetBuiltByID resets all changes to the "built_by_id" field.
func (m *SLSAAttestationMutation) ResetBuiltByID() {
	m.built_by = nil
}

// SetSubjectID sets the "subject_id" field.
func (m *SLSAAttestationMutation) SetSubjectID(i int) {
	m.subject = &i
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *SLSAAttestationMutation) SubjectID() (r int, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldSubjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *SLSAAttestationMutation) ResetSubjectID() {
	m.subject = nil
}

// SetSlsaPredicate sets the "slsa_predicate" field.
func (m *SLSAAttestationMutation) SetSlsaPredicate(mp []*model.SLSAPredicate) {
	m.slsa_predicate = &mp
	m.appendslsa_predicate = nil
}

// SlsaPredicate returns the value of the "slsa_predicate" field in the mutation.
func (m *SLSAAttestationMutation) SlsaPredicate() (r []*model.SLSAPredicate, exists bool) {
	v := m.slsa_predicate
	if v == nil {
		return
	}
	return *v, true
}

// OldSlsaPredicate returns the old "slsa_predicate" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldSlsaPredicate(ctx context.Context) (v []*model.SLSAPredicate, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlsaPredicate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlsaPredicate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlsaPredicate: %w", err)
	}
	return oldValue.SlsaPredicate, nil
}

// AppendSlsaPredicate adds mp to the "slsa_predicate" field.
func (m *SLSAAttestationMutation) AppendSlsaPredicate(mp []*model.SLSAPredicate) {
	m.appendslsa_predicate = append(m.appendslsa_predicate, mp...)
}

// AppendedSlsaPredicate returns the list of values that were appended to the "slsa_predicate" field in this mutation.
func (m *SLSAAttestationMutation) AppendedSlsaPredicate() ([]*model.SLSAPredicate, bool) {
	if len(m.appendslsa_predicate) == 0 {
		return nil, false
	}
	return m.appendslsa_predicate, true
}

// ClearSlsaPredicate clears the value of the "slsa_predicate" field.
func (m *SLSAAttestationMutation) ClearSlsaPredicate() {
	m.slsa_predicate = nil
	m.appendslsa_predicate = nil
	m.clearedFields[slsaattestation.FieldSlsaPredicate] = struct{}{}
}

// SlsaPredicateCleared returns if the "slsa_predicate" field was cleared in this mutation.
func (m *SLSAAttestationMutation) SlsaPredicateCleared() bool {
	_, ok := m.clearedFields[slsaattestation.FieldSlsaPredicate]
	return ok
}

// ResetSlsaPredicate resets all changes to the "slsa_predicate" field.
func (m *SLSAAttestationMutation) ResetSlsaPredicate() {
	m.slsa_predicate = nil
	m.appendslsa_predicate = nil
	delete(m.clearedFields, slsaattestation.FieldSlsaPredicate)
}

// SetSlsaVersion sets the "slsa_version" field.
func (m *SLSAAttestationMutation) SetSlsaVersion(s string) {
	m.slsa_version = &s
}

// SlsaVersion returns the value of the "slsa_version" field in the mutation.
func (m *SLSAAttestationMutation) SlsaVersion() (r string, exists bool) {
	v := m.slsa_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSlsaVersion returns the old "slsa_version" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldSlsaVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlsaVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlsaVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlsaVersion: %w", err)
	}
	return oldValue.SlsaVersion, nil
}

// ResetSlsaVersion resets all changes to the "slsa_version" field.
func (m *SLSAAttestationMutation) ResetSlsaVersion() {
	m.slsa_version = nil
}

// SetStartedOn sets the "started_on" field.
func (m *SLSAAttestationMutation) SetStartedOn(t time.Time) {
	m.started_on = &t
}

// StartedOn returns the value of the "started_on" field in the mutation.
func (m *SLSAAttestationMutation) StartedOn() (r time.Time, exists bool) {
	v := m.started_on
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedOn returns the old "started_on" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldStartedOn(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedOn: %w", err)
	}
	return oldValue.StartedOn, nil
}

// ClearStartedOn clears the value of the "started_on" field.
func (m *SLSAAttestationMutation) ClearStartedOn() {
	m.started_on = nil
	m.clearedFields[slsaattestation.FieldStartedOn] = struct{}{}
}

// StartedOnCleared returns if the "started_on" field was cleared in this mutation.
func (m *SLSAAttestationMutation) StartedOnCleared() bool {
	_, ok := m.clearedFields[slsaattestation.FieldStartedOn]
	return ok
}

// ResetStartedOn resets all changes to the "started_on" field.
func (m *SLSAAttestationMutation) ResetStartedOn() {
	m.started_on = nil
	delete(m.clearedFields, slsaattestation.FieldStartedOn)
}

// SetFinishedOn sets the "finished_on" field.
func (m *SLSAAttestationMutation) SetFinishedOn(t time.Time) {
	m.finished_on = &t
}

// FinishedOn returns the value of the "finished_on" field in the mutation.
func (m *SLSAAttestationMutation) FinishedOn() (r time.Time, exists bool) {
	v := m.finished_on
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedOn returns the old "finished_on" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldFinishedOn(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedOn: %w", err)
	}
	return oldValue.FinishedOn, nil
}

// ClearFinishedOn clears the value of the "finished_on" field.
func (m *SLSAAttestationMutation) ClearFinishedOn() {
	m.finished_on = nil
	m.clearedFields[slsaattestation.FieldFinishedOn] = struct{}{}
}

// FinishedOnCleared returns if the "finished_on" field was cleared in this mutation.
func (m *SLSAAttestationMutation) FinishedOnCleared() bool {
	_, ok := m.clearedFields[slsaattestation.FieldFinishedOn]
	return ok
}

// ResetFinishedOn resets all changes to the "finished_on" field.
func (m *SLSAAttestationMutation) ResetFinishedOn() {
	m.finished_on = nil
	delete(m.clearedFields, slsaattestation.FieldFinishedOn)
}

// SetOrigin sets the "origin" field.
func (m *SLSAAttestationMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *SLSAAttestationMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *SLSAAttestationMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *SLSAAttestationMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *SLSAAttestationMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *SLSAAttestationMutation) ResetCollector() {
	m.collector = nil
}

// SetBuiltFromHash sets the "built_from_hash" field.
func (m *SLSAAttestationMutation) SetBuiltFromHash(s string) {
	m.built_from_hash = &s
}

// BuiltFromHash returns the value of the "built_from_hash" field in the mutation.
func (m *SLSAAttestationMutation) BuiltFromHash() (r string, exists bool) {
	v := m.built_from_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltFromHash returns the old "built_from_hash" field's value of the SLSAAttestation entity.
// If the SLSAAttestation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SLSAAttestationMutation) OldBuiltFromHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltFromHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltFromHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltFromHash: %w", err)
	}
	return oldValue.BuiltFromHash, nil
}

// ResetBuiltFromHash resets all changes to the "built_from_hash" field.
func (m *SLSAAttestationMutation) ResetBuiltFromHash() {
	m.built_from_hash = nil
}

// AddBuiltFromIDs adds the "built_from" edge to the Artifact entity by ids.
func (m *SLSAAttestationMutation) AddBuiltFromIDs(ids ...int) {
	if m.built_from == nil {
		m.built_from = make(map[int]struct{})
	}
	for i := range ids {
		m.built_from[ids[i]] = struct{}{}
	}
}

// ClearBuiltFrom clears the "built_from" edge to the Artifact entity.
func (m *SLSAAttestationMutation) ClearBuiltFrom() {
	m.clearedbuilt_from = true
}

// BuiltFromCleared reports if the "built_from" edge to the Artifact entity was cleared.
func (m *SLSAAttestationMutation) BuiltFromCleared() bool {
	return m.clearedbuilt_from
}

// RemoveBuiltFromIDs removes the "built_from" edge to the Artifact entity by IDs.
func (m *SLSAAttestationMutation) RemoveBuiltFromIDs(ids ...int) {
	if m.removedbuilt_from == nil {
		m.removedbuilt_from = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.built_from, ids[i])
		m.removedbuilt_from[ids[i]] = struct{}{}
	}
}

// RemovedBuiltFrom returns the removed IDs of the "built_from" edge to the Artifact entity.
func (m *SLSAAttestationMutation) RemovedBuiltFromIDs() (ids []int) {
	for id := range m.removedbuilt_from {
		ids = append(ids, id)
	}
	return
}

// BuiltFromIDs returns the "built_from" edge IDs in the mutation.
func (m *SLSAAttestationMutation) BuiltFromIDs() (ids []int) {
	for id := range m.built_from {
		ids = append(ids, id)
	}
	return
}

// ResetBuiltFrom resets all changes to the "built_from" edge.
func (m *SLSAAttestationMutation) ResetBuiltFrom() {
	m.built_from = nil
	m.clearedbuilt_from = false
	m.removedbuilt_from = nil
}

// ClearBuiltBy clears the "built_by" edge to the Builder entity.
func (m *SLSAAttestationMutation) ClearBuiltBy() {
	m.clearedbuilt_by = true
	m.clearedFields[slsaattestation.FieldBuiltByID] = struct{}{}
}

// BuiltByCleared reports if the "built_by" edge to the Builder entity was cleared.
func (m *SLSAAttestationMutation) BuiltByCleared() bool {
	return m.clearedbuilt_by
}

// BuiltByIDs returns the "built_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuiltByID instead. It exists only for internal usage by the builders.
func (m *SLSAAttestationMutation) BuiltByIDs() (ids []int) {
	if id := m.built_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuiltBy resets all changes to the "built_by" edge.
func (m *SLSAAttestationMutation) ResetBuiltBy() {
	m.built_by = nil
	m.clearedbuilt_by = false
}

// ClearSubject clears the "subject" edge to the Artifact entity.
func (m *SLSAAttestationMutation) ClearSubject() {
	m.clearedsubject = true
	m.clearedFields[slsaattestation.FieldSubjectID] = struct{}{}
}

// SubjectCleared reports if the "subject" edge to the Artifact entity was cleared.
func (m *SLSAAttestationMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectIDs returns the "subject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *SLSAAttestationMutation) SubjectIDs() (ids []int) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject resets all changes to the "subject" edge.
func (m *SLSAAttestationMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// Where appends a list predicates to the SLSAAttestationMutation builder.
func (m *SLSAAttestationMutation) Where(ps ...predicate.SLSAAttestation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SLSAAttestationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SLSAAttestationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SLSAAttestation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SLSAAttestationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SLSAAttestationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SLSAAttestation).
func (m *SLSAAttestationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SLSAAttestationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.build_type != nil {
		fields = append(fields, slsaattestation.FieldBuildType)
	}
	if m.built_by != nil {
		fields = append(fields, slsaattestation.FieldBuiltByID)
	}
	if m.subject != nil {
		fields = append(fields, slsaattestation.FieldSubjectID)
	}
	if m.slsa_predicate != nil {
		fields = append(fields, slsaattestation.FieldSlsaPredicate)
	}
	if m.slsa_version != nil {
		fields = append(fields, slsaattestation.FieldSlsaVersion)
	}
	if m.started_on != nil {
		fields = append(fields, slsaattestation.FieldStartedOn)
	}
	if m.finished_on != nil {
		fields = append(fields, slsaattestation.FieldFinishedOn)
	}
	if m.origin != nil {
		fields = append(fields, slsaattestation.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, slsaattestation.FieldCollector)
	}
	if m.built_from_hash != nil {
		fields = append(fields, slsaattestation.FieldBuiltFromHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SLSAAttestationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slsaattestation.FieldBuildType:
		return m.BuildType()
	case slsaattestation.FieldBuiltByID:
		return m.BuiltByID()
	case slsaattestation.FieldSubjectID:
		return m.SubjectID()
	case slsaattestation.FieldSlsaPredicate:
		return m.SlsaPredicate()
	case slsaattestation.FieldSlsaVersion:
		return m.SlsaVersion()
	case slsaattestation.FieldStartedOn:
		return m.StartedOn()
	case slsaattestation.FieldFinishedOn:
		return m.FinishedOn()
	case slsaattestation.FieldOrigin:
		return m.Origin()
	case slsaattestation.FieldCollector:
		return m.Collector()
	case slsaattestation.FieldBuiltFromHash:
		return m.BuiltFromHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SLSAAttestationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slsaattestation.FieldBuildType:
		return m.OldBuildType(ctx)
	case slsaattestation.FieldBuiltByID:
		return m.OldBuiltByID(ctx)
	case slsaattestation.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case slsaattestation.FieldSlsaPredicate:
		return m.OldSlsaPredicate(ctx)
	case slsaattestation.FieldSlsaVersion:
		return m.OldSlsaVersion(ctx)
	case slsaattestation.FieldStartedOn:
		return m.OldStartedOn(ctx)
	case slsaattestation.FieldFinishedOn:
		return m.OldFinishedOn(ctx)
	case slsaattestation.FieldOrigin:
		return m.OldOrigin(ctx)
	case slsaattestation.FieldCollector:
		return m.OldCollector(ctx)
	case slsaattestation.FieldBuiltFromHash:
		return m.OldBuiltFromHash(ctx)
	}
	return nil, fmt.Errorf("unknown SLSAAttestation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLSAAttestationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slsaattestation.FieldBuildType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildType(v)
		return nil
	case slsaattestation.FieldBuiltByID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltByID(v)
		return nil
	case slsaattestation.FieldSubjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case slsaattestation.FieldSlsaPredicate:
		v, ok := value.([]*model.SLSAPredicate)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlsaPredicate(v)
		return nil
	case slsaattestation.FieldSlsaVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlsaVersion(v)
		return nil
	case slsaattestation.FieldStartedOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedOn(v)
		return nil
	case slsaattestation.FieldFinishedOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedOn(v)
		return nil
	case slsaattestation.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case slsaattestation.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	case slsaattestation.FieldBuiltFromHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltFromHash(v)
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SLSAAttestationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SLSAAttestationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SLSAAttestationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SLSAAttestation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SLSAAttestationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(slsaattestation.FieldSlsaPredicate) {
		fields = append(fields, slsaattestation.FieldSlsaPredicate)
	}
	if m.FieldCleared(slsaattestation.FieldStartedOn) {
		fields = append(fields, slsaattestation.FieldStartedOn)
	}
	if m.FieldCleared(slsaattestation.FieldFinishedOn) {
		fields = append(fields, slsaattestation.FieldFinishedOn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SLSAAttestationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SLSAAttestationMutation) ClearField(name string) error {
	switch name {
	case slsaattestation.FieldSlsaPredicate:
		m.ClearSlsaPredicate()
		return nil
	case slsaattestation.FieldStartedOn:
		m.ClearStartedOn()
		return nil
	case slsaattestation.FieldFinishedOn:
		m.ClearFinishedOn()
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SLSAAttestationMutation) ResetField(name string) error {
	switch name {
	case slsaattestation.FieldBuildType:
		m.ResetBuildType()
		return nil
	case slsaattestation.FieldBuiltByID:
		m.ResetBuiltByID()
		return nil
	case slsaattestation.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case slsaattestation.FieldSlsaPredicate:
		m.ResetSlsaPredicate()
		return nil
	case slsaattestation.FieldSlsaVersion:
		m.ResetSlsaVersion()
		return nil
	case slsaattestation.FieldStartedOn:
		m.ResetStartedOn()
		return nil
	case slsaattestation.FieldFinishedOn:
		m.ResetFinishedOn()
		return nil
	case slsaattestation.FieldOrigin:
		m.ResetOrigin()
		return nil
	case slsaattestation.FieldCollector:
		m.ResetCollector()
		return nil
	case slsaattestation.FieldBuiltFromHash:
		m.ResetBuiltFromHash()
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SLSAAttestationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.built_from != nil {
		edges = append(edges, slsaattestation.EdgeBuiltFrom)
	}
	if m.built_by != nil {
		edges = append(edges, slsaattestation.EdgeBuiltBy)
	}
	if m.subject != nil {
		edges = append(edges, slsaattestation.EdgeSubject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SLSAAttestationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case slsaattestation.EdgeBuiltFrom:
		ids := make([]ent.Value, 0, len(m.built_from))
		for id := range m.built_from {
			ids = append(ids, id)
		}
		return ids
	case slsaattestation.EdgeBuiltBy:
		if id := m.built_by; id != nil {
			return []ent.Value{*id}
		}
	case slsaattestation.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SLSAAttestationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbuilt_from != nil {
		edges = append(edges, slsaattestation.EdgeBuiltFrom)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SLSAAttestationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case slsaattestation.EdgeBuiltFrom:
		ids := make([]ent.Value, 0, len(m.removedbuilt_from))
		for id := range m.removedbuilt_from {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SLSAAttestationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbuilt_from {
		edges = append(edges, slsaattestation.EdgeBuiltFrom)
	}
	if m.clearedbuilt_by {
		edges = append(edges, slsaattestation.EdgeBuiltBy)
	}
	if m.clearedsubject {
		edges = append(edges, slsaattestation.EdgeSubject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SLSAAttestationMutation) EdgeCleared(name string) bool {
	switch name {
	case slsaattestation.EdgeBuiltFrom:
		return m.clearedbuilt_from
	case slsaattestation.EdgeBuiltBy:
		return m.clearedbuilt_by
	case slsaattestation.EdgeSubject:
		return m.clearedsubject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SLSAAttestationMutation) ClearEdge(name string) error {
	switch name {
	case slsaattestation.EdgeBuiltBy:
		m.ClearBuiltBy()
		return nil
	case slsaattestation.EdgeSubject:
		m.ClearSubject()
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SLSAAttestationMutation) ResetEdge(name string) error {
	switch name {
	case slsaattestation.EdgeBuiltFrom:
		m.ResetBuiltFrom()
		return nil
	case slsaattestation.EdgeBuiltBy:
		m.ResetBuiltBy()
		return nil
	case slsaattestation.EdgeSubject:
		m.ResetSubject()
		return nil
	}
	return fmt.Errorf("unknown SLSAAttestation edge %s", name)
}

// ScorecardMutation represents an operation that mutates the Scorecard nodes in the graph.
type ScorecardMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	checks                *[]*model.ScorecardCheck
	appendchecks          []*model.ScorecardCheck
	aggregate_score       *float64
	addaggregate_score    *float64
	time_scanned          *time.Time
	scorecard_version     *string
	scorecard_commit      *string
	origin                *string
	collector             *string
	clearedFields         map[string]struct{}
	certifications        map[int]struct{}
	removedcertifications map[int]struct{}
	clearedcertifications bool
	done                  bool
	oldValue              func(context.Context) (*Scorecard, error)
	predicates            []predicate.Scorecard
}

var _ ent.Mutation = (*ScorecardMutation)(nil)

// scorecardOption allows management of the mutation configuration using functional options.
type scorecardOption func(*ScorecardMutation)

// newScorecardMutation creates new mutation for the Scorecard entity.
func newScorecardMutation(c config, op Op, opts ...scorecardOption) *ScorecardMutation {
	m := &ScorecardMutation{
		config:        c,
		op:            op,
		typ:           TypeScorecard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScorecardID sets the ID field of the mutation.
func withScorecardID(id int) scorecardOption {
	return func(m *ScorecardMutation) {
		var (
			err   error
			once  sync.Once
			value *Scorecard
		)
		m.oldValue = func(ctx context.Context) (*Scorecard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scorecard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScorecard sets the old Scorecard of the mutation.
func withScorecard(node *Scorecard) scorecardOption {
	return func(m *ScorecardMutation) {
		m.oldValue = func(context.Context) (*Scorecard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScorecardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScorecardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScorecardMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScorecardMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Scorecard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChecks sets the "checks" field.
func (m *ScorecardMutation) SetChecks(mc []*model.ScorecardCheck) {
	m.checks = &mc
	m.appendchecks = nil
}

// Checks returns the value of the "checks" field in the mutation.
func (m *ScorecardMutation) Checks() (r []*model.ScorecardCheck, exists bool) {
	v := m.checks
	if v == nil {
		return
	}
	return *v, true
}

// OldChecks returns the old "checks" field's value of the Scorecard entity.
// If the Scorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScorecardMutation) OldChecks(ctx context.Context) (v []*model.ScorecardCheck, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecks: %w", err)
	}
	return oldValue.Checks, nil
}

// AppendChecks adds mc to the "checks" field.
func (m *ScorecardMutation) AppendChecks(mc []*model.ScorecardCheck) {
	m.appendchecks = append(m.appendchecks, mc...)
}

// AppendedChecks returns the list of values that were appended to the "checks" field in this mutation.
func (m *ScorecardMutation) AppendedChecks() ([]*model.ScorecardCheck, bool) {
	if len(m.appendchecks) == 0 {
		return nil, false
	}
	return m.appendchecks, true
}

// ResetChecks resets all changes to the "checks" field.
func (m *ScorecardMutation) ResetChecks() {
	m.checks = nil
	m.appendchecks = nil
}

// SetAggregateScore sets the "aggregate_score" field.
func (m *ScorecardMutation) SetAggregateScore(f float64) {
	m.aggregate_score = &f
	m.addaggregate_score = nil
}

// AggregateScore returns the value of the "aggregate_score" field in the mutation.
func (m *ScorecardMutation) AggregateScore() (r float64, exists bool) {
	v := m.aggregate_score
	if v == nil {
		return
	}
	return *v, true
}

// OldAggregateScore returns the old "aggregate_score" field's value of the Scorecard entity.
// If the Scorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScorecardMutation) OldAggregateScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAggregateScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAggregateScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAggregateScore: %w", err)
	}
	return oldValue.AggregateScore, nil
}

// AddAggregateScore adds f to the "aggregate_score" field.
func (m *ScorecardMutation) AddAggregateScore(f float64) {
	if m.addaggregate_score != nil {
		*m.addaggregate_score += f
	} else {
		m.addaggregate_score = &f
	}
}

// AddedAggregateScore returns the value that was added to the "aggregate_score" field in this mutation.
func (m *ScorecardMutation) AddedAggregateScore() (r float64, exists bool) {
	v := m.addaggregate_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetAggregateScore resets all changes to the "aggregate_score" field.
func (m *ScorecardMutation) ResetAggregateScore() {
	m.aggregate_score = nil
	m.addaggregate_score = nil
}

// SetTimeScanned sets the "time_scanned" field.
func (m *ScorecardMutation) SetTimeScanned(t time.Time) {
	m.time_scanned = &t
}

// TimeScanned returns the value of the "time_scanned" field in the mutation.
func (m *ScorecardMutation) TimeScanned() (r time.Time, exists bool) {
	v := m.time_scanned
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeScanned returns the old "time_scanned" field's value of the Scorecard entity.
// If the Scorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScorecardMutation) OldTimeScanned(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeScanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeScanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeScanned: %w", err)
	}
	return oldValue.TimeScanned, nil
}

// ResetTimeScanned resets all changes to the "time_scanned" field.
func (m *ScorecardMutation) ResetTimeScanned() {
	m.time_scanned = nil
}

// SetScorecardVersion sets the "scorecard_version" field.
func (m *ScorecardMutation) SetScorecardVersion(s string) {
	m.scorecard_version = &s
}

// ScorecardVersion returns the value of the "scorecard_version" field in the mutation.
func (m *ScorecardMutation) ScorecardVersion() (r string, exists bool) {
	v := m.scorecard_version
	if v == nil {
		return
	}
	return *v, true
}

// OldScorecardVersion returns the old "scorecard_version" field's value of the Scorecard entity.
// If the Scorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScorecardMutation) OldScorecardVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScorecardVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScorecardVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScorecardVersion: %w", err)
	}
	return oldValue.ScorecardVersion, nil
}

// ResetScorecardVersion resets all changes to the "scorecard_version" field.
func (m *ScorecardMutation) ResetScorecardVersion() {
	m.scorecard_version = nil
}

// SetScorecardCommit sets the "scorecard_commit" field.
func (m *ScorecardMutation) SetScorecardCommit(s string) {
	m.scorecard_commit = &s
}

// ScorecardCommit returns the value of the "scorecard_commit" field in the mutation.
func (m *ScorecardMutation) ScorecardCommit() (r string, exists bool) {
	v := m.scorecard_commit
	if v == nil {
		return
	}
	return *v, true
}

// OldScorecardCommit returns the old "scorecard_commit" field's value of the Scorecard entity.
// If the Scorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScorecardMutation) OldScorecardCommit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScorecardCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScorecardCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScorecardCommit: %w", err)
	}
	return oldValue.ScorecardCommit, nil
}

// ResetScorecardCommit resets all changes to the "scorecard_commit" field.
func (m *ScorecardMutation) ResetScorecardCommit() {
	m.scorecard_commit = nil
}

// SetOrigin sets the "origin" field.
func (m *ScorecardMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *ScorecardMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the Scorecard entity.
// If the Scorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScorecardMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *ScorecardMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *ScorecardMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *ScorecardMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the Scorecard entity.
// If the Scorecard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScorecardMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *ScorecardMutation) ResetCollector() {
	m.collector = nil
}

// AddCertificationIDs adds the "certifications" edge to the CertifyScorecard entity by ids.
func (m *ScorecardMutation) AddCertificationIDs(ids ...int) {
	if m.certifications == nil {
		m.certifications = make(map[int]struct{})
	}
	for i := range ids {
		m.certifications[ids[i]] = struct{}{}
	}
}

// ClearCertifications clears the "certifications" edge to the CertifyScorecard entity.
func (m *ScorecardMutation) ClearCertifications() {
	m.clearedcertifications = true
}

// CertificationsCleared reports if the "certifications" edge to the CertifyScorecard entity was cleared.
func (m *ScorecardMutation) CertificationsCleared() bool {
	return m.clearedcertifications
}

// RemoveCertificationIDs removes the "certifications" edge to the CertifyScorecard entity by IDs.
func (m *ScorecardMutation) RemoveCertificationIDs(ids ...int) {
	if m.removedcertifications == nil {
		m.removedcertifications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.certifications, ids[i])
		m.removedcertifications[ids[i]] = struct{}{}
	}
}

// RemovedCertifications returns the removed IDs of the "certifications" edge to the CertifyScorecard entity.
func (m *ScorecardMutation) RemovedCertificationsIDs() (ids []int) {
	for id := range m.removedcertifications {
		ids = append(ids, id)
	}
	return
}

// CertificationsIDs returns the "certifications" edge IDs in the mutation.
func (m *ScorecardMutation) CertificationsIDs() (ids []int) {
	for id := range m.certifications {
		ids = append(ids, id)
	}
	return
}

// ResetCertifications resets all changes to the "certifications" edge.
func (m *ScorecardMutation) ResetCertifications() {
	m.certifications = nil
	m.clearedcertifications = false
	m.removedcertifications = nil
}

// Where appends a list predicates to the ScorecardMutation builder.
func (m *ScorecardMutation) Where(ps ...predicate.Scorecard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScorecardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScorecardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Scorecard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScorecardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScorecardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Scorecard).
func (m *ScorecardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScorecardMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.checks != nil {
		fields = append(fields, scorecard.FieldChecks)
	}
	if m.aggregate_score != nil {
		fields = append(fields, scorecard.FieldAggregateScore)
	}
	if m.time_scanned != nil {
		fields = append(fields, scorecard.FieldTimeScanned)
	}
	if m.scorecard_version != nil {
		fields = append(fields, scorecard.FieldScorecardVersion)
	}
	if m.scorecard_commit != nil {
		fields = append(fields, scorecard.FieldScorecardCommit)
	}
	if m.origin != nil {
		fields = append(fields, scorecard.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, scorecard.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScorecardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scorecard.FieldChecks:
		return m.Checks()
	case scorecard.FieldAggregateScore:
		return m.AggregateScore()
	case scorecard.FieldTimeScanned:
		return m.TimeScanned()
	case scorecard.FieldScorecardVersion:
		return m.ScorecardVersion()
	case scorecard.FieldScorecardCommit:
		return m.ScorecardCommit()
	case scorecard.FieldOrigin:
		return m.Origin()
	case scorecard.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScorecardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scorecard.FieldChecks:
		return m.OldChecks(ctx)
	case scorecard.FieldAggregateScore:
		return m.OldAggregateScore(ctx)
	case scorecard.FieldTimeScanned:
		return m.OldTimeScanned(ctx)
	case scorecard.FieldScorecardVersion:
		return m.OldScorecardVersion(ctx)
	case scorecard.FieldScorecardCommit:
		return m.OldScorecardCommit(ctx)
	case scorecard.FieldOrigin:
		return m.OldOrigin(ctx)
	case scorecard.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown Scorecard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScorecardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scorecard.FieldChecks:
		v, ok := value.([]*model.ScorecardCheck)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecks(v)
		return nil
	case scorecard.FieldAggregateScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAggregateScore(v)
		return nil
	case scorecard.FieldTimeScanned:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeScanned(v)
		return nil
	case scorecard.FieldScorecardVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScorecardVersion(v)
		return nil
	case scorecard.FieldScorecardCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScorecardCommit(v)
		return nil
	case scorecard.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case scorecard.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown Scorecard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScorecardMutation) AddedFields() []string {
	var fields []string
	if m.addaggregate_score != nil {
		fields = append(fields, scorecard.FieldAggregateScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScorecardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scorecard.FieldAggregateScore:
		return m.AddedAggregateScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScorecardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scorecard.FieldAggregateScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAggregateScore(v)
		return nil
	}
	return fmt.Errorf("unknown Scorecard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScorecardMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScorecardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScorecardMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Scorecard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScorecardMutation) ResetField(name string) error {
	switch name {
	case scorecard.FieldChecks:
		m.ResetChecks()
		return nil
	case scorecard.FieldAggregateScore:
		m.ResetAggregateScore()
		return nil
	case scorecard.FieldTimeScanned:
		m.ResetTimeScanned()
		return nil
	case scorecard.FieldScorecardVersion:
		m.ResetScorecardVersion()
		return nil
	case scorecard.FieldScorecardCommit:
		m.ResetScorecardCommit()
		return nil
	case scorecard.FieldOrigin:
		m.ResetOrigin()
		return nil
	case scorecard.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown Scorecard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScorecardMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.certifications != nil {
		edges = append(edges, scorecard.EdgeCertifications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScorecardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scorecard.EdgeCertifications:
		ids := make([]ent.Value, 0, len(m.certifications))
		for id := range m.certifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScorecardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcertifications != nil {
		edges = append(edges, scorecard.EdgeCertifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScorecardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case scorecard.EdgeCertifications:
		ids := make([]ent.Value, 0, len(m.removedcertifications))
		for id := range m.removedcertifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScorecardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcertifications {
		edges = append(edges, scorecard.EdgeCertifications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScorecardMutation) EdgeCleared(name string) bool {
	switch name {
	case scorecard.EdgeCertifications:
		return m.clearedcertifications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScorecardMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Scorecard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScorecardMutation) ResetEdge(name string) error {
	switch name {
	case scorecard.EdgeCertifications:
		m.ResetCertifications()
		return nil
	}
	return fmt.Errorf("unknown Scorecard edge %s", name)
}

// SourceNameMutation represents an operation that mutates the SourceName nodes in the graph.
type SourceNameMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	commit             *string
	tag                *string
	clearedFields      map[string]struct{}
	namespace          *int
	clearednamespace   bool
	occurrences        map[int]struct{}
	removedoccurrences map[int]struct{}
	clearedoccurrences bool
	done               bool
	oldValue           func(context.Context) (*SourceName, error)
	predicates         []predicate.SourceName
}

var _ ent.Mutation = (*SourceNameMutation)(nil)

// sourcenameOption allows management of the mutation configuration using functional options.
type sourcenameOption func(*SourceNameMutation)

// newSourceNameMutation creates new mutation for the SourceName entity.
func newSourceNameMutation(c config, op Op, opts ...sourcenameOption) *SourceNameMutation {
	m := &SourceNameMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceName,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceNameID sets the ID field of the mutation.
func withSourceNameID(id int) sourcenameOption {
	return func(m *SourceNameMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceName
		)
		m.oldValue = func(ctx context.Context) (*SourceName, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceName.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceName sets the old SourceName of the mutation.
func withSourceName(node *SourceName) sourcenameOption {
	return func(m *SourceNameMutation) {
		m.oldValue = func(context.Context) (*SourceName, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceNameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceNameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceNameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceNameMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceName.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SourceNameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SourceNameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SourceNameMutation) ResetName() {
	m.name = nil
}

// SetCommit sets the "commit" field.
func (m *SourceNameMutation) SetCommit(s string) {
	m.commit = &s
}

// Commit returns the value of the "commit" field in the mutation.
func (m *SourceNameMutation) Commit() (r string, exists bool) {
	v := m.commit
	if v == nil {
		return
	}
	return *v, true
}

// OldCommit returns the old "commit" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldCommit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommit: %w", err)
	}
	return oldValue.Commit, nil
}

// ClearCommit clears the value of the "commit" field.
func (m *SourceNameMutation) ClearCommit() {
	m.commit = nil
	m.clearedFields[sourcename.FieldCommit] = struct{}{}
}

// CommitCleared returns if the "commit" field was cleared in this mutation.
func (m *SourceNameMutation) CommitCleared() bool {
	_, ok := m.clearedFields[sourcename.FieldCommit]
	return ok
}

// ResetCommit resets all changes to the "commit" field.
func (m *SourceNameMutation) ResetCommit() {
	m.commit = nil
	delete(m.clearedFields, sourcename.FieldCommit)
}

// SetTag sets the "tag" field.
func (m *SourceNameMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *SourceNameMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ClearTag clears the value of the "tag" field.
func (m *SourceNameMutation) ClearTag() {
	m.tag = nil
	m.clearedFields[sourcename.FieldTag] = struct{}{}
}

// TagCleared returns if the "tag" field was cleared in this mutation.
func (m *SourceNameMutation) TagCleared() bool {
	_, ok := m.clearedFields[sourcename.FieldTag]
	return ok
}

// ResetTag resets all changes to the "tag" field.
func (m *SourceNameMutation) ResetTag() {
	m.tag = nil
	delete(m.clearedFields, sourcename.FieldTag)
}

// SetNamespaceID sets the "namespace_id" field.
func (m *SourceNameMutation) SetNamespaceID(i int) {
	m.namespace = &i
}

// NamespaceID returns the value of the "namespace_id" field in the mutation.
func (m *SourceNameMutation) NamespaceID() (r int, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespaceID returns the old "namespace_id" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldNamespaceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespaceID: %w", err)
	}
	return oldValue.NamespaceID, nil
}

// ResetNamespaceID resets all changes to the "namespace_id" field.
func (m *SourceNameMutation) ResetNamespaceID() {
	m.namespace = nil
}

// ClearNamespace clears the "namespace" edge to the SourceNamespace entity.
func (m *SourceNameMutation) ClearNamespace() {
	m.clearednamespace = true
	m.clearedFields[sourcename.FieldNamespaceID] = struct{}{}
}

// NamespaceCleared reports if the "namespace" edge to the SourceNamespace entity was cleared.
func (m *SourceNameMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *SourceNameMutation) NamespaceIDs() (ids []int) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *SourceNameMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by ids.
func (m *SourceNameMutation) AddOccurrenceIDs(ids ...int) {
	if m.occurrences == nil {
		m.occurrences = make(map[int]struct{})
	}
	for i := range ids {
		m.occurrences[ids[i]] = struct{}{}
	}
}

// ClearOccurrences clears the "occurrences" edge to the Occurrence entity.
func (m *SourceNameMutation) ClearOccurrences() {
	m.clearedoccurrences = true
}

// OccurrencesCleared reports if the "occurrences" edge to the Occurrence entity was cleared.
func (m *SourceNameMutation) OccurrencesCleared() bool {
	return m.clearedoccurrences
}

// RemoveOccurrenceIDs removes the "occurrences" edge to the Occurrence entity by IDs.
func (m *SourceNameMutation) RemoveOccurrenceIDs(ids ...int) {
	if m.removedoccurrences == nil {
		m.removedoccurrences = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occurrences, ids[i])
		m.removedoccurrences[ids[i]] = struct{}{}
	}
}

// RemovedOccurrences returns the removed IDs of the "occurrences" edge to the Occurrence entity.
func (m *SourceNameMutation) RemovedOccurrencesIDs() (ids []int) {
	for id := range m.removedoccurrences {
		ids = append(ids, id)
	}
	return
}

// OccurrencesIDs returns the "occurrences" edge IDs in the mutation.
func (m *SourceNameMutation) OccurrencesIDs() (ids []int) {
	for id := range m.occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetOccurrences resets all changes to the "occurrences" edge.
func (m *SourceNameMutation) ResetOccurrences() {
	m.occurrences = nil
	m.clearedoccurrences = false
	m.removedoccurrences = nil
}

// Where appends a list predicates to the SourceNameMutation builder.
func (m *SourceNameMutation) Where(ps ...predicate.SourceName) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceNameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceNameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceName, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceNameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceNameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceName).
func (m *SourceNameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceNameMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, sourcename.FieldName)
	}
	if m.commit != nil {
		fields = append(fields, sourcename.FieldCommit)
	}
	if m.tag != nil {
		fields = append(fields, sourcename.FieldTag)
	}
	if m.namespace != nil {
		fields = append(fields, sourcename.FieldNamespaceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceNameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcename.FieldName:
		return m.Name()
	case sourcename.FieldCommit:
		return m.Commit()
	case sourcename.FieldTag:
		return m.Tag()
	case sourcename.FieldNamespaceID:
		return m.NamespaceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceNameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcename.FieldName:
		return m.OldName(ctx)
	case sourcename.FieldCommit:
		return m.OldCommit(ctx)
	case sourcename.FieldTag:
		return m.OldTag(ctx)
	case sourcename.FieldNamespaceID:
		return m.OldNamespaceID(ctx)
	}
	return nil, fmt.Errorf("unknown SourceName field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcename.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sourcename.FieldCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommit(v)
		return nil
	case sourcename.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case sourcename.FieldNamespaceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespaceID(v)
		return nil
	}
	return fmt.Errorf("unknown SourceName field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceNameMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceNameMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceName numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceNameMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sourcename.FieldCommit) {
		fields = append(fields, sourcename.FieldCommit)
	}
	if m.FieldCleared(sourcename.FieldTag) {
		fields = append(fields, sourcename.FieldTag)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceNameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceNameMutation) ClearField(name string) error {
	switch name {
	case sourcename.FieldCommit:
		m.ClearCommit()
		return nil
	case sourcename.FieldTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown SourceName nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceNameMutation) ResetField(name string) error {
	switch name {
	case sourcename.FieldName:
		m.ResetName()
		return nil
	case sourcename.FieldCommit:
		m.ResetCommit()
		return nil
	case sourcename.FieldTag:
		m.ResetTag()
		return nil
	case sourcename.FieldNamespaceID:
		m.ResetNamespaceID()
		return nil
	}
	return fmt.Errorf("unknown SourceName field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceNameMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.namespace != nil {
		edges = append(edges, sourcename.EdgeNamespace)
	}
	if m.occurrences != nil {
		edges = append(edges, sourcename.EdgeOccurrences)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceNameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourcename.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case sourcename.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.occurrences))
		for id := range m.occurrences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceNameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoccurrences != nil {
		edges = append(edges, sourcename.EdgeOccurrences)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceNameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sourcename.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.removedoccurrences))
		for id := range m.removedoccurrences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceNameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednamespace {
		edges = append(edges, sourcename.EdgeNamespace)
	}
	if m.clearedoccurrences {
		edges = append(edges, sourcename.EdgeOccurrences)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceNameMutation) EdgeCleared(name string) bool {
	switch name {
	case sourcename.EdgeNamespace:
		return m.clearednamespace
	case sourcename.EdgeOccurrences:
		return m.clearedoccurrences
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceNameMutation) ClearEdge(name string) error {
	switch name {
	case sourcename.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown SourceName unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceNameMutation) ResetEdge(name string) error {
	switch name {
	case sourcename.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case sourcename.EdgeOccurrences:
		m.ResetOccurrences()
		return nil
	}
	return fmt.Errorf("unknown SourceName edge %s", name)
}

// SourceNamespaceMutation represents an operation that mutates the SourceNamespace nodes in the graph.
type SourceNamespaceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	namespace          *string
	clearedFields      map[string]struct{}
	source_type        *int
	clearedsource_type bool
	names              map[int]struct{}
	removednames       map[int]struct{}
	clearednames       bool
	done               bool
	oldValue           func(context.Context) (*SourceNamespace, error)
	predicates         []predicate.SourceNamespace
}

var _ ent.Mutation = (*SourceNamespaceMutation)(nil)

// sourcenamespaceOption allows management of the mutation configuration using functional options.
type sourcenamespaceOption func(*SourceNamespaceMutation)

// newSourceNamespaceMutation creates new mutation for the SourceNamespace entity.
func newSourceNamespaceMutation(c config, op Op, opts ...sourcenamespaceOption) *SourceNamespaceMutation {
	m := &SourceNamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceNamespaceID sets the ID field of the mutation.
func withSourceNamespaceID(id int) sourcenamespaceOption {
	return func(m *SourceNamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceNamespace
		)
		m.oldValue = func(ctx context.Context) (*SourceNamespace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceNamespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceNamespace sets the old SourceNamespace of the mutation.
func withSourceNamespace(node *SourceNamespace) sourcenamespaceOption {
	return func(m *SourceNamespaceMutation) {
		m.oldValue = func(context.Context) (*SourceNamespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceNamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceNamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceNamespaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceNamespaceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceNamespace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SourceNamespaceMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SourceNamespaceMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the SourceNamespace entity.
// If the SourceNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNamespaceMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SourceNamespaceMutation) ResetNamespace() {
	m.namespace = nil
}

// SetSourceID sets the "source_id" field.
func (m *SourceNamespaceMutation) SetSourceID(i int) {
	m.source_type = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *SourceNamespaceMutation) SourceID() (r int, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the SourceNamespace entity.
// If the SourceNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNamespaceMutation) OldSourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *SourceNamespaceMutation) ResetSourceID() {
	m.source_type = nil
}

// SetSourceTypeID sets the "source_type" edge to the SourceType entity by id.
func (m *SourceNamespaceMutation) SetSourceTypeID(id int) {
	m.source_type = &id
}

// ClearSourceType clears the "source_type" edge to the SourceType entity.
func (m *SourceNamespaceMutation) ClearSourceType() {
	m.clearedsource_type = true
	m.clearedFields[sourcenamespace.FieldSourceID] = struct{}{}
}

// SourceTypeCleared reports if the "source_type" edge to the SourceType entity was cleared.
func (m *SourceNamespaceMutation) SourceTypeCleared() bool {
	return m.clearedsource_type
}

// SourceTypeID returns the "source_type" edge ID in the mutation.
func (m *SourceNamespaceMutation) SourceTypeID() (id int, exists bool) {
	if m.source_type != nil {
		return *m.source_type, true
	}
	return
}

// SourceTypeIDs returns the "source_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceTypeID instead. It exists only for internal usage by the builders.
func (m *SourceNamespaceMutation) SourceTypeIDs() (ids []int) {
	if id := m.source_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceType resets all changes to the "source_type" edge.
func (m *SourceNamespaceMutation) ResetSourceType() {
	m.source_type = nil
	m.clearedsource_type = false
}

// AddNameIDs adds the "names" edge to the SourceName entity by ids.
func (m *SourceNamespaceMutation) AddNameIDs(ids ...int) {
	if m.names == nil {
		m.names = make(map[int]struct{})
	}
	for i := range ids {
		m.names[ids[i]] = struct{}{}
	}
}

// ClearNames clears the "names" edge to the SourceName entity.
func (m *SourceNamespaceMutation) ClearNames() {
	m.clearednames = true
}

// NamesCleared reports if the "names" edge to the SourceName entity was cleared.
func (m *SourceNamespaceMutation) NamesCleared() bool {
	return m.clearednames
}

// RemoveNameIDs removes the "names" edge to the SourceName entity by IDs.
func (m *SourceNamespaceMutation) RemoveNameIDs(ids ...int) {
	if m.removednames == nil {
		m.removednames = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.names, ids[i])
		m.removednames[ids[i]] = struct{}{}
	}
}

// RemovedNames returns the removed IDs of the "names" edge to the SourceName entity.
func (m *SourceNamespaceMutation) RemovedNamesIDs() (ids []int) {
	for id := range m.removednames {
		ids = append(ids, id)
	}
	return
}

// NamesIDs returns the "names" edge IDs in the mutation.
func (m *SourceNamespaceMutation) NamesIDs() (ids []int) {
	for id := range m.names {
		ids = append(ids, id)
	}
	return
}

// ResetNames resets all changes to the "names" edge.
func (m *SourceNamespaceMutation) ResetNames() {
	m.names = nil
	m.clearednames = false
	m.removednames = nil
}

// Where appends a list predicates to the SourceNamespaceMutation builder.
func (m *SourceNamespaceMutation) Where(ps ...predicate.SourceNamespace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceNamespaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceNamespaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceNamespace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceNamespaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceNamespaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceNamespace).
func (m *SourceNamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceNamespaceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.namespace != nil {
		fields = append(fields, sourcenamespace.FieldNamespace)
	}
	if m.source_type != nil {
		fields = append(fields, sourcenamespace.FieldSourceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceNamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcenamespace.FieldNamespace:
		return m.Namespace()
	case sourcenamespace.FieldSourceID:
		return m.SourceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceNamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcenamespace.FieldNamespace:
		return m.OldNamespace(ctx)
	case sourcenamespace.FieldSourceID:
		return m.OldSourceID(ctx)
	}
	return nil, fmt.Errorf("unknown SourceNamespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcenamespace.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case sourcenamespace.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	}
	return fmt.Errorf("unknown SourceNamespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceNamespaceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceNamespaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceNamespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceNamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceNamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceNamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SourceNamespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceNamespaceMutation) ResetField(name string) error {
	switch name {
	case sourcenamespace.FieldNamespace:
		m.ResetNamespace()
		return nil
	case sourcenamespace.FieldSourceID:
		m.ResetSourceID()
		return nil
	}
	return fmt.Errorf("unknown SourceNamespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceNamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.source_type != nil {
		edges = append(edges, sourcenamespace.EdgeSourceType)
	}
	if m.names != nil {
		edges = append(edges, sourcenamespace.EdgeNames)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceNamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourcenamespace.EdgeSourceType:
		if id := m.source_type; id != nil {
			return []ent.Value{*id}
		}
	case sourcenamespace.EdgeNames:
		ids := make([]ent.Value, 0, len(m.names))
		for id := range m.names {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceNamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednames != nil {
		edges = append(edges, sourcenamespace.EdgeNames)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceNamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sourcenamespace.EdgeNames:
		ids := make([]ent.Value, 0, len(m.removednames))
		for id := range m.removednames {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceNamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsource_type {
		edges = append(edges, sourcenamespace.EdgeSourceType)
	}
	if m.clearednames {
		edges = append(edges, sourcenamespace.EdgeNames)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceNamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case sourcenamespace.EdgeSourceType:
		return m.clearedsource_type
	case sourcenamespace.EdgeNames:
		return m.clearednames
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceNamespaceMutation) ClearEdge(name string) error {
	switch name {
	case sourcenamespace.EdgeSourceType:
		m.ClearSourceType()
		return nil
	}
	return fmt.Errorf("unknown SourceNamespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceNamespaceMutation) ResetEdge(name string) error {
	switch name {
	case sourcenamespace.EdgeSourceType:
		m.ResetSourceType()
		return nil
	case sourcenamespace.EdgeNames:
		m.ResetNames()
		return nil
	}
	return fmt.Errorf("unknown SourceNamespace edge %s", name)
}

// SourceTypeMutation represents an operation that mutates the SourceType nodes in the graph.
type SourceTypeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_type             *string
	clearedFields     map[string]struct{}
	namespaces        map[int]struct{}
	removednamespaces map[int]struct{}
	clearednamespaces bool
	done              bool
	oldValue          func(context.Context) (*SourceType, error)
	predicates        []predicate.SourceType
}

var _ ent.Mutation = (*SourceTypeMutation)(nil)

// sourcetypeOption allows management of the mutation configuration using functional options.
type sourcetypeOption func(*SourceTypeMutation)

// newSourceTypeMutation creates new mutation for the SourceType entity.
func newSourceTypeMutation(c config, op Op, opts ...sourcetypeOption) *SourceTypeMutation {
	m := &SourceTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceTypeID sets the ID field of the mutation.
func withSourceTypeID(id int) sourcetypeOption {
	return func(m *SourceTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceType
		)
		m.oldValue = func(ctx context.Context) (*SourceType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceType sets the old SourceType of the mutation.
func withSourceType(node *SourceType) sourcetypeOption {
	return func(m *SourceTypeMutation) {
		m.oldValue = func(context.Context) (*SourceType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *SourceTypeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SourceTypeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SourceType entity.
// If the SourceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceTypeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SourceTypeMutation) ResetType() {
	m._type = nil
}

// AddNamespaceIDs adds the "namespaces" edge to the SourceNamespace entity by ids.
func (m *SourceTypeMutation) AddNamespaceIDs(ids ...int) {
	if m.namespaces == nil {
		m.namespaces = make(map[int]struct{})
	}
	for i := range ids {
		m.namespaces[ids[i]] = struct{}{}
	}
}

// ClearNamespaces clears the "namespaces" edge to the SourceNamespace entity.
func (m *SourceTypeMutation) ClearNamespaces() {
	m.clearednamespaces = true
}

// NamespacesCleared reports if the "namespaces" edge to the SourceNamespace entity was cleared.
func (m *SourceTypeMutation) NamespacesCleared() bool {
	return m.clearednamespaces
}

// RemoveNamespaceIDs removes the "namespaces" edge to the SourceNamespace entity by IDs.
func (m *SourceTypeMutation) RemoveNamespaceIDs(ids ...int) {
	if m.removednamespaces == nil {
		m.removednamespaces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.namespaces, ids[i])
		m.removednamespaces[ids[i]] = struct{}{}
	}
}

// RemovedNamespaces returns the removed IDs of the "namespaces" edge to the SourceNamespace entity.
func (m *SourceTypeMutation) RemovedNamespacesIDs() (ids []int) {
	for id := range m.removednamespaces {
		ids = append(ids, id)
	}
	return
}

// NamespacesIDs returns the "namespaces" edge IDs in the mutation.
func (m *SourceTypeMutation) NamespacesIDs() (ids []int) {
	for id := range m.namespaces {
		ids = append(ids, id)
	}
	return
}

// ResetNamespaces resets all changes to the "namespaces" edge.
func (m *SourceTypeMutation) ResetNamespaces() {
	m.namespaces = nil
	m.clearednamespaces = false
	m.removednamespaces = nil
}

// Where appends a list predicates to the SourceTypeMutation builder.
func (m *SourceTypeMutation) Where(ps ...predicate.SourceType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceType).
func (m *SourceTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._type != nil {
		fields = append(fields, sourcetype.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcetype.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcetype.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown SourceType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcetype.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown SourceType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SourceType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceTypeMutation) ResetField(name string) error {
	switch name {
	case sourcetype.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown SourceType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespaces != nil {
		edges = append(edges, sourcetype.EdgeNamespaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourcetype.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.namespaces))
		for id := range m.namespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednamespaces != nil {
		edges = append(edges, sourcetype.EdgeNamespaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sourcetype.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.removednamespaces))
		for id := range m.removednamespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespaces {
		edges = append(edges, sourcetype.EdgeNamespaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case sourcetype.EdgeNamespaces:
		return m.clearednamespaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceTypeMutation) ResetEdge(name string) error {
	switch name {
	case sourcetype.EdgeNamespaces:
		m.ResetNamespaces()
		return nil
	}
	return fmt.Errorf("unknown SourceType edge %s", name)
}

// VulnEqualMutation represents an operation that mutates the VulnEqual nodes in the graph.
type VulnEqualMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	justification            *string
	origin                   *string
	collector                *string
	clearedFields            map[string]struct{}
	vulnerability_ids        map[int]struct{}
	removedvulnerability_ids map[int]struct{}
	clearedvulnerability_ids bool
	done                     bool
	oldValue                 func(context.Context) (*VulnEqual, error)
	predicates               []predicate.VulnEqual
}

var _ ent.Mutation = (*VulnEqualMutation)(nil)

// vulnequalOption allows management of the mutation configuration using functional options.
type vulnequalOption func(*VulnEqualMutation)

// newVulnEqualMutation creates new mutation for the VulnEqual entity.
func newVulnEqualMutation(c config, op Op, opts ...vulnequalOption) *VulnEqualMutation {
	m := &VulnEqualMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnEqual,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnEqualID sets the ID field of the mutation.
func withVulnEqualID(id int) vulnequalOption {
	return func(m *VulnEqualMutation) {
		var (
			err   error
			once  sync.Once
			value *VulnEqual
		)
		m.oldValue = func(ctx context.Context) (*VulnEqual, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VulnEqual.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnEqual sets the old VulnEqual of the mutation.
func withVulnEqual(node *VulnEqual) vulnequalOption {
	return func(m *VulnEqualMutation) {
		m.oldValue = func(context.Context) (*VulnEqual, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnEqualMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnEqualMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnEqualMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VulnEqualMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VulnEqual.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJustification sets the "justification" field.
func (m *VulnEqualMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *VulnEqualMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the VulnEqual entity.
// If the VulnEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnEqualMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *VulnEqualMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *VulnEqualMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *VulnEqualMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the VulnEqual entity.
// If the VulnEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnEqualMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *VulnEqualMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *VulnEqualMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *VulnEqualMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the VulnEqual entity.
// If the VulnEqual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnEqualMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *VulnEqualMutation) ResetCollector() {
	m.collector = nil
}

// AddVulnerabilityIDIDs adds the "vulnerability_ids" edge to the VulnerabilityID entity by ids.
func (m *VulnEqualMutation) AddVulnerabilityIDIDs(ids ...int) {
	if m.vulnerability_ids == nil {
		m.vulnerability_ids = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerability_ids[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilityIds clears the "vulnerability_ids" edge to the VulnerabilityID entity.
func (m *VulnEqualMutation) ClearVulnerabilityIds() {
	m.clearedvulnerability_ids = true
}

// VulnerabilityIdsCleared reports if the "vulnerability_ids" edge to the VulnerabilityID entity was cleared.
func (m *VulnEqualMutation) VulnerabilityIdsCleared() bool {
	return m.clearedvulnerability_ids
}

// RemoveVulnerabilityIDIDs removes the "vulnerability_ids" edge to the VulnerabilityID entity by IDs.
func (m *VulnEqualMutation) RemoveVulnerabilityIDIDs(ids ...int) {
	if m.removedvulnerability_ids == nil {
		m.removedvulnerability_ids = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerability_ids, ids[i])
		m.removedvulnerability_ids[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilityIds returns the removed IDs of the "vulnerability_ids" edge to the VulnerabilityID entity.
func (m *VulnEqualMutation) RemovedVulnerabilityIdsIDs() (ids []int) {
	for id := range m.removedvulnerability_ids {
		ids = append(ids, id)
	}
	return
}

// VulnerabilityIdsIDs returns the "vulnerability_ids" edge IDs in the mutation.
func (m *VulnEqualMutation) VulnerabilityIdsIDs() (ids []int) {
	for id := range m.vulnerability_ids {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilityIds resets all changes to the "vulnerability_ids" edge.
func (m *VulnEqualMutation) ResetVulnerabilityIds() {
	m.vulnerability_ids = nil
	m.clearedvulnerability_ids = false
	m.removedvulnerability_ids = nil
}

// Where appends a list predicates to the VulnEqualMutation builder.
func (m *VulnEqualMutation) Where(ps ...predicate.VulnEqual) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VulnEqualMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VulnEqualMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VulnEqual, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VulnEqualMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VulnEqualMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VulnEqual).
func (m *VulnEqualMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnEqualMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.justification != nil {
		fields = append(fields, vulnequal.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, vulnequal.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, vulnequal.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnEqualMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnequal.FieldJustification:
		return m.Justification()
	case vulnequal.FieldOrigin:
		return m.Origin()
	case vulnequal.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnEqualMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnequal.FieldJustification:
		return m.OldJustification(ctx)
	case vulnequal.FieldOrigin:
		return m.OldOrigin(ctx)
	case vulnequal.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown VulnEqual field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnEqualMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnequal.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case vulnequal.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case vulnequal.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown VulnEqual field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnEqualMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnEqualMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnEqualMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VulnEqual numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnEqualMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnEqualMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnEqualMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VulnEqual nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnEqualMutation) ResetField(name string) error {
	switch name {
	case vulnequal.FieldJustification:
		m.ResetJustification()
		return nil
	case vulnequal.FieldOrigin:
		m.ResetOrigin()
		return nil
	case vulnequal.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown VulnEqual field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnEqualMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vulnerability_ids != nil {
		edges = append(edges, vulnequal.EdgeVulnerabilityIds)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnEqualMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnequal.EdgeVulnerabilityIds:
		ids := make([]ent.Value, 0, len(m.vulnerability_ids))
		for id := range m.vulnerability_ids {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnEqualMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvulnerability_ids != nil {
		edges = append(edges, vulnequal.EdgeVulnerabilityIds)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnEqualMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vulnequal.EdgeVulnerabilityIds:
		ids := make([]ent.Value, 0, len(m.removedvulnerability_ids))
		for id := range m.removedvulnerability_ids {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnEqualMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvulnerability_ids {
		edges = append(edges, vulnequal.EdgeVulnerabilityIds)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnEqualMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnequal.EdgeVulnerabilityIds:
		return m.clearedvulnerability_ids
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnEqualMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown VulnEqual unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnEqualMutation) ResetEdge(name string) error {
	switch name {
	case vulnequal.EdgeVulnerabilityIds:
		m.ResetVulnerabilityIds()
		return nil
	}
	return fmt.Errorf("unknown VulnEqual edge %s", name)
}

// VulnerabilityIDMutation represents an operation that mutates the VulnerabilityID nodes in the graph.
type VulnerabilityIDMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	vulnerability_id   *string
	clearedFields      map[string]struct{}
	_type              *int
	cleared_type       bool
	vuln_equals        map[int]struct{}
	removedvuln_equals map[int]struct{}
	clearedvuln_equals bool
	done               bool
	oldValue           func(context.Context) (*VulnerabilityID, error)
	predicates         []predicate.VulnerabilityID
}

var _ ent.Mutation = (*VulnerabilityIDMutation)(nil)

// vulnerabilityidOption allows management of the mutation configuration using functional options.
type vulnerabilityidOption func(*VulnerabilityIDMutation)

// newVulnerabilityIDMutation creates new mutation for the VulnerabilityID entity.
func newVulnerabilityIDMutation(c config, op Op, opts ...vulnerabilityidOption) *VulnerabilityIDMutation {
	m := &VulnerabilityIDMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnerabilityID,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnerabilityIDID sets the ID field of the mutation.
func withVulnerabilityIDID(id int) vulnerabilityidOption {
	return func(m *VulnerabilityIDMutation) {
		var (
			err   error
			once  sync.Once
			value *VulnerabilityID
		)
		m.oldValue = func(ctx context.Context) (*VulnerabilityID, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VulnerabilityID.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnerabilityID sets the old VulnerabilityID of the mutation.
func withVulnerabilityID(node *VulnerabilityID) vulnerabilityidOption {
	return func(m *VulnerabilityIDMutation) {
		m.oldValue = func(context.Context) (*VulnerabilityID, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnerabilityIDMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnerabilityIDMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnerabilityIDMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VulnerabilityIDMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VulnerabilityID.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVulnerabilityID sets the "vulnerability_id" field.
func (m *VulnerabilityIDMutation) SetVulnerabilityID(s string) {
	m.vulnerability_id = &s
}

// VulnerabilityID returns the value of the "vulnerability_id" field in the mutation.
func (m *VulnerabilityIDMutation) VulnerabilityID() (r string, exists bool) {
	v := m.vulnerability_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVulnerabilityID returns the old "vulnerability_id" field's value of the VulnerabilityID entity.
// If the VulnerabilityID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityIDMutation) OldVulnerabilityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVulnerabilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVulnerabilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVulnerabilityID: %w", err)
	}
	return oldValue.VulnerabilityID, nil
}

// ResetVulnerabilityID resets all changes to the "vulnerability_id" field.
func (m *VulnerabilityIDMutation) ResetVulnerabilityID() {
	m.vulnerability_id = nil
}

// SetTypeID sets the "type_id" field.
func (m *VulnerabilityIDMutation) SetTypeID(i int) {
	m._type = &i
}

// TypeID returns the value of the "type_id" field in the mutation.
func (m *VulnerabilityIDMutation) TypeID() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeID returns the old "type_id" field's value of the VulnerabilityID entity.
// If the VulnerabilityID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityIDMutation) OldTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeID: %w", err)
	}
	return oldValue.TypeID, nil
}

// ResetTypeID resets all changes to the "type_id" field.
func (m *VulnerabilityIDMutation) ResetTypeID() {
	m._type = nil
}

// ClearType clears the "type" edge to the VulnerabilityType entity.
func (m *VulnerabilityIDMutation) ClearType() {
	m.cleared_type = true
	m.clearedFields[vulnerabilityid.FieldTypeID] = struct{}{}
}

// TypeCleared reports if the "type" edge to the VulnerabilityType entity was cleared.
func (m *VulnerabilityIDMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeIDs returns the "type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *VulnerabilityIDMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *VulnerabilityIDMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// AddVulnEqualIDs adds the "vuln_equals" edge to the VulnEqual entity by ids.
func (m *VulnerabilityIDMutation) AddVulnEqualIDs(ids ...int) {
	if m.vuln_equals == nil {
		m.vuln_equals = make(map[int]struct{})
	}
	for i := range ids {
		m.vuln_equals[ids[i]] = struct{}{}
	}
}

// ClearVulnEquals clears the "vuln_equals" edge to the VulnEqual entity.
func (m *VulnerabilityIDMutation) ClearVulnEquals() {
	m.clearedvuln_equals = true
}

// VulnEqualsCleared reports if the "vuln_equals" edge to the VulnEqual entity was cleared.
func (m *VulnerabilityIDMutation) VulnEqualsCleared() bool {
	return m.clearedvuln_equals
}

// RemoveVulnEqualIDs removes the "vuln_equals" edge to the VulnEqual entity by IDs.
func (m *VulnerabilityIDMutation) RemoveVulnEqualIDs(ids ...int) {
	if m.removedvuln_equals == nil {
		m.removedvuln_equals = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vuln_equals, ids[i])
		m.removedvuln_equals[ids[i]] = struct{}{}
	}
}

// RemovedVulnEquals returns the removed IDs of the "vuln_equals" edge to the VulnEqual entity.
func (m *VulnerabilityIDMutation) RemovedVulnEqualsIDs() (ids []int) {
	for id := range m.removedvuln_equals {
		ids = append(ids, id)
	}
	return
}

// VulnEqualsIDs returns the "vuln_equals" edge IDs in the mutation.
func (m *VulnerabilityIDMutation) VulnEqualsIDs() (ids []int) {
	for id := range m.vuln_equals {
		ids = append(ids, id)
	}
	return
}

// ResetVulnEquals resets all changes to the "vuln_equals" edge.
func (m *VulnerabilityIDMutation) ResetVulnEquals() {
	m.vuln_equals = nil
	m.clearedvuln_equals = false
	m.removedvuln_equals = nil
}

// Where appends a list predicates to the VulnerabilityIDMutation builder.
func (m *VulnerabilityIDMutation) Where(ps ...predicate.VulnerabilityID) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VulnerabilityIDMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VulnerabilityIDMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VulnerabilityID, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VulnerabilityIDMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VulnerabilityIDMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VulnerabilityID).
func (m *VulnerabilityIDMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnerabilityIDMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.vulnerability_id != nil {
		fields = append(fields, vulnerabilityid.FieldVulnerabilityID)
	}
	if m._type != nil {
		fields = append(fields, vulnerabilityid.FieldTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnerabilityIDMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnerabilityid.FieldVulnerabilityID:
		return m.VulnerabilityID()
	case vulnerabilityid.FieldTypeID:
		return m.TypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnerabilityIDMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnerabilityid.FieldVulnerabilityID:
		return m.OldVulnerabilityID(ctx)
	case vulnerabilityid.FieldTypeID:
		return m.OldTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown VulnerabilityID field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityIDMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnerabilityid.FieldVulnerabilityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVulnerabilityID(v)
		return nil
	case vulnerabilityid.FieldTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityID field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnerabilityIDMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnerabilityIDMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityIDMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VulnerabilityID numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnerabilityIDMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnerabilityIDMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnerabilityIDMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VulnerabilityID nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnerabilityIDMutation) ResetField(name string) error {
	switch name {
	case vulnerabilityid.FieldVulnerabilityID:
		m.ResetVulnerabilityID()
		return nil
	case vulnerabilityid.FieldTypeID:
		m.ResetTypeID()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityID field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnerabilityIDMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._type != nil {
		edges = append(edges, vulnerabilityid.EdgeType)
	}
	if m.vuln_equals != nil {
		edges = append(edges, vulnerabilityid.EdgeVulnEquals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnerabilityIDMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnerabilityid.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case vulnerabilityid.EdgeVulnEquals:
		ids := make([]ent.Value, 0, len(m.vuln_equals))
		for id := range m.vuln_equals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnerabilityIDMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvuln_equals != nil {
		edges = append(edges, vulnerabilityid.EdgeVulnEquals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnerabilityIDMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vulnerabilityid.EdgeVulnEquals:
		ids := make([]ent.Value, 0, len(m.removedvuln_equals))
		for id := range m.removedvuln_equals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnerabilityIDMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_type {
		edges = append(edges, vulnerabilityid.EdgeType)
	}
	if m.clearedvuln_equals {
		edges = append(edges, vulnerabilityid.EdgeVulnEquals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnerabilityIDMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnerabilityid.EdgeType:
		return m.cleared_type
	case vulnerabilityid.EdgeVulnEquals:
		return m.clearedvuln_equals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnerabilityIDMutation) ClearEdge(name string) error {
	switch name {
	case vulnerabilityid.EdgeType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityID unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnerabilityIDMutation) ResetEdge(name string) error {
	switch name {
	case vulnerabilityid.EdgeType:
		m.ResetType()
		return nil
	case vulnerabilityid.EdgeVulnEquals:
		m.ResetVulnEquals()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityID edge %s", name)
}

// VulnerabilityTypeMutation represents an operation that mutates the VulnerabilityType nodes in the graph.
type VulnerabilityTypeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	_type                    *string
	clearedFields            map[string]struct{}
	vulnerability_ids        map[int]struct{}
	removedvulnerability_ids map[int]struct{}
	clearedvulnerability_ids bool
	done                     bool
	oldValue                 func(context.Context) (*VulnerabilityType, error)
	predicates               []predicate.VulnerabilityType
}

var _ ent.Mutation = (*VulnerabilityTypeMutation)(nil)

// vulnerabilitytypeOption allows management of the mutation configuration using functional options.
type vulnerabilitytypeOption func(*VulnerabilityTypeMutation)

// newVulnerabilityTypeMutation creates new mutation for the VulnerabilityType entity.
func newVulnerabilityTypeMutation(c config, op Op, opts ...vulnerabilitytypeOption) *VulnerabilityTypeMutation {
	m := &VulnerabilityTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnerabilityType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnerabilityTypeID sets the ID field of the mutation.
func withVulnerabilityTypeID(id int) vulnerabilitytypeOption {
	return func(m *VulnerabilityTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *VulnerabilityType
		)
		m.oldValue = func(ctx context.Context) (*VulnerabilityType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VulnerabilityType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnerabilityType sets the old VulnerabilityType of the mutation.
func withVulnerabilityType(node *VulnerabilityType) vulnerabilitytypeOption {
	return func(m *VulnerabilityTypeMutation) {
		m.oldValue = func(context.Context) (*VulnerabilityType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnerabilityTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnerabilityTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnerabilityTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VulnerabilityTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VulnerabilityType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *VulnerabilityTypeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *VulnerabilityTypeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the VulnerabilityType entity.
// If the VulnerabilityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityTypeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *VulnerabilityTypeMutation) ResetType() {
	m._type = nil
}

// AddVulnerabilityIDIDs adds the "vulnerability_ids" edge to the VulnerabilityID entity by ids.
func (m *VulnerabilityTypeMutation) AddVulnerabilityIDIDs(ids ...int) {
	if m.vulnerability_ids == nil {
		m.vulnerability_ids = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerability_ids[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilityIds clears the "vulnerability_ids" edge to the VulnerabilityID entity.
func (m *VulnerabilityTypeMutation) ClearVulnerabilityIds() {
	m.clearedvulnerability_ids = true
}

// VulnerabilityIdsCleared reports if the "vulnerability_ids" edge to the VulnerabilityID entity was cleared.
func (m *VulnerabilityTypeMutation) VulnerabilityIdsCleared() bool {
	return m.clearedvulnerability_ids
}

// RemoveVulnerabilityIDIDs removes the "vulnerability_ids" edge to the VulnerabilityID entity by IDs.
func (m *VulnerabilityTypeMutation) RemoveVulnerabilityIDIDs(ids ...int) {
	if m.removedvulnerability_ids == nil {
		m.removedvulnerability_ids = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerability_ids, ids[i])
		m.removedvulnerability_ids[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilityIds returns the removed IDs of the "vulnerability_ids" edge to the VulnerabilityID entity.
func (m *VulnerabilityTypeMutation) RemovedVulnerabilityIdsIDs() (ids []int) {
	for id := range m.removedvulnerability_ids {
		ids = append(ids, id)
	}
	return
}

// VulnerabilityIdsIDs returns the "vulnerability_ids" edge IDs in the mutation.
func (m *VulnerabilityTypeMutation) VulnerabilityIdsIDs() (ids []int) {
	for id := range m.vulnerability_ids {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilityIds resets all changes to the "vulnerability_ids" edge.
func (m *VulnerabilityTypeMutation) ResetVulnerabilityIds() {
	m.vulnerability_ids = nil
	m.clearedvulnerability_ids = false
	m.removedvulnerability_ids = nil
}

// Where appends a list predicates to the VulnerabilityTypeMutation builder.
func (m *VulnerabilityTypeMutation) Where(ps ...predicate.VulnerabilityType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VulnerabilityTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VulnerabilityTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VulnerabilityType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VulnerabilityTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VulnerabilityTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VulnerabilityType).
func (m *VulnerabilityTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnerabilityTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._type != nil {
		fields = append(fields, vulnerabilitytype.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnerabilityTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnerabilitytype.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnerabilityTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnerabilitytype.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown VulnerabilityType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnerabilitytype.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnerabilityTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnerabilityTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VulnerabilityType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnerabilityTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnerabilityTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnerabilityTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VulnerabilityType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnerabilityTypeMutation) ResetField(name string) error {
	switch name {
	case vulnerabilitytype.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnerabilityTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vulnerability_ids != nil {
		edges = append(edges, vulnerabilitytype.EdgeVulnerabilityIds)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnerabilityTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnerabilitytype.EdgeVulnerabilityIds:
		ids := make([]ent.Value, 0, len(m.vulnerability_ids))
		for id := range m.vulnerability_ids {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnerabilityTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvulnerability_ids != nil {
		edges = append(edges, vulnerabilitytype.EdgeVulnerabilityIds)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnerabilityTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vulnerabilitytype.EdgeVulnerabilityIds:
		ids := make([]ent.Value, 0, len(m.removedvulnerability_ids))
		for id := range m.removedvulnerability_ids {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnerabilityTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvulnerability_ids {
		edges = append(edges, vulnerabilitytype.EdgeVulnerabilityIds)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnerabilityTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnerabilitytype.EdgeVulnerabilityIds:
		return m.clearedvulnerability_ids
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnerabilityTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown VulnerabilityType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnerabilityTypeMutation) ResetEdge(name string) error {
	switch name {
	case vulnerabilitytype.EdgeVulnerabilityIds:
		m.ResetVulnerabilityIds()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityType edge %s", name)
}
