// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/artifact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/buildernode"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/dependency"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/occurrence"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/occurrencesubject"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagenode"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/predicate"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/source"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcenamespace"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArtifact          = "Artifact"
	TypeBuilderNode       = "BuilderNode"
	TypeDependency        = "Dependency"
	TypeOccurrence        = "Occurrence"
	TypeOccurrenceSubject = "OccurrenceSubject"
	TypePackageName       = "PackageName"
	TypePackageNamespace  = "PackageNamespace"
	TypePackageNode       = "PackageNode"
	TypePackageVersion    = "PackageVersion"
	TypeSource            = "Source"
	TypeSourceName        = "SourceName"
	TypeSourceNamespace   = "SourceNamespace"
)

// ArtifactMutation represents an operation that mutates the Artifact nodes in the graph.
type ArtifactMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	algorithm          *string
	digest             *string
	clearedFields      map[string]struct{}
	occurrences        map[int]struct{}
	removedoccurrences map[int]struct{}
	clearedoccurrences bool
	done               bool
	oldValue           func(context.Context) (*Artifact, error)
	predicates         []predicate.Artifact
}

var _ ent.Mutation = (*ArtifactMutation)(nil)

// artifactOption allows management of the mutation configuration using functional options.
type artifactOption func(*ArtifactMutation)

// newArtifactMutation creates new mutation for the Artifact entity.
func newArtifactMutation(c config, op Op, opts ...artifactOption) *ArtifactMutation {
	m := &ArtifactMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactID sets the ID field of the mutation.
func withArtifactID(id int) artifactOption {
	return func(m *ArtifactMutation) {
		var (
			err   error
			once  sync.Once
			value *Artifact
		)
		m.oldValue = func(ctx context.Context) (*Artifact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artifact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifact sets the old Artifact of the mutation.
func withArtifact(node *Artifact) artifactOption {
	return func(m *ArtifactMutation) {
		m.oldValue = func(context.Context) (*Artifact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtifactMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artifact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlgorithm sets the "algorithm" field.
func (m *ArtifactMutation) SetAlgorithm(s string) {
	m.algorithm = &s
}

// Algorithm returns the value of the "algorithm" field in the mutation.
func (m *ArtifactMutation) Algorithm() (r string, exists bool) {
	v := m.algorithm
	if v == nil {
		return
	}
	return *v, true
}

// OldAlgorithm returns the old "algorithm" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldAlgorithm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlgorithm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlgorithm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlgorithm: %w", err)
	}
	return oldValue.Algorithm, nil
}

// ResetAlgorithm resets all changes to the "algorithm" field.
func (m *ArtifactMutation) ResetAlgorithm() {
	m.algorithm = nil
}

// SetDigest sets the "digest" field.
func (m *ArtifactMutation) SetDigest(s string) {
	m.digest = &s
}

// Digest returns the value of the "digest" field in the mutation.
func (m *ArtifactMutation) Digest() (r string, exists bool) {
	v := m.digest
	if v == nil {
		return
	}
	return *v, true
}

// OldDigest returns the old "digest" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldDigest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigest: %w", err)
	}
	return oldValue.Digest, nil
}

// ResetDigest resets all changes to the "digest" field.
func (m *ArtifactMutation) ResetDigest() {
	m.digest = nil
}

// AddOccurrenceIDs adds the "occurrences" edge to the Occurrence entity by ids.
func (m *ArtifactMutation) AddOccurrenceIDs(ids ...int) {
	if m.occurrences == nil {
		m.occurrences = make(map[int]struct{})
	}
	for i := range ids {
		m.occurrences[ids[i]] = struct{}{}
	}
}

// ClearOccurrences clears the "occurrences" edge to the Occurrence entity.
func (m *ArtifactMutation) ClearOccurrences() {
	m.clearedoccurrences = true
}

// OccurrencesCleared reports if the "occurrences" edge to the Occurrence entity was cleared.
func (m *ArtifactMutation) OccurrencesCleared() bool {
	return m.clearedoccurrences
}

// RemoveOccurrenceIDs removes the "occurrences" edge to the Occurrence entity by IDs.
func (m *ArtifactMutation) RemoveOccurrenceIDs(ids ...int) {
	if m.removedoccurrences == nil {
		m.removedoccurrences = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occurrences, ids[i])
		m.removedoccurrences[ids[i]] = struct{}{}
	}
}

// RemovedOccurrences returns the removed IDs of the "occurrences" edge to the Occurrence entity.
func (m *ArtifactMutation) RemovedOccurrencesIDs() (ids []int) {
	for id := range m.removedoccurrences {
		ids = append(ids, id)
	}
	return
}

// OccurrencesIDs returns the "occurrences" edge IDs in the mutation.
func (m *ArtifactMutation) OccurrencesIDs() (ids []int) {
	for id := range m.occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetOccurrences resets all changes to the "occurrences" edge.
func (m *ArtifactMutation) ResetOccurrences() {
	m.occurrences = nil
	m.clearedoccurrences = false
	m.removedoccurrences = nil
}

// Where appends a list predicates to the ArtifactMutation builder.
func (m *ArtifactMutation) Where(ps ...predicate.Artifact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtifactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtifactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Artifact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtifactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtifactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Artifact).
func (m *ArtifactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.algorithm != nil {
		fields = append(fields, artifact.FieldAlgorithm)
	}
	if m.digest != nil {
		fields = append(fields, artifact.FieldDigest)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifact.FieldAlgorithm:
		return m.Algorithm()
	case artifact.FieldDigest:
		return m.Digest()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifact.FieldAlgorithm:
		return m.OldAlgorithm(ctx)
	case artifact.FieldDigest:
		return m.OldDigest(ctx)
	}
	return nil, fmt.Errorf("unknown Artifact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifact.FieldAlgorithm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlgorithm(v)
		return nil
	case artifact.FieldDigest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigest(v)
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Artifact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactMutation) ResetField(name string) error {
	switch name {
	case artifact.FieldAlgorithm:
		m.ResetAlgorithm()
		return nil
	case artifact.FieldDigest:
		m.ResetDigest()
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.occurrences != nil {
		edges = append(edges, artifact.EdgeOccurrences)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.occurrences))
		for id := range m.occurrences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedoccurrences != nil {
		edges = append(edges, artifact.EdgeOccurrences)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.removedoccurrences))
		for id := range m.removedoccurrences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedoccurrences {
		edges = append(edges, artifact.EdgeOccurrences)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactMutation) EdgeCleared(name string) bool {
	switch name {
	case artifact.EdgeOccurrences:
		return m.clearedoccurrences
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactMutation) ResetEdge(name string) error {
	switch name {
	case artifact.EdgeOccurrences:
		m.ResetOccurrences()
		return nil
	}
	return fmt.Errorf("unknown Artifact edge %s", name)
}

// BuilderNodeMutation represents an operation that mutates the BuilderNode nodes in the graph.
type BuilderNodeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uri           *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BuilderNode, error)
	predicates    []predicate.BuilderNode
}

var _ ent.Mutation = (*BuilderNodeMutation)(nil)

// buildernodeOption allows management of the mutation configuration using functional options.
type buildernodeOption func(*BuilderNodeMutation)

// newBuilderNodeMutation creates new mutation for the BuilderNode entity.
func newBuilderNodeMutation(c config, op Op, opts ...buildernodeOption) *BuilderNodeMutation {
	m := &BuilderNodeMutation{
		config:        c,
		op:            op,
		typ:           TypeBuilderNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuilderNodeID sets the ID field of the mutation.
func withBuilderNodeID(id int) buildernodeOption {
	return func(m *BuilderNodeMutation) {
		var (
			err   error
			once  sync.Once
			value *BuilderNode
		)
		m.oldValue = func(ctx context.Context) (*BuilderNode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BuilderNode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuilderNode sets the old BuilderNode of the mutation.
func withBuilderNode(node *BuilderNode) buildernodeOption {
	return func(m *BuilderNodeMutation) {
		m.oldValue = func(context.Context) (*BuilderNode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuilderNodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuilderNodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuilderNodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuilderNodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BuilderNode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURI sets the "uri" field.
func (m *BuilderNodeMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *BuilderNodeMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the BuilderNode entity.
// If the BuilderNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuilderNodeMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *BuilderNodeMutation) ResetURI() {
	m.uri = nil
}

// Where appends a list predicates to the BuilderNodeMutation builder.
func (m *BuilderNodeMutation) Where(ps ...predicate.BuilderNode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BuilderNodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BuilderNodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BuilderNode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BuilderNodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BuilderNodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BuilderNode).
func (m *BuilderNodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuilderNodeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.uri != nil {
		fields = append(fields, buildernode.FieldURI)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuilderNodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case buildernode.FieldURI:
		return m.URI()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuilderNodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case buildernode.FieldURI:
		return m.OldURI(ctx)
	}
	return nil, fmt.Errorf("unknown BuilderNode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuilderNodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case buildernode.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	}
	return fmt.Errorf("unknown BuilderNode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuilderNodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuilderNodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuilderNodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BuilderNode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuilderNodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuilderNodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuilderNodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BuilderNode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuilderNodeMutation) ResetField(name string) error {
	switch name {
	case buildernode.FieldURI:
		m.ResetURI()
		return nil
	}
	return fmt.Errorf("unknown BuilderNode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuilderNodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuilderNodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuilderNodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuilderNodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuilderNodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuilderNodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuilderNodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BuilderNode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuilderNodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BuilderNode edge %s", name)
}

// DependencyMutation represents an operation that mutates the Dependency nodes in the graph.
type DependencyMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	version_range            *string
	dependency_type          *string
	justification            *string
	origin                   *string
	collector                *string
	clearedFields            map[string]struct{}
	_package                 *int
	cleared_package          bool
	dependent_package        *int
	cleareddependent_package bool
	done                     bool
	oldValue                 func(context.Context) (*Dependency, error)
	predicates               []predicate.Dependency
}

var _ ent.Mutation = (*DependencyMutation)(nil)

// dependencyOption allows management of the mutation configuration using functional options.
type dependencyOption func(*DependencyMutation)

// newDependencyMutation creates new mutation for the Dependency entity.
func newDependencyMutation(c config, op Op, opts ...dependencyOption) *DependencyMutation {
	m := &DependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDependencyID sets the ID field of the mutation.
func withDependencyID(id int) dependencyOption {
	return func(m *DependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Dependency
		)
		m.oldValue = func(ctx context.Context) (*Dependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDependency sets the old Dependency of the mutation.
func withDependency(node *Dependency) dependencyOption {
	return func(m *DependencyMutation) {
		m.oldValue = func(context.Context) (*Dependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DependencyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DependencyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *DependencyMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *DependencyMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldPackageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *DependencyMutation) ResetPackageID() {
	m._package = nil
}

// SetDependentPackageID sets the "dependent_package_id" field.
func (m *DependencyMutation) SetDependentPackageID(i int) {
	m.dependent_package = &i
}

// DependentPackageID returns the value of the "dependent_package_id" field in the mutation.
func (m *DependencyMutation) DependentPackageID() (r int, exists bool) {
	v := m.dependent_package
	if v == nil {
		return
	}
	return *v, true
}

// OldDependentPackageID returns the old "dependent_package_id" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldDependentPackageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependentPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependentPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependentPackageID: %w", err)
	}
	return oldValue.DependentPackageID, nil
}

// ResetDependentPackageID resets all changes to the "dependent_package_id" field.
func (m *DependencyMutation) ResetDependentPackageID() {
	m.dependent_package = nil
}

// SetVersionRange sets the "version_range" field.
func (m *DependencyMutation) SetVersionRange(s string) {
	m.version_range = &s
}

// VersionRange returns the value of the "version_range" field in the mutation.
func (m *DependencyMutation) VersionRange() (r string, exists bool) {
	v := m.version_range
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionRange returns the old "version_range" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldVersionRange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionRange: %w", err)
	}
	return oldValue.VersionRange, nil
}

// ResetVersionRange resets all changes to the "version_range" field.
func (m *DependencyMutation) ResetVersionRange() {
	m.version_range = nil
}

// SetDependencyType sets the "dependency_type" field.
func (m *DependencyMutation) SetDependencyType(s string) {
	m.dependency_type = &s
}

// DependencyType returns the value of the "dependency_type" field in the mutation.
func (m *DependencyMutation) DependencyType() (r string, exists bool) {
	v := m.dependency_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencyType returns the old "dependency_type" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldDependencyType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencyType: %w", err)
	}
	return oldValue.DependencyType, nil
}

// ResetDependencyType resets all changes to the "dependency_type" field.
func (m *DependencyMutation) ResetDependencyType() {
	m.dependency_type = nil
}

// SetJustification sets the "justification" field.
func (m *DependencyMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *DependencyMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *DependencyMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *DependencyMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *DependencyMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *DependencyMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *DependencyMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *DependencyMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the Dependency entity.
// If the Dependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DependencyMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *DependencyMutation) ResetCollector() {
	m.collector = nil
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *DependencyMutation) ClearPackage() {
	m.cleared_package = true
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *DependencyMutation) PackageCleared() bool {
	return m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *DependencyMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *DependencyMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearDependentPackage clears the "dependent_package" edge to the PackageName entity.
func (m *DependencyMutation) ClearDependentPackage() {
	m.cleareddependent_package = true
}

// DependentPackageCleared reports if the "dependent_package" edge to the PackageName entity was cleared.
func (m *DependencyMutation) DependentPackageCleared() bool {
	return m.cleareddependent_package
}

// DependentPackageIDs returns the "dependent_package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DependentPackageID instead. It exists only for internal usage by the builders.
func (m *DependencyMutation) DependentPackageIDs() (ids []int) {
	if id := m.dependent_package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDependentPackage resets all changes to the "dependent_package" edge.
func (m *DependencyMutation) ResetDependentPackage() {
	m.dependent_package = nil
	m.cleareddependent_package = false
}

// Where appends a list predicates to the DependencyMutation builder.
func (m *DependencyMutation) Where(ps ...predicate.Dependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dependency).
func (m *DependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DependencyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._package != nil {
		fields = append(fields, dependency.FieldPackageID)
	}
	if m.dependent_package != nil {
		fields = append(fields, dependency.FieldDependentPackageID)
	}
	if m.version_range != nil {
		fields = append(fields, dependency.FieldVersionRange)
	}
	if m.dependency_type != nil {
		fields = append(fields, dependency.FieldDependencyType)
	}
	if m.justification != nil {
		fields = append(fields, dependency.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, dependency.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, dependency.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dependency.FieldPackageID:
		return m.PackageID()
	case dependency.FieldDependentPackageID:
		return m.DependentPackageID()
	case dependency.FieldVersionRange:
		return m.VersionRange()
	case dependency.FieldDependencyType:
		return m.DependencyType()
	case dependency.FieldJustification:
		return m.Justification()
	case dependency.FieldOrigin:
		return m.Origin()
	case dependency.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dependency.FieldPackageID:
		return m.OldPackageID(ctx)
	case dependency.FieldDependentPackageID:
		return m.OldDependentPackageID(ctx)
	case dependency.FieldVersionRange:
		return m.OldVersionRange(ctx)
	case dependency.FieldDependencyType:
		return m.OldDependencyType(ctx)
	case dependency.FieldJustification:
		return m.OldJustification(ctx)
	case dependency.FieldOrigin:
		return m.OldOrigin(ctx)
	case dependency.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown Dependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dependency.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case dependency.FieldDependentPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependentPackageID(v)
		return nil
	case dependency.FieldVersionRange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionRange(v)
		return nil
	case dependency.FieldDependencyType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencyType(v)
		return nil
	case dependency.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case dependency.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case dependency.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown Dependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DependencyMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DependencyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Dependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DependencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DependencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Dependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DependencyMutation) ResetField(name string) error {
	switch name {
	case dependency.FieldPackageID:
		m.ResetPackageID()
		return nil
	case dependency.FieldDependentPackageID:
		m.ResetDependentPackageID()
		return nil
	case dependency.FieldVersionRange:
		m.ResetVersionRange()
		return nil
	case dependency.FieldDependencyType:
		m.ResetDependencyType()
		return nil
	case dependency.FieldJustification:
		m.ResetJustification()
		return nil
	case dependency.FieldOrigin:
		m.ResetOrigin()
		return nil
	case dependency.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown Dependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._package != nil {
		edges = append(edges, dependency.EdgePackage)
	}
	if m.dependent_package != nil {
		edges = append(edges, dependency.EdgeDependentPackage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dependency.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case dependency.EdgeDependentPackage:
		if id := m.dependent_package; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_package {
		edges = append(edges, dependency.EdgePackage)
	}
	if m.cleareddependent_package {
		edges = append(edges, dependency.EdgeDependentPackage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case dependency.EdgePackage:
		return m.cleared_package
	case dependency.EdgeDependentPackage:
		return m.cleareddependent_package
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DependencyMutation) ClearEdge(name string) error {
	switch name {
	case dependency.EdgePackage:
		m.ClearPackage()
		return nil
	case dependency.EdgeDependentPackage:
		m.ClearDependentPackage()
		return nil
	}
	return fmt.Errorf("unknown Dependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DependencyMutation) ResetEdge(name string) error {
	switch name {
	case dependency.EdgePackage:
		m.ResetPackage()
		return nil
	case dependency.EdgeDependentPackage:
		m.ResetDependentPackage()
		return nil
	}
	return fmt.Errorf("unknown Dependency edge %s", name)
}

// OccurrenceMutation represents an operation that mutates the Occurrence nodes in the graph.
type OccurrenceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	justification   *string
	origin          *string
	collector       *string
	clearedFields   map[string]struct{}
	subject         *int
	clearedsubject  bool
	artifact        *int
	clearedartifact bool
	done            bool
	oldValue        func(context.Context) (*Occurrence, error)
	predicates      []predicate.Occurrence
}

var _ ent.Mutation = (*OccurrenceMutation)(nil)

// occurrenceOption allows management of the mutation configuration using functional options.
type occurrenceOption func(*OccurrenceMutation)

// newOccurrenceMutation creates new mutation for the Occurrence entity.
func newOccurrenceMutation(c config, op Op, opts ...occurrenceOption) *OccurrenceMutation {
	m := &OccurrenceMutation{
		config:        c,
		op:            op,
		typ:           TypeOccurrence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOccurrenceID sets the ID field of the mutation.
func withOccurrenceID(id int) occurrenceOption {
	return func(m *OccurrenceMutation) {
		var (
			err   error
			once  sync.Once
			value *Occurrence
		)
		m.oldValue = func(ctx context.Context) (*Occurrence, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Occurrence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOccurrence sets the old Occurrence of the mutation.
func withOccurrence(node *Occurrence) occurrenceOption {
	return func(m *OccurrenceMutation) {
		m.oldValue = func(context.Context) (*Occurrence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OccurrenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OccurrenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OccurrenceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OccurrenceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Occurrence.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArtifactID sets the "artifact_id" field.
func (m *OccurrenceMutation) SetArtifactID(i int) {
	m.artifact = &i
}

// ArtifactID returns the value of the "artifact_id" field in the mutation.
func (m *OccurrenceMutation) ArtifactID() (r int, exists bool) {
	v := m.artifact
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactID returns the old "artifact_id" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldArtifactID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactID: %w", err)
	}
	return oldValue.ArtifactID, nil
}

// ResetArtifactID resets all changes to the "artifact_id" field.
func (m *OccurrenceMutation) ResetArtifactID() {
	m.artifact = nil
}

// SetJustification sets the "justification" field.
func (m *OccurrenceMutation) SetJustification(s string) {
	m.justification = &s
}

// Justification returns the value of the "justification" field in the mutation.
func (m *OccurrenceMutation) Justification() (r string, exists bool) {
	v := m.justification
	if v == nil {
		return
	}
	return *v, true
}

// OldJustification returns the old "justification" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldJustification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJustification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJustification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJustification: %w", err)
	}
	return oldValue.Justification, nil
}

// ResetJustification resets all changes to the "justification" field.
func (m *OccurrenceMutation) ResetJustification() {
	m.justification = nil
}

// SetOrigin sets the "origin" field.
func (m *OccurrenceMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *OccurrenceMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *OccurrenceMutation) ResetOrigin() {
	m.origin = nil
}

// SetCollector sets the "collector" field.
func (m *OccurrenceMutation) SetCollector(s string) {
	m.collector = &s
}

// Collector returns the value of the "collector" field in the mutation.
func (m *OccurrenceMutation) Collector() (r string, exists bool) {
	v := m.collector
	if v == nil {
		return
	}
	return *v, true
}

// OldCollector returns the old "collector" field's value of the Occurrence entity.
// If the Occurrence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceMutation) OldCollector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollector: %w", err)
	}
	return oldValue.Collector, nil
}

// ResetCollector resets all changes to the "collector" field.
func (m *OccurrenceMutation) ResetCollector() {
	m.collector = nil
}

// SetSubjectID sets the "subject" edge to the OccurrenceSubject entity by id.
func (m *OccurrenceMutation) SetSubjectID(id int) {
	m.subject = &id
}

// ClearSubject clears the "subject" edge to the OccurrenceSubject entity.
func (m *OccurrenceMutation) ClearSubject() {
	m.clearedsubject = true
}

// SubjectCleared reports if the "subject" edge to the OccurrenceSubject entity was cleared.
func (m *OccurrenceMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectID returns the "subject" edge ID in the mutation.
func (m *OccurrenceMutation) SubjectID() (id int, exists bool) {
	if m.subject != nil {
		return *m.subject, true
	}
	return
}

// SubjectIDs returns the "subject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *OccurrenceMutation) SubjectIDs() (ids []int) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject resets all changes to the "subject" edge.
func (m *OccurrenceMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *OccurrenceMutation) ClearArtifact() {
	m.clearedartifact = true
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *OccurrenceMutation) ArtifactCleared() bool {
	return m.clearedartifact
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *OccurrenceMutation) ArtifactIDs() (ids []int) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *OccurrenceMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// Where appends a list predicates to the OccurrenceMutation builder.
func (m *OccurrenceMutation) Where(ps ...predicate.Occurrence) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OccurrenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OccurrenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Occurrence, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OccurrenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OccurrenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Occurrence).
func (m *OccurrenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OccurrenceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.artifact != nil {
		fields = append(fields, occurrence.FieldArtifactID)
	}
	if m.justification != nil {
		fields = append(fields, occurrence.FieldJustification)
	}
	if m.origin != nil {
		fields = append(fields, occurrence.FieldOrigin)
	}
	if m.collector != nil {
		fields = append(fields, occurrence.FieldCollector)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OccurrenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case occurrence.FieldArtifactID:
		return m.ArtifactID()
	case occurrence.FieldJustification:
		return m.Justification()
	case occurrence.FieldOrigin:
		return m.Origin()
	case occurrence.FieldCollector:
		return m.Collector()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OccurrenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case occurrence.FieldArtifactID:
		return m.OldArtifactID(ctx)
	case occurrence.FieldJustification:
		return m.OldJustification(ctx)
	case occurrence.FieldOrigin:
		return m.OldOrigin(ctx)
	case occurrence.FieldCollector:
		return m.OldCollector(ctx)
	}
	return nil, fmt.Errorf("unknown Occurrence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurrenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case occurrence.FieldArtifactID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactID(v)
		return nil
	case occurrence.FieldJustification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJustification(v)
		return nil
	case occurrence.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case occurrence.FieldCollector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollector(v)
		return nil
	}
	return fmt.Errorf("unknown Occurrence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OccurrenceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OccurrenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurrenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Occurrence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OccurrenceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OccurrenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OccurrenceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Occurrence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OccurrenceMutation) ResetField(name string) error {
	switch name {
	case occurrence.FieldArtifactID:
		m.ResetArtifactID()
		return nil
	case occurrence.FieldJustification:
		m.ResetJustification()
		return nil
	case occurrence.FieldOrigin:
		m.ResetOrigin()
		return nil
	case occurrence.FieldCollector:
		m.ResetCollector()
		return nil
	}
	return fmt.Errorf("unknown Occurrence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OccurrenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.subject != nil {
		edges = append(edges, occurrence.EdgeSubject)
	}
	if m.artifact != nil {
		edges = append(edges, occurrence.EdgeArtifact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OccurrenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case occurrence.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	case occurrence.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OccurrenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OccurrenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OccurrenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsubject {
		edges = append(edges, occurrence.EdgeSubject)
	}
	if m.clearedartifact {
		edges = append(edges, occurrence.EdgeArtifact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OccurrenceMutation) EdgeCleared(name string) bool {
	switch name {
	case occurrence.EdgeSubject:
		return m.clearedsubject
	case occurrence.EdgeArtifact:
		return m.clearedartifact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OccurrenceMutation) ClearEdge(name string) error {
	switch name {
	case occurrence.EdgeSubject:
		m.ClearSubject()
		return nil
	case occurrence.EdgeArtifact:
		m.ClearArtifact()
		return nil
	}
	return fmt.Errorf("unknown Occurrence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OccurrenceMutation) ResetEdge(name string) error {
	switch name {
	case occurrence.EdgeSubject:
		m.ResetSubject()
		return nil
	case occurrence.EdgeArtifact:
		m.ResetArtifact()
		return nil
	}
	return fmt.Errorf("unknown Occurrence edge %s", name)
}

// OccurrenceSubjectMutation represents an operation that mutates the OccurrenceSubject nodes in the graph.
type OccurrenceSubjectMutation struct {
	config
	op                Op
	typ               string
	id                *int
	clearedFields     map[string]struct{}
	occurrence        *int
	clearedoccurrence bool
	_package          *int
	cleared_package   bool
	source            *int
	clearedsource     bool
	done              bool
	oldValue          func(context.Context) (*OccurrenceSubject, error)
	predicates        []predicate.OccurrenceSubject
}

var _ ent.Mutation = (*OccurrenceSubjectMutation)(nil)

// occurrencesubjectOption allows management of the mutation configuration using functional options.
type occurrencesubjectOption func(*OccurrenceSubjectMutation)

// newOccurrenceSubjectMutation creates new mutation for the OccurrenceSubject entity.
func newOccurrenceSubjectMutation(c config, op Op, opts ...occurrencesubjectOption) *OccurrenceSubjectMutation {
	m := &OccurrenceSubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeOccurrenceSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOccurrenceSubjectID sets the ID field of the mutation.
func withOccurrenceSubjectID(id int) occurrencesubjectOption {
	return func(m *OccurrenceSubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *OccurrenceSubject
		)
		m.oldValue = func(ctx context.Context) (*OccurrenceSubject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OccurrenceSubject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOccurrenceSubject sets the old OccurrenceSubject of the mutation.
func withOccurrenceSubject(node *OccurrenceSubject) occurrencesubjectOption {
	return func(m *OccurrenceSubjectMutation) {
		m.oldValue = func(context.Context) (*OccurrenceSubject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OccurrenceSubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OccurrenceSubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OccurrenceSubjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OccurrenceSubjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OccurrenceSubject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOccurrenceID sets the "occurrence_id" field.
func (m *OccurrenceSubjectMutation) SetOccurrenceID(i int) {
	m.occurrence = &i
}

// OccurrenceID returns the value of the "occurrence_id" field in the mutation.
func (m *OccurrenceSubjectMutation) OccurrenceID() (r int, exists bool) {
	v := m.occurrence
	if v == nil {
		return
	}
	return *v, true
}

// OldOccurrenceID returns the old "occurrence_id" field's value of the OccurrenceSubject entity.
// If the OccurrenceSubject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceSubjectMutation) OldOccurrenceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccurrenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccurrenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccurrenceID: %w", err)
	}
	return oldValue.OccurrenceID, nil
}

// ResetOccurrenceID resets all changes to the "occurrence_id" field.
func (m *OccurrenceSubjectMutation) ResetOccurrenceID() {
	m.occurrence = nil
}

// SetSourceID sets the "source_id" field.
func (m *OccurrenceSubjectMutation) SetSourceID(i int) {
	m.source = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *OccurrenceSubjectMutation) SourceID() (r int, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the OccurrenceSubject entity.
// If the OccurrenceSubject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceSubjectMutation) OldSourceID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *OccurrenceSubjectMutation) ClearSourceID() {
	m.source = nil
	m.clearedFields[occurrencesubject.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *OccurrenceSubjectMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[occurrencesubject.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *OccurrenceSubjectMutation) ResetSourceID() {
	m.source = nil
	delete(m.clearedFields, occurrencesubject.FieldSourceID)
}

// SetPackageID sets the "package_id" field.
func (m *OccurrenceSubjectMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *OccurrenceSubjectMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the OccurrenceSubject entity.
// If the OccurrenceSubject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccurrenceSubjectMutation) OldPackageID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *OccurrenceSubjectMutation) ClearPackageID() {
	m._package = nil
	m.clearedFields[occurrencesubject.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *OccurrenceSubjectMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[occurrencesubject.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *OccurrenceSubjectMutation) ResetPackageID() {
	m._package = nil
	delete(m.clearedFields, occurrencesubject.FieldPackageID)
}

// ClearOccurrence clears the "occurrence" edge to the Occurrence entity.
func (m *OccurrenceSubjectMutation) ClearOccurrence() {
	m.clearedoccurrence = true
}

// OccurrenceCleared reports if the "occurrence" edge to the Occurrence entity was cleared.
func (m *OccurrenceSubjectMutation) OccurrenceCleared() bool {
	return m.clearedoccurrence
}

// OccurrenceIDs returns the "occurrence" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OccurrenceID instead. It exists only for internal usage by the builders.
func (m *OccurrenceSubjectMutation) OccurrenceIDs() (ids []int) {
	if id := m.occurrence; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOccurrence resets all changes to the "occurrence" edge.
func (m *OccurrenceSubjectMutation) ResetOccurrence() {
	m.occurrence = nil
	m.clearedoccurrence = false
}

// ClearPackage clears the "package" edge to the PackageVersion entity.
func (m *OccurrenceSubjectMutation) ClearPackage() {
	m.cleared_package = true
}

// PackageCleared reports if the "package" edge to the PackageVersion entity was cleared.
func (m *OccurrenceSubjectMutation) PackageCleared() bool {
	return m.PackageIDCleared() || m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *OccurrenceSubjectMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *OccurrenceSubjectMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// ClearSource clears the "source" edge to the SourceName entity.
func (m *OccurrenceSubjectMutation) ClearSource() {
	m.clearedsource = true
}

// SourceCleared reports if the "source" edge to the SourceName entity was cleared.
func (m *OccurrenceSubjectMutation) SourceCleared() bool {
	return m.SourceIDCleared() || m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *OccurrenceSubjectMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *OccurrenceSubjectMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Where appends a list predicates to the OccurrenceSubjectMutation builder.
func (m *OccurrenceSubjectMutation) Where(ps ...predicate.OccurrenceSubject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OccurrenceSubjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OccurrenceSubjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OccurrenceSubject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OccurrenceSubjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OccurrenceSubjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OccurrenceSubject).
func (m *OccurrenceSubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OccurrenceSubjectMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.occurrence != nil {
		fields = append(fields, occurrencesubject.FieldOccurrenceID)
	}
	if m.source != nil {
		fields = append(fields, occurrencesubject.FieldSourceID)
	}
	if m._package != nil {
		fields = append(fields, occurrencesubject.FieldPackageID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OccurrenceSubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case occurrencesubject.FieldOccurrenceID:
		return m.OccurrenceID()
	case occurrencesubject.FieldSourceID:
		return m.SourceID()
	case occurrencesubject.FieldPackageID:
		return m.PackageID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OccurrenceSubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case occurrencesubject.FieldOccurrenceID:
		return m.OldOccurrenceID(ctx)
	case occurrencesubject.FieldSourceID:
		return m.OldSourceID(ctx)
	case occurrencesubject.FieldPackageID:
		return m.OldPackageID(ctx)
	}
	return nil, fmt.Errorf("unknown OccurrenceSubject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurrenceSubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case occurrencesubject.FieldOccurrenceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccurrenceID(v)
		return nil
	case occurrencesubject.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case occurrencesubject.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	}
	return fmt.Errorf("unknown OccurrenceSubject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OccurrenceSubjectMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OccurrenceSubjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccurrenceSubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OccurrenceSubject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OccurrenceSubjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(occurrencesubject.FieldSourceID) {
		fields = append(fields, occurrencesubject.FieldSourceID)
	}
	if m.FieldCleared(occurrencesubject.FieldPackageID) {
		fields = append(fields, occurrencesubject.FieldPackageID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OccurrenceSubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OccurrenceSubjectMutation) ClearField(name string) error {
	switch name {
	case occurrencesubject.FieldSourceID:
		m.ClearSourceID()
		return nil
	case occurrencesubject.FieldPackageID:
		m.ClearPackageID()
		return nil
	}
	return fmt.Errorf("unknown OccurrenceSubject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OccurrenceSubjectMutation) ResetField(name string) error {
	switch name {
	case occurrencesubject.FieldOccurrenceID:
		m.ResetOccurrenceID()
		return nil
	case occurrencesubject.FieldSourceID:
		m.ResetSourceID()
		return nil
	case occurrencesubject.FieldPackageID:
		m.ResetPackageID()
		return nil
	}
	return fmt.Errorf("unknown OccurrenceSubject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OccurrenceSubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.occurrence != nil {
		edges = append(edges, occurrencesubject.EdgeOccurrence)
	}
	if m._package != nil {
		edges = append(edges, occurrencesubject.EdgePackage)
	}
	if m.source != nil {
		edges = append(edges, occurrencesubject.EdgeSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OccurrenceSubjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case occurrencesubject.EdgeOccurrence:
		if id := m.occurrence; id != nil {
			return []ent.Value{*id}
		}
	case occurrencesubject.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case occurrencesubject.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OccurrenceSubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OccurrenceSubjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OccurrenceSubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedoccurrence {
		edges = append(edges, occurrencesubject.EdgeOccurrence)
	}
	if m.cleared_package {
		edges = append(edges, occurrencesubject.EdgePackage)
	}
	if m.clearedsource {
		edges = append(edges, occurrencesubject.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OccurrenceSubjectMutation) EdgeCleared(name string) bool {
	switch name {
	case occurrencesubject.EdgeOccurrence:
		return m.clearedoccurrence
	case occurrencesubject.EdgePackage:
		return m.cleared_package
	case occurrencesubject.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OccurrenceSubjectMutation) ClearEdge(name string) error {
	switch name {
	case occurrencesubject.EdgeOccurrence:
		m.ClearOccurrence()
		return nil
	case occurrencesubject.EdgePackage:
		m.ClearPackage()
		return nil
	case occurrencesubject.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown OccurrenceSubject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OccurrenceSubjectMutation) ResetEdge(name string) error {
	switch name {
	case occurrencesubject.EdgeOccurrence:
		m.ResetOccurrence()
		return nil
	case occurrencesubject.EdgePackage:
		m.ResetPackage()
		return nil
	case occurrencesubject.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown OccurrenceSubject edge %s", name)
}

// PackageNameMutation represents an operation that mutates the PackageName nodes in the graph.
type PackageNameMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	namespace        *int
	clearednamespace bool
	versions         map[int]struct{}
	removedversions  map[int]struct{}
	clearedversions  bool
	done             bool
	oldValue         func(context.Context) (*PackageName, error)
	predicates       []predicate.PackageName
}

var _ ent.Mutation = (*PackageNameMutation)(nil)

// packagenameOption allows management of the mutation configuration using functional options.
type packagenameOption func(*PackageNameMutation)

// newPackageNameMutation creates new mutation for the PackageName entity.
func newPackageNameMutation(c config, op Op, opts ...packagenameOption) *PackageNameMutation {
	m := &PackageNameMutation{
		config:        c,
		op:            op,
		typ:           TypePackageName,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageNameID sets the ID field of the mutation.
func withPackageNameID(id int) packagenameOption {
	return func(m *PackageNameMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageName
		)
		m.oldValue = func(ctx context.Context) (*PackageName, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageName.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageName sets the old PackageName of the mutation.
func withPackageName(node *PackageName) packagenameOption {
	return func(m *PackageNameMutation) {
		m.oldValue = func(context.Context) (*PackageName, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageNameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageNameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageNameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageNameMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageName.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespaceID sets the "namespace_id" field.
func (m *PackageNameMutation) SetNamespaceID(i int) {
	m.namespace = &i
}

// NamespaceID returns the value of the "namespace_id" field in the mutation.
func (m *PackageNameMutation) NamespaceID() (r int, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespaceID returns the old "namespace_id" field's value of the PackageName entity.
// If the PackageName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNameMutation) OldNamespaceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespaceID: %w", err)
	}
	return oldValue.NamespaceID, nil
}

// ResetNamespaceID resets all changes to the "namespace_id" field.
func (m *PackageNameMutation) ResetNamespaceID() {
	m.namespace = nil
}

// SetName sets the "name" field.
func (m *PackageNameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PackageNameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PackageName entity.
// If the PackageName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PackageNameMutation) ResetName() {
	m.name = nil
}

// ClearNamespace clears the "namespace" edge to the PackageNamespace entity.
func (m *PackageNameMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the PackageNamespace entity was cleared.
func (m *PackageNameMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *PackageNameMutation) NamespaceIDs() (ids []int) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *PackageNameMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// AddVersionIDs adds the "versions" edge to the PackageVersion entity by ids.
func (m *PackageNameMutation) AddVersionIDs(ids ...int) {
	if m.versions == nil {
		m.versions = make(map[int]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the PackageVersion entity.
func (m *PackageNameMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the PackageVersion entity was cleared.
func (m *PackageNameMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the PackageVersion entity by IDs.
func (m *PackageNameMutation) RemoveVersionIDs(ids ...int) {
	if m.removedversions == nil {
		m.removedversions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the PackageVersion entity.
func (m *PackageNameMutation) RemovedVersionsIDs() (ids []int) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *PackageNameMutation) VersionsIDs() (ids []int) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *PackageNameMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// Where appends a list predicates to the PackageNameMutation builder.
func (m *PackageNameMutation) Where(ps ...predicate.PackageName) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageNameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageNameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageName, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageNameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageNameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageName).
func (m *PackageNameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageNameMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.namespace != nil {
		fields = append(fields, packagename.FieldNamespaceID)
	}
	if m.name != nil {
		fields = append(fields, packagename.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageNameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagename.FieldNamespaceID:
		return m.NamespaceID()
	case packagename.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageNameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagename.FieldNamespaceID:
		return m.OldNamespaceID(ctx)
	case packagename.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown PackageName field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagename.FieldNamespaceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespaceID(v)
		return nil
	case packagename.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown PackageName field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageNameMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageNameMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageName numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageNameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageNameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageNameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackageName nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageNameMutation) ResetField(name string) error {
	switch name {
	case packagename.FieldNamespaceID:
		m.ResetNamespaceID()
		return nil
	case packagename.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PackageName field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageNameMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.namespace != nil {
		edges = append(edges, packagename.EdgeNamespace)
	}
	if m.versions != nil {
		edges = append(edges, packagename.EdgeVersions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageNameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagename.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case packagename.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageNameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedversions != nil {
		edges = append(edges, packagename.EdgeVersions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageNameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packagename.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageNameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednamespace {
		edges = append(edges, packagename.EdgeNamespace)
	}
	if m.clearedversions {
		edges = append(edges, packagename.EdgeVersions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageNameMutation) EdgeCleared(name string) bool {
	switch name {
	case packagename.EdgeNamespace:
		return m.clearednamespace
	case packagename.EdgeVersions:
		return m.clearedversions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageNameMutation) ClearEdge(name string) error {
	switch name {
	case packagename.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown PackageName unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageNameMutation) ResetEdge(name string) error {
	switch name {
	case packagename.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case packagename.EdgeVersions:
		m.ResetVersions()
		return nil
	}
	return fmt.Errorf("unknown PackageName edge %s", name)
}

// PackageNamespaceMutation represents an operation that mutates the PackageNamespace nodes in the graph.
type PackageNamespaceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	namespace       *string
	clearedFields   map[string]struct{}
	_package        *int
	cleared_package bool
	names           map[int]struct{}
	removednames    map[int]struct{}
	clearednames    bool
	done            bool
	oldValue        func(context.Context) (*PackageNamespace, error)
	predicates      []predicate.PackageNamespace
}

var _ ent.Mutation = (*PackageNamespaceMutation)(nil)

// packagenamespaceOption allows management of the mutation configuration using functional options.
type packagenamespaceOption func(*PackageNamespaceMutation)

// newPackageNamespaceMutation creates new mutation for the PackageNamespace entity.
func newPackageNamespaceMutation(c config, op Op, opts ...packagenamespaceOption) *PackageNamespaceMutation {
	m := &PackageNamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypePackageNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageNamespaceID sets the ID field of the mutation.
func withPackageNamespaceID(id int) packagenamespaceOption {
	return func(m *PackageNamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageNamespace
		)
		m.oldValue = func(ctx context.Context) (*PackageNamespace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageNamespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageNamespace sets the old PackageNamespace of the mutation.
func withPackageNamespace(node *PackageNamespace) packagenamespaceOption {
	return func(m *PackageNamespaceMutation) {
		m.oldValue = func(context.Context) (*PackageNamespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageNamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageNamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageNamespaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageNamespaceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageNamespace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *PackageNamespaceMutation) SetPackageID(i int) {
	m._package = &i
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *PackageNamespaceMutation) PackageID() (r int, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the PackageNamespace entity.
// If the PackageNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNamespaceMutation) OldPackageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *PackageNamespaceMutation) ResetPackageID() {
	m._package = nil
}

// SetNamespace sets the "namespace" field.
func (m *PackageNamespaceMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PackageNamespaceMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the PackageNamespace entity.
// If the PackageNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNamespaceMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PackageNamespaceMutation) ResetNamespace() {
	m.namespace = nil
}

// ClearPackage clears the "package" edge to the PackageNode entity.
func (m *PackageNamespaceMutation) ClearPackage() {
	m.cleared_package = true
}

// PackageCleared reports if the "package" edge to the PackageNode entity was cleared.
func (m *PackageNamespaceMutation) PackageCleared() bool {
	return m.cleared_package
}

// PackageIDs returns the "package" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackageID instead. It exists only for internal usage by the builders.
func (m *PackageNamespaceMutation) PackageIDs() (ids []int) {
	if id := m._package; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *PackageNamespaceMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
}

// AddNameIDs adds the "names" edge to the PackageName entity by ids.
func (m *PackageNamespaceMutation) AddNameIDs(ids ...int) {
	if m.names == nil {
		m.names = make(map[int]struct{})
	}
	for i := range ids {
		m.names[ids[i]] = struct{}{}
	}
}

// ClearNames clears the "names" edge to the PackageName entity.
func (m *PackageNamespaceMutation) ClearNames() {
	m.clearednames = true
}

// NamesCleared reports if the "names" edge to the PackageName entity was cleared.
func (m *PackageNamespaceMutation) NamesCleared() bool {
	return m.clearednames
}

// RemoveNameIDs removes the "names" edge to the PackageName entity by IDs.
func (m *PackageNamespaceMutation) RemoveNameIDs(ids ...int) {
	if m.removednames == nil {
		m.removednames = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.names, ids[i])
		m.removednames[ids[i]] = struct{}{}
	}
}

// RemovedNames returns the removed IDs of the "names" edge to the PackageName entity.
func (m *PackageNamespaceMutation) RemovedNamesIDs() (ids []int) {
	for id := range m.removednames {
		ids = append(ids, id)
	}
	return
}

// NamesIDs returns the "names" edge IDs in the mutation.
func (m *PackageNamespaceMutation) NamesIDs() (ids []int) {
	for id := range m.names {
		ids = append(ids, id)
	}
	return
}

// ResetNames resets all changes to the "names" edge.
func (m *PackageNamespaceMutation) ResetNames() {
	m.names = nil
	m.clearednames = false
	m.removednames = nil
}

// Where appends a list predicates to the PackageNamespaceMutation builder.
func (m *PackageNamespaceMutation) Where(ps ...predicate.PackageNamespace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageNamespaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageNamespaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageNamespace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageNamespaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageNamespaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageNamespace).
func (m *PackageNamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageNamespaceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._package != nil {
		fields = append(fields, packagenamespace.FieldPackageID)
	}
	if m.namespace != nil {
		fields = append(fields, packagenamespace.FieldNamespace)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageNamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagenamespace.FieldPackageID:
		return m.PackageID()
	case packagenamespace.FieldNamespace:
		return m.Namespace()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageNamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagenamespace.FieldPackageID:
		return m.OldPackageID(ctx)
	case packagenamespace.FieldNamespace:
		return m.OldNamespace(ctx)
	}
	return nil, fmt.Errorf("unknown PackageNamespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagenamespace.FieldPackageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case packagenamespace.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	}
	return fmt.Errorf("unknown PackageNamespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageNamespaceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageNamespaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageNamespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageNamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageNamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageNamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackageNamespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageNamespaceMutation) ResetField(name string) error {
	switch name {
	case packagenamespace.FieldPackageID:
		m.ResetPackageID()
		return nil
	case packagenamespace.FieldNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown PackageNamespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageNamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._package != nil {
		edges = append(edges, packagenamespace.EdgePackage)
	}
	if m.names != nil {
		edges = append(edges, packagenamespace.EdgeNames)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageNamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagenamespace.EdgePackage:
		if id := m._package; id != nil {
			return []ent.Value{*id}
		}
	case packagenamespace.EdgeNames:
		ids := make([]ent.Value, 0, len(m.names))
		for id := range m.names {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageNamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednames != nil {
		edges = append(edges, packagenamespace.EdgeNames)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageNamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packagenamespace.EdgeNames:
		ids := make([]ent.Value, 0, len(m.removednames))
		for id := range m.removednames {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageNamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_package {
		edges = append(edges, packagenamespace.EdgePackage)
	}
	if m.clearednames {
		edges = append(edges, packagenamespace.EdgeNames)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageNamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case packagenamespace.EdgePackage:
		return m.cleared_package
	case packagenamespace.EdgeNames:
		return m.clearednames
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageNamespaceMutation) ClearEdge(name string) error {
	switch name {
	case packagenamespace.EdgePackage:
		m.ClearPackage()
		return nil
	}
	return fmt.Errorf("unknown PackageNamespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageNamespaceMutation) ResetEdge(name string) error {
	switch name {
	case packagenamespace.EdgePackage:
		m.ResetPackage()
		return nil
	case packagenamespace.EdgeNames:
		m.ResetNames()
		return nil
	}
	return fmt.Errorf("unknown PackageNamespace edge %s", name)
}

// PackageNodeMutation represents an operation that mutates the PackageNode nodes in the graph.
type PackageNodeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_type             *string
	clearedFields     map[string]struct{}
	namespaces        map[int]struct{}
	removednamespaces map[int]struct{}
	clearednamespaces bool
	done              bool
	oldValue          func(context.Context) (*PackageNode, error)
	predicates        []predicate.PackageNode
}

var _ ent.Mutation = (*PackageNodeMutation)(nil)

// packagenodeOption allows management of the mutation configuration using functional options.
type packagenodeOption func(*PackageNodeMutation)

// newPackageNodeMutation creates new mutation for the PackageNode entity.
func newPackageNodeMutation(c config, op Op, opts ...packagenodeOption) *PackageNodeMutation {
	m := &PackageNodeMutation{
		config:        c,
		op:            op,
		typ:           TypePackageNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageNodeID sets the ID field of the mutation.
func withPackageNodeID(id int) packagenodeOption {
	return func(m *PackageNodeMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageNode
		)
		m.oldValue = func(ctx context.Context) (*PackageNode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageNode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageNode sets the old PackageNode of the mutation.
func withPackageNode(node *PackageNode) packagenodeOption {
	return func(m *PackageNodeMutation) {
		m.oldValue = func(context.Context) (*PackageNode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageNodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageNodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageNodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageNodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageNode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *PackageNodeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PackageNodeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PackageNode entity.
// If the PackageNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageNodeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PackageNodeMutation) ResetType() {
	m._type = nil
}

// AddNamespaceIDs adds the "namespaces" edge to the PackageNamespace entity by ids.
func (m *PackageNodeMutation) AddNamespaceIDs(ids ...int) {
	if m.namespaces == nil {
		m.namespaces = make(map[int]struct{})
	}
	for i := range ids {
		m.namespaces[ids[i]] = struct{}{}
	}
}

// ClearNamespaces clears the "namespaces" edge to the PackageNamespace entity.
func (m *PackageNodeMutation) ClearNamespaces() {
	m.clearednamespaces = true
}

// NamespacesCleared reports if the "namespaces" edge to the PackageNamespace entity was cleared.
func (m *PackageNodeMutation) NamespacesCleared() bool {
	return m.clearednamespaces
}

// RemoveNamespaceIDs removes the "namespaces" edge to the PackageNamespace entity by IDs.
func (m *PackageNodeMutation) RemoveNamespaceIDs(ids ...int) {
	if m.removednamespaces == nil {
		m.removednamespaces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.namespaces, ids[i])
		m.removednamespaces[ids[i]] = struct{}{}
	}
}

// RemovedNamespaces returns the removed IDs of the "namespaces" edge to the PackageNamespace entity.
func (m *PackageNodeMutation) RemovedNamespacesIDs() (ids []int) {
	for id := range m.removednamespaces {
		ids = append(ids, id)
	}
	return
}

// NamespacesIDs returns the "namespaces" edge IDs in the mutation.
func (m *PackageNodeMutation) NamespacesIDs() (ids []int) {
	for id := range m.namespaces {
		ids = append(ids, id)
	}
	return
}

// ResetNamespaces resets all changes to the "namespaces" edge.
func (m *PackageNodeMutation) ResetNamespaces() {
	m.namespaces = nil
	m.clearednamespaces = false
	m.removednamespaces = nil
}

// Where appends a list predicates to the PackageNodeMutation builder.
func (m *PackageNodeMutation) Where(ps ...predicate.PackageNode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageNodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageNodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageNode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageNodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageNodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageNode).
func (m *PackageNodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageNodeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._type != nil {
		fields = append(fields, packagenode.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageNodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagenode.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageNodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagenode.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown PackageNode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagenode.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown PackageNode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageNodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageNodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageNodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageNode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageNodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageNodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageNodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackageNode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageNodeMutation) ResetField(name string) error {
	switch name {
	case packagenode.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown PackageNode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageNodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespaces != nil {
		edges = append(edges, packagenode.EdgeNamespaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageNodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagenode.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.namespaces))
		for id := range m.namespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageNodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednamespaces != nil {
		edges = append(edges, packagenode.EdgeNamespaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageNodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packagenode.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.removednamespaces))
		for id := range m.removednamespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageNodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespaces {
		edges = append(edges, packagenode.EdgeNamespaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageNodeMutation) EdgeCleared(name string) bool {
	switch name {
	case packagenode.EdgeNamespaces:
		return m.clearednamespaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageNodeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageNode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageNodeMutation) ResetEdge(name string) error {
	switch name {
	case packagenode.EdgeNamespaces:
		m.ResetNamespaces()
		return nil
	}
	return fmt.Errorf("unknown PackageNode edge %s", name)
}

// PackageVersionMutation represents an operation that mutates the PackageVersion nodes in the graph.
type PackageVersionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	version          *string
	subpath          *string
	qualifiers       *[]model.PackageQualifier
	appendqualifiers []model.PackageQualifier
	hash             *string
	clearedFields    map[string]struct{}
	name             *int
	clearedname      bool
	done             bool
	oldValue         func(context.Context) (*PackageVersion, error)
	predicates       []predicate.PackageVersion
}

var _ ent.Mutation = (*PackageVersionMutation)(nil)

// packageversionOption allows management of the mutation configuration using functional options.
type packageversionOption func(*PackageVersionMutation)

// newPackageVersionMutation creates new mutation for the PackageVersion entity.
func newPackageVersionMutation(c config, op Op, opts ...packageversionOption) *PackageVersionMutation {
	m := &PackageVersionMutation{
		config:        c,
		op:            op,
		typ:           TypePackageVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackageVersionID sets the ID field of the mutation.
func withPackageVersionID(id int) packageversionOption {
	return func(m *PackageVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *PackageVersion
		)
		m.oldValue = func(ctx context.Context) (*PackageVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackageVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackageVersion sets the old PackageVersion of the mutation.
func withPackageVersion(node *PackageVersion) packageversionOption {
	return func(m *PackageVersionMutation) {
		m.oldValue = func(context.Context) (*PackageVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackageVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackageVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackageVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackageVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackageVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameID sets the "name_id" field.
func (m *PackageVersionMutation) SetNameID(i int) {
	m.name = &i
}

// NameID returns the value of the "name_id" field in the mutation.
func (m *PackageVersionMutation) NameID() (r int, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldNameID returns the old "name_id" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldNameID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameID: %w", err)
	}
	return oldValue.NameID, nil
}

// ResetNameID resets all changes to the "name_id" field.
func (m *PackageVersionMutation) ResetNameID() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *PackageVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PackageVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PackageVersionMutation) ResetVersion() {
	m.version = nil
}

// SetSubpath sets the "subpath" field.
func (m *PackageVersionMutation) SetSubpath(s string) {
	m.subpath = &s
}

// Subpath returns the value of the "subpath" field in the mutation.
func (m *PackageVersionMutation) Subpath() (r string, exists bool) {
	v := m.subpath
	if v == nil {
		return
	}
	return *v, true
}

// OldSubpath returns the old "subpath" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldSubpath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubpath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubpath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubpath: %w", err)
	}
	return oldValue.Subpath, nil
}

// ResetSubpath resets all changes to the "subpath" field.
func (m *PackageVersionMutation) ResetSubpath() {
	m.subpath = nil
}

// SetQualifiers sets the "qualifiers" field.
func (m *PackageVersionMutation) SetQualifiers(mq []model.PackageQualifier) {
	m.qualifiers = &mq
	m.appendqualifiers = nil
}

// Qualifiers returns the value of the "qualifiers" field in the mutation.
func (m *PackageVersionMutation) Qualifiers() (r []model.PackageQualifier, exists bool) {
	v := m.qualifiers
	if v == nil {
		return
	}
	return *v, true
}

// OldQualifiers returns the old "qualifiers" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldQualifiers(ctx context.Context) (v []model.PackageQualifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualifiers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualifiers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualifiers: %w", err)
	}
	return oldValue.Qualifiers, nil
}

// AppendQualifiers adds mq to the "qualifiers" field.
func (m *PackageVersionMutation) AppendQualifiers(mq []model.PackageQualifier) {
	m.appendqualifiers = append(m.appendqualifiers, mq...)
}

// AppendedQualifiers returns the list of values that were appended to the "qualifiers" field in this mutation.
func (m *PackageVersionMutation) AppendedQualifiers() ([]model.PackageQualifier, bool) {
	if len(m.appendqualifiers) == 0 {
		return nil, false
	}
	return m.appendqualifiers, true
}

// ClearQualifiers clears the value of the "qualifiers" field.
func (m *PackageVersionMutation) ClearQualifiers() {
	m.qualifiers = nil
	m.appendqualifiers = nil
	m.clearedFields[packageversion.FieldQualifiers] = struct{}{}
}

// QualifiersCleared returns if the "qualifiers" field was cleared in this mutation.
func (m *PackageVersionMutation) QualifiersCleared() bool {
	_, ok := m.clearedFields[packageversion.FieldQualifiers]
	return ok
}

// ResetQualifiers resets all changes to the "qualifiers" field.
func (m *PackageVersionMutation) ResetQualifiers() {
	m.qualifiers = nil
	m.appendqualifiers = nil
	delete(m.clearedFields, packageversion.FieldQualifiers)
}

// SetHash sets the "hash" field.
func (m *PackageVersionMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *PackageVersionMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the PackageVersion entity.
// If the PackageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackageVersionMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *PackageVersionMutation) ResetHash() {
	m.hash = nil
}

// ClearName clears the "name" edge to the PackageName entity.
func (m *PackageVersionMutation) ClearName() {
	m.clearedname = true
}

// NameCleared reports if the "name" edge to the PackageName entity was cleared.
func (m *PackageVersionMutation) NameCleared() bool {
	return m.clearedname
}

// NameIDs returns the "name" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NameID instead. It exists only for internal usage by the builders.
func (m *PackageVersionMutation) NameIDs() (ids []int) {
	if id := m.name; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetName resets all changes to the "name" edge.
func (m *PackageVersionMutation) ResetName() {
	m.name = nil
	m.clearedname = false
}

// Where appends a list predicates to the PackageVersionMutation builder.
func (m *PackageVersionMutation) Where(ps ...predicate.PackageVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackageVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackageVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackageVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackageVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackageVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackageVersion).
func (m *PackageVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackageVersionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, packageversion.FieldNameID)
	}
	if m.version != nil {
		fields = append(fields, packageversion.FieldVersion)
	}
	if m.subpath != nil {
		fields = append(fields, packageversion.FieldSubpath)
	}
	if m.qualifiers != nil {
		fields = append(fields, packageversion.FieldQualifiers)
	}
	if m.hash != nil {
		fields = append(fields, packageversion.FieldHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackageVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packageversion.FieldNameID:
		return m.NameID()
	case packageversion.FieldVersion:
		return m.Version()
	case packageversion.FieldSubpath:
		return m.Subpath()
	case packageversion.FieldQualifiers:
		return m.Qualifiers()
	case packageversion.FieldHash:
		return m.Hash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackageVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packageversion.FieldNameID:
		return m.OldNameID(ctx)
	case packageversion.FieldVersion:
		return m.OldVersion(ctx)
	case packageversion.FieldSubpath:
		return m.OldSubpath(ctx)
	case packageversion.FieldQualifiers:
		return m.OldQualifiers(ctx)
	case packageversion.FieldHash:
		return m.OldHash(ctx)
	}
	return nil, fmt.Errorf("unknown PackageVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packageversion.FieldNameID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameID(v)
		return nil
	case packageversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case packageversion.FieldSubpath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubpath(v)
		return nil
	case packageversion.FieldQualifiers:
		v, ok := value.([]model.PackageQualifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualifiers(v)
		return nil
	case packageversion.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	}
	return fmt.Errorf("unknown PackageVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackageVersionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackageVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackageVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackageVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackageVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(packageversion.FieldQualifiers) {
		fields = append(fields, packageversion.FieldQualifiers)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackageVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackageVersionMutation) ClearField(name string) error {
	switch name {
	case packageversion.FieldQualifiers:
		m.ClearQualifiers()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackageVersionMutation) ResetField(name string) error {
	switch name {
	case packageversion.FieldNameID:
		m.ResetNameID()
		return nil
	case packageversion.FieldVersion:
		m.ResetVersion()
		return nil
	case packageversion.FieldSubpath:
		m.ResetSubpath()
		return nil
	case packageversion.FieldQualifiers:
		m.ResetQualifiers()
		return nil
	case packageversion.FieldHash:
		m.ResetHash()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackageVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.name != nil {
		edges = append(edges, packageversion.EdgeName)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackageVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packageversion.EdgeName:
		if id := m.name; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackageVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackageVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackageVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedname {
		edges = append(edges, packageversion.EdgeName)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackageVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case packageversion.EdgeName:
		return m.clearedname
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackageVersionMutation) ClearEdge(name string) error {
	switch name {
	case packageversion.EdgeName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackageVersionMutation) ResetEdge(name string) error {
	switch name {
	case packageversion.EdgeName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PackageVersion edge %s", name)
}

// SourceMutation represents an operation that mutates the Source nodes in the graph.
type SourceMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_type             *string
	namespace         *string
	name              *string
	tag               *string
	commit            *string
	clearedFields     map[string]struct{}
	namespaces        map[int]struct{}
	removednamespaces map[int]struct{}
	clearednamespaces bool
	done              bool
	oldValue          func(context.Context) (*Source, error)
	predicates        []predicate.Source
}

var _ ent.Mutation = (*SourceMutation)(nil)

// sourceOption allows management of the mutation configuration using functional options.
type sourceOption func(*SourceMutation)

// newSourceMutation creates new mutation for the Source entity.
func newSourceMutation(c config, op Op, opts ...sourceOption) *SourceMutation {
	m := &SourceMutation{
		config:        c,
		op:            op,
		typ:           TypeSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceID sets the ID field of the mutation.
func withSourceID(id int) sourceOption {
	return func(m *SourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Source
		)
		m.oldValue = func(ctx context.Context) (*Source, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Source.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSource sets the old Source of the mutation.
func withSource(node *Source) sourceOption {
	return func(m *SourceMutation) {
		m.oldValue = func(context.Context) (*Source, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Source.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *SourceMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SourceMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SourceMutation) ResetType() {
	m._type = nil
}

// SetNamespace sets the "namespace" field.
func (m *SourceMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SourceMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ClearNamespace clears the value of the "namespace" field.
func (m *SourceMutation) ClearNamespace() {
	m.namespace = nil
	m.clearedFields[source.FieldNamespace] = struct{}{}
}

// NamespaceCleared returns if the "namespace" field was cleared in this mutation.
func (m *SourceMutation) NamespaceCleared() bool {
	_, ok := m.clearedFields[source.FieldNamespace]
	return ok
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SourceMutation) ResetNamespace() {
	m.namespace = nil
	delete(m.clearedFields, source.FieldNamespace)
}

// SetName sets the "name" field.
func (m *SourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *SourceMutation) ClearName() {
	m.name = nil
	m.clearedFields[source.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *SourceMutation) NameCleared() bool {
	_, ok := m.clearedFields[source.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *SourceMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, source.FieldName)
}

// SetTag sets the "tag" field.
func (m *SourceMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *SourceMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ClearTag clears the value of the "tag" field.
func (m *SourceMutation) ClearTag() {
	m.tag = nil
	m.clearedFields[source.FieldTag] = struct{}{}
}

// TagCleared returns if the "tag" field was cleared in this mutation.
func (m *SourceMutation) TagCleared() bool {
	_, ok := m.clearedFields[source.FieldTag]
	return ok
}

// ResetTag resets all changes to the "tag" field.
func (m *SourceMutation) ResetTag() {
	m.tag = nil
	delete(m.clearedFields, source.FieldTag)
}

// SetCommit sets the "commit" field.
func (m *SourceMutation) SetCommit(s string) {
	m.commit = &s
}

// Commit returns the value of the "commit" field in the mutation.
func (m *SourceMutation) Commit() (r string, exists bool) {
	v := m.commit
	if v == nil {
		return
	}
	return *v, true
}

// OldCommit returns the old "commit" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldCommit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommit: %w", err)
	}
	return oldValue.Commit, nil
}

// ClearCommit clears the value of the "commit" field.
func (m *SourceMutation) ClearCommit() {
	m.commit = nil
	m.clearedFields[source.FieldCommit] = struct{}{}
}

// CommitCleared returns if the "commit" field was cleared in this mutation.
func (m *SourceMutation) CommitCleared() bool {
	_, ok := m.clearedFields[source.FieldCommit]
	return ok
}

// ResetCommit resets all changes to the "commit" field.
func (m *SourceMutation) ResetCommit() {
	m.commit = nil
	delete(m.clearedFields, source.FieldCommit)
}

// AddNamespaceIDs adds the "namespaces" edge to the SourceNamespace entity by ids.
func (m *SourceMutation) AddNamespaceIDs(ids ...int) {
	if m.namespaces == nil {
		m.namespaces = make(map[int]struct{})
	}
	for i := range ids {
		m.namespaces[ids[i]] = struct{}{}
	}
}

// ClearNamespaces clears the "namespaces" edge to the SourceNamespace entity.
func (m *SourceMutation) ClearNamespaces() {
	m.clearednamespaces = true
}

// NamespacesCleared reports if the "namespaces" edge to the SourceNamespace entity was cleared.
func (m *SourceMutation) NamespacesCleared() bool {
	return m.clearednamespaces
}

// RemoveNamespaceIDs removes the "namespaces" edge to the SourceNamespace entity by IDs.
func (m *SourceMutation) RemoveNamespaceIDs(ids ...int) {
	if m.removednamespaces == nil {
		m.removednamespaces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.namespaces, ids[i])
		m.removednamespaces[ids[i]] = struct{}{}
	}
}

// RemovedNamespaces returns the removed IDs of the "namespaces" edge to the SourceNamespace entity.
func (m *SourceMutation) RemovedNamespacesIDs() (ids []int) {
	for id := range m.removednamespaces {
		ids = append(ids, id)
	}
	return
}

// NamespacesIDs returns the "namespaces" edge IDs in the mutation.
func (m *SourceMutation) NamespacesIDs() (ids []int) {
	for id := range m.namespaces {
		ids = append(ids, id)
	}
	return
}

// ResetNamespaces resets all changes to the "namespaces" edge.
func (m *SourceMutation) ResetNamespaces() {
	m.namespaces = nil
	m.clearednamespaces = false
	m.removednamespaces = nil
}

// Where appends a list predicates to the SourceMutation builder.
func (m *SourceMutation) Where(ps ...predicate.Source) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Source, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Source).
func (m *SourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._type != nil {
		fields = append(fields, source.FieldType)
	}
	if m.namespace != nil {
		fields = append(fields, source.FieldNamespace)
	}
	if m.name != nil {
		fields = append(fields, source.FieldName)
	}
	if m.tag != nil {
		fields = append(fields, source.FieldTag)
	}
	if m.commit != nil {
		fields = append(fields, source.FieldCommit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case source.FieldType:
		return m.GetType()
	case source.FieldNamespace:
		return m.Namespace()
	case source.FieldName:
		return m.Name()
	case source.FieldTag:
		return m.Tag()
	case source.FieldCommit:
		return m.Commit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case source.FieldType:
		return m.OldType(ctx)
	case source.FieldNamespace:
		return m.OldNamespace(ctx)
	case source.FieldName:
		return m.OldName(ctx)
	case source.FieldTag:
		return m.OldTag(ctx)
	case source.FieldCommit:
		return m.OldCommit(ctx)
	}
	return nil, fmt.Errorf("unknown Source field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case source.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case source.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case source.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case source.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case source.FieldCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommit(v)
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Source numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(source.FieldNamespace) {
		fields = append(fields, source.FieldNamespace)
	}
	if m.FieldCleared(source.FieldName) {
		fields = append(fields, source.FieldName)
	}
	if m.FieldCleared(source.FieldTag) {
		fields = append(fields, source.FieldTag)
	}
	if m.FieldCleared(source.FieldCommit) {
		fields = append(fields, source.FieldCommit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceMutation) ClearField(name string) error {
	switch name {
	case source.FieldNamespace:
		m.ClearNamespace()
		return nil
	case source.FieldName:
		m.ClearName()
		return nil
	case source.FieldTag:
		m.ClearTag()
		return nil
	case source.FieldCommit:
		m.ClearCommit()
		return nil
	}
	return fmt.Errorf("unknown Source nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceMutation) ResetField(name string) error {
	switch name {
	case source.FieldType:
		m.ResetType()
		return nil
	case source.FieldNamespace:
		m.ResetNamespace()
		return nil
	case source.FieldName:
		m.ResetName()
		return nil
	case source.FieldTag:
		m.ResetTag()
		return nil
	case source.FieldCommit:
		m.ResetCommit()
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespaces != nil {
		edges = append(edges, source.EdgeNamespaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case source.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.namespaces))
		for id := range m.namespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednamespaces != nil {
		edges = append(edges, source.EdgeNamespaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case source.EdgeNamespaces:
		ids := make([]ent.Value, 0, len(m.removednamespaces))
		for id := range m.removednamespaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespaces {
		edges = append(edges, source.EdgeNamespaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceMutation) EdgeCleared(name string) bool {
	switch name {
	case source.EdgeNamespaces:
		return m.clearednamespaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Source unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceMutation) ResetEdge(name string) error {
	switch name {
	case source.EdgeNamespaces:
		m.ResetNamespaces()
		return nil
	}
	return fmt.Errorf("unknown Source edge %s", name)
}

// SourceNameMutation represents an operation that mutates the SourceName nodes in the graph.
type SourceNameMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	commit             *string
	tag                *string
	clearedFields      map[string]struct{}
	namespace          *int
	clearednamespace   bool
	occurrences        map[int]struct{}
	removedoccurrences map[int]struct{}
	clearedoccurrences bool
	done               bool
	oldValue           func(context.Context) (*SourceName, error)
	predicates         []predicate.SourceName
}

var _ ent.Mutation = (*SourceNameMutation)(nil)

// sourcenameOption allows management of the mutation configuration using functional options.
type sourcenameOption func(*SourceNameMutation)

// newSourceNameMutation creates new mutation for the SourceName entity.
func newSourceNameMutation(c config, op Op, opts ...sourcenameOption) *SourceNameMutation {
	m := &SourceNameMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceName,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceNameID sets the ID field of the mutation.
func withSourceNameID(id int) sourcenameOption {
	return func(m *SourceNameMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceName
		)
		m.oldValue = func(ctx context.Context) (*SourceName, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceName.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceName sets the old SourceName of the mutation.
func withSourceName(node *SourceName) sourcenameOption {
	return func(m *SourceNameMutation) {
		m.oldValue = func(context.Context) (*SourceName, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceNameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceNameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceNameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceNameMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceName.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SourceNameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SourceNameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SourceNameMutation) ResetName() {
	m.name = nil
}

// SetCommit sets the "commit" field.
func (m *SourceNameMutation) SetCommit(s string) {
	m.commit = &s
}

// Commit returns the value of the "commit" field in the mutation.
func (m *SourceNameMutation) Commit() (r string, exists bool) {
	v := m.commit
	if v == nil {
		return
	}
	return *v, true
}

// OldCommit returns the old "commit" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldCommit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommit: %w", err)
	}
	return oldValue.Commit, nil
}

// ClearCommit clears the value of the "commit" field.
func (m *SourceNameMutation) ClearCommit() {
	m.commit = nil
	m.clearedFields[sourcename.FieldCommit] = struct{}{}
}

// CommitCleared returns if the "commit" field was cleared in this mutation.
func (m *SourceNameMutation) CommitCleared() bool {
	_, ok := m.clearedFields[sourcename.FieldCommit]
	return ok
}

// ResetCommit resets all changes to the "commit" field.
func (m *SourceNameMutation) ResetCommit() {
	m.commit = nil
	delete(m.clearedFields, sourcename.FieldCommit)
}

// SetTag sets the "tag" field.
func (m *SourceNameMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *SourceNameMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ClearTag clears the value of the "tag" field.
func (m *SourceNameMutation) ClearTag() {
	m.tag = nil
	m.clearedFields[sourcename.FieldTag] = struct{}{}
}

// TagCleared returns if the "tag" field was cleared in this mutation.
func (m *SourceNameMutation) TagCleared() bool {
	_, ok := m.clearedFields[sourcename.FieldTag]
	return ok
}

// ResetTag resets all changes to the "tag" field.
func (m *SourceNameMutation) ResetTag() {
	m.tag = nil
	delete(m.clearedFields, sourcename.FieldTag)
}

// SetNamespaceID sets the "namespace_id" field.
func (m *SourceNameMutation) SetNamespaceID(i int) {
	m.namespace = &i
}

// NamespaceID returns the value of the "namespace_id" field in the mutation.
func (m *SourceNameMutation) NamespaceID() (r int, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespaceID returns the old "namespace_id" field's value of the SourceName entity.
// If the SourceName object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNameMutation) OldNamespaceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespaceID: %w", err)
	}
	return oldValue.NamespaceID, nil
}

// ResetNamespaceID resets all changes to the "namespace_id" field.
func (m *SourceNameMutation) ResetNamespaceID() {
	m.namespace = nil
}

// ClearNamespace clears the "namespace" edge to the SourceNamespace entity.
func (m *SourceNameMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the SourceNamespace entity was cleared.
func (m *SourceNameMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *SourceNameMutation) NamespaceIDs() (ids []int) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *SourceNameMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// AddOccurrenceIDs adds the "occurrences" edge to the OccurrenceSubject entity by ids.
func (m *SourceNameMutation) AddOccurrenceIDs(ids ...int) {
	if m.occurrences == nil {
		m.occurrences = make(map[int]struct{})
	}
	for i := range ids {
		m.occurrences[ids[i]] = struct{}{}
	}
}

// ClearOccurrences clears the "occurrences" edge to the OccurrenceSubject entity.
func (m *SourceNameMutation) ClearOccurrences() {
	m.clearedoccurrences = true
}

// OccurrencesCleared reports if the "occurrences" edge to the OccurrenceSubject entity was cleared.
func (m *SourceNameMutation) OccurrencesCleared() bool {
	return m.clearedoccurrences
}

// RemoveOccurrenceIDs removes the "occurrences" edge to the OccurrenceSubject entity by IDs.
func (m *SourceNameMutation) RemoveOccurrenceIDs(ids ...int) {
	if m.removedoccurrences == nil {
		m.removedoccurrences = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occurrences, ids[i])
		m.removedoccurrences[ids[i]] = struct{}{}
	}
}

// RemovedOccurrences returns the removed IDs of the "occurrences" edge to the OccurrenceSubject entity.
func (m *SourceNameMutation) RemovedOccurrencesIDs() (ids []int) {
	for id := range m.removedoccurrences {
		ids = append(ids, id)
	}
	return
}

// OccurrencesIDs returns the "occurrences" edge IDs in the mutation.
func (m *SourceNameMutation) OccurrencesIDs() (ids []int) {
	for id := range m.occurrences {
		ids = append(ids, id)
	}
	return
}

// ResetOccurrences resets all changes to the "occurrences" edge.
func (m *SourceNameMutation) ResetOccurrences() {
	m.occurrences = nil
	m.clearedoccurrences = false
	m.removedoccurrences = nil
}

// Where appends a list predicates to the SourceNameMutation builder.
func (m *SourceNameMutation) Where(ps ...predicate.SourceName) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceNameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceNameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceName, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceNameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceNameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceName).
func (m *SourceNameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceNameMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, sourcename.FieldName)
	}
	if m.commit != nil {
		fields = append(fields, sourcename.FieldCommit)
	}
	if m.tag != nil {
		fields = append(fields, sourcename.FieldTag)
	}
	if m.namespace != nil {
		fields = append(fields, sourcename.FieldNamespaceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceNameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcename.FieldName:
		return m.Name()
	case sourcename.FieldCommit:
		return m.Commit()
	case sourcename.FieldTag:
		return m.Tag()
	case sourcename.FieldNamespaceID:
		return m.NamespaceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceNameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcename.FieldName:
		return m.OldName(ctx)
	case sourcename.FieldCommit:
		return m.OldCommit(ctx)
	case sourcename.FieldTag:
		return m.OldTag(ctx)
	case sourcename.FieldNamespaceID:
		return m.OldNamespaceID(ctx)
	}
	return nil, fmt.Errorf("unknown SourceName field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcename.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sourcename.FieldCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommit(v)
		return nil
	case sourcename.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case sourcename.FieldNamespaceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespaceID(v)
		return nil
	}
	return fmt.Errorf("unknown SourceName field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceNameMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceNameMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceName numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceNameMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sourcename.FieldCommit) {
		fields = append(fields, sourcename.FieldCommit)
	}
	if m.FieldCleared(sourcename.FieldTag) {
		fields = append(fields, sourcename.FieldTag)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceNameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceNameMutation) ClearField(name string) error {
	switch name {
	case sourcename.FieldCommit:
		m.ClearCommit()
		return nil
	case sourcename.FieldTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown SourceName nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceNameMutation) ResetField(name string) error {
	switch name {
	case sourcename.FieldName:
		m.ResetName()
		return nil
	case sourcename.FieldCommit:
		m.ResetCommit()
		return nil
	case sourcename.FieldTag:
		m.ResetTag()
		return nil
	case sourcename.FieldNamespaceID:
		m.ResetNamespaceID()
		return nil
	}
	return fmt.Errorf("unknown SourceName field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceNameMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.namespace != nil {
		edges = append(edges, sourcename.EdgeNamespace)
	}
	if m.occurrences != nil {
		edges = append(edges, sourcename.EdgeOccurrences)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceNameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourcename.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case sourcename.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.occurrences))
		for id := range m.occurrences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceNameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoccurrences != nil {
		edges = append(edges, sourcename.EdgeOccurrences)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceNameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sourcename.EdgeOccurrences:
		ids := make([]ent.Value, 0, len(m.removedoccurrences))
		for id := range m.removedoccurrences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceNameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednamespace {
		edges = append(edges, sourcename.EdgeNamespace)
	}
	if m.clearedoccurrences {
		edges = append(edges, sourcename.EdgeOccurrences)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceNameMutation) EdgeCleared(name string) bool {
	switch name {
	case sourcename.EdgeNamespace:
		return m.clearednamespace
	case sourcename.EdgeOccurrences:
		return m.clearedoccurrences
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceNameMutation) ClearEdge(name string) error {
	switch name {
	case sourcename.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown SourceName unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceNameMutation) ResetEdge(name string) error {
	switch name {
	case sourcename.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case sourcename.EdgeOccurrences:
		m.ResetOccurrences()
		return nil
	}
	return fmt.Errorf("unknown SourceName edge %s", name)
}

// SourceNamespaceMutation represents an operation that mutates the SourceNamespace nodes in the graph.
type SourceNamespaceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	namespace     *string
	clearedFields map[string]struct{}
	source        *int
	clearedsource bool
	names         map[int]struct{}
	removednames  map[int]struct{}
	clearednames  bool
	done          bool
	oldValue      func(context.Context) (*SourceNamespace, error)
	predicates    []predicate.SourceNamespace
}

var _ ent.Mutation = (*SourceNamespaceMutation)(nil)

// sourcenamespaceOption allows management of the mutation configuration using functional options.
type sourcenamespaceOption func(*SourceNamespaceMutation)

// newSourceNamespaceMutation creates new mutation for the SourceNamespace entity.
func newSourceNamespaceMutation(c config, op Op, opts ...sourcenamespaceOption) *SourceNamespaceMutation {
	m := &SourceNamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceNamespaceID sets the ID field of the mutation.
func withSourceNamespaceID(id int) sourcenamespaceOption {
	return func(m *SourceNamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceNamespace
		)
		m.oldValue = func(ctx context.Context) (*SourceNamespace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceNamespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceNamespace sets the old SourceNamespace of the mutation.
func withSourceNamespace(node *SourceNamespace) sourcenamespaceOption {
	return func(m *SourceNamespaceMutation) {
		m.oldValue = func(context.Context) (*SourceNamespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceNamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceNamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceNamespaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceNamespaceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceNamespace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *SourceNamespaceMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *SourceNamespaceMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the SourceNamespace entity.
// If the SourceNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNamespaceMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *SourceNamespaceMutation) ResetNamespace() {
	m.namespace = nil
}

// SetSourceID sets the "source_id" field.
func (m *SourceNamespaceMutation) SetSourceID(i int) {
	m.source = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *SourceNamespaceMutation) SourceID() (r int, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the SourceNamespace entity.
// If the SourceNamespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceNamespaceMutation) OldSourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *SourceNamespaceMutation) ResetSourceID() {
	m.source = nil
}

// ClearSource clears the "source" edge to the Source entity.
func (m *SourceNamespaceMutation) ClearSource() {
	m.clearedsource = true
}

// SourceCleared reports if the "source" edge to the Source entity was cleared.
func (m *SourceNamespaceMutation) SourceCleared() bool {
	return m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *SourceNamespaceMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *SourceNamespaceMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// AddNameIDs adds the "names" edge to the SourceName entity by ids.
func (m *SourceNamespaceMutation) AddNameIDs(ids ...int) {
	if m.names == nil {
		m.names = make(map[int]struct{})
	}
	for i := range ids {
		m.names[ids[i]] = struct{}{}
	}
}

// ClearNames clears the "names" edge to the SourceName entity.
func (m *SourceNamespaceMutation) ClearNames() {
	m.clearednames = true
}

// NamesCleared reports if the "names" edge to the SourceName entity was cleared.
func (m *SourceNamespaceMutation) NamesCleared() bool {
	return m.clearednames
}

// RemoveNameIDs removes the "names" edge to the SourceName entity by IDs.
func (m *SourceNamespaceMutation) RemoveNameIDs(ids ...int) {
	if m.removednames == nil {
		m.removednames = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.names, ids[i])
		m.removednames[ids[i]] = struct{}{}
	}
}

// RemovedNames returns the removed IDs of the "names" edge to the SourceName entity.
func (m *SourceNamespaceMutation) RemovedNamesIDs() (ids []int) {
	for id := range m.removednames {
		ids = append(ids, id)
	}
	return
}

// NamesIDs returns the "names" edge IDs in the mutation.
func (m *SourceNamespaceMutation) NamesIDs() (ids []int) {
	for id := range m.names {
		ids = append(ids, id)
	}
	return
}

// ResetNames resets all changes to the "names" edge.
func (m *SourceNamespaceMutation) ResetNames() {
	m.names = nil
	m.clearednames = false
	m.removednames = nil
}

// Where appends a list predicates to the SourceNamespaceMutation builder.
func (m *SourceNamespaceMutation) Where(ps ...predicate.SourceNamespace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceNamespaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceNamespaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceNamespace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceNamespaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceNamespaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceNamespace).
func (m *SourceNamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceNamespaceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.namespace != nil {
		fields = append(fields, sourcenamespace.FieldNamespace)
	}
	if m.source != nil {
		fields = append(fields, sourcenamespace.FieldSourceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceNamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcenamespace.FieldNamespace:
		return m.Namespace()
	case sourcenamespace.FieldSourceID:
		return m.SourceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceNamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcenamespace.FieldNamespace:
		return m.OldNamespace(ctx)
	case sourcenamespace.FieldSourceID:
		return m.OldSourceID(ctx)
	}
	return nil, fmt.Errorf("unknown SourceNamespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcenamespace.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case sourcenamespace.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	}
	return fmt.Errorf("unknown SourceNamespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceNamespaceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceNamespaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceNamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceNamespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceNamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceNamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceNamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SourceNamespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceNamespaceMutation) ResetField(name string) error {
	switch name {
	case sourcenamespace.FieldNamespace:
		m.ResetNamespace()
		return nil
	case sourcenamespace.FieldSourceID:
		m.ResetSourceID()
		return nil
	}
	return fmt.Errorf("unknown SourceNamespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceNamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.source != nil {
		edges = append(edges, sourcenamespace.EdgeSource)
	}
	if m.names != nil {
		edges = append(edges, sourcenamespace.EdgeNames)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceNamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourcenamespace.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	case sourcenamespace.EdgeNames:
		ids := make([]ent.Value, 0, len(m.names))
		for id := range m.names {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceNamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednames != nil {
		edges = append(edges, sourcenamespace.EdgeNames)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceNamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sourcenamespace.EdgeNames:
		ids := make([]ent.Value, 0, len(m.removednames))
		for id := range m.removednames {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceNamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsource {
		edges = append(edges, sourcenamespace.EdgeSource)
	}
	if m.clearednames {
		edges = append(edges, sourcenamespace.EdgeNames)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceNamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case sourcenamespace.EdgeSource:
		return m.clearedsource
	case sourcenamespace.EdgeNames:
		return m.clearednames
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceNamespaceMutation) ClearEdge(name string) error {
	switch name {
	case sourcenamespace.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown SourceNamespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceNamespaceMutation) ResetEdge(name string) error {
	switch name {
	case sourcenamespace.EdgeSource:
		m.ResetSource()
		return nil
	case sourcenamespace.EdgeNames:
		m.ResetNames()
		return nil
	}
	return fmt.Errorf("unknown SourceNamespace edge %s", name)
}
