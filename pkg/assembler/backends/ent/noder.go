// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/guacsec/guac/pkg/assembler/backends/ent/artifact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/billofmaterials"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/builder"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certification"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvuln"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/dependency"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hashequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hassourceat"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/isvulnerability"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/occurrence"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagetype"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pkgequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/securityadvisory"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/slsaattestation"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcetype"
)

func (*Artifact) IsNode() {}

func (*BillOfMaterials) IsNode() {}

func (*Builder) IsNode() {}

func (*Certification) IsNode() {}

func (*CertifyVuln) IsNode() {}

func (*Dependency) IsNode() {}

func (*HasSourceAt) IsNode() {}

func (*HashEqual) IsNode() {}

func (*IsVulnerability) IsNode() {}

func (*Occurrence) IsNode() {}

func (*PackageName) IsNode() {}

func (*PackageNamespace) IsNode() {}

func (*PackageType) IsNode() {}

func (*PackageVersion) IsNode() {}

func (*PkgEqual) IsNode() {}

func (*SLSAAttestation) IsNode() {}

func (*SecurityAdvisory) IsNode() {}

func (*SourceName) IsNode() {}

func (*SourceNamespace) IsNode() {}

func (*SourceType) IsNode() {}

func (c *Client) noder(ctx context.Context, table string, id int) (Noder, error) {
	switch table {
	case artifact.Table:
		query := c.Artifact.Query().
			Where(artifact.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case billofmaterials.Table:
		query := c.BillOfMaterials.Query().
			Where(billofmaterials.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case builder.Table:
		query := c.Builder.Query().
			Where(builder.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case certification.Table:
		query := c.Certification.Query().
			Where(certification.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case certifyvuln.Table:
		query := c.CertifyVuln.Query().
			Where(certifyvuln.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case dependency.Table:
		query := c.Dependency.Query().
			Where(dependency.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case hassourceat.Table:
		query := c.HasSourceAt.Query().
			Where(hassourceat.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case hashequal.Table:
		query := c.HashEqual.Query().
			Where(hashequal.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case isvulnerability.Table:
		query := c.IsVulnerability.Query().
			Where(isvulnerability.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case occurrence.Table:
		query := c.Occurrence.Query().
			Where(occurrence.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case packagename.Table:
		query := c.PackageName.Query().
			Where(packagename.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case packagenamespace.Table:
		query := c.PackageNamespace.Query().
			Where(packagenamespace.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case packagetype.Table:
		query := c.PackageType.Query().
			Where(packagetype.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case packageversion.Table:
		query := c.PackageVersion.Query().
			Where(packageversion.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case pkgequal.Table:
		query := c.PkgEqual.Query().
			Where(pkgequal.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case slsaattestation.Table:
		query := c.SLSAAttestation.Query().
			Where(slsaattestation.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case securityadvisory.Table:
		query := c.SecurityAdvisory.Query().
			Where(securityadvisory.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case sourcename.Table:
		query := c.SourceName.Query().
			Where(sourcename.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case sourcenamespace.Table:
		query := c.SourceNamespace.Query().
			Where(sourcenamespace.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case sourcetype.Table:
		query := c.SourceType.Query().
			Where(sourcetype.ID(id))
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	default:
		return nil, fmt.Errorf("cannot resolve noder from table %q: %w", table, errNodeInvalidID)
	}
}
