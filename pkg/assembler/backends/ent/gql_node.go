// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/artifact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/billofmaterials"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/builder"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certification"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifylegal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyscorecard"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvex"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvuln"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/dependency"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hashequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hasmetadata"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hassourceat"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/isdeployed"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/license"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/occurrence"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pkgequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pointofcontact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/slsaattestation"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilityid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilitymetadata"
	"github.com/hashicorp/go-multierror"
)

// Noder wraps the basic Node method.
type Noder interface {
	IsNode()
}

var artifactImplementors = []string{"Artifact", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Artifact) IsNode() {}

var billofmaterialsImplementors = []string{"BillOfMaterials", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*BillOfMaterials) IsNode() {}

var builderImplementors = []string{"Builder", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Builder) IsNode() {}

var certificationImplementors = []string{"Certification", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Certification) IsNode() {}

var certifylegalImplementors = []string{"CertifyLegal", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*CertifyLegal) IsNode() {}

var certifyscorecardImplementors = []string{"CertifyScorecard", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*CertifyScorecard) IsNode() {}

var certifyvexImplementors = []string{"CertifyVex", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*CertifyVex) IsNode() {}

var certifyvulnImplementors = []string{"CertifyVuln", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*CertifyVuln) IsNode() {}

var dependencyImplementors = []string{"Dependency", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Dependency) IsNode() {}

var hasmetadataImplementors = []string{"HasMetadata", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*HasMetadata) IsNode() {}

var hassourceatImplementors = []string{"HasSourceAt", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*HasSourceAt) IsNode() {}

var hashequalImplementors = []string{"HashEqual", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*HashEqual) IsNode() {}

var isdeployedImplementors = []string{"IsDeployed", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*IsDeployed) IsNode() {}

var licenseImplementors = []string{"License", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*License) IsNode() {}

var occurrenceImplementors = []string{"Occurrence", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Occurrence) IsNode() {}

var packagenameImplementors = []string{"PackageName", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*PackageName) IsNode() {}

var packageversionImplementors = []string{"PackageVersion", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*PackageVersion) IsNode() {}

var pkgequalImplementors = []string{"PkgEqual", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*PkgEqual) IsNode() {}

var pointofcontactImplementors = []string{"PointOfContact", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*PointOfContact) IsNode() {}

var slsaattestationImplementors = []string{"SLSAAttestation", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*SLSAAttestation) IsNode() {}

var sourcenameImplementors = []string{"SourceName", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*SourceName) IsNode() {}

var vulnequalImplementors = []string{"VulnEqual", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*VulnEqual) IsNode() {}

var vulnerabilityidImplementors = []string{"VulnerabilityID", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*VulnerabilityID) IsNode() {}

var vulnerabilitymetadataImplementors = []string{"VulnerabilityMetadata", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*VulnerabilityMetadata) IsNode() {}

var errNodeInvalidID = &NotFoundError{"node"}

// NodeOption allows configuring the Noder execution using functional options.
type NodeOption func(*nodeOptions)

// WithNodeType sets the node Type resolver function (i.e. the table to query).
// If was not provided, the table will be derived from the universal-id
// configuration as described in: https://entgo.io/docs/migrate/#universal-ids.
func WithNodeType(f func(context.Context, uuid.UUID) (string, error)) NodeOption {
	return func(o *nodeOptions) {
		o.nodeType = f
	}
}

// WithFixedNodeType sets the Type of the node to a fixed value.
func WithFixedNodeType(t string) NodeOption {
	return WithNodeType(func(context.Context, uuid.UUID) (string, error) {
		return t, nil
	})
}

type nodeOptions struct {
	nodeType func(context.Context, uuid.UUID) (string, error)
}

func (c *Client) newNodeOpts(opts []NodeOption) *nodeOptions {
	nopts := &nodeOptions{}
	for _, opt := range opts {
		opt(nopts)
	}
	if nopts.nodeType == nil {
		nopts.nodeType = func(ctx context.Context, id uuid.UUID) (string, error) {
			return "", fmt.Errorf("cannot resolve noder (%v) without its type", id)
		}
	}
	return nopts
}

// Noder returns a Node by its id. If the NodeType was not provided, it will
// be derived from the id value according to the universal-id configuration.
//
//	c.Noder(ctx, id)
//	c.Noder(ctx, id, ent.WithNodeType(typeResolver))
func (c *Client) Noder(ctx context.Context, id uuid.UUID, opts ...NodeOption) (_ Noder, err error) {
	defer func() {
		if IsNotFound(err) {
			err = multierror.Append(err, entgql.ErrNodeNotFound(id))
		}
	}()
	table, err := c.newNodeOpts(opts).nodeType(ctx, id)
	if err != nil {
		return nil, err
	}
	return c.noder(ctx, table, id)
}

func (c *Client) noder(ctx context.Context, table string, id uuid.UUID) (Noder, error) {
	switch table {
	case artifact.Table:
		query := c.Artifact.Query().
			Where(artifact.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, artifactImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case billofmaterials.Table:
		query := c.BillOfMaterials.Query().
			Where(billofmaterials.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, billofmaterialsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case builder.Table:
		query := c.Builder.Query().
			Where(builder.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, builderImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case certification.Table:
		query := c.Certification.Query().
			Where(certification.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, certificationImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case certifylegal.Table:
		query := c.CertifyLegal.Query().
			Where(certifylegal.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, certifylegalImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case certifyscorecard.Table:
		query := c.CertifyScorecard.Query().
			Where(certifyscorecard.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, certifyscorecardImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case certifyvex.Table:
		query := c.CertifyVex.Query().
			Where(certifyvex.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, certifyvexImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case certifyvuln.Table:
		query := c.CertifyVuln.Query().
			Where(certifyvuln.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, certifyvulnImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case dependency.Table:
		query := c.Dependency.Query().
			Where(dependency.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, dependencyImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case hasmetadata.Table:
		query := c.HasMetadata.Query().
			Where(hasmetadata.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, hasmetadataImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case hassourceat.Table:
		query := c.HasSourceAt.Query().
			Where(hassourceat.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, hassourceatImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case hashequal.Table:
		query := c.HashEqual.Query().
			Where(hashequal.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, hashequalImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case isdeployed.Table:
		query := c.IsDeployed.Query().
			Where(isdeployed.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, isdeployedImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case license.Table:
		query := c.License.Query().
			Where(license.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, licenseImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case occurrence.Table:
		query := c.Occurrence.Query().
			Where(occurrence.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, occurrenceImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case packagename.Table:
		query := c.PackageName.Query().
			Where(packagename.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, packagenameImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case packageversion.Table:
		query := c.PackageVersion.Query().
			Where(packageversion.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, packageversionImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case pkgequal.Table:
		query := c.PkgEqual.Query().
			Where(pkgequal.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, pkgequalImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case pointofcontact.Table:
		query := c.PointOfContact.Query().
			Where(pointofcontact.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, pointofcontactImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case slsaattestation.Table:
		query := c.SLSAAttestation.Query().
			Where(slsaattestation.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, slsaattestationImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case sourcename.Table:
		query := c.SourceName.Query().
			Where(sourcename.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, sourcenameImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case vulnequal.Table:
		query := c.VulnEqual.Query().
			Where(vulnequal.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, vulnequalImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case vulnerabilityid.Table:
		query := c.VulnerabilityID.Query().
			Where(vulnerabilityid.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, vulnerabilityidImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case vulnerabilitymetadata.Table:
		query := c.VulnerabilityMetadata.Query().
			Where(vulnerabilitymetadata.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, vulnerabilitymetadataImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	default:
		return nil, fmt.Errorf("cannot resolve noder from table %q: %w", table, errNodeInvalidID)
	}
}

func (c *Client) Noders(ctx context.Context, ids []uuid.UUID, opts ...NodeOption) ([]Noder, error) {
	switch len(ids) {
	case 1:
		noder, err := c.Noder(ctx, ids[0], opts...)
		if err != nil {
			return nil, err
		}
		return []Noder{noder}, nil
	case 0:
		return []Noder{}, nil
	}

	noders := make([]Noder, len(ids))
	errors := make([]error, len(ids))
	tables := make(map[string][]uuid.UUID)
	id2idx := make(map[uuid.UUID][]int, len(ids))
	nopts := c.newNodeOpts(opts)
	for i, id := range ids {
		table, err := nopts.nodeType(ctx, id)
		if err != nil {
			errors[i] = err
			continue
		}
		tables[table] = append(tables[table], id)
		id2idx[id] = append(id2idx[id], i)
	}

	for table, ids := range tables {
		nodes, err := c.noders(ctx, table, ids)
		if err != nil {
			for _, id := range ids {
				for _, idx := range id2idx[id] {
					errors[idx] = err
				}
			}
		} else {
			for i, id := range ids {
				for _, idx := range id2idx[id] {
					noders[idx] = nodes[i]
				}
			}
		}
	}

	for i, id := range ids {
		if errors[i] == nil {
			if noders[i] != nil {
				continue
			}
			errors[i] = entgql.ErrNodeNotFound(id)
		} else if IsNotFound(errors[i]) {
			errors[i] = multierror.Append(errors[i], entgql.ErrNodeNotFound(id))
		}
		ctx := graphql.WithPathContext(ctx,
			graphql.NewPathWithIndex(i),
		)
		graphql.AddError(ctx, errors[i])
	}
	return noders, nil
}

func (c *Client) noders(ctx context.Context, table string, ids []uuid.UUID) ([]Noder, error) {
	noders := make([]Noder, len(ids))
	idmap := make(map[uuid.UUID][]*Noder, len(ids))
	for i, id := range ids {
		idmap[id] = append(idmap[id], &noders[i])
	}
	switch table {
	case artifact.Table:
		query := c.Artifact.Query().
			Where(artifact.IDIn(ids...))
		query, err := query.CollectFields(ctx, artifactImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case billofmaterials.Table:
		query := c.BillOfMaterials.Query().
			Where(billofmaterials.IDIn(ids...))
		query, err := query.CollectFields(ctx, billofmaterialsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case builder.Table:
		query := c.Builder.Query().
			Where(builder.IDIn(ids...))
		query, err := query.CollectFields(ctx, builderImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case certification.Table:
		query := c.Certification.Query().
			Where(certification.IDIn(ids...))
		query, err := query.CollectFields(ctx, certificationImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case certifylegal.Table:
		query := c.CertifyLegal.Query().
			Where(certifylegal.IDIn(ids...))
		query, err := query.CollectFields(ctx, certifylegalImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case certifyscorecard.Table:
		query := c.CertifyScorecard.Query().
			Where(certifyscorecard.IDIn(ids...))
		query, err := query.CollectFields(ctx, certifyscorecardImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case certifyvex.Table:
		query := c.CertifyVex.Query().
			Where(certifyvex.IDIn(ids...))
		query, err := query.CollectFields(ctx, certifyvexImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case certifyvuln.Table:
		query := c.CertifyVuln.Query().
			Where(certifyvuln.IDIn(ids...))
		query, err := query.CollectFields(ctx, certifyvulnImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case dependency.Table:
		query := c.Dependency.Query().
			Where(dependency.IDIn(ids...))
		query, err := query.CollectFields(ctx, dependencyImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case hasmetadata.Table:
		query := c.HasMetadata.Query().
			Where(hasmetadata.IDIn(ids...))
		query, err := query.CollectFields(ctx, hasmetadataImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case hassourceat.Table:
		query := c.HasSourceAt.Query().
			Where(hassourceat.IDIn(ids...))
		query, err := query.CollectFields(ctx, hassourceatImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case hashequal.Table:
		query := c.HashEqual.Query().
			Where(hashequal.IDIn(ids...))
		query, err := query.CollectFields(ctx, hashequalImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case isdeployed.Table:
		query := c.IsDeployed.Query().
			Where(isdeployed.IDIn(ids...))
		query, err := query.CollectFields(ctx, isdeployedImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case license.Table:
		query := c.License.Query().
			Where(license.IDIn(ids...))
		query, err := query.CollectFields(ctx, licenseImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case occurrence.Table:
		query := c.Occurrence.Query().
			Where(occurrence.IDIn(ids...))
		query, err := query.CollectFields(ctx, occurrenceImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case packagename.Table:
		query := c.PackageName.Query().
			Where(packagename.IDIn(ids...))
		query, err := query.CollectFields(ctx, packagenameImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case packageversion.Table:
		query := c.PackageVersion.Query().
			Where(packageversion.IDIn(ids...))
		query, err := query.CollectFields(ctx, packageversionImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case pkgequal.Table:
		query := c.PkgEqual.Query().
			Where(pkgequal.IDIn(ids...))
		query, err := query.CollectFields(ctx, pkgequalImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case pointofcontact.Table:
		query := c.PointOfContact.Query().
			Where(pointofcontact.IDIn(ids...))
		query, err := query.CollectFields(ctx, pointofcontactImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case slsaattestation.Table:
		query := c.SLSAAttestation.Query().
			Where(slsaattestation.IDIn(ids...))
		query, err := query.CollectFields(ctx, slsaattestationImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case sourcename.Table:
		query := c.SourceName.Query().
			Where(sourcename.IDIn(ids...))
		query, err := query.CollectFields(ctx, sourcenameImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case vulnequal.Table:
		query := c.VulnEqual.Query().
			Where(vulnequal.IDIn(ids...))
		query, err := query.CollectFields(ctx, vulnequalImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case vulnerabilityid.Table:
		query := c.VulnerabilityID.Query().
			Where(vulnerabilityid.IDIn(ids...))
		query, err := query.CollectFields(ctx, vulnerabilityidImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case vulnerabilitymetadata.Table:
		query := c.VulnerabilityMetadata.Query().
			Where(vulnerabilitymetadata.IDIn(ids...))
		query, err := query.CollectFields(ctx, vulnerabilitymetadataImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	default:
		return nil, fmt.Errorf("cannot resolve noders from table %q: %w", table, errNodeInvalidID)
	}
	return noders, nil
}
