// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/guacsec/guac/pkg/assembler/backends/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/artifact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/buildernode"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/dependency"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/isoccurrence"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagenode"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/source"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcenamespace"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Artifact is the client for interacting with the Artifact builders.
	Artifact *ArtifactClient
	// BuilderNode is the client for interacting with the BuilderNode builders.
	BuilderNode *BuilderNodeClient
	// Dependency is the client for interacting with the Dependency builders.
	Dependency *DependencyClient
	// IsOccurrence is the client for interacting with the IsOccurrence builders.
	IsOccurrence *IsOccurrenceClient
	// PackageName is the client for interacting with the PackageName builders.
	PackageName *PackageNameClient
	// PackageNamespace is the client for interacting with the PackageNamespace builders.
	PackageNamespace *PackageNamespaceClient
	// PackageNode is the client for interacting with the PackageNode builders.
	PackageNode *PackageNodeClient
	// PackageVersion is the client for interacting with the PackageVersion builders.
	PackageVersion *PackageVersionClient
	// Source is the client for interacting with the Source builders.
	Source *SourceClient
	// SourceName is the client for interacting with the SourceName builders.
	SourceName *SourceNameClient
	// SourceNamespace is the client for interacting with the SourceNamespace builders.
	SourceNamespace *SourceNamespaceClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Artifact = NewArtifactClient(c.config)
	c.BuilderNode = NewBuilderNodeClient(c.config)
	c.Dependency = NewDependencyClient(c.config)
	c.IsOccurrence = NewIsOccurrenceClient(c.config)
	c.PackageName = NewPackageNameClient(c.config)
	c.PackageNamespace = NewPackageNamespaceClient(c.config)
	c.PackageNode = NewPackageNodeClient(c.config)
	c.PackageVersion = NewPackageVersionClient(c.config)
	c.Source = NewSourceClient(c.config)
	c.SourceName = NewSourceNameClient(c.config)
	c.SourceNamespace = NewSourceNamespaceClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Artifact:         NewArtifactClient(cfg),
		BuilderNode:      NewBuilderNodeClient(cfg),
		Dependency:       NewDependencyClient(cfg),
		IsOccurrence:     NewIsOccurrenceClient(cfg),
		PackageName:      NewPackageNameClient(cfg),
		PackageNamespace: NewPackageNamespaceClient(cfg),
		PackageNode:      NewPackageNodeClient(cfg),
		PackageVersion:   NewPackageVersionClient(cfg),
		Source:           NewSourceClient(cfg),
		SourceName:       NewSourceNameClient(cfg),
		SourceNamespace:  NewSourceNamespaceClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Artifact:         NewArtifactClient(cfg),
		BuilderNode:      NewBuilderNodeClient(cfg),
		Dependency:       NewDependencyClient(cfg),
		IsOccurrence:     NewIsOccurrenceClient(cfg),
		PackageName:      NewPackageNameClient(cfg),
		PackageNamespace: NewPackageNamespaceClient(cfg),
		PackageNode:      NewPackageNodeClient(cfg),
		PackageVersion:   NewPackageVersionClient(cfg),
		Source:           NewSourceClient(cfg),
		SourceName:       NewSourceNameClient(cfg),
		SourceNamespace:  NewSourceNamespaceClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Artifact.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Artifact, c.BuilderNode, c.Dependency, c.IsOccurrence, c.PackageName,
		c.PackageNamespace, c.PackageNode, c.PackageVersion, c.Source, c.SourceName,
		c.SourceNamespace,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Artifact, c.BuilderNode, c.Dependency, c.IsOccurrence, c.PackageName,
		c.PackageNamespace, c.PackageNode, c.PackageVersion, c.Source, c.SourceName,
		c.SourceNamespace,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ArtifactMutation:
		return c.Artifact.mutate(ctx, m)
	case *BuilderNodeMutation:
		return c.BuilderNode.mutate(ctx, m)
	case *DependencyMutation:
		return c.Dependency.mutate(ctx, m)
	case *IsOccurrenceMutation:
		return c.IsOccurrence.mutate(ctx, m)
	case *PackageNameMutation:
		return c.PackageName.mutate(ctx, m)
	case *PackageNamespaceMutation:
		return c.PackageNamespace.mutate(ctx, m)
	case *PackageNodeMutation:
		return c.PackageNode.mutate(ctx, m)
	case *PackageVersionMutation:
		return c.PackageVersion.mutate(ctx, m)
	case *SourceMutation:
		return c.Source.mutate(ctx, m)
	case *SourceNameMutation:
		return c.SourceName.mutate(ctx, m)
	case *SourceNamespaceMutation:
		return c.SourceNamespace.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ArtifactClient is a client for the Artifact schema.
type ArtifactClient struct {
	config
}

// NewArtifactClient returns a client for the Artifact from the given config.
func NewArtifactClient(c config) *ArtifactClient {
	return &ArtifactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artifact.Hooks(f(g(h())))`.
func (c *ArtifactClient) Use(hooks ...Hook) {
	c.hooks.Artifact = append(c.hooks.Artifact, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `artifact.Intercept(f(g(h())))`.
func (c *ArtifactClient) Intercept(interceptors ...Interceptor) {
	c.inters.Artifact = append(c.inters.Artifact, interceptors...)
}

// Create returns a builder for creating a Artifact entity.
func (c *ArtifactClient) Create() *ArtifactCreate {
	mutation := newArtifactMutation(c.config, OpCreate)
	return &ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Artifact entities.
func (c *ArtifactClient) CreateBulk(builders ...*ArtifactCreate) *ArtifactCreateBulk {
	return &ArtifactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Artifact.
func (c *ArtifactClient) Update() *ArtifactUpdate {
	mutation := newArtifactMutation(c.config, OpUpdate)
	return &ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtifactClient) UpdateOne(a *Artifact) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifact(a))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtifactClient) UpdateOneID(id int) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifactID(id))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Artifact.
func (c *ArtifactClient) Delete() *ArtifactDelete {
	mutation := newArtifactMutation(c.config, OpDelete)
	return &ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtifactClient) DeleteOne(a *Artifact) *ArtifactDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtifactClient) DeleteOneID(id int) *ArtifactDeleteOne {
	builder := c.Delete().Where(artifact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtifactDeleteOne{builder}
}

// Query returns a query builder for Artifact.
func (c *ArtifactClient) Query() *ArtifactQuery {
	return &ArtifactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArtifact},
		inters: c.Interceptors(),
	}
}

// Get returns a Artifact entity by its id.
func (c *ArtifactClient) Get(ctx context.Context, id int) (*Artifact, error) {
	return c.Query().Where(artifact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtifactClient) GetX(ctx context.Context, id int) *Artifact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOccurrences queries the occurrences edge of a Artifact.
func (c *ArtifactClient) QueryOccurrences(a *Artifact) *IsOccurrenceQuery {
	query := (&IsOccurrenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(isoccurrence.Table, isoccurrence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.OccurrencesTable, artifact.OccurrencesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtifactClient) Hooks() []Hook {
	return c.hooks.Artifact
}

// Interceptors returns the client interceptors.
func (c *ArtifactClient) Interceptors() []Interceptor {
	return c.inters.Artifact
}

func (c *ArtifactClient) mutate(ctx context.Context, m *ArtifactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Artifact mutation op: %q", m.Op())
	}
}

// BuilderNodeClient is a client for the BuilderNode schema.
type BuilderNodeClient struct {
	config
}

// NewBuilderNodeClient returns a client for the BuilderNode from the given config.
func NewBuilderNodeClient(c config) *BuilderNodeClient {
	return &BuilderNodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `buildernode.Hooks(f(g(h())))`.
func (c *BuilderNodeClient) Use(hooks ...Hook) {
	c.hooks.BuilderNode = append(c.hooks.BuilderNode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `buildernode.Intercept(f(g(h())))`.
func (c *BuilderNodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.BuilderNode = append(c.inters.BuilderNode, interceptors...)
}

// Create returns a builder for creating a BuilderNode entity.
func (c *BuilderNodeClient) Create() *BuilderNodeCreate {
	mutation := newBuilderNodeMutation(c.config, OpCreate)
	return &BuilderNodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BuilderNode entities.
func (c *BuilderNodeClient) CreateBulk(builders ...*BuilderNodeCreate) *BuilderNodeCreateBulk {
	return &BuilderNodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BuilderNode.
func (c *BuilderNodeClient) Update() *BuilderNodeUpdate {
	mutation := newBuilderNodeMutation(c.config, OpUpdate)
	return &BuilderNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BuilderNodeClient) UpdateOne(bn *BuilderNode) *BuilderNodeUpdateOne {
	mutation := newBuilderNodeMutation(c.config, OpUpdateOne, withBuilderNode(bn))
	return &BuilderNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BuilderNodeClient) UpdateOneID(id int) *BuilderNodeUpdateOne {
	mutation := newBuilderNodeMutation(c.config, OpUpdateOne, withBuilderNodeID(id))
	return &BuilderNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BuilderNode.
func (c *BuilderNodeClient) Delete() *BuilderNodeDelete {
	mutation := newBuilderNodeMutation(c.config, OpDelete)
	return &BuilderNodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BuilderNodeClient) DeleteOne(bn *BuilderNode) *BuilderNodeDeleteOne {
	return c.DeleteOneID(bn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BuilderNodeClient) DeleteOneID(id int) *BuilderNodeDeleteOne {
	builder := c.Delete().Where(buildernode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BuilderNodeDeleteOne{builder}
}

// Query returns a query builder for BuilderNode.
func (c *BuilderNodeClient) Query() *BuilderNodeQuery {
	return &BuilderNodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBuilderNode},
		inters: c.Interceptors(),
	}
}

// Get returns a BuilderNode entity by its id.
func (c *BuilderNodeClient) Get(ctx context.Context, id int) (*BuilderNode, error) {
	return c.Query().Where(buildernode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BuilderNodeClient) GetX(ctx context.Context, id int) *BuilderNode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BuilderNodeClient) Hooks() []Hook {
	return c.hooks.BuilderNode
}

// Interceptors returns the client interceptors.
func (c *BuilderNodeClient) Interceptors() []Interceptor {
	return c.inters.BuilderNode
}

func (c *BuilderNodeClient) mutate(ctx context.Context, m *BuilderNodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BuilderNodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BuilderNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BuilderNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BuilderNodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BuilderNode mutation op: %q", m.Op())
	}
}

// DependencyClient is a client for the Dependency schema.
type DependencyClient struct {
	config
}

// NewDependencyClient returns a client for the Dependency from the given config.
func NewDependencyClient(c config) *DependencyClient {
	return &DependencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dependency.Hooks(f(g(h())))`.
func (c *DependencyClient) Use(hooks ...Hook) {
	c.hooks.Dependency = append(c.hooks.Dependency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dependency.Intercept(f(g(h())))`.
func (c *DependencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Dependency = append(c.inters.Dependency, interceptors...)
}

// Create returns a builder for creating a Dependency entity.
func (c *DependencyClient) Create() *DependencyCreate {
	mutation := newDependencyMutation(c.config, OpCreate)
	return &DependencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dependency entities.
func (c *DependencyClient) CreateBulk(builders ...*DependencyCreate) *DependencyCreateBulk {
	return &DependencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dependency.
func (c *DependencyClient) Update() *DependencyUpdate {
	mutation := newDependencyMutation(c.config, OpUpdate)
	return &DependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DependencyClient) UpdateOne(d *Dependency) *DependencyUpdateOne {
	mutation := newDependencyMutation(c.config, OpUpdateOne, withDependency(d))
	return &DependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DependencyClient) UpdateOneID(id int) *DependencyUpdateOne {
	mutation := newDependencyMutation(c.config, OpUpdateOne, withDependencyID(id))
	return &DependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dependency.
func (c *DependencyClient) Delete() *DependencyDelete {
	mutation := newDependencyMutation(c.config, OpDelete)
	return &DependencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DependencyClient) DeleteOne(d *Dependency) *DependencyDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DependencyClient) DeleteOneID(id int) *DependencyDeleteOne {
	builder := c.Delete().Where(dependency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DependencyDeleteOne{builder}
}

// Query returns a query builder for Dependency.
func (c *DependencyClient) Query() *DependencyQuery {
	return &DependencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDependency},
		inters: c.Interceptors(),
	}
}

// Get returns a Dependency entity by its id.
func (c *DependencyClient) Get(ctx context.Context, id int) (*Dependency, error) {
	return c.Query().Where(dependency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DependencyClient) GetX(ctx context.Context, id int) *Dependency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a Dependency.
func (c *DependencyClient) QueryPackage(d *Dependency) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dependency.Table, dependency.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, dependency.PackageTable, dependency.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependentPackage queries the dependent_package edge of a Dependency.
func (c *DependencyClient) QueryDependentPackage(d *Dependency) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dependency.Table, dependency.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, dependency.DependentPackageTable, dependency.DependentPackageColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DependencyClient) Hooks() []Hook {
	return c.hooks.Dependency
}

// Interceptors returns the client interceptors.
func (c *DependencyClient) Interceptors() []Interceptor {
	return c.inters.Dependency
}

func (c *DependencyClient) mutate(ctx context.Context, m *DependencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DependencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DependencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Dependency mutation op: %q", m.Op())
	}
}

// IsOccurrenceClient is a client for the IsOccurrence schema.
type IsOccurrenceClient struct {
	config
}

// NewIsOccurrenceClient returns a client for the IsOccurrence from the given config.
func NewIsOccurrenceClient(c config) *IsOccurrenceClient {
	return &IsOccurrenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `isoccurrence.Hooks(f(g(h())))`.
func (c *IsOccurrenceClient) Use(hooks ...Hook) {
	c.hooks.IsOccurrence = append(c.hooks.IsOccurrence, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `isoccurrence.Intercept(f(g(h())))`.
func (c *IsOccurrenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.IsOccurrence = append(c.inters.IsOccurrence, interceptors...)
}

// Create returns a builder for creating a IsOccurrence entity.
func (c *IsOccurrenceClient) Create() *IsOccurrenceCreate {
	mutation := newIsOccurrenceMutation(c.config, OpCreate)
	return &IsOccurrenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IsOccurrence entities.
func (c *IsOccurrenceClient) CreateBulk(builders ...*IsOccurrenceCreate) *IsOccurrenceCreateBulk {
	return &IsOccurrenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IsOccurrence.
func (c *IsOccurrenceClient) Update() *IsOccurrenceUpdate {
	mutation := newIsOccurrenceMutation(c.config, OpUpdate)
	return &IsOccurrenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IsOccurrenceClient) UpdateOne(io *IsOccurrence) *IsOccurrenceUpdateOne {
	mutation := newIsOccurrenceMutation(c.config, OpUpdateOne, withIsOccurrence(io))
	return &IsOccurrenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IsOccurrenceClient) UpdateOneID(id int) *IsOccurrenceUpdateOne {
	mutation := newIsOccurrenceMutation(c.config, OpUpdateOne, withIsOccurrenceID(id))
	return &IsOccurrenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IsOccurrence.
func (c *IsOccurrenceClient) Delete() *IsOccurrenceDelete {
	mutation := newIsOccurrenceMutation(c.config, OpDelete)
	return &IsOccurrenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IsOccurrenceClient) DeleteOne(io *IsOccurrence) *IsOccurrenceDeleteOne {
	return c.DeleteOneID(io.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IsOccurrenceClient) DeleteOneID(id int) *IsOccurrenceDeleteOne {
	builder := c.Delete().Where(isoccurrence.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IsOccurrenceDeleteOne{builder}
}

// Query returns a query builder for IsOccurrence.
func (c *IsOccurrenceClient) Query() *IsOccurrenceQuery {
	return &IsOccurrenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIsOccurrence},
		inters: c.Interceptors(),
	}
}

// Get returns a IsOccurrence entity by its id.
func (c *IsOccurrenceClient) Get(ctx context.Context, id int) (*IsOccurrence, error) {
	return c.Query().Where(isoccurrence.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IsOccurrenceClient) GetX(ctx context.Context, id int) *IsOccurrence {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackageVersion queries the package_version edge of a IsOccurrence.
func (c *IsOccurrenceClient) QueryPackageVersion(io *IsOccurrence) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := io.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(isoccurrence.Table, isoccurrence.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, isoccurrence.PackageVersionTable, isoccurrence.PackageVersionColumn),
		)
		fromV = sqlgraph.Neighbors(io.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySource queries the source edge of a IsOccurrence.
func (c *IsOccurrenceClient) QuerySource(io *IsOccurrence) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := io.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(isoccurrence.Table, isoccurrence.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, isoccurrence.SourceTable, isoccurrence.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(io.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifact queries the artifact edge of a IsOccurrence.
func (c *IsOccurrenceClient) QueryArtifact(io *IsOccurrence) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := io.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(isoccurrence.Table, isoccurrence.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, isoccurrence.ArtifactTable, isoccurrence.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(io.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IsOccurrenceClient) Hooks() []Hook {
	return c.hooks.IsOccurrence
}

// Interceptors returns the client interceptors.
func (c *IsOccurrenceClient) Interceptors() []Interceptor {
	return c.inters.IsOccurrence
}

func (c *IsOccurrenceClient) mutate(ctx context.Context, m *IsOccurrenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IsOccurrenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IsOccurrenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IsOccurrenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IsOccurrenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IsOccurrence mutation op: %q", m.Op())
	}
}

// PackageNameClient is a client for the PackageName schema.
type PackageNameClient struct {
	config
}

// NewPackageNameClient returns a client for the PackageName from the given config.
func NewPackageNameClient(c config) *PackageNameClient {
	return &PackageNameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packagename.Hooks(f(g(h())))`.
func (c *PackageNameClient) Use(hooks ...Hook) {
	c.hooks.PackageName = append(c.hooks.PackageName, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packagename.Intercept(f(g(h())))`.
func (c *PackageNameClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageName = append(c.inters.PackageName, interceptors...)
}

// Create returns a builder for creating a PackageName entity.
func (c *PackageNameClient) Create() *PackageNameCreate {
	mutation := newPackageNameMutation(c.config, OpCreate)
	return &PackageNameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageName entities.
func (c *PackageNameClient) CreateBulk(builders ...*PackageNameCreate) *PackageNameCreateBulk {
	return &PackageNameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageName.
func (c *PackageNameClient) Update() *PackageNameUpdate {
	mutation := newPackageNameMutation(c.config, OpUpdate)
	return &PackageNameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageNameClient) UpdateOne(pn *PackageName) *PackageNameUpdateOne {
	mutation := newPackageNameMutation(c.config, OpUpdateOne, withPackageName(pn))
	return &PackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageNameClient) UpdateOneID(id int) *PackageNameUpdateOne {
	mutation := newPackageNameMutation(c.config, OpUpdateOne, withPackageNameID(id))
	return &PackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageName.
func (c *PackageNameClient) Delete() *PackageNameDelete {
	mutation := newPackageNameMutation(c.config, OpDelete)
	return &PackageNameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageNameClient) DeleteOne(pn *PackageName) *PackageNameDeleteOne {
	return c.DeleteOneID(pn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageNameClient) DeleteOneID(id int) *PackageNameDeleteOne {
	builder := c.Delete().Where(packagename.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageNameDeleteOne{builder}
}

// Query returns a query builder for PackageName.
func (c *PackageNameClient) Query() *PackageNameQuery {
	return &PackageNameQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageName},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageName entity by its id.
func (c *PackageNameClient) Get(ctx context.Context, id int) (*PackageName, error) {
	return c.Query().Where(packagename.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageNameClient) GetX(ctx context.Context, id int) *PackageName {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a PackageName.
func (c *PackageNameClient) QueryNamespace(pn *PackageName) *PackageNamespaceQuery {
	query := (&PackageNamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagename.Table, packagename.FieldID, id),
			sqlgraph.To(packagenamespace.Table, packagenamespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, packagename.NamespaceTable, packagename.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVersions queries the versions edge of a PackageName.
func (c *PackageNameClient) QueryVersions(pn *PackageName) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagename.Table, packagename.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, packagename.VersionsTable, packagename.VersionsColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageNameClient) Hooks() []Hook {
	return c.hooks.PackageName
}

// Interceptors returns the client interceptors.
func (c *PackageNameClient) Interceptors() []Interceptor {
	return c.inters.PackageName
}

func (c *PackageNameClient) mutate(ctx context.Context, m *PackageNameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageNameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageNameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageNameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageName mutation op: %q", m.Op())
	}
}

// PackageNamespaceClient is a client for the PackageNamespace schema.
type PackageNamespaceClient struct {
	config
}

// NewPackageNamespaceClient returns a client for the PackageNamespace from the given config.
func NewPackageNamespaceClient(c config) *PackageNamespaceClient {
	return &PackageNamespaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packagenamespace.Hooks(f(g(h())))`.
func (c *PackageNamespaceClient) Use(hooks ...Hook) {
	c.hooks.PackageNamespace = append(c.hooks.PackageNamespace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packagenamespace.Intercept(f(g(h())))`.
func (c *PackageNamespaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageNamespace = append(c.inters.PackageNamespace, interceptors...)
}

// Create returns a builder for creating a PackageNamespace entity.
func (c *PackageNamespaceClient) Create() *PackageNamespaceCreate {
	mutation := newPackageNamespaceMutation(c.config, OpCreate)
	return &PackageNamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageNamespace entities.
func (c *PackageNamespaceClient) CreateBulk(builders ...*PackageNamespaceCreate) *PackageNamespaceCreateBulk {
	return &PackageNamespaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageNamespace.
func (c *PackageNamespaceClient) Update() *PackageNamespaceUpdate {
	mutation := newPackageNamespaceMutation(c.config, OpUpdate)
	return &PackageNamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageNamespaceClient) UpdateOne(pn *PackageNamespace) *PackageNamespaceUpdateOne {
	mutation := newPackageNamespaceMutation(c.config, OpUpdateOne, withPackageNamespace(pn))
	return &PackageNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageNamespaceClient) UpdateOneID(id int) *PackageNamespaceUpdateOne {
	mutation := newPackageNamespaceMutation(c.config, OpUpdateOne, withPackageNamespaceID(id))
	return &PackageNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageNamespace.
func (c *PackageNamespaceClient) Delete() *PackageNamespaceDelete {
	mutation := newPackageNamespaceMutation(c.config, OpDelete)
	return &PackageNamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageNamespaceClient) DeleteOne(pn *PackageNamespace) *PackageNamespaceDeleteOne {
	return c.DeleteOneID(pn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageNamespaceClient) DeleteOneID(id int) *PackageNamespaceDeleteOne {
	builder := c.Delete().Where(packagenamespace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageNamespaceDeleteOne{builder}
}

// Query returns a query builder for PackageNamespace.
func (c *PackageNamespaceClient) Query() *PackageNamespaceQuery {
	return &PackageNamespaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageNamespace},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageNamespace entity by its id.
func (c *PackageNamespaceClient) Get(ctx context.Context, id int) (*PackageNamespace, error) {
	return c.Query().Where(packagenamespace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageNamespaceClient) GetX(ctx context.Context, id int) *PackageNamespace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a PackageNamespace.
func (c *PackageNamespaceClient) QueryPackage(pn *PackageNamespace) *PackageNodeQuery {
	query := (&PackageNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagenamespace.Table, packagenamespace.FieldID, id),
			sqlgraph.To(packagenode.Table, packagenode.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, packagenamespace.PackageTable, packagenamespace.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNames queries the names edge of a PackageNamespace.
func (c *PackageNamespaceClient) QueryNames(pn *PackageNamespace) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagenamespace.Table, packagenamespace.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, packagenamespace.NamesTable, packagenamespace.NamesColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageNamespaceClient) Hooks() []Hook {
	return c.hooks.PackageNamespace
}

// Interceptors returns the client interceptors.
func (c *PackageNamespaceClient) Interceptors() []Interceptor {
	return c.inters.PackageNamespace
}

func (c *PackageNamespaceClient) mutate(ctx context.Context, m *PackageNamespaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageNamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageNamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageNamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageNamespace mutation op: %q", m.Op())
	}
}

// PackageNodeClient is a client for the PackageNode schema.
type PackageNodeClient struct {
	config
}

// NewPackageNodeClient returns a client for the PackageNode from the given config.
func NewPackageNodeClient(c config) *PackageNodeClient {
	return &PackageNodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packagenode.Hooks(f(g(h())))`.
func (c *PackageNodeClient) Use(hooks ...Hook) {
	c.hooks.PackageNode = append(c.hooks.PackageNode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packagenode.Intercept(f(g(h())))`.
func (c *PackageNodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageNode = append(c.inters.PackageNode, interceptors...)
}

// Create returns a builder for creating a PackageNode entity.
func (c *PackageNodeClient) Create() *PackageNodeCreate {
	mutation := newPackageNodeMutation(c.config, OpCreate)
	return &PackageNodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageNode entities.
func (c *PackageNodeClient) CreateBulk(builders ...*PackageNodeCreate) *PackageNodeCreateBulk {
	return &PackageNodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageNode.
func (c *PackageNodeClient) Update() *PackageNodeUpdate {
	mutation := newPackageNodeMutation(c.config, OpUpdate)
	return &PackageNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageNodeClient) UpdateOne(pn *PackageNode) *PackageNodeUpdateOne {
	mutation := newPackageNodeMutation(c.config, OpUpdateOne, withPackageNode(pn))
	return &PackageNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageNodeClient) UpdateOneID(id int) *PackageNodeUpdateOne {
	mutation := newPackageNodeMutation(c.config, OpUpdateOne, withPackageNodeID(id))
	return &PackageNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageNode.
func (c *PackageNodeClient) Delete() *PackageNodeDelete {
	mutation := newPackageNodeMutation(c.config, OpDelete)
	return &PackageNodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageNodeClient) DeleteOne(pn *PackageNode) *PackageNodeDeleteOne {
	return c.DeleteOneID(pn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageNodeClient) DeleteOneID(id int) *PackageNodeDeleteOne {
	builder := c.Delete().Where(packagenode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageNodeDeleteOne{builder}
}

// Query returns a query builder for PackageNode.
func (c *PackageNodeClient) Query() *PackageNodeQuery {
	return &PackageNodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageNode},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageNode entity by its id.
func (c *PackageNodeClient) Get(ctx context.Context, id int) (*PackageNode, error) {
	return c.Query().Where(packagenode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageNodeClient) GetX(ctx context.Context, id int) *PackageNode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespaces queries the namespaces edge of a PackageNode.
func (c *PackageNodeClient) QueryNamespaces(pn *PackageNode) *PackageNamespaceQuery {
	query := (&PackageNamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagenode.Table, packagenode.FieldID, id),
			sqlgraph.To(packagenamespace.Table, packagenamespace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, packagenode.NamespacesTable, packagenode.NamespacesColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageNodeClient) Hooks() []Hook {
	return c.hooks.PackageNode
}

// Interceptors returns the client interceptors.
func (c *PackageNodeClient) Interceptors() []Interceptor {
	return c.inters.PackageNode
}

func (c *PackageNodeClient) mutate(ctx context.Context, m *PackageNodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageNodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageNodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageNode mutation op: %q", m.Op())
	}
}

// PackageVersionClient is a client for the PackageVersion schema.
type PackageVersionClient struct {
	config
}

// NewPackageVersionClient returns a client for the PackageVersion from the given config.
func NewPackageVersionClient(c config) *PackageVersionClient {
	return &PackageVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packageversion.Hooks(f(g(h())))`.
func (c *PackageVersionClient) Use(hooks ...Hook) {
	c.hooks.PackageVersion = append(c.hooks.PackageVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packageversion.Intercept(f(g(h())))`.
func (c *PackageVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageVersion = append(c.inters.PackageVersion, interceptors...)
}

// Create returns a builder for creating a PackageVersion entity.
func (c *PackageVersionClient) Create() *PackageVersionCreate {
	mutation := newPackageVersionMutation(c.config, OpCreate)
	return &PackageVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageVersion entities.
func (c *PackageVersionClient) CreateBulk(builders ...*PackageVersionCreate) *PackageVersionCreateBulk {
	return &PackageVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageVersion.
func (c *PackageVersionClient) Update() *PackageVersionUpdate {
	mutation := newPackageVersionMutation(c.config, OpUpdate)
	return &PackageVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageVersionClient) UpdateOne(pv *PackageVersion) *PackageVersionUpdateOne {
	mutation := newPackageVersionMutation(c.config, OpUpdateOne, withPackageVersion(pv))
	return &PackageVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageVersionClient) UpdateOneID(id int) *PackageVersionUpdateOne {
	mutation := newPackageVersionMutation(c.config, OpUpdateOne, withPackageVersionID(id))
	return &PackageVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageVersion.
func (c *PackageVersionClient) Delete() *PackageVersionDelete {
	mutation := newPackageVersionMutation(c.config, OpDelete)
	return &PackageVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageVersionClient) DeleteOne(pv *PackageVersion) *PackageVersionDeleteOne {
	return c.DeleteOneID(pv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageVersionClient) DeleteOneID(id int) *PackageVersionDeleteOne {
	builder := c.Delete().Where(packageversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageVersionDeleteOne{builder}
}

// Query returns a query builder for PackageVersion.
func (c *PackageVersionClient) Query() *PackageVersionQuery {
	return &PackageVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageVersion entity by its id.
func (c *PackageVersionClient) Get(ctx context.Context, id int) (*PackageVersion, error) {
	return c.Query().Where(packageversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageVersionClient) GetX(ctx context.Context, id int) *PackageVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryName queries the name edge of a PackageVersion.
func (c *PackageVersionClient) QueryName(pv *PackageVersion) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, packageversion.NameTable, packageversion.NameColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageVersionClient) Hooks() []Hook {
	return c.hooks.PackageVersion
}

// Interceptors returns the client interceptors.
func (c *PackageVersionClient) Interceptors() []Interceptor {
	return c.inters.PackageVersion
}

func (c *PackageVersionClient) mutate(ctx context.Context, m *PackageVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageVersion mutation op: %q", m.Op())
	}
}

// SourceClient is a client for the Source schema.
type SourceClient struct {
	config
}

// NewSourceClient returns a client for the Source from the given config.
func NewSourceClient(c config) *SourceClient {
	return &SourceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `source.Hooks(f(g(h())))`.
func (c *SourceClient) Use(hooks ...Hook) {
	c.hooks.Source = append(c.hooks.Source, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `source.Intercept(f(g(h())))`.
func (c *SourceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Source = append(c.inters.Source, interceptors...)
}

// Create returns a builder for creating a Source entity.
func (c *SourceClient) Create() *SourceCreate {
	mutation := newSourceMutation(c.config, OpCreate)
	return &SourceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Source entities.
func (c *SourceClient) CreateBulk(builders ...*SourceCreate) *SourceCreateBulk {
	return &SourceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Source.
func (c *SourceClient) Update() *SourceUpdate {
	mutation := newSourceMutation(c.config, OpUpdate)
	return &SourceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceClient) UpdateOne(s *Source) *SourceUpdateOne {
	mutation := newSourceMutation(c.config, OpUpdateOne, withSource(s))
	return &SourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceClient) UpdateOneID(id int) *SourceUpdateOne {
	mutation := newSourceMutation(c.config, OpUpdateOne, withSourceID(id))
	return &SourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Source.
func (c *SourceClient) Delete() *SourceDelete {
	mutation := newSourceMutation(c.config, OpDelete)
	return &SourceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceClient) DeleteOne(s *Source) *SourceDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceClient) DeleteOneID(id int) *SourceDeleteOne {
	builder := c.Delete().Where(source.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceDeleteOne{builder}
}

// Query returns a query builder for Source.
func (c *SourceClient) Query() *SourceQuery {
	return &SourceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSource},
		inters: c.Interceptors(),
	}
}

// Get returns a Source entity by its id.
func (c *SourceClient) Get(ctx context.Context, id int) (*Source, error) {
	return c.Query().Where(source.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceClient) GetX(ctx context.Context, id int) *Source {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespaces queries the namespaces edge of a Source.
func (c *SourceClient) QueryNamespaces(s *Source) *SourceNamespaceQuery {
	query := (&SourceNamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(source.Table, source.FieldID, id),
			sqlgraph.To(sourcenamespace.Table, sourcenamespace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, source.NamespacesTable, source.NamespacesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SourceClient) Hooks() []Hook {
	return c.hooks.Source
}

// Interceptors returns the client interceptors.
func (c *SourceClient) Interceptors() []Interceptor {
	return c.inters.Source
}

func (c *SourceClient) mutate(ctx context.Context, m *SourceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Source mutation op: %q", m.Op())
	}
}

// SourceNameClient is a client for the SourceName schema.
type SourceNameClient struct {
	config
}

// NewSourceNameClient returns a client for the SourceName from the given config.
func NewSourceNameClient(c config) *SourceNameClient {
	return &SourceNameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sourcename.Hooks(f(g(h())))`.
func (c *SourceNameClient) Use(hooks ...Hook) {
	c.hooks.SourceName = append(c.hooks.SourceName, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sourcename.Intercept(f(g(h())))`.
func (c *SourceNameClient) Intercept(interceptors ...Interceptor) {
	c.inters.SourceName = append(c.inters.SourceName, interceptors...)
}

// Create returns a builder for creating a SourceName entity.
func (c *SourceNameClient) Create() *SourceNameCreate {
	mutation := newSourceNameMutation(c.config, OpCreate)
	return &SourceNameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SourceName entities.
func (c *SourceNameClient) CreateBulk(builders ...*SourceNameCreate) *SourceNameCreateBulk {
	return &SourceNameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SourceName.
func (c *SourceNameClient) Update() *SourceNameUpdate {
	mutation := newSourceNameMutation(c.config, OpUpdate)
	return &SourceNameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceNameClient) UpdateOne(sn *SourceName) *SourceNameUpdateOne {
	mutation := newSourceNameMutation(c.config, OpUpdateOne, withSourceName(sn))
	return &SourceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceNameClient) UpdateOneID(id int) *SourceNameUpdateOne {
	mutation := newSourceNameMutation(c.config, OpUpdateOne, withSourceNameID(id))
	return &SourceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SourceName.
func (c *SourceNameClient) Delete() *SourceNameDelete {
	mutation := newSourceNameMutation(c.config, OpDelete)
	return &SourceNameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceNameClient) DeleteOne(sn *SourceName) *SourceNameDeleteOne {
	return c.DeleteOneID(sn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceNameClient) DeleteOneID(id int) *SourceNameDeleteOne {
	builder := c.Delete().Where(sourcename.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceNameDeleteOne{builder}
}

// Query returns a query builder for SourceName.
func (c *SourceNameClient) Query() *SourceNameQuery {
	return &SourceNameQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSourceName},
		inters: c.Interceptors(),
	}
}

// Get returns a SourceName entity by its id.
func (c *SourceNameClient) Get(ctx context.Context, id int) (*SourceName, error) {
	return c.Query().Where(sourcename.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceNameClient) GetX(ctx context.Context, id int) *SourceName {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a SourceName.
func (c *SourceNameClient) QueryNamespace(sn *SourceName) *SourceNamespaceQuery {
	query := (&SourceNamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcename.Table, sourcename.FieldID, id),
			sqlgraph.To(sourcenamespace.Table, sourcenamespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, sourcename.NamespaceTable, sourcename.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOccurrences queries the occurrences edge of a SourceName.
func (c *SourceNameClient) QueryOccurrences(sn *SourceName) *IsOccurrenceQuery {
	query := (&IsOccurrenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcename.Table, sourcename.FieldID, id),
			sqlgraph.To(isoccurrence.Table, isoccurrence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcename.OccurrencesTable, sourcename.OccurrencesColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SourceNameClient) Hooks() []Hook {
	return c.hooks.SourceName
}

// Interceptors returns the client interceptors.
func (c *SourceNameClient) Interceptors() []Interceptor {
	return c.inters.SourceName
}

func (c *SourceNameClient) mutate(ctx context.Context, m *SourceNameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceNameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceNameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceNameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SourceName mutation op: %q", m.Op())
	}
}

// SourceNamespaceClient is a client for the SourceNamespace schema.
type SourceNamespaceClient struct {
	config
}

// NewSourceNamespaceClient returns a client for the SourceNamespace from the given config.
func NewSourceNamespaceClient(c config) *SourceNamespaceClient {
	return &SourceNamespaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sourcenamespace.Hooks(f(g(h())))`.
func (c *SourceNamespaceClient) Use(hooks ...Hook) {
	c.hooks.SourceNamespace = append(c.hooks.SourceNamespace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sourcenamespace.Intercept(f(g(h())))`.
func (c *SourceNamespaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.SourceNamespace = append(c.inters.SourceNamespace, interceptors...)
}

// Create returns a builder for creating a SourceNamespace entity.
func (c *SourceNamespaceClient) Create() *SourceNamespaceCreate {
	mutation := newSourceNamespaceMutation(c.config, OpCreate)
	return &SourceNamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SourceNamespace entities.
func (c *SourceNamespaceClient) CreateBulk(builders ...*SourceNamespaceCreate) *SourceNamespaceCreateBulk {
	return &SourceNamespaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SourceNamespace.
func (c *SourceNamespaceClient) Update() *SourceNamespaceUpdate {
	mutation := newSourceNamespaceMutation(c.config, OpUpdate)
	return &SourceNamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceNamespaceClient) UpdateOne(sn *SourceNamespace) *SourceNamespaceUpdateOne {
	mutation := newSourceNamespaceMutation(c.config, OpUpdateOne, withSourceNamespace(sn))
	return &SourceNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceNamespaceClient) UpdateOneID(id int) *SourceNamespaceUpdateOne {
	mutation := newSourceNamespaceMutation(c.config, OpUpdateOne, withSourceNamespaceID(id))
	return &SourceNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SourceNamespace.
func (c *SourceNamespaceClient) Delete() *SourceNamespaceDelete {
	mutation := newSourceNamespaceMutation(c.config, OpDelete)
	return &SourceNamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceNamespaceClient) DeleteOne(sn *SourceNamespace) *SourceNamespaceDeleteOne {
	return c.DeleteOneID(sn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceNamespaceClient) DeleteOneID(id int) *SourceNamespaceDeleteOne {
	builder := c.Delete().Where(sourcenamespace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceNamespaceDeleteOne{builder}
}

// Query returns a query builder for SourceNamespace.
func (c *SourceNamespaceClient) Query() *SourceNamespaceQuery {
	return &SourceNamespaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSourceNamespace},
		inters: c.Interceptors(),
	}
}

// Get returns a SourceNamespace entity by its id.
func (c *SourceNamespaceClient) Get(ctx context.Context, id int) (*SourceNamespace, error) {
	return c.Query().Where(sourcenamespace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceNamespaceClient) GetX(ctx context.Context, id int) *SourceNamespace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySource queries the source edge of a SourceNamespace.
func (c *SourceNamespaceClient) QuerySource(sn *SourceNamespace) *SourceQuery {
	query := (&SourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcenamespace.Table, sourcenamespace.FieldID, id),
			sqlgraph.To(source.Table, source.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, sourcenamespace.SourceTable, sourcenamespace.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNames queries the names edge of a SourceNamespace.
func (c *SourceNamespaceClient) QueryNames(sn *SourceNamespace) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcenamespace.Table, sourcenamespace.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcenamespace.NamesTable, sourcenamespace.NamesColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SourceNamespaceClient) Hooks() []Hook {
	return c.hooks.SourceNamespace
}

// Interceptors returns the client interceptors.
func (c *SourceNamespaceClient) Interceptors() []Interceptor {
	return c.inters.SourceNamespace
}

func (c *SourceNamespaceClient) mutate(ctx context.Context, m *SourceNamespaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceNamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceNamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceNamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SourceNamespace mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Artifact, BuilderNode, Dependency, IsOccurrence, PackageName, PackageNamespace,
		PackageNode, PackageVersion, Source, SourceName, SourceNamespace []ent.Hook
	}
	inters struct {
		Artifact, BuilderNode, Dependency, IsOccurrence, PackageName, PackageNamespace,
		PackageNode, PackageVersion, Source, SourceName,
		SourceNamespace []ent.Interceptor
	}
)
