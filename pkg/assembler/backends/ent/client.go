// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/guacsec/guac/pkg/assembler/backends/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/artifact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/billofmaterials"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/builder"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certification"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifylegal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyscorecard"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvex"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvuln"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/dependency"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hashequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hassourceat"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/isvulnerability"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/license"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/occurrence"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagetype"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pkgequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/scorecard"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/slsaattestation"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcetype"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilityid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilitytype"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Artifact is the client for interacting with the Artifact builders.
	Artifact *ArtifactClient
	// BillOfMaterials is the client for interacting with the BillOfMaterials builders.
	BillOfMaterials *BillOfMaterialsClient
	// Builder is the client for interacting with the Builder builders.
	Builder *BuilderClient
	// Certification is the client for interacting with the Certification builders.
	Certification *CertificationClient
	// CertifyLegal is the client for interacting with the CertifyLegal builders.
	CertifyLegal *CertifyLegalClient
	// CertifyScorecard is the client for interacting with the CertifyScorecard builders.
	CertifyScorecard *CertifyScorecardClient
	// CertifyVex is the client for interacting with the CertifyVex builders.
	CertifyVex *CertifyVexClient
	// CertifyVuln is the client for interacting with the CertifyVuln builders.
	CertifyVuln *CertifyVulnClient
	// Dependency is the client for interacting with the Dependency builders.
	Dependency *DependencyClient
	// HasSourceAt is the client for interacting with the HasSourceAt builders.
	HasSourceAt *HasSourceAtClient
	// HashEqual is the client for interacting with the HashEqual builders.
	HashEqual *HashEqualClient
	// IsVulnerability is the client for interacting with the IsVulnerability builders.
	IsVulnerability *IsVulnerabilityClient
	// License is the client for interacting with the License builders.
	License *LicenseClient
	// Occurrence is the client for interacting with the Occurrence builders.
	Occurrence *OccurrenceClient
	// PackageName is the client for interacting with the PackageName builders.
	PackageName *PackageNameClient
	// PackageNamespace is the client for interacting with the PackageNamespace builders.
	PackageNamespace *PackageNamespaceClient
	// PackageType is the client for interacting with the PackageType builders.
	PackageType *PackageTypeClient
	// PackageVersion is the client for interacting with the PackageVersion builders.
	PackageVersion *PackageVersionClient
	// PkgEqual is the client for interacting with the PkgEqual builders.
	PkgEqual *PkgEqualClient
	// SLSAAttestation is the client for interacting with the SLSAAttestation builders.
	SLSAAttestation *SLSAAttestationClient
	// Scorecard is the client for interacting with the Scorecard builders.
	Scorecard *ScorecardClient
	// SourceName is the client for interacting with the SourceName builders.
	SourceName *SourceNameClient
	// SourceNamespace is the client for interacting with the SourceNamespace builders.
	SourceNamespace *SourceNamespaceClient
	// SourceType is the client for interacting with the SourceType builders.
	SourceType *SourceTypeClient
	// VulnEqual is the client for interacting with the VulnEqual builders.
	VulnEqual *VulnEqualClient
	// VulnerabilityID is the client for interacting with the VulnerabilityID builders.
	VulnerabilityID *VulnerabilityIDClient
	// VulnerabilityType is the client for interacting with the VulnerabilityType builders.
	VulnerabilityType *VulnerabilityTypeClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Artifact = NewArtifactClient(c.config)
	c.BillOfMaterials = NewBillOfMaterialsClient(c.config)
	c.Builder = NewBuilderClient(c.config)
	c.Certification = NewCertificationClient(c.config)
	c.CertifyLegal = NewCertifyLegalClient(c.config)
	c.CertifyScorecard = NewCertifyScorecardClient(c.config)
	c.CertifyVex = NewCertifyVexClient(c.config)
	c.CertifyVuln = NewCertifyVulnClient(c.config)
	c.Dependency = NewDependencyClient(c.config)
	c.HasSourceAt = NewHasSourceAtClient(c.config)
	c.HashEqual = NewHashEqualClient(c.config)
	c.IsVulnerability = NewIsVulnerabilityClient(c.config)
	c.License = NewLicenseClient(c.config)
	c.Occurrence = NewOccurrenceClient(c.config)
	c.PackageName = NewPackageNameClient(c.config)
	c.PackageNamespace = NewPackageNamespaceClient(c.config)
	c.PackageType = NewPackageTypeClient(c.config)
	c.PackageVersion = NewPackageVersionClient(c.config)
	c.PkgEqual = NewPkgEqualClient(c.config)
	c.SLSAAttestation = NewSLSAAttestationClient(c.config)
	c.Scorecard = NewScorecardClient(c.config)
	c.SourceName = NewSourceNameClient(c.config)
	c.SourceNamespace = NewSourceNamespaceClient(c.config)
	c.SourceType = NewSourceTypeClient(c.config)
	c.VulnEqual = NewVulnEqualClient(c.config)
	c.VulnerabilityID = NewVulnerabilityIDClient(c.config)
	c.VulnerabilityType = NewVulnerabilityTypeClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Artifact:          NewArtifactClient(cfg),
		BillOfMaterials:   NewBillOfMaterialsClient(cfg),
		Builder:           NewBuilderClient(cfg),
		Certification:     NewCertificationClient(cfg),
		CertifyLegal:      NewCertifyLegalClient(cfg),
		CertifyScorecard:  NewCertifyScorecardClient(cfg),
		CertifyVex:        NewCertifyVexClient(cfg),
		CertifyVuln:       NewCertifyVulnClient(cfg),
		Dependency:        NewDependencyClient(cfg),
		HasSourceAt:       NewHasSourceAtClient(cfg),
		HashEqual:         NewHashEqualClient(cfg),
		IsVulnerability:   NewIsVulnerabilityClient(cfg),
		License:           NewLicenseClient(cfg),
		Occurrence:        NewOccurrenceClient(cfg),
		PackageName:       NewPackageNameClient(cfg),
		PackageNamespace:  NewPackageNamespaceClient(cfg),
		PackageType:       NewPackageTypeClient(cfg),
		PackageVersion:    NewPackageVersionClient(cfg),
		PkgEqual:          NewPkgEqualClient(cfg),
		SLSAAttestation:   NewSLSAAttestationClient(cfg),
		Scorecard:         NewScorecardClient(cfg),
		SourceName:        NewSourceNameClient(cfg),
		SourceNamespace:   NewSourceNamespaceClient(cfg),
		SourceType:        NewSourceTypeClient(cfg),
		VulnEqual:         NewVulnEqualClient(cfg),
		VulnerabilityID:   NewVulnerabilityIDClient(cfg),
		VulnerabilityType: NewVulnerabilityTypeClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Artifact:          NewArtifactClient(cfg),
		BillOfMaterials:   NewBillOfMaterialsClient(cfg),
		Builder:           NewBuilderClient(cfg),
		Certification:     NewCertificationClient(cfg),
		CertifyLegal:      NewCertifyLegalClient(cfg),
		CertifyScorecard:  NewCertifyScorecardClient(cfg),
		CertifyVex:        NewCertifyVexClient(cfg),
		CertifyVuln:       NewCertifyVulnClient(cfg),
		Dependency:        NewDependencyClient(cfg),
		HasSourceAt:       NewHasSourceAtClient(cfg),
		HashEqual:         NewHashEqualClient(cfg),
		IsVulnerability:   NewIsVulnerabilityClient(cfg),
		License:           NewLicenseClient(cfg),
		Occurrence:        NewOccurrenceClient(cfg),
		PackageName:       NewPackageNameClient(cfg),
		PackageNamespace:  NewPackageNamespaceClient(cfg),
		PackageType:       NewPackageTypeClient(cfg),
		PackageVersion:    NewPackageVersionClient(cfg),
		PkgEqual:          NewPkgEqualClient(cfg),
		SLSAAttestation:   NewSLSAAttestationClient(cfg),
		Scorecard:         NewScorecardClient(cfg),
		SourceName:        NewSourceNameClient(cfg),
		SourceNamespace:   NewSourceNamespaceClient(cfg),
		SourceType:        NewSourceTypeClient(cfg),
		VulnEqual:         NewVulnEqualClient(cfg),
		VulnerabilityID:   NewVulnerabilityIDClient(cfg),
		VulnerabilityType: NewVulnerabilityTypeClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Artifact.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Artifact, c.BillOfMaterials, c.Builder, c.Certification, c.CertifyLegal,
		c.CertifyScorecard, c.CertifyVex, c.CertifyVuln, c.Dependency, c.HasSourceAt,
		c.HashEqual, c.IsVulnerability, c.License, c.Occurrence, c.PackageName,
		c.PackageNamespace, c.PackageType, c.PackageVersion, c.PkgEqual,
		c.SLSAAttestation, c.Scorecard, c.SourceName, c.SourceNamespace, c.SourceType,
		c.VulnEqual, c.VulnerabilityID, c.VulnerabilityType,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Artifact, c.BillOfMaterials, c.Builder, c.Certification, c.CertifyLegal,
		c.CertifyScorecard, c.CertifyVex, c.CertifyVuln, c.Dependency, c.HasSourceAt,
		c.HashEqual, c.IsVulnerability, c.License, c.Occurrence, c.PackageName,
		c.PackageNamespace, c.PackageType, c.PackageVersion, c.PkgEqual,
		c.SLSAAttestation, c.Scorecard, c.SourceName, c.SourceNamespace, c.SourceType,
		c.VulnEqual, c.VulnerabilityID, c.VulnerabilityType,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ArtifactMutation:
		return c.Artifact.mutate(ctx, m)
	case *BillOfMaterialsMutation:
		return c.BillOfMaterials.mutate(ctx, m)
	case *BuilderMutation:
		return c.Builder.mutate(ctx, m)
	case *CertificationMutation:
		return c.Certification.mutate(ctx, m)
	case *CertifyLegalMutation:
		return c.CertifyLegal.mutate(ctx, m)
	case *CertifyScorecardMutation:
		return c.CertifyScorecard.mutate(ctx, m)
	case *CertifyVexMutation:
		return c.CertifyVex.mutate(ctx, m)
	case *CertifyVulnMutation:
		return c.CertifyVuln.mutate(ctx, m)
	case *DependencyMutation:
		return c.Dependency.mutate(ctx, m)
	case *HasSourceAtMutation:
		return c.HasSourceAt.mutate(ctx, m)
	case *HashEqualMutation:
		return c.HashEqual.mutate(ctx, m)
	case *IsVulnerabilityMutation:
		return c.IsVulnerability.mutate(ctx, m)
	case *LicenseMutation:
		return c.License.mutate(ctx, m)
	case *OccurrenceMutation:
		return c.Occurrence.mutate(ctx, m)
	case *PackageNameMutation:
		return c.PackageName.mutate(ctx, m)
	case *PackageNamespaceMutation:
		return c.PackageNamespace.mutate(ctx, m)
	case *PackageTypeMutation:
		return c.PackageType.mutate(ctx, m)
	case *PackageVersionMutation:
		return c.PackageVersion.mutate(ctx, m)
	case *PkgEqualMutation:
		return c.PkgEqual.mutate(ctx, m)
	case *SLSAAttestationMutation:
		return c.SLSAAttestation.mutate(ctx, m)
	case *ScorecardMutation:
		return c.Scorecard.mutate(ctx, m)
	case *SourceNameMutation:
		return c.SourceName.mutate(ctx, m)
	case *SourceNamespaceMutation:
		return c.SourceNamespace.mutate(ctx, m)
	case *SourceTypeMutation:
		return c.SourceType.mutate(ctx, m)
	case *VulnEqualMutation:
		return c.VulnEqual.mutate(ctx, m)
	case *VulnerabilityIDMutation:
		return c.VulnerabilityID.mutate(ctx, m)
	case *VulnerabilityTypeMutation:
		return c.VulnerabilityType.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ArtifactClient is a client for the Artifact schema.
type ArtifactClient struct {
	config
}

// NewArtifactClient returns a client for the Artifact from the given config.
func NewArtifactClient(c config) *ArtifactClient {
	return &ArtifactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artifact.Hooks(f(g(h())))`.
func (c *ArtifactClient) Use(hooks ...Hook) {
	c.hooks.Artifact = append(c.hooks.Artifact, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `artifact.Intercept(f(g(h())))`.
func (c *ArtifactClient) Intercept(interceptors ...Interceptor) {
	c.inters.Artifact = append(c.inters.Artifact, interceptors...)
}

// Create returns a builder for creating a Artifact entity.
func (c *ArtifactClient) Create() *ArtifactCreate {
	mutation := newArtifactMutation(c.config, OpCreate)
	return &ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Artifact entities.
func (c *ArtifactClient) CreateBulk(builders ...*ArtifactCreate) *ArtifactCreateBulk {
	return &ArtifactCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ArtifactClient) MapCreateBulk(slice any, setFunc func(*ArtifactCreate, int)) *ArtifactCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ArtifactCreateBulk{err: fmt.Errorf("calling to ArtifactClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ArtifactCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ArtifactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Artifact.
func (c *ArtifactClient) Update() *ArtifactUpdate {
	mutation := newArtifactMutation(c.config, OpUpdate)
	return &ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtifactClient) UpdateOne(a *Artifact) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifact(a))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtifactClient) UpdateOneID(id int) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifactID(id))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Artifact.
func (c *ArtifactClient) Delete() *ArtifactDelete {
	mutation := newArtifactMutation(c.config, OpDelete)
	return &ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtifactClient) DeleteOne(a *Artifact) *ArtifactDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtifactClient) DeleteOneID(id int) *ArtifactDeleteOne {
	builder := c.Delete().Where(artifact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtifactDeleteOne{builder}
}

// Query returns a query builder for Artifact.
func (c *ArtifactClient) Query() *ArtifactQuery {
	return &ArtifactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArtifact},
		inters: c.Interceptors(),
	}
}

// Get returns a Artifact entity by its id.
func (c *ArtifactClient) Get(ctx context.Context, id int) (*Artifact, error) {
	return c.Query().Where(artifact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtifactClient) GetX(ctx context.Context, id int) *Artifact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOccurrences queries the occurrences edge of a Artifact.
func (c *ArtifactClient) QueryOccurrences(a *Artifact) *OccurrenceQuery {
	query := (&OccurrenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(occurrence.Table, occurrence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.OccurrencesTable, artifact.OccurrencesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySbom queries the sbom edge of a Artifact.
func (c *ArtifactClient) QuerySbom(a *Artifact) *BillOfMaterialsQuery {
	query := (&BillOfMaterialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(billofmaterials.Table, billofmaterials.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.SbomTable, artifact.SbomColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttestations queries the attestations edge of a Artifact.
func (c *ArtifactClient) QueryAttestations(a *Artifact) *SLSAAttestationQuery {
	query := (&SLSAAttestationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(slsaattestation.Table, slsaattestation.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, artifact.AttestationsTable, artifact.AttestationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySame queries the same edge of a Artifact.
func (c *ArtifactClient) QuerySame(a *Artifact) *HashEqualQuery {
	query := (&HashEqualClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(hashequal.Table, hashequal.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, artifact.SameTable, artifact.SamePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtifactClient) Hooks() []Hook {
	return c.hooks.Artifact
}

// Interceptors returns the client interceptors.
func (c *ArtifactClient) Interceptors() []Interceptor {
	return c.inters.Artifact
}

func (c *ArtifactClient) mutate(ctx context.Context, m *ArtifactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Artifact mutation op: %q", m.Op())
	}
}

// BillOfMaterialsClient is a client for the BillOfMaterials schema.
type BillOfMaterialsClient struct {
	config
}

// NewBillOfMaterialsClient returns a client for the BillOfMaterials from the given config.
func NewBillOfMaterialsClient(c config) *BillOfMaterialsClient {
	return &BillOfMaterialsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `billofmaterials.Hooks(f(g(h())))`.
func (c *BillOfMaterialsClient) Use(hooks ...Hook) {
	c.hooks.BillOfMaterials = append(c.hooks.BillOfMaterials, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `billofmaterials.Intercept(f(g(h())))`.
func (c *BillOfMaterialsClient) Intercept(interceptors ...Interceptor) {
	c.inters.BillOfMaterials = append(c.inters.BillOfMaterials, interceptors...)
}

// Create returns a builder for creating a BillOfMaterials entity.
func (c *BillOfMaterialsClient) Create() *BillOfMaterialsCreate {
	mutation := newBillOfMaterialsMutation(c.config, OpCreate)
	return &BillOfMaterialsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BillOfMaterials entities.
func (c *BillOfMaterialsClient) CreateBulk(builders ...*BillOfMaterialsCreate) *BillOfMaterialsCreateBulk {
	return &BillOfMaterialsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BillOfMaterialsClient) MapCreateBulk(slice any, setFunc func(*BillOfMaterialsCreate, int)) *BillOfMaterialsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BillOfMaterialsCreateBulk{err: fmt.Errorf("calling to BillOfMaterialsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BillOfMaterialsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BillOfMaterialsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BillOfMaterials.
func (c *BillOfMaterialsClient) Update() *BillOfMaterialsUpdate {
	mutation := newBillOfMaterialsMutation(c.config, OpUpdate)
	return &BillOfMaterialsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BillOfMaterialsClient) UpdateOne(bom *BillOfMaterials) *BillOfMaterialsUpdateOne {
	mutation := newBillOfMaterialsMutation(c.config, OpUpdateOne, withBillOfMaterials(bom))
	return &BillOfMaterialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BillOfMaterialsClient) UpdateOneID(id int) *BillOfMaterialsUpdateOne {
	mutation := newBillOfMaterialsMutation(c.config, OpUpdateOne, withBillOfMaterialsID(id))
	return &BillOfMaterialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BillOfMaterials.
func (c *BillOfMaterialsClient) Delete() *BillOfMaterialsDelete {
	mutation := newBillOfMaterialsMutation(c.config, OpDelete)
	return &BillOfMaterialsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BillOfMaterialsClient) DeleteOne(bom *BillOfMaterials) *BillOfMaterialsDeleteOne {
	return c.DeleteOneID(bom.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BillOfMaterialsClient) DeleteOneID(id int) *BillOfMaterialsDeleteOne {
	builder := c.Delete().Where(billofmaterials.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BillOfMaterialsDeleteOne{builder}
}

// Query returns a query builder for BillOfMaterials.
func (c *BillOfMaterialsClient) Query() *BillOfMaterialsQuery {
	return &BillOfMaterialsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBillOfMaterials},
		inters: c.Interceptors(),
	}
}

// Get returns a BillOfMaterials entity by its id.
func (c *BillOfMaterialsClient) Get(ctx context.Context, id int) (*BillOfMaterials, error) {
	return c.Query().Where(billofmaterials.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BillOfMaterialsClient) GetX(ctx context.Context, id int) *BillOfMaterials {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a BillOfMaterials.
func (c *BillOfMaterialsClient) QueryPackage(bom *BillOfMaterials) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bom.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(billofmaterials.Table, billofmaterials.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, billofmaterials.PackageTable, billofmaterials.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(bom.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifact queries the artifact edge of a BillOfMaterials.
func (c *BillOfMaterialsClient) QueryArtifact(bom *BillOfMaterials) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bom.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(billofmaterials.Table, billofmaterials.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, billofmaterials.ArtifactTable, billofmaterials.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(bom.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BillOfMaterialsClient) Hooks() []Hook {
	return c.hooks.BillOfMaterials
}

// Interceptors returns the client interceptors.
func (c *BillOfMaterialsClient) Interceptors() []Interceptor {
	return c.inters.BillOfMaterials
}

func (c *BillOfMaterialsClient) mutate(ctx context.Context, m *BillOfMaterialsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BillOfMaterialsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BillOfMaterialsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BillOfMaterialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BillOfMaterialsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BillOfMaterials mutation op: %q", m.Op())
	}
}

// BuilderClient is a client for the Builder schema.
type BuilderClient struct {
	config
}

// NewBuilderClient returns a client for the Builder from the given config.
func NewBuilderClient(c config) *BuilderClient {
	return &BuilderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `builder.Hooks(f(g(h())))`.
func (c *BuilderClient) Use(hooks ...Hook) {
	c.hooks.Builder = append(c.hooks.Builder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `builder.Intercept(f(g(h())))`.
func (c *BuilderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Builder = append(c.inters.Builder, interceptors...)
}

// Create returns a builder for creating a Builder entity.
func (c *BuilderClient) Create() *BuilderCreate {
	mutation := newBuilderMutation(c.config, OpCreate)
	return &BuilderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Builder entities.
func (c *BuilderClient) CreateBulk(builders ...*BuilderCreate) *BuilderCreateBulk {
	return &BuilderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BuilderClient) MapCreateBulk(slice any, setFunc func(*BuilderCreate, int)) *BuilderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BuilderCreateBulk{err: fmt.Errorf("calling to BuilderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BuilderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BuilderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Builder.
func (c *BuilderClient) Update() *BuilderUpdate {
	mutation := newBuilderMutation(c.config, OpUpdate)
	return &BuilderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BuilderClient) UpdateOne(b *Builder) *BuilderUpdateOne {
	mutation := newBuilderMutation(c.config, OpUpdateOne, withBuilder(b))
	return &BuilderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BuilderClient) UpdateOneID(id int) *BuilderUpdateOne {
	mutation := newBuilderMutation(c.config, OpUpdateOne, withBuilderID(id))
	return &BuilderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Builder.
func (c *BuilderClient) Delete() *BuilderDelete {
	mutation := newBuilderMutation(c.config, OpDelete)
	return &BuilderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BuilderClient) DeleteOne(b *Builder) *BuilderDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BuilderClient) DeleteOneID(id int) *BuilderDeleteOne {
	builderC := c.Delete().Where(builder.ID(id))
	builderC.mutation.id = &id
	builderC.mutation.op = OpDeleteOne
	return &BuilderDeleteOne{builderC}
}

// Query returns a query builder for Builder.
func (c *BuilderClient) Query() *BuilderQuery {
	return &BuilderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBuilder},
		inters: c.Interceptors(),
	}
}

// Get returns a Builder entity by its id.
func (c *BuilderClient) Get(ctx context.Context, id int) (*Builder, error) {
	return c.Query().Where(builder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BuilderClient) GetX(ctx context.Context, id int) *Builder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySlsaAttestations queries the slsa_attestations edge of a Builder.
func (c *BuilderClient) QuerySlsaAttestations(b *Builder) *SLSAAttestationQuery {
	query := (&SLSAAttestationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(builder.Table, builder.FieldID, id),
			sqlgraph.To(slsaattestation.Table, slsaattestation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, builder.SlsaAttestationsTable, builder.SlsaAttestationsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BuilderClient) Hooks() []Hook {
	return c.hooks.Builder
}

// Interceptors returns the client interceptors.
func (c *BuilderClient) Interceptors() []Interceptor {
	return c.inters.Builder
}

func (c *BuilderClient) mutate(ctx context.Context, m *BuilderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BuilderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BuilderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BuilderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BuilderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Builder mutation op: %q", m.Op())
	}
}

// CertificationClient is a client for the Certification schema.
type CertificationClient struct {
	config
}

// NewCertificationClient returns a client for the Certification from the given config.
func NewCertificationClient(c config) *CertificationClient {
	return &CertificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certification.Hooks(f(g(h())))`.
func (c *CertificationClient) Use(hooks ...Hook) {
	c.hooks.Certification = append(c.hooks.Certification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certification.Intercept(f(g(h())))`.
func (c *CertificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Certification = append(c.inters.Certification, interceptors...)
}

// Create returns a builder for creating a Certification entity.
func (c *CertificationClient) Create() *CertificationCreate {
	mutation := newCertificationMutation(c.config, OpCreate)
	return &CertificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Certification entities.
func (c *CertificationClient) CreateBulk(builders ...*CertificationCreate) *CertificationCreateBulk {
	return &CertificationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertificationClient) MapCreateBulk(slice any, setFunc func(*CertificationCreate, int)) *CertificationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertificationCreateBulk{err: fmt.Errorf("calling to CertificationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertificationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Certification.
func (c *CertificationClient) Update() *CertificationUpdate {
	mutation := newCertificationMutation(c.config, OpUpdate)
	return &CertificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertificationClient) UpdateOne(ce *Certification) *CertificationUpdateOne {
	mutation := newCertificationMutation(c.config, OpUpdateOne, withCertification(ce))
	return &CertificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertificationClient) UpdateOneID(id int) *CertificationUpdateOne {
	mutation := newCertificationMutation(c.config, OpUpdateOne, withCertificationID(id))
	return &CertificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Certification.
func (c *CertificationClient) Delete() *CertificationDelete {
	mutation := newCertificationMutation(c.config, OpDelete)
	return &CertificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertificationClient) DeleteOne(ce *Certification) *CertificationDeleteOne {
	return c.DeleteOneID(ce.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertificationClient) DeleteOneID(id int) *CertificationDeleteOne {
	builder := c.Delete().Where(certification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertificationDeleteOne{builder}
}

// Query returns a query builder for Certification.
func (c *CertificationClient) Query() *CertificationQuery {
	return &CertificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertification},
		inters: c.Interceptors(),
	}
}

// Get returns a Certification entity by its id.
func (c *CertificationClient) Get(ctx context.Context, id int) (*Certification, error) {
	return c.Query().Where(certification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertificationClient) GetX(ctx context.Context, id int) *Certification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySource queries the source edge of a Certification.
func (c *CertificationClient) QuerySource(ce *Certification) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certification.Table, certification.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certification.SourceTable, certification.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPackageVersion queries the package_version edge of a Certification.
func (c *CertificationClient) QueryPackageVersion(ce *Certification) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certification.Table, certification.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certification.PackageVersionTable, certification.PackageVersionColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAllVersions queries the all_versions edge of a Certification.
func (c *CertificationClient) QueryAllVersions(ce *Certification) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certification.Table, certification.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certification.AllVersionsTable, certification.AllVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifact queries the artifact edge of a Certification.
func (c *CertificationClient) QueryArtifact(ce *Certification) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certification.Table, certification.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certification.ArtifactTable, certification.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertificationClient) Hooks() []Hook {
	return c.hooks.Certification
}

// Interceptors returns the client interceptors.
func (c *CertificationClient) Interceptors() []Interceptor {
	return c.inters.Certification
}

func (c *CertificationClient) mutate(ctx context.Context, m *CertificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Certification mutation op: %q", m.Op())
	}
}

// CertifyLegalClient is a client for the CertifyLegal schema.
type CertifyLegalClient struct {
	config
}

// NewCertifyLegalClient returns a client for the CertifyLegal from the given config.
func NewCertifyLegalClient(c config) *CertifyLegalClient {
	return &CertifyLegalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certifylegal.Hooks(f(g(h())))`.
func (c *CertifyLegalClient) Use(hooks ...Hook) {
	c.hooks.CertifyLegal = append(c.hooks.CertifyLegal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certifylegal.Intercept(f(g(h())))`.
func (c *CertifyLegalClient) Intercept(interceptors ...Interceptor) {
	c.inters.CertifyLegal = append(c.inters.CertifyLegal, interceptors...)
}

// Create returns a builder for creating a CertifyLegal entity.
func (c *CertifyLegalClient) Create() *CertifyLegalCreate {
	mutation := newCertifyLegalMutation(c.config, OpCreate)
	return &CertifyLegalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CertifyLegal entities.
func (c *CertifyLegalClient) CreateBulk(builders ...*CertifyLegalCreate) *CertifyLegalCreateBulk {
	return &CertifyLegalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertifyLegalClient) MapCreateBulk(slice any, setFunc func(*CertifyLegalCreate, int)) *CertifyLegalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertifyLegalCreateBulk{err: fmt.Errorf("calling to CertifyLegalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertifyLegalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertifyLegalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CertifyLegal.
func (c *CertifyLegalClient) Update() *CertifyLegalUpdate {
	mutation := newCertifyLegalMutation(c.config, OpUpdate)
	return &CertifyLegalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertifyLegalClient) UpdateOne(cl *CertifyLegal) *CertifyLegalUpdateOne {
	mutation := newCertifyLegalMutation(c.config, OpUpdateOne, withCertifyLegal(cl))
	return &CertifyLegalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertifyLegalClient) UpdateOneID(id int) *CertifyLegalUpdateOne {
	mutation := newCertifyLegalMutation(c.config, OpUpdateOne, withCertifyLegalID(id))
	return &CertifyLegalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CertifyLegal.
func (c *CertifyLegalClient) Delete() *CertifyLegalDelete {
	mutation := newCertifyLegalMutation(c.config, OpDelete)
	return &CertifyLegalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertifyLegalClient) DeleteOne(cl *CertifyLegal) *CertifyLegalDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertifyLegalClient) DeleteOneID(id int) *CertifyLegalDeleteOne {
	builder := c.Delete().Where(certifylegal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertifyLegalDeleteOne{builder}
}

// Query returns a query builder for CertifyLegal.
func (c *CertifyLegalClient) Query() *CertifyLegalQuery {
	return &CertifyLegalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertifyLegal},
		inters: c.Interceptors(),
	}
}

// Get returns a CertifyLegal entity by its id.
func (c *CertifyLegalClient) Get(ctx context.Context, id int) (*CertifyLegal, error) {
	return c.Query().Where(certifylegal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertifyLegalClient) GetX(ctx context.Context, id int) *CertifyLegal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a CertifyLegal.
func (c *CertifyLegalClient) QueryPackage(cl *CertifyLegal) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifylegal.Table, certifylegal.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifylegal.PackageTable, certifylegal.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySource queries the source edge of a CertifyLegal.
func (c *CertifyLegalClient) QuerySource(cl *CertifyLegal) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifylegal.Table, certifylegal.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifylegal.SourceTable, certifylegal.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeclaredLicenses queries the declared_licenses edge of a CertifyLegal.
func (c *CertifyLegalClient) QueryDeclaredLicenses(cl *CertifyLegal) *LicenseQuery {
	query := (&LicenseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifylegal.Table, certifylegal.FieldID, id),
			sqlgraph.To(license.Table, license.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, certifylegal.DeclaredLicensesTable, certifylegal.DeclaredLicensesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscoveredLicenses queries the discovered_licenses edge of a CertifyLegal.
func (c *CertifyLegalClient) QueryDiscoveredLicenses(cl *CertifyLegal) *LicenseQuery {
	query := (&LicenseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifylegal.Table, certifylegal.FieldID, id),
			sqlgraph.To(license.Table, license.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, certifylegal.DiscoveredLicensesTable, certifylegal.DiscoveredLicensesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertifyLegalClient) Hooks() []Hook {
	return c.hooks.CertifyLegal
}

// Interceptors returns the client interceptors.
func (c *CertifyLegalClient) Interceptors() []Interceptor {
	return c.inters.CertifyLegal
}

func (c *CertifyLegalClient) mutate(ctx context.Context, m *CertifyLegalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertifyLegalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertifyLegalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertifyLegalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertifyLegalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CertifyLegal mutation op: %q", m.Op())
	}
}

// CertifyScorecardClient is a client for the CertifyScorecard schema.
type CertifyScorecardClient struct {
	config
}

// NewCertifyScorecardClient returns a client for the CertifyScorecard from the given config.
func NewCertifyScorecardClient(c config) *CertifyScorecardClient {
	return &CertifyScorecardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certifyscorecard.Hooks(f(g(h())))`.
func (c *CertifyScorecardClient) Use(hooks ...Hook) {
	c.hooks.CertifyScorecard = append(c.hooks.CertifyScorecard, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certifyscorecard.Intercept(f(g(h())))`.
func (c *CertifyScorecardClient) Intercept(interceptors ...Interceptor) {
	c.inters.CertifyScorecard = append(c.inters.CertifyScorecard, interceptors...)
}

// Create returns a builder for creating a CertifyScorecard entity.
func (c *CertifyScorecardClient) Create() *CertifyScorecardCreate {
	mutation := newCertifyScorecardMutation(c.config, OpCreate)
	return &CertifyScorecardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CertifyScorecard entities.
func (c *CertifyScorecardClient) CreateBulk(builders ...*CertifyScorecardCreate) *CertifyScorecardCreateBulk {
	return &CertifyScorecardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertifyScorecardClient) MapCreateBulk(slice any, setFunc func(*CertifyScorecardCreate, int)) *CertifyScorecardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertifyScorecardCreateBulk{err: fmt.Errorf("calling to CertifyScorecardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertifyScorecardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertifyScorecardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CertifyScorecard.
func (c *CertifyScorecardClient) Update() *CertifyScorecardUpdate {
	mutation := newCertifyScorecardMutation(c.config, OpUpdate)
	return &CertifyScorecardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertifyScorecardClient) UpdateOne(cs *CertifyScorecard) *CertifyScorecardUpdateOne {
	mutation := newCertifyScorecardMutation(c.config, OpUpdateOne, withCertifyScorecard(cs))
	return &CertifyScorecardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertifyScorecardClient) UpdateOneID(id int) *CertifyScorecardUpdateOne {
	mutation := newCertifyScorecardMutation(c.config, OpUpdateOne, withCertifyScorecardID(id))
	return &CertifyScorecardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CertifyScorecard.
func (c *CertifyScorecardClient) Delete() *CertifyScorecardDelete {
	mutation := newCertifyScorecardMutation(c.config, OpDelete)
	return &CertifyScorecardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertifyScorecardClient) DeleteOne(cs *CertifyScorecard) *CertifyScorecardDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertifyScorecardClient) DeleteOneID(id int) *CertifyScorecardDeleteOne {
	builder := c.Delete().Where(certifyscorecard.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertifyScorecardDeleteOne{builder}
}

// Query returns a query builder for CertifyScorecard.
func (c *CertifyScorecardClient) Query() *CertifyScorecardQuery {
	return &CertifyScorecardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertifyScorecard},
		inters: c.Interceptors(),
	}
}

// Get returns a CertifyScorecard entity by its id.
func (c *CertifyScorecardClient) Get(ctx context.Context, id int) (*CertifyScorecard, error) {
	return c.Query().Where(certifyscorecard.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertifyScorecardClient) GetX(ctx context.Context, id int) *CertifyScorecard {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScorecard queries the scorecard edge of a CertifyScorecard.
func (c *CertifyScorecardClient) QueryScorecard(cs *CertifyScorecard) *ScorecardQuery {
	query := (&ScorecardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifyscorecard.Table, certifyscorecard.FieldID, id),
			sqlgraph.To(scorecard.Table, scorecard.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, certifyscorecard.ScorecardTable, certifyscorecard.ScorecardColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySource queries the source edge of a CertifyScorecard.
func (c *CertifyScorecardClient) QuerySource(cs *CertifyScorecard) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifyscorecard.Table, certifyscorecard.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifyscorecard.SourceTable, certifyscorecard.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertifyScorecardClient) Hooks() []Hook {
	return c.hooks.CertifyScorecard
}

// Interceptors returns the client interceptors.
func (c *CertifyScorecardClient) Interceptors() []Interceptor {
	return c.inters.CertifyScorecard
}

func (c *CertifyScorecardClient) mutate(ctx context.Context, m *CertifyScorecardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertifyScorecardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertifyScorecardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertifyScorecardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertifyScorecardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CertifyScorecard mutation op: %q", m.Op())
	}
}

// CertifyVexClient is a client for the CertifyVex schema.
type CertifyVexClient struct {
	config
}

// NewCertifyVexClient returns a client for the CertifyVex from the given config.
func NewCertifyVexClient(c config) *CertifyVexClient {
	return &CertifyVexClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certifyvex.Hooks(f(g(h())))`.
func (c *CertifyVexClient) Use(hooks ...Hook) {
	c.hooks.CertifyVex = append(c.hooks.CertifyVex, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certifyvex.Intercept(f(g(h())))`.
func (c *CertifyVexClient) Intercept(interceptors ...Interceptor) {
	c.inters.CertifyVex = append(c.inters.CertifyVex, interceptors...)
}

// Create returns a builder for creating a CertifyVex entity.
func (c *CertifyVexClient) Create() *CertifyVexCreate {
	mutation := newCertifyVexMutation(c.config, OpCreate)
	return &CertifyVexCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CertifyVex entities.
func (c *CertifyVexClient) CreateBulk(builders ...*CertifyVexCreate) *CertifyVexCreateBulk {
	return &CertifyVexCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertifyVexClient) MapCreateBulk(slice any, setFunc func(*CertifyVexCreate, int)) *CertifyVexCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertifyVexCreateBulk{err: fmt.Errorf("calling to CertifyVexClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertifyVexCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertifyVexCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CertifyVex.
func (c *CertifyVexClient) Update() *CertifyVexUpdate {
	mutation := newCertifyVexMutation(c.config, OpUpdate)
	return &CertifyVexUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertifyVexClient) UpdateOne(cv *CertifyVex) *CertifyVexUpdateOne {
	mutation := newCertifyVexMutation(c.config, OpUpdateOne, withCertifyVex(cv))
	return &CertifyVexUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertifyVexClient) UpdateOneID(id int) *CertifyVexUpdateOne {
	mutation := newCertifyVexMutation(c.config, OpUpdateOne, withCertifyVexID(id))
	return &CertifyVexUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CertifyVex.
func (c *CertifyVexClient) Delete() *CertifyVexDelete {
	mutation := newCertifyVexMutation(c.config, OpDelete)
	return &CertifyVexDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertifyVexClient) DeleteOne(cv *CertifyVex) *CertifyVexDeleteOne {
	return c.DeleteOneID(cv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertifyVexClient) DeleteOneID(id int) *CertifyVexDeleteOne {
	builder := c.Delete().Where(certifyvex.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertifyVexDeleteOne{builder}
}

// Query returns a query builder for CertifyVex.
func (c *CertifyVexClient) Query() *CertifyVexQuery {
	return &CertifyVexQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertifyVex},
		inters: c.Interceptors(),
	}
}

// Get returns a CertifyVex entity by its id.
func (c *CertifyVexClient) Get(ctx context.Context, id int) (*CertifyVex, error) {
	return c.Query().Where(certifyvex.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertifyVexClient) GetX(ctx context.Context, id int) *CertifyVex {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a CertifyVex.
func (c *CertifyVexClient) QueryPackage(cv *CertifyVex) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifyvex.Table, certifyvex.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifyvex.PackageTable, certifyvex.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifact queries the artifact edge of a CertifyVex.
func (c *CertifyVexClient) QueryArtifact(cv *CertifyVex) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifyvex.Table, certifyvex.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifyvex.ArtifactTable, certifyvex.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerability queries the vulnerability edge of a CertifyVex.
func (c *CertifyVexClient) QueryVulnerability(cv *CertifyVex) *VulnerabilityTypeQuery {
	query := (&VulnerabilityTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifyvex.Table, certifyvex.FieldID, id),
			sqlgraph.To(vulnerabilitytype.Table, vulnerabilitytype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifyvex.VulnerabilityTable, certifyvex.VulnerabilityColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertifyVexClient) Hooks() []Hook {
	return c.hooks.CertifyVex
}

// Interceptors returns the client interceptors.
func (c *CertifyVexClient) Interceptors() []Interceptor {
	return c.inters.CertifyVex
}

func (c *CertifyVexClient) mutate(ctx context.Context, m *CertifyVexMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertifyVexCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertifyVexUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertifyVexUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertifyVexDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CertifyVex mutation op: %q", m.Op())
	}
}

// CertifyVulnClient is a client for the CertifyVuln schema.
type CertifyVulnClient struct {
	config
}

// NewCertifyVulnClient returns a client for the CertifyVuln from the given config.
func NewCertifyVulnClient(c config) *CertifyVulnClient {
	return &CertifyVulnClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certifyvuln.Hooks(f(g(h())))`.
func (c *CertifyVulnClient) Use(hooks ...Hook) {
	c.hooks.CertifyVuln = append(c.hooks.CertifyVuln, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certifyvuln.Intercept(f(g(h())))`.
func (c *CertifyVulnClient) Intercept(interceptors ...Interceptor) {
	c.inters.CertifyVuln = append(c.inters.CertifyVuln, interceptors...)
}

// Create returns a builder for creating a CertifyVuln entity.
func (c *CertifyVulnClient) Create() *CertifyVulnCreate {
	mutation := newCertifyVulnMutation(c.config, OpCreate)
	return &CertifyVulnCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CertifyVuln entities.
func (c *CertifyVulnClient) CreateBulk(builders ...*CertifyVulnCreate) *CertifyVulnCreateBulk {
	return &CertifyVulnCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertifyVulnClient) MapCreateBulk(slice any, setFunc func(*CertifyVulnCreate, int)) *CertifyVulnCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertifyVulnCreateBulk{err: fmt.Errorf("calling to CertifyVulnClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertifyVulnCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertifyVulnCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CertifyVuln.
func (c *CertifyVulnClient) Update() *CertifyVulnUpdate {
	mutation := newCertifyVulnMutation(c.config, OpUpdate)
	return &CertifyVulnUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertifyVulnClient) UpdateOne(cv *CertifyVuln) *CertifyVulnUpdateOne {
	mutation := newCertifyVulnMutation(c.config, OpUpdateOne, withCertifyVuln(cv))
	return &CertifyVulnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertifyVulnClient) UpdateOneID(id int) *CertifyVulnUpdateOne {
	mutation := newCertifyVulnMutation(c.config, OpUpdateOne, withCertifyVulnID(id))
	return &CertifyVulnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CertifyVuln.
func (c *CertifyVulnClient) Delete() *CertifyVulnDelete {
	mutation := newCertifyVulnMutation(c.config, OpDelete)
	return &CertifyVulnDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertifyVulnClient) DeleteOne(cv *CertifyVuln) *CertifyVulnDeleteOne {
	return c.DeleteOneID(cv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertifyVulnClient) DeleteOneID(id int) *CertifyVulnDeleteOne {
	builder := c.Delete().Where(certifyvuln.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertifyVulnDeleteOne{builder}
}

// Query returns a query builder for CertifyVuln.
func (c *CertifyVulnClient) Query() *CertifyVulnQuery {
	return &CertifyVulnQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertifyVuln},
		inters: c.Interceptors(),
	}
}

// Get returns a CertifyVuln entity by its id.
func (c *CertifyVulnClient) Get(ctx context.Context, id int) (*CertifyVuln, error) {
	return c.Query().Where(certifyvuln.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertifyVulnClient) GetX(ctx context.Context, id int) *CertifyVuln {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVulnerability queries the vulnerability edge of a CertifyVuln.
func (c *CertifyVulnClient) QueryVulnerability(cv *CertifyVuln) *VulnerabilityIDQuery {
	query := (&VulnerabilityIDClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifyvuln.Table, certifyvuln.FieldID, id),
			sqlgraph.To(vulnerabilityid.Table, vulnerabilityid.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifyvuln.VulnerabilityTable, certifyvuln.VulnerabilityColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPackage queries the package edge of a CertifyVuln.
func (c *CertifyVulnClient) QueryPackage(cv *CertifyVuln) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifyvuln.Table, certifyvuln.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifyvuln.PackageTable, certifyvuln.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertifyVulnClient) Hooks() []Hook {
	return c.hooks.CertifyVuln
}

// Interceptors returns the client interceptors.
func (c *CertifyVulnClient) Interceptors() []Interceptor {
	return c.inters.CertifyVuln
}

func (c *CertifyVulnClient) mutate(ctx context.Context, m *CertifyVulnMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertifyVulnCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertifyVulnUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertifyVulnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertifyVulnDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CertifyVuln mutation op: %q", m.Op())
	}
}

// DependencyClient is a client for the Dependency schema.
type DependencyClient struct {
	config
}

// NewDependencyClient returns a client for the Dependency from the given config.
func NewDependencyClient(c config) *DependencyClient {
	return &DependencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dependency.Hooks(f(g(h())))`.
func (c *DependencyClient) Use(hooks ...Hook) {
	c.hooks.Dependency = append(c.hooks.Dependency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dependency.Intercept(f(g(h())))`.
func (c *DependencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Dependency = append(c.inters.Dependency, interceptors...)
}

// Create returns a builder for creating a Dependency entity.
func (c *DependencyClient) Create() *DependencyCreate {
	mutation := newDependencyMutation(c.config, OpCreate)
	return &DependencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dependency entities.
func (c *DependencyClient) CreateBulk(builders ...*DependencyCreate) *DependencyCreateBulk {
	return &DependencyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DependencyClient) MapCreateBulk(slice any, setFunc func(*DependencyCreate, int)) *DependencyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DependencyCreateBulk{err: fmt.Errorf("calling to DependencyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DependencyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DependencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dependency.
func (c *DependencyClient) Update() *DependencyUpdate {
	mutation := newDependencyMutation(c.config, OpUpdate)
	return &DependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DependencyClient) UpdateOne(d *Dependency) *DependencyUpdateOne {
	mutation := newDependencyMutation(c.config, OpUpdateOne, withDependency(d))
	return &DependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DependencyClient) UpdateOneID(id int) *DependencyUpdateOne {
	mutation := newDependencyMutation(c.config, OpUpdateOne, withDependencyID(id))
	return &DependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dependency.
func (c *DependencyClient) Delete() *DependencyDelete {
	mutation := newDependencyMutation(c.config, OpDelete)
	return &DependencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DependencyClient) DeleteOne(d *Dependency) *DependencyDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DependencyClient) DeleteOneID(id int) *DependencyDeleteOne {
	builder := c.Delete().Where(dependency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DependencyDeleteOne{builder}
}

// Query returns a query builder for Dependency.
func (c *DependencyClient) Query() *DependencyQuery {
	return &DependencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDependency},
		inters: c.Interceptors(),
	}
}

// Get returns a Dependency entity by its id.
func (c *DependencyClient) Get(ctx context.Context, id int) (*Dependency, error) {
	return c.Query().Where(dependency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DependencyClient) GetX(ctx context.Context, id int) *Dependency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a Dependency.
func (c *DependencyClient) QueryPackage(d *Dependency) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dependency.Table, dependency.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, dependency.PackageTable, dependency.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependentPackageName queries the dependent_package_name edge of a Dependency.
func (c *DependencyClient) QueryDependentPackageName(d *Dependency) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dependency.Table, dependency.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, dependency.DependentPackageNameTable, dependency.DependentPackageNameColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependentPackageVersion queries the dependent_package_version edge of a Dependency.
func (c *DependencyClient) QueryDependentPackageVersion(d *Dependency) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dependency.Table, dependency.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, dependency.DependentPackageVersionTable, dependency.DependentPackageVersionColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DependencyClient) Hooks() []Hook {
	return c.hooks.Dependency
}

// Interceptors returns the client interceptors.
func (c *DependencyClient) Interceptors() []Interceptor {
	return c.inters.Dependency
}

func (c *DependencyClient) mutate(ctx context.Context, m *DependencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DependencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DependencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Dependency mutation op: %q", m.Op())
	}
}

// HasSourceAtClient is a client for the HasSourceAt schema.
type HasSourceAtClient struct {
	config
}

// NewHasSourceAtClient returns a client for the HasSourceAt from the given config.
func NewHasSourceAtClient(c config) *HasSourceAtClient {
	return &HasSourceAtClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hassourceat.Hooks(f(g(h())))`.
func (c *HasSourceAtClient) Use(hooks ...Hook) {
	c.hooks.HasSourceAt = append(c.hooks.HasSourceAt, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hassourceat.Intercept(f(g(h())))`.
func (c *HasSourceAtClient) Intercept(interceptors ...Interceptor) {
	c.inters.HasSourceAt = append(c.inters.HasSourceAt, interceptors...)
}

// Create returns a builder for creating a HasSourceAt entity.
func (c *HasSourceAtClient) Create() *HasSourceAtCreate {
	mutation := newHasSourceAtMutation(c.config, OpCreate)
	return &HasSourceAtCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HasSourceAt entities.
func (c *HasSourceAtClient) CreateBulk(builders ...*HasSourceAtCreate) *HasSourceAtCreateBulk {
	return &HasSourceAtCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HasSourceAtClient) MapCreateBulk(slice any, setFunc func(*HasSourceAtCreate, int)) *HasSourceAtCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HasSourceAtCreateBulk{err: fmt.Errorf("calling to HasSourceAtClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HasSourceAtCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HasSourceAtCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HasSourceAt.
func (c *HasSourceAtClient) Update() *HasSourceAtUpdate {
	mutation := newHasSourceAtMutation(c.config, OpUpdate)
	return &HasSourceAtUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HasSourceAtClient) UpdateOne(hsa *HasSourceAt) *HasSourceAtUpdateOne {
	mutation := newHasSourceAtMutation(c.config, OpUpdateOne, withHasSourceAt(hsa))
	return &HasSourceAtUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HasSourceAtClient) UpdateOneID(id int) *HasSourceAtUpdateOne {
	mutation := newHasSourceAtMutation(c.config, OpUpdateOne, withHasSourceAtID(id))
	return &HasSourceAtUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HasSourceAt.
func (c *HasSourceAtClient) Delete() *HasSourceAtDelete {
	mutation := newHasSourceAtMutation(c.config, OpDelete)
	return &HasSourceAtDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HasSourceAtClient) DeleteOne(hsa *HasSourceAt) *HasSourceAtDeleteOne {
	return c.DeleteOneID(hsa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HasSourceAtClient) DeleteOneID(id int) *HasSourceAtDeleteOne {
	builder := c.Delete().Where(hassourceat.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HasSourceAtDeleteOne{builder}
}

// Query returns a query builder for HasSourceAt.
func (c *HasSourceAtClient) Query() *HasSourceAtQuery {
	return &HasSourceAtQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHasSourceAt},
		inters: c.Interceptors(),
	}
}

// Get returns a HasSourceAt entity by its id.
func (c *HasSourceAtClient) Get(ctx context.Context, id int) (*HasSourceAt, error) {
	return c.Query().Where(hassourceat.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HasSourceAtClient) GetX(ctx context.Context, id int) *HasSourceAt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackageVersion queries the package_version edge of a HasSourceAt.
func (c *HasSourceAtClient) QueryPackageVersion(hsa *HasSourceAt) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hsa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hassourceat.Table, hassourceat.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hassourceat.PackageVersionTable, hassourceat.PackageVersionColumn),
		)
		fromV = sqlgraph.Neighbors(hsa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAllVersions queries the all_versions edge of a HasSourceAt.
func (c *HasSourceAtClient) QueryAllVersions(hsa *HasSourceAt) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hsa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hassourceat.Table, hassourceat.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hassourceat.AllVersionsTable, hassourceat.AllVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(hsa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySource queries the source edge of a HasSourceAt.
func (c *HasSourceAtClient) QuerySource(hsa *HasSourceAt) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hsa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hassourceat.Table, hassourceat.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hassourceat.SourceTable, hassourceat.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(hsa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HasSourceAtClient) Hooks() []Hook {
	return c.hooks.HasSourceAt
}

// Interceptors returns the client interceptors.
func (c *HasSourceAtClient) Interceptors() []Interceptor {
	return c.inters.HasSourceAt
}

func (c *HasSourceAtClient) mutate(ctx context.Context, m *HasSourceAtMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HasSourceAtCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HasSourceAtUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HasSourceAtUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HasSourceAtDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HasSourceAt mutation op: %q", m.Op())
	}
}

// HashEqualClient is a client for the HashEqual schema.
type HashEqualClient struct {
	config
}

// NewHashEqualClient returns a client for the HashEqual from the given config.
func NewHashEqualClient(c config) *HashEqualClient {
	return &HashEqualClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hashequal.Hooks(f(g(h())))`.
func (c *HashEqualClient) Use(hooks ...Hook) {
	c.hooks.HashEqual = append(c.hooks.HashEqual, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hashequal.Intercept(f(g(h())))`.
func (c *HashEqualClient) Intercept(interceptors ...Interceptor) {
	c.inters.HashEqual = append(c.inters.HashEqual, interceptors...)
}

// Create returns a builder for creating a HashEqual entity.
func (c *HashEqualClient) Create() *HashEqualCreate {
	mutation := newHashEqualMutation(c.config, OpCreate)
	return &HashEqualCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HashEqual entities.
func (c *HashEqualClient) CreateBulk(builders ...*HashEqualCreate) *HashEqualCreateBulk {
	return &HashEqualCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HashEqualClient) MapCreateBulk(slice any, setFunc func(*HashEqualCreate, int)) *HashEqualCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HashEqualCreateBulk{err: fmt.Errorf("calling to HashEqualClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HashEqualCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HashEqualCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HashEqual.
func (c *HashEqualClient) Update() *HashEqualUpdate {
	mutation := newHashEqualMutation(c.config, OpUpdate)
	return &HashEqualUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HashEqualClient) UpdateOne(he *HashEqual) *HashEqualUpdateOne {
	mutation := newHashEqualMutation(c.config, OpUpdateOne, withHashEqual(he))
	return &HashEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HashEqualClient) UpdateOneID(id int) *HashEqualUpdateOne {
	mutation := newHashEqualMutation(c.config, OpUpdateOne, withHashEqualID(id))
	return &HashEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HashEqual.
func (c *HashEqualClient) Delete() *HashEqualDelete {
	mutation := newHashEqualMutation(c.config, OpDelete)
	return &HashEqualDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HashEqualClient) DeleteOne(he *HashEqual) *HashEqualDeleteOne {
	return c.DeleteOneID(he.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HashEqualClient) DeleteOneID(id int) *HashEqualDeleteOne {
	builder := c.Delete().Where(hashequal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HashEqualDeleteOne{builder}
}

// Query returns a query builder for HashEqual.
func (c *HashEqualClient) Query() *HashEqualQuery {
	return &HashEqualQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHashEqual},
		inters: c.Interceptors(),
	}
}

// Get returns a HashEqual entity by its id.
func (c *HashEqualClient) Get(ctx context.Context, id int) (*HashEqual, error) {
	return c.Query().Where(hashequal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HashEqualClient) GetX(ctx context.Context, id int) *HashEqual {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifacts queries the artifacts edge of a HashEqual.
func (c *HashEqualClient) QueryArtifacts(he *HashEqual) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := he.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hashequal.Table, hashequal.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, hashequal.ArtifactsTable, hashequal.ArtifactsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(he.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HashEqualClient) Hooks() []Hook {
	return c.hooks.HashEqual
}

// Interceptors returns the client interceptors.
func (c *HashEqualClient) Interceptors() []Interceptor {
	return c.inters.HashEqual
}

func (c *HashEqualClient) mutate(ctx context.Context, m *HashEqualMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HashEqualCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HashEqualUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HashEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HashEqualDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HashEqual mutation op: %q", m.Op())
	}
}

// IsVulnerabilityClient is a client for the IsVulnerability schema.
type IsVulnerabilityClient struct {
	config
}

// NewIsVulnerabilityClient returns a client for the IsVulnerability from the given config.
func NewIsVulnerabilityClient(c config) *IsVulnerabilityClient {
	return &IsVulnerabilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `isvulnerability.Hooks(f(g(h())))`.
func (c *IsVulnerabilityClient) Use(hooks ...Hook) {
	c.hooks.IsVulnerability = append(c.hooks.IsVulnerability, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `isvulnerability.Intercept(f(g(h())))`.
func (c *IsVulnerabilityClient) Intercept(interceptors ...Interceptor) {
	c.inters.IsVulnerability = append(c.inters.IsVulnerability, interceptors...)
}

// Create returns a builder for creating a IsVulnerability entity.
func (c *IsVulnerabilityClient) Create() *IsVulnerabilityCreate {
	mutation := newIsVulnerabilityMutation(c.config, OpCreate)
	return &IsVulnerabilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IsVulnerability entities.
func (c *IsVulnerabilityClient) CreateBulk(builders ...*IsVulnerabilityCreate) *IsVulnerabilityCreateBulk {
	return &IsVulnerabilityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IsVulnerabilityClient) MapCreateBulk(slice any, setFunc func(*IsVulnerabilityCreate, int)) *IsVulnerabilityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IsVulnerabilityCreateBulk{err: fmt.Errorf("calling to IsVulnerabilityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IsVulnerabilityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IsVulnerabilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IsVulnerability.
func (c *IsVulnerabilityClient) Update() *IsVulnerabilityUpdate {
	mutation := newIsVulnerabilityMutation(c.config, OpUpdate)
	return &IsVulnerabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IsVulnerabilityClient) UpdateOne(iv *IsVulnerability) *IsVulnerabilityUpdateOne {
	mutation := newIsVulnerabilityMutation(c.config, OpUpdateOne, withIsVulnerability(iv))
	return &IsVulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IsVulnerabilityClient) UpdateOneID(id int) *IsVulnerabilityUpdateOne {
	mutation := newIsVulnerabilityMutation(c.config, OpUpdateOne, withIsVulnerabilityID(id))
	return &IsVulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IsVulnerability.
func (c *IsVulnerabilityClient) Delete() *IsVulnerabilityDelete {
	mutation := newIsVulnerabilityMutation(c.config, OpDelete)
	return &IsVulnerabilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IsVulnerabilityClient) DeleteOne(iv *IsVulnerability) *IsVulnerabilityDeleteOne {
	return c.DeleteOneID(iv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IsVulnerabilityClient) DeleteOneID(id int) *IsVulnerabilityDeleteOne {
	builder := c.Delete().Where(isvulnerability.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IsVulnerabilityDeleteOne{builder}
}

// Query returns a query builder for IsVulnerability.
func (c *IsVulnerabilityClient) Query() *IsVulnerabilityQuery {
	return &IsVulnerabilityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIsVulnerability},
		inters: c.Interceptors(),
	}
}

// Get returns a IsVulnerability entity by its id.
func (c *IsVulnerabilityClient) Get(ctx context.Context, id int) (*IsVulnerability, error) {
	return c.Query().Where(isvulnerability.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IsVulnerabilityClient) GetX(ctx context.Context, id int) *IsVulnerability {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOsv queries the osv edge of a IsVulnerability.
func (c *IsVulnerabilityClient) QueryOsv(iv *IsVulnerability) *VulnerabilityTypeQuery {
	query := (&VulnerabilityTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(isvulnerability.Table, isvulnerability.FieldID, id),
			sqlgraph.To(vulnerabilitytype.Table, vulnerabilitytype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, isvulnerability.OsvTable, isvulnerability.OsvColumn),
		)
		fromV = sqlgraph.Neighbors(iv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerability queries the vulnerability edge of a IsVulnerability.
func (c *IsVulnerabilityClient) QueryVulnerability(iv *IsVulnerability) *VulnerabilityTypeQuery {
	query := (&VulnerabilityTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := iv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(isvulnerability.Table, isvulnerability.FieldID, id),
			sqlgraph.To(vulnerabilitytype.Table, vulnerabilitytype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, isvulnerability.VulnerabilityTable, isvulnerability.VulnerabilityColumn),
		)
		fromV = sqlgraph.Neighbors(iv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IsVulnerabilityClient) Hooks() []Hook {
	return c.hooks.IsVulnerability
}

// Interceptors returns the client interceptors.
func (c *IsVulnerabilityClient) Interceptors() []Interceptor {
	return c.inters.IsVulnerability
}

func (c *IsVulnerabilityClient) mutate(ctx context.Context, m *IsVulnerabilityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IsVulnerabilityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IsVulnerabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IsVulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IsVulnerabilityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IsVulnerability mutation op: %q", m.Op())
	}
}

// LicenseClient is a client for the License schema.
type LicenseClient struct {
	config
}

// NewLicenseClient returns a client for the License from the given config.
func NewLicenseClient(c config) *LicenseClient {
	return &LicenseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `license.Hooks(f(g(h())))`.
func (c *LicenseClient) Use(hooks ...Hook) {
	c.hooks.License = append(c.hooks.License, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `license.Intercept(f(g(h())))`.
func (c *LicenseClient) Intercept(interceptors ...Interceptor) {
	c.inters.License = append(c.inters.License, interceptors...)
}

// Create returns a builder for creating a License entity.
func (c *LicenseClient) Create() *LicenseCreate {
	mutation := newLicenseMutation(c.config, OpCreate)
	return &LicenseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of License entities.
func (c *LicenseClient) CreateBulk(builders ...*LicenseCreate) *LicenseCreateBulk {
	return &LicenseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LicenseClient) MapCreateBulk(slice any, setFunc func(*LicenseCreate, int)) *LicenseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LicenseCreateBulk{err: fmt.Errorf("calling to LicenseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LicenseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LicenseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for License.
func (c *LicenseClient) Update() *LicenseUpdate {
	mutation := newLicenseMutation(c.config, OpUpdate)
	return &LicenseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LicenseClient) UpdateOne(l *License) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicense(l))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LicenseClient) UpdateOneID(id int) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicenseID(id))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for License.
func (c *LicenseClient) Delete() *LicenseDelete {
	mutation := newLicenseMutation(c.config, OpDelete)
	return &LicenseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LicenseClient) DeleteOne(l *License) *LicenseDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LicenseClient) DeleteOneID(id int) *LicenseDeleteOne {
	builder := c.Delete().Where(license.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LicenseDeleteOne{builder}
}

// Query returns a query builder for License.
func (c *LicenseClient) Query() *LicenseQuery {
	return &LicenseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLicense},
		inters: c.Interceptors(),
	}
}

// Get returns a License entity by its id.
func (c *LicenseClient) Get(ctx context.Context, id int) (*License, error) {
	return c.Query().Where(license.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LicenseClient) GetX(ctx context.Context, id int) *License {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDeclaredInCertifyLegals queries the declared_in_certify_legals edge of a License.
func (c *LicenseClient) QueryDeclaredInCertifyLegals(l *License) *CertifyLegalQuery {
	query := (&CertifyLegalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(certifylegal.Table, certifylegal.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, license.DeclaredInCertifyLegalsTable, license.DeclaredInCertifyLegalsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscoveredInCertifyLegals queries the discovered_in_certify_legals edge of a License.
func (c *LicenseClient) QueryDiscoveredInCertifyLegals(l *License) *CertifyLegalQuery {
	query := (&CertifyLegalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(certifylegal.Table, certifylegal.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, license.DiscoveredInCertifyLegalsTable, license.DiscoveredInCertifyLegalsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LicenseClient) Hooks() []Hook {
	return c.hooks.License
}

// Interceptors returns the client interceptors.
func (c *LicenseClient) Interceptors() []Interceptor {
	return c.inters.License
}

func (c *LicenseClient) mutate(ctx context.Context, m *LicenseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LicenseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LicenseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LicenseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown License mutation op: %q", m.Op())
	}
}

// OccurrenceClient is a client for the Occurrence schema.
type OccurrenceClient struct {
	config
}

// NewOccurrenceClient returns a client for the Occurrence from the given config.
func NewOccurrenceClient(c config) *OccurrenceClient {
	return &OccurrenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `occurrence.Hooks(f(g(h())))`.
func (c *OccurrenceClient) Use(hooks ...Hook) {
	c.hooks.Occurrence = append(c.hooks.Occurrence, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `occurrence.Intercept(f(g(h())))`.
func (c *OccurrenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Occurrence = append(c.inters.Occurrence, interceptors...)
}

// Create returns a builder for creating a Occurrence entity.
func (c *OccurrenceClient) Create() *OccurrenceCreate {
	mutation := newOccurrenceMutation(c.config, OpCreate)
	return &OccurrenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Occurrence entities.
func (c *OccurrenceClient) CreateBulk(builders ...*OccurrenceCreate) *OccurrenceCreateBulk {
	return &OccurrenceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OccurrenceClient) MapCreateBulk(slice any, setFunc func(*OccurrenceCreate, int)) *OccurrenceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OccurrenceCreateBulk{err: fmt.Errorf("calling to OccurrenceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OccurrenceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OccurrenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Occurrence.
func (c *OccurrenceClient) Update() *OccurrenceUpdate {
	mutation := newOccurrenceMutation(c.config, OpUpdate)
	return &OccurrenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OccurrenceClient) UpdateOne(o *Occurrence) *OccurrenceUpdateOne {
	mutation := newOccurrenceMutation(c.config, OpUpdateOne, withOccurrence(o))
	return &OccurrenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OccurrenceClient) UpdateOneID(id int) *OccurrenceUpdateOne {
	mutation := newOccurrenceMutation(c.config, OpUpdateOne, withOccurrenceID(id))
	return &OccurrenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Occurrence.
func (c *OccurrenceClient) Delete() *OccurrenceDelete {
	mutation := newOccurrenceMutation(c.config, OpDelete)
	return &OccurrenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OccurrenceClient) DeleteOne(o *Occurrence) *OccurrenceDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OccurrenceClient) DeleteOneID(id int) *OccurrenceDeleteOne {
	builder := c.Delete().Where(occurrence.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OccurrenceDeleteOne{builder}
}

// Query returns a query builder for Occurrence.
func (c *OccurrenceClient) Query() *OccurrenceQuery {
	return &OccurrenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOccurrence},
		inters: c.Interceptors(),
	}
}

// Get returns a Occurrence entity by its id.
func (c *OccurrenceClient) Get(ctx context.Context, id int) (*Occurrence, error) {
	return c.Query().Where(occurrence.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OccurrenceClient) GetX(ctx context.Context, id int) *Occurrence {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifact queries the artifact edge of a Occurrence.
func (c *OccurrenceClient) QueryArtifact(o *Occurrence) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(occurrence.Table, occurrence.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, occurrence.ArtifactTable, occurrence.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPackage queries the package edge of a Occurrence.
func (c *OccurrenceClient) QueryPackage(o *Occurrence) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(occurrence.Table, occurrence.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, occurrence.PackageTable, occurrence.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySource queries the source edge of a Occurrence.
func (c *OccurrenceClient) QuerySource(o *Occurrence) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(occurrence.Table, occurrence.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, occurrence.SourceTable, occurrence.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OccurrenceClient) Hooks() []Hook {
	return c.hooks.Occurrence
}

// Interceptors returns the client interceptors.
func (c *OccurrenceClient) Interceptors() []Interceptor {
	return c.inters.Occurrence
}

func (c *OccurrenceClient) mutate(ctx context.Context, m *OccurrenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OccurrenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OccurrenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OccurrenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OccurrenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Occurrence mutation op: %q", m.Op())
	}
}

// PackageNameClient is a client for the PackageName schema.
type PackageNameClient struct {
	config
}

// NewPackageNameClient returns a client for the PackageName from the given config.
func NewPackageNameClient(c config) *PackageNameClient {
	return &PackageNameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packagename.Hooks(f(g(h())))`.
func (c *PackageNameClient) Use(hooks ...Hook) {
	c.hooks.PackageName = append(c.hooks.PackageName, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packagename.Intercept(f(g(h())))`.
func (c *PackageNameClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageName = append(c.inters.PackageName, interceptors...)
}

// Create returns a builder for creating a PackageName entity.
func (c *PackageNameClient) Create() *PackageNameCreate {
	mutation := newPackageNameMutation(c.config, OpCreate)
	return &PackageNameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageName entities.
func (c *PackageNameClient) CreateBulk(builders ...*PackageNameCreate) *PackageNameCreateBulk {
	return &PackageNameCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PackageNameClient) MapCreateBulk(slice any, setFunc func(*PackageNameCreate, int)) *PackageNameCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PackageNameCreateBulk{err: fmt.Errorf("calling to PackageNameClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PackageNameCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PackageNameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageName.
func (c *PackageNameClient) Update() *PackageNameUpdate {
	mutation := newPackageNameMutation(c.config, OpUpdate)
	return &PackageNameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageNameClient) UpdateOne(pn *PackageName) *PackageNameUpdateOne {
	mutation := newPackageNameMutation(c.config, OpUpdateOne, withPackageName(pn))
	return &PackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageNameClient) UpdateOneID(id int) *PackageNameUpdateOne {
	mutation := newPackageNameMutation(c.config, OpUpdateOne, withPackageNameID(id))
	return &PackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageName.
func (c *PackageNameClient) Delete() *PackageNameDelete {
	mutation := newPackageNameMutation(c.config, OpDelete)
	return &PackageNameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageNameClient) DeleteOne(pn *PackageName) *PackageNameDeleteOne {
	return c.DeleteOneID(pn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageNameClient) DeleteOneID(id int) *PackageNameDeleteOne {
	builder := c.Delete().Where(packagename.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageNameDeleteOne{builder}
}

// Query returns a query builder for PackageName.
func (c *PackageNameClient) Query() *PackageNameQuery {
	return &PackageNameQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageName},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageName entity by its id.
func (c *PackageNameClient) Get(ctx context.Context, id int) (*PackageName, error) {
	return c.Query().Where(packagename.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageNameClient) GetX(ctx context.Context, id int) *PackageName {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a PackageName.
func (c *PackageNameClient) QueryNamespace(pn *PackageName) *PackageNamespaceQuery {
	query := (&PackageNamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagename.Table, packagename.FieldID, id),
			sqlgraph.To(packagenamespace.Table, packagenamespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, packagename.NamespaceTable, packagename.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVersions queries the versions edge of a PackageName.
func (c *PackageNameClient) QueryVersions(pn *PackageName) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagename.Table, packagename.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, packagename.VersionsTable, packagename.VersionsColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageNameClient) Hooks() []Hook {
	return c.hooks.PackageName
}

// Interceptors returns the client interceptors.
func (c *PackageNameClient) Interceptors() []Interceptor {
	return c.inters.PackageName
}

func (c *PackageNameClient) mutate(ctx context.Context, m *PackageNameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageNameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageNameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageNameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageName mutation op: %q", m.Op())
	}
}

// PackageNamespaceClient is a client for the PackageNamespace schema.
type PackageNamespaceClient struct {
	config
}

// NewPackageNamespaceClient returns a client for the PackageNamespace from the given config.
func NewPackageNamespaceClient(c config) *PackageNamespaceClient {
	return &PackageNamespaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packagenamespace.Hooks(f(g(h())))`.
func (c *PackageNamespaceClient) Use(hooks ...Hook) {
	c.hooks.PackageNamespace = append(c.hooks.PackageNamespace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packagenamespace.Intercept(f(g(h())))`.
func (c *PackageNamespaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageNamespace = append(c.inters.PackageNamespace, interceptors...)
}

// Create returns a builder for creating a PackageNamespace entity.
func (c *PackageNamespaceClient) Create() *PackageNamespaceCreate {
	mutation := newPackageNamespaceMutation(c.config, OpCreate)
	return &PackageNamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageNamespace entities.
func (c *PackageNamespaceClient) CreateBulk(builders ...*PackageNamespaceCreate) *PackageNamespaceCreateBulk {
	return &PackageNamespaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PackageNamespaceClient) MapCreateBulk(slice any, setFunc func(*PackageNamespaceCreate, int)) *PackageNamespaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PackageNamespaceCreateBulk{err: fmt.Errorf("calling to PackageNamespaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PackageNamespaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PackageNamespaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageNamespace.
func (c *PackageNamespaceClient) Update() *PackageNamespaceUpdate {
	mutation := newPackageNamespaceMutation(c.config, OpUpdate)
	return &PackageNamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageNamespaceClient) UpdateOne(pn *PackageNamespace) *PackageNamespaceUpdateOne {
	mutation := newPackageNamespaceMutation(c.config, OpUpdateOne, withPackageNamespace(pn))
	return &PackageNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageNamespaceClient) UpdateOneID(id int) *PackageNamespaceUpdateOne {
	mutation := newPackageNamespaceMutation(c.config, OpUpdateOne, withPackageNamespaceID(id))
	return &PackageNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageNamespace.
func (c *PackageNamespaceClient) Delete() *PackageNamespaceDelete {
	mutation := newPackageNamespaceMutation(c.config, OpDelete)
	return &PackageNamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageNamespaceClient) DeleteOne(pn *PackageNamespace) *PackageNamespaceDeleteOne {
	return c.DeleteOneID(pn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageNamespaceClient) DeleteOneID(id int) *PackageNamespaceDeleteOne {
	builder := c.Delete().Where(packagenamespace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageNamespaceDeleteOne{builder}
}

// Query returns a query builder for PackageNamespace.
func (c *PackageNamespaceClient) Query() *PackageNamespaceQuery {
	return &PackageNamespaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageNamespace},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageNamespace entity by its id.
func (c *PackageNamespaceClient) Get(ctx context.Context, id int) (*PackageNamespace, error) {
	return c.Query().Where(packagenamespace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageNamespaceClient) GetX(ctx context.Context, id int) *PackageNamespace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a PackageNamespace.
func (c *PackageNamespaceClient) QueryPackage(pn *PackageNamespace) *PackageTypeQuery {
	query := (&PackageTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagenamespace.Table, packagenamespace.FieldID, id),
			sqlgraph.To(packagetype.Table, packagetype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, packagenamespace.PackageTable, packagenamespace.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNames queries the names edge of a PackageNamespace.
func (c *PackageNamespaceClient) QueryNames(pn *PackageNamespace) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagenamespace.Table, packagenamespace.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, packagenamespace.NamesTable, packagenamespace.NamesColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageNamespaceClient) Hooks() []Hook {
	return c.hooks.PackageNamespace
}

// Interceptors returns the client interceptors.
func (c *PackageNamespaceClient) Interceptors() []Interceptor {
	return c.inters.PackageNamespace
}

func (c *PackageNamespaceClient) mutate(ctx context.Context, m *PackageNamespaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageNamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageNamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageNamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageNamespace mutation op: %q", m.Op())
	}
}

// PackageTypeClient is a client for the PackageType schema.
type PackageTypeClient struct {
	config
}

// NewPackageTypeClient returns a client for the PackageType from the given config.
func NewPackageTypeClient(c config) *PackageTypeClient {
	return &PackageTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packagetype.Hooks(f(g(h())))`.
func (c *PackageTypeClient) Use(hooks ...Hook) {
	c.hooks.PackageType = append(c.hooks.PackageType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packagetype.Intercept(f(g(h())))`.
func (c *PackageTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageType = append(c.inters.PackageType, interceptors...)
}

// Create returns a builder for creating a PackageType entity.
func (c *PackageTypeClient) Create() *PackageTypeCreate {
	mutation := newPackageTypeMutation(c.config, OpCreate)
	return &PackageTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageType entities.
func (c *PackageTypeClient) CreateBulk(builders ...*PackageTypeCreate) *PackageTypeCreateBulk {
	return &PackageTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PackageTypeClient) MapCreateBulk(slice any, setFunc func(*PackageTypeCreate, int)) *PackageTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PackageTypeCreateBulk{err: fmt.Errorf("calling to PackageTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PackageTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PackageTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageType.
func (c *PackageTypeClient) Update() *PackageTypeUpdate {
	mutation := newPackageTypeMutation(c.config, OpUpdate)
	return &PackageTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageTypeClient) UpdateOne(pt *PackageType) *PackageTypeUpdateOne {
	mutation := newPackageTypeMutation(c.config, OpUpdateOne, withPackageType(pt))
	return &PackageTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageTypeClient) UpdateOneID(id int) *PackageTypeUpdateOne {
	mutation := newPackageTypeMutation(c.config, OpUpdateOne, withPackageTypeID(id))
	return &PackageTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageType.
func (c *PackageTypeClient) Delete() *PackageTypeDelete {
	mutation := newPackageTypeMutation(c.config, OpDelete)
	return &PackageTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageTypeClient) DeleteOne(pt *PackageType) *PackageTypeDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageTypeClient) DeleteOneID(id int) *PackageTypeDeleteOne {
	builder := c.Delete().Where(packagetype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageTypeDeleteOne{builder}
}

// Query returns a query builder for PackageType.
func (c *PackageTypeClient) Query() *PackageTypeQuery {
	return &PackageTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageType},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageType entity by its id.
func (c *PackageTypeClient) Get(ctx context.Context, id int) (*PackageType, error) {
	return c.Query().Where(packagetype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageTypeClient) GetX(ctx context.Context, id int) *PackageType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespaces queries the namespaces edge of a PackageType.
func (c *PackageTypeClient) QueryNamespaces(pt *PackageType) *PackageNamespaceQuery {
	query := (&PackageNamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagetype.Table, packagetype.FieldID, id),
			sqlgraph.To(packagenamespace.Table, packagenamespace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, packagetype.NamespacesTable, packagetype.NamespacesColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageTypeClient) Hooks() []Hook {
	return c.hooks.PackageType
}

// Interceptors returns the client interceptors.
func (c *PackageTypeClient) Interceptors() []Interceptor {
	return c.inters.PackageType
}

func (c *PackageTypeClient) mutate(ctx context.Context, m *PackageTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageType mutation op: %q", m.Op())
	}
}

// PackageVersionClient is a client for the PackageVersion schema.
type PackageVersionClient struct {
	config
}

// NewPackageVersionClient returns a client for the PackageVersion from the given config.
func NewPackageVersionClient(c config) *PackageVersionClient {
	return &PackageVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packageversion.Hooks(f(g(h())))`.
func (c *PackageVersionClient) Use(hooks ...Hook) {
	c.hooks.PackageVersion = append(c.hooks.PackageVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packageversion.Intercept(f(g(h())))`.
func (c *PackageVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageVersion = append(c.inters.PackageVersion, interceptors...)
}

// Create returns a builder for creating a PackageVersion entity.
func (c *PackageVersionClient) Create() *PackageVersionCreate {
	mutation := newPackageVersionMutation(c.config, OpCreate)
	return &PackageVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageVersion entities.
func (c *PackageVersionClient) CreateBulk(builders ...*PackageVersionCreate) *PackageVersionCreateBulk {
	return &PackageVersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PackageVersionClient) MapCreateBulk(slice any, setFunc func(*PackageVersionCreate, int)) *PackageVersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PackageVersionCreateBulk{err: fmt.Errorf("calling to PackageVersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PackageVersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PackageVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageVersion.
func (c *PackageVersionClient) Update() *PackageVersionUpdate {
	mutation := newPackageVersionMutation(c.config, OpUpdate)
	return &PackageVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageVersionClient) UpdateOne(pv *PackageVersion) *PackageVersionUpdateOne {
	mutation := newPackageVersionMutation(c.config, OpUpdateOne, withPackageVersion(pv))
	return &PackageVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageVersionClient) UpdateOneID(id int) *PackageVersionUpdateOne {
	mutation := newPackageVersionMutation(c.config, OpUpdateOne, withPackageVersionID(id))
	return &PackageVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageVersion.
func (c *PackageVersionClient) Delete() *PackageVersionDelete {
	mutation := newPackageVersionMutation(c.config, OpDelete)
	return &PackageVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageVersionClient) DeleteOne(pv *PackageVersion) *PackageVersionDeleteOne {
	return c.DeleteOneID(pv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageVersionClient) DeleteOneID(id int) *PackageVersionDeleteOne {
	builder := c.Delete().Where(packageversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageVersionDeleteOne{builder}
}

// Query returns a query builder for PackageVersion.
func (c *PackageVersionClient) Query() *PackageVersionQuery {
	return &PackageVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageVersion entity by its id.
func (c *PackageVersionClient) Get(ctx context.Context, id int) (*PackageVersion, error) {
	return c.Query().Where(packageversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageVersionClient) GetX(ctx context.Context, id int) *PackageVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryName queries the name edge of a PackageVersion.
func (c *PackageVersionClient) QueryName(pv *PackageVersion) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, packageversion.NameTable, packageversion.NameColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOccurrences queries the occurrences edge of a PackageVersion.
func (c *PackageVersionClient) QueryOccurrences(pv *PackageVersion) *OccurrenceQuery {
	query := (&OccurrenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(occurrence.Table, occurrence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.OccurrencesTable, packageversion.OccurrencesColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySbom queries the sbom edge of a PackageVersion.
func (c *PackageVersionClient) QuerySbom(pv *PackageVersion) *BillOfMaterialsQuery {
	query := (&BillOfMaterialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(billofmaterials.Table, billofmaterials.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.SbomTable, packageversion.SbomColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEqualPackages queries the equal_packages edge of a PackageVersion.
func (c *PackageVersionClient) QueryEqualPackages(pv *PackageVersion) *PkgEqualQuery {
	query := (&PkgEqualClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(pkgequal.Table, pkgequal.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, packageversion.EqualPackagesTable, packageversion.EqualPackagesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageVersionClient) Hooks() []Hook {
	return c.hooks.PackageVersion
}

// Interceptors returns the client interceptors.
func (c *PackageVersionClient) Interceptors() []Interceptor {
	return c.inters.PackageVersion
}

func (c *PackageVersionClient) mutate(ctx context.Context, m *PackageVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageVersion mutation op: %q", m.Op())
	}
}

// PkgEqualClient is a client for the PkgEqual schema.
type PkgEqualClient struct {
	config
}

// NewPkgEqualClient returns a client for the PkgEqual from the given config.
func NewPkgEqualClient(c config) *PkgEqualClient {
	return &PkgEqualClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pkgequal.Hooks(f(g(h())))`.
func (c *PkgEqualClient) Use(hooks ...Hook) {
	c.hooks.PkgEqual = append(c.hooks.PkgEqual, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pkgequal.Intercept(f(g(h())))`.
func (c *PkgEqualClient) Intercept(interceptors ...Interceptor) {
	c.inters.PkgEqual = append(c.inters.PkgEqual, interceptors...)
}

// Create returns a builder for creating a PkgEqual entity.
func (c *PkgEqualClient) Create() *PkgEqualCreate {
	mutation := newPkgEqualMutation(c.config, OpCreate)
	return &PkgEqualCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PkgEqual entities.
func (c *PkgEqualClient) CreateBulk(builders ...*PkgEqualCreate) *PkgEqualCreateBulk {
	return &PkgEqualCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PkgEqualClient) MapCreateBulk(slice any, setFunc func(*PkgEqualCreate, int)) *PkgEqualCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PkgEqualCreateBulk{err: fmt.Errorf("calling to PkgEqualClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PkgEqualCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PkgEqualCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PkgEqual.
func (c *PkgEqualClient) Update() *PkgEqualUpdate {
	mutation := newPkgEqualMutation(c.config, OpUpdate)
	return &PkgEqualUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PkgEqualClient) UpdateOne(pe *PkgEqual) *PkgEqualUpdateOne {
	mutation := newPkgEqualMutation(c.config, OpUpdateOne, withPkgEqual(pe))
	return &PkgEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PkgEqualClient) UpdateOneID(id int) *PkgEqualUpdateOne {
	mutation := newPkgEqualMutation(c.config, OpUpdateOne, withPkgEqualID(id))
	return &PkgEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PkgEqual.
func (c *PkgEqualClient) Delete() *PkgEqualDelete {
	mutation := newPkgEqualMutation(c.config, OpDelete)
	return &PkgEqualDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PkgEqualClient) DeleteOne(pe *PkgEqual) *PkgEqualDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PkgEqualClient) DeleteOneID(id int) *PkgEqualDeleteOne {
	builder := c.Delete().Where(pkgequal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PkgEqualDeleteOne{builder}
}

// Query returns a query builder for PkgEqual.
func (c *PkgEqualClient) Query() *PkgEqualQuery {
	return &PkgEqualQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePkgEqual},
		inters: c.Interceptors(),
	}
}

// Get returns a PkgEqual entity by its id.
func (c *PkgEqualClient) Get(ctx context.Context, id int) (*PkgEqual, error) {
	return c.Query().Where(pkgequal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PkgEqualClient) GetX(ctx context.Context, id int) *PkgEqual {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackages queries the packages edge of a PkgEqual.
func (c *PkgEqualClient) QueryPackages(pe *PkgEqual) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pkgequal.Table, pkgequal.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, pkgequal.PackagesTable, pkgequal.PackagesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PkgEqualClient) Hooks() []Hook {
	return c.hooks.PkgEqual
}

// Interceptors returns the client interceptors.
func (c *PkgEqualClient) Interceptors() []Interceptor {
	return c.inters.PkgEqual
}

func (c *PkgEqualClient) mutate(ctx context.Context, m *PkgEqualMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PkgEqualCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PkgEqualUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PkgEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PkgEqualDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PkgEqual mutation op: %q", m.Op())
	}
}

// SLSAAttestationClient is a client for the SLSAAttestation schema.
type SLSAAttestationClient struct {
	config
}

// NewSLSAAttestationClient returns a client for the SLSAAttestation from the given config.
func NewSLSAAttestationClient(c config) *SLSAAttestationClient {
	return &SLSAAttestationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `slsaattestation.Hooks(f(g(h())))`.
func (c *SLSAAttestationClient) Use(hooks ...Hook) {
	c.hooks.SLSAAttestation = append(c.hooks.SLSAAttestation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `slsaattestation.Intercept(f(g(h())))`.
func (c *SLSAAttestationClient) Intercept(interceptors ...Interceptor) {
	c.inters.SLSAAttestation = append(c.inters.SLSAAttestation, interceptors...)
}

// Create returns a builder for creating a SLSAAttestation entity.
func (c *SLSAAttestationClient) Create() *SLSAAttestationCreate {
	mutation := newSLSAAttestationMutation(c.config, OpCreate)
	return &SLSAAttestationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SLSAAttestation entities.
func (c *SLSAAttestationClient) CreateBulk(builders ...*SLSAAttestationCreate) *SLSAAttestationCreateBulk {
	return &SLSAAttestationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SLSAAttestationClient) MapCreateBulk(slice any, setFunc func(*SLSAAttestationCreate, int)) *SLSAAttestationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SLSAAttestationCreateBulk{err: fmt.Errorf("calling to SLSAAttestationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SLSAAttestationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SLSAAttestationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SLSAAttestation.
func (c *SLSAAttestationClient) Update() *SLSAAttestationUpdate {
	mutation := newSLSAAttestationMutation(c.config, OpUpdate)
	return &SLSAAttestationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SLSAAttestationClient) UpdateOne(sa *SLSAAttestation) *SLSAAttestationUpdateOne {
	mutation := newSLSAAttestationMutation(c.config, OpUpdateOne, withSLSAAttestation(sa))
	return &SLSAAttestationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SLSAAttestationClient) UpdateOneID(id int) *SLSAAttestationUpdateOne {
	mutation := newSLSAAttestationMutation(c.config, OpUpdateOne, withSLSAAttestationID(id))
	return &SLSAAttestationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SLSAAttestation.
func (c *SLSAAttestationClient) Delete() *SLSAAttestationDelete {
	mutation := newSLSAAttestationMutation(c.config, OpDelete)
	return &SLSAAttestationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SLSAAttestationClient) DeleteOne(sa *SLSAAttestation) *SLSAAttestationDeleteOne {
	return c.DeleteOneID(sa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SLSAAttestationClient) DeleteOneID(id int) *SLSAAttestationDeleteOne {
	builder := c.Delete().Where(slsaattestation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SLSAAttestationDeleteOne{builder}
}

// Query returns a query builder for SLSAAttestation.
func (c *SLSAAttestationClient) Query() *SLSAAttestationQuery {
	return &SLSAAttestationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSLSAAttestation},
		inters: c.Interceptors(),
	}
}

// Get returns a SLSAAttestation entity by its id.
func (c *SLSAAttestationClient) Get(ctx context.Context, id int) (*SLSAAttestation, error) {
	return c.Query().Where(slsaattestation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SLSAAttestationClient) GetX(ctx context.Context, id int) *SLSAAttestation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBuiltFrom queries the built_from edge of a SLSAAttestation.
func (c *SLSAAttestationClient) QueryBuiltFrom(sa *SLSAAttestation) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(slsaattestation.Table, slsaattestation.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, slsaattestation.BuiltFromTable, slsaattestation.BuiltFromPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuiltBy queries the built_by edge of a SLSAAttestation.
func (c *SLSAAttestationClient) QueryBuiltBy(sa *SLSAAttestation) *BuilderQuery {
	query := (&BuilderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(slsaattestation.Table, slsaattestation.FieldID, id),
			sqlgraph.To(builder.Table, builder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, slsaattestation.BuiltByTable, slsaattestation.BuiltByColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubject queries the subject edge of a SLSAAttestation.
func (c *SLSAAttestationClient) QuerySubject(sa *SLSAAttestation) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(slsaattestation.Table, slsaattestation.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, slsaattestation.SubjectTable, slsaattestation.SubjectColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SLSAAttestationClient) Hooks() []Hook {
	return c.hooks.SLSAAttestation
}

// Interceptors returns the client interceptors.
func (c *SLSAAttestationClient) Interceptors() []Interceptor {
	return c.inters.SLSAAttestation
}

func (c *SLSAAttestationClient) mutate(ctx context.Context, m *SLSAAttestationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SLSAAttestationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SLSAAttestationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SLSAAttestationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SLSAAttestationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SLSAAttestation mutation op: %q", m.Op())
	}
}

// ScorecardClient is a client for the Scorecard schema.
type ScorecardClient struct {
	config
}

// NewScorecardClient returns a client for the Scorecard from the given config.
func NewScorecardClient(c config) *ScorecardClient {
	return &ScorecardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scorecard.Hooks(f(g(h())))`.
func (c *ScorecardClient) Use(hooks ...Hook) {
	c.hooks.Scorecard = append(c.hooks.Scorecard, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scorecard.Intercept(f(g(h())))`.
func (c *ScorecardClient) Intercept(interceptors ...Interceptor) {
	c.inters.Scorecard = append(c.inters.Scorecard, interceptors...)
}

// Create returns a builder for creating a Scorecard entity.
func (c *ScorecardClient) Create() *ScorecardCreate {
	mutation := newScorecardMutation(c.config, OpCreate)
	return &ScorecardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Scorecard entities.
func (c *ScorecardClient) CreateBulk(builders ...*ScorecardCreate) *ScorecardCreateBulk {
	return &ScorecardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScorecardClient) MapCreateBulk(slice any, setFunc func(*ScorecardCreate, int)) *ScorecardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScorecardCreateBulk{err: fmt.Errorf("calling to ScorecardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScorecardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScorecardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Scorecard.
func (c *ScorecardClient) Update() *ScorecardUpdate {
	mutation := newScorecardMutation(c.config, OpUpdate)
	return &ScorecardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScorecardClient) UpdateOne(s *Scorecard) *ScorecardUpdateOne {
	mutation := newScorecardMutation(c.config, OpUpdateOne, withScorecard(s))
	return &ScorecardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScorecardClient) UpdateOneID(id int) *ScorecardUpdateOne {
	mutation := newScorecardMutation(c.config, OpUpdateOne, withScorecardID(id))
	return &ScorecardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Scorecard.
func (c *ScorecardClient) Delete() *ScorecardDelete {
	mutation := newScorecardMutation(c.config, OpDelete)
	return &ScorecardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScorecardClient) DeleteOne(s *Scorecard) *ScorecardDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScorecardClient) DeleteOneID(id int) *ScorecardDeleteOne {
	builder := c.Delete().Where(scorecard.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScorecardDeleteOne{builder}
}

// Query returns a query builder for Scorecard.
func (c *ScorecardClient) Query() *ScorecardQuery {
	return &ScorecardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScorecard},
		inters: c.Interceptors(),
	}
}

// Get returns a Scorecard entity by its id.
func (c *ScorecardClient) Get(ctx context.Context, id int) (*Scorecard, error) {
	return c.Query().Where(scorecard.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScorecardClient) GetX(ctx context.Context, id int) *Scorecard {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCertifications queries the certifications edge of a Scorecard.
func (c *ScorecardClient) QueryCertifications(s *Scorecard) *CertifyScorecardQuery {
	query := (&CertifyScorecardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scorecard.Table, scorecard.FieldID, id),
			sqlgraph.To(certifyscorecard.Table, certifyscorecard.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scorecard.CertificationsTable, scorecard.CertificationsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScorecardClient) Hooks() []Hook {
	return c.hooks.Scorecard
}

// Interceptors returns the client interceptors.
func (c *ScorecardClient) Interceptors() []Interceptor {
	return c.inters.Scorecard
}

func (c *ScorecardClient) mutate(ctx context.Context, m *ScorecardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScorecardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScorecardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScorecardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScorecardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Scorecard mutation op: %q", m.Op())
	}
}

// SourceNameClient is a client for the SourceName schema.
type SourceNameClient struct {
	config
}

// NewSourceNameClient returns a client for the SourceName from the given config.
func NewSourceNameClient(c config) *SourceNameClient {
	return &SourceNameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sourcename.Hooks(f(g(h())))`.
func (c *SourceNameClient) Use(hooks ...Hook) {
	c.hooks.SourceName = append(c.hooks.SourceName, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sourcename.Intercept(f(g(h())))`.
func (c *SourceNameClient) Intercept(interceptors ...Interceptor) {
	c.inters.SourceName = append(c.inters.SourceName, interceptors...)
}

// Create returns a builder for creating a SourceName entity.
func (c *SourceNameClient) Create() *SourceNameCreate {
	mutation := newSourceNameMutation(c.config, OpCreate)
	return &SourceNameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SourceName entities.
func (c *SourceNameClient) CreateBulk(builders ...*SourceNameCreate) *SourceNameCreateBulk {
	return &SourceNameCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SourceNameClient) MapCreateBulk(slice any, setFunc func(*SourceNameCreate, int)) *SourceNameCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SourceNameCreateBulk{err: fmt.Errorf("calling to SourceNameClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SourceNameCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SourceNameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SourceName.
func (c *SourceNameClient) Update() *SourceNameUpdate {
	mutation := newSourceNameMutation(c.config, OpUpdate)
	return &SourceNameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceNameClient) UpdateOne(sn *SourceName) *SourceNameUpdateOne {
	mutation := newSourceNameMutation(c.config, OpUpdateOne, withSourceName(sn))
	return &SourceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceNameClient) UpdateOneID(id int) *SourceNameUpdateOne {
	mutation := newSourceNameMutation(c.config, OpUpdateOne, withSourceNameID(id))
	return &SourceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SourceName.
func (c *SourceNameClient) Delete() *SourceNameDelete {
	mutation := newSourceNameMutation(c.config, OpDelete)
	return &SourceNameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceNameClient) DeleteOne(sn *SourceName) *SourceNameDeleteOne {
	return c.DeleteOneID(sn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceNameClient) DeleteOneID(id int) *SourceNameDeleteOne {
	builder := c.Delete().Where(sourcename.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceNameDeleteOne{builder}
}

// Query returns a query builder for SourceName.
func (c *SourceNameClient) Query() *SourceNameQuery {
	return &SourceNameQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSourceName},
		inters: c.Interceptors(),
	}
}

// Get returns a SourceName entity by its id.
func (c *SourceNameClient) Get(ctx context.Context, id int) (*SourceName, error) {
	return c.Query().Where(sourcename.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceNameClient) GetX(ctx context.Context, id int) *SourceName {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a SourceName.
func (c *SourceNameClient) QueryNamespace(sn *SourceName) *SourceNamespaceQuery {
	query := (&SourceNamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcename.Table, sourcename.FieldID, id),
			sqlgraph.To(sourcenamespace.Table, sourcenamespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, sourcename.NamespaceTable, sourcename.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOccurrences queries the occurrences edge of a SourceName.
func (c *SourceNameClient) QueryOccurrences(sn *SourceName) *OccurrenceQuery {
	query := (&OccurrenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcename.Table, sourcename.FieldID, id),
			sqlgraph.To(occurrence.Table, occurrence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcename.OccurrencesTable, sourcename.OccurrencesColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SourceNameClient) Hooks() []Hook {
	return c.hooks.SourceName
}

// Interceptors returns the client interceptors.
func (c *SourceNameClient) Interceptors() []Interceptor {
	return c.inters.SourceName
}

func (c *SourceNameClient) mutate(ctx context.Context, m *SourceNameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceNameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceNameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceNameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SourceName mutation op: %q", m.Op())
	}
}

// SourceNamespaceClient is a client for the SourceNamespace schema.
type SourceNamespaceClient struct {
	config
}

// NewSourceNamespaceClient returns a client for the SourceNamespace from the given config.
func NewSourceNamespaceClient(c config) *SourceNamespaceClient {
	return &SourceNamespaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sourcenamespace.Hooks(f(g(h())))`.
func (c *SourceNamespaceClient) Use(hooks ...Hook) {
	c.hooks.SourceNamespace = append(c.hooks.SourceNamespace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sourcenamespace.Intercept(f(g(h())))`.
func (c *SourceNamespaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.SourceNamespace = append(c.inters.SourceNamespace, interceptors...)
}

// Create returns a builder for creating a SourceNamespace entity.
func (c *SourceNamespaceClient) Create() *SourceNamespaceCreate {
	mutation := newSourceNamespaceMutation(c.config, OpCreate)
	return &SourceNamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SourceNamespace entities.
func (c *SourceNamespaceClient) CreateBulk(builders ...*SourceNamespaceCreate) *SourceNamespaceCreateBulk {
	return &SourceNamespaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SourceNamespaceClient) MapCreateBulk(slice any, setFunc func(*SourceNamespaceCreate, int)) *SourceNamespaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SourceNamespaceCreateBulk{err: fmt.Errorf("calling to SourceNamespaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SourceNamespaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SourceNamespaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SourceNamespace.
func (c *SourceNamespaceClient) Update() *SourceNamespaceUpdate {
	mutation := newSourceNamespaceMutation(c.config, OpUpdate)
	return &SourceNamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceNamespaceClient) UpdateOne(sn *SourceNamespace) *SourceNamespaceUpdateOne {
	mutation := newSourceNamespaceMutation(c.config, OpUpdateOne, withSourceNamespace(sn))
	return &SourceNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceNamespaceClient) UpdateOneID(id int) *SourceNamespaceUpdateOne {
	mutation := newSourceNamespaceMutation(c.config, OpUpdateOne, withSourceNamespaceID(id))
	return &SourceNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SourceNamespace.
func (c *SourceNamespaceClient) Delete() *SourceNamespaceDelete {
	mutation := newSourceNamespaceMutation(c.config, OpDelete)
	return &SourceNamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceNamespaceClient) DeleteOne(sn *SourceNamespace) *SourceNamespaceDeleteOne {
	return c.DeleteOneID(sn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceNamespaceClient) DeleteOneID(id int) *SourceNamespaceDeleteOne {
	builder := c.Delete().Where(sourcenamespace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceNamespaceDeleteOne{builder}
}

// Query returns a query builder for SourceNamespace.
func (c *SourceNamespaceClient) Query() *SourceNamespaceQuery {
	return &SourceNamespaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSourceNamespace},
		inters: c.Interceptors(),
	}
}

// Get returns a SourceNamespace entity by its id.
func (c *SourceNamespaceClient) Get(ctx context.Context, id int) (*SourceNamespace, error) {
	return c.Query().Where(sourcenamespace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceNamespaceClient) GetX(ctx context.Context, id int) *SourceNamespace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySourceType queries the source_type edge of a SourceNamespace.
func (c *SourceNamespaceClient) QuerySourceType(sn *SourceNamespace) *SourceTypeQuery {
	query := (&SourceTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcenamespace.Table, sourcenamespace.FieldID, id),
			sqlgraph.To(sourcetype.Table, sourcetype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, sourcenamespace.SourceTypeTable, sourcenamespace.SourceTypeColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNames queries the names edge of a SourceNamespace.
func (c *SourceNamespaceClient) QueryNames(sn *SourceNamespace) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcenamespace.Table, sourcenamespace.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcenamespace.NamesTable, sourcenamespace.NamesColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SourceNamespaceClient) Hooks() []Hook {
	return c.hooks.SourceNamespace
}

// Interceptors returns the client interceptors.
func (c *SourceNamespaceClient) Interceptors() []Interceptor {
	return c.inters.SourceNamespace
}

func (c *SourceNamespaceClient) mutate(ctx context.Context, m *SourceNamespaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceNamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceNamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceNamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SourceNamespace mutation op: %q", m.Op())
	}
}

// SourceTypeClient is a client for the SourceType schema.
type SourceTypeClient struct {
	config
}

// NewSourceTypeClient returns a client for the SourceType from the given config.
func NewSourceTypeClient(c config) *SourceTypeClient {
	return &SourceTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sourcetype.Hooks(f(g(h())))`.
func (c *SourceTypeClient) Use(hooks ...Hook) {
	c.hooks.SourceType = append(c.hooks.SourceType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sourcetype.Intercept(f(g(h())))`.
func (c *SourceTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.SourceType = append(c.inters.SourceType, interceptors...)
}

// Create returns a builder for creating a SourceType entity.
func (c *SourceTypeClient) Create() *SourceTypeCreate {
	mutation := newSourceTypeMutation(c.config, OpCreate)
	return &SourceTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SourceType entities.
func (c *SourceTypeClient) CreateBulk(builders ...*SourceTypeCreate) *SourceTypeCreateBulk {
	return &SourceTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SourceTypeClient) MapCreateBulk(slice any, setFunc func(*SourceTypeCreate, int)) *SourceTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SourceTypeCreateBulk{err: fmt.Errorf("calling to SourceTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SourceTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SourceTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SourceType.
func (c *SourceTypeClient) Update() *SourceTypeUpdate {
	mutation := newSourceTypeMutation(c.config, OpUpdate)
	return &SourceTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceTypeClient) UpdateOne(st *SourceType) *SourceTypeUpdateOne {
	mutation := newSourceTypeMutation(c.config, OpUpdateOne, withSourceType(st))
	return &SourceTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceTypeClient) UpdateOneID(id int) *SourceTypeUpdateOne {
	mutation := newSourceTypeMutation(c.config, OpUpdateOne, withSourceTypeID(id))
	return &SourceTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SourceType.
func (c *SourceTypeClient) Delete() *SourceTypeDelete {
	mutation := newSourceTypeMutation(c.config, OpDelete)
	return &SourceTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceTypeClient) DeleteOne(st *SourceType) *SourceTypeDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceTypeClient) DeleteOneID(id int) *SourceTypeDeleteOne {
	builder := c.Delete().Where(sourcetype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceTypeDeleteOne{builder}
}

// Query returns a query builder for SourceType.
func (c *SourceTypeClient) Query() *SourceTypeQuery {
	return &SourceTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSourceType},
		inters: c.Interceptors(),
	}
}

// Get returns a SourceType entity by its id.
func (c *SourceTypeClient) Get(ctx context.Context, id int) (*SourceType, error) {
	return c.Query().Where(sourcetype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceTypeClient) GetX(ctx context.Context, id int) *SourceType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespaces queries the namespaces edge of a SourceType.
func (c *SourceTypeClient) QueryNamespaces(st *SourceType) *SourceNamespaceQuery {
	query := (&SourceNamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcetype.Table, sourcetype.FieldID, id),
			sqlgraph.To(sourcenamespace.Table, sourcenamespace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcetype.NamespacesTable, sourcetype.NamespacesColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SourceTypeClient) Hooks() []Hook {
	return c.hooks.SourceType
}

// Interceptors returns the client interceptors.
func (c *SourceTypeClient) Interceptors() []Interceptor {
	return c.inters.SourceType
}

func (c *SourceTypeClient) mutate(ctx context.Context, m *SourceTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SourceType mutation op: %q", m.Op())
	}
}

// VulnEqualClient is a client for the VulnEqual schema.
type VulnEqualClient struct {
	config
}

// NewVulnEqualClient returns a client for the VulnEqual from the given config.
func NewVulnEqualClient(c config) *VulnEqualClient {
	return &VulnEqualClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vulnequal.Hooks(f(g(h())))`.
func (c *VulnEqualClient) Use(hooks ...Hook) {
	c.hooks.VulnEqual = append(c.hooks.VulnEqual, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vulnequal.Intercept(f(g(h())))`.
func (c *VulnEqualClient) Intercept(interceptors ...Interceptor) {
	c.inters.VulnEqual = append(c.inters.VulnEqual, interceptors...)
}

// Create returns a builder for creating a VulnEqual entity.
func (c *VulnEqualClient) Create() *VulnEqualCreate {
	mutation := newVulnEqualMutation(c.config, OpCreate)
	return &VulnEqualCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VulnEqual entities.
func (c *VulnEqualClient) CreateBulk(builders ...*VulnEqualCreate) *VulnEqualCreateBulk {
	return &VulnEqualCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VulnEqualClient) MapCreateBulk(slice any, setFunc func(*VulnEqualCreate, int)) *VulnEqualCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VulnEqualCreateBulk{err: fmt.Errorf("calling to VulnEqualClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VulnEqualCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VulnEqualCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VulnEqual.
func (c *VulnEqualClient) Update() *VulnEqualUpdate {
	mutation := newVulnEqualMutation(c.config, OpUpdate)
	return &VulnEqualUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VulnEqualClient) UpdateOne(ve *VulnEqual) *VulnEqualUpdateOne {
	mutation := newVulnEqualMutation(c.config, OpUpdateOne, withVulnEqual(ve))
	return &VulnEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VulnEqualClient) UpdateOneID(id int) *VulnEqualUpdateOne {
	mutation := newVulnEqualMutation(c.config, OpUpdateOne, withVulnEqualID(id))
	return &VulnEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VulnEqual.
func (c *VulnEqualClient) Delete() *VulnEqualDelete {
	mutation := newVulnEqualMutation(c.config, OpDelete)
	return &VulnEqualDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VulnEqualClient) DeleteOne(ve *VulnEqual) *VulnEqualDeleteOne {
	return c.DeleteOneID(ve.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VulnEqualClient) DeleteOneID(id int) *VulnEqualDeleteOne {
	builder := c.Delete().Where(vulnequal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VulnEqualDeleteOne{builder}
}

// Query returns a query builder for VulnEqual.
func (c *VulnEqualClient) Query() *VulnEqualQuery {
	return &VulnEqualQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVulnEqual},
		inters: c.Interceptors(),
	}
}

// Get returns a VulnEqual entity by its id.
func (c *VulnEqualClient) Get(ctx context.Context, id int) (*VulnEqual, error) {
	return c.Query().Where(vulnequal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VulnEqualClient) GetX(ctx context.Context, id int) *VulnEqual {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVulnerabilityIds queries the vulnerability_ids edge of a VulnEqual.
func (c *VulnEqualClient) QueryVulnerabilityIds(ve *VulnEqual) *VulnerabilityIDQuery {
	query := (&VulnerabilityIDClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ve.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnequal.Table, vulnequal.FieldID, id),
			sqlgraph.To(vulnerabilityid.Table, vulnerabilityid.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, vulnequal.VulnerabilityIdsTable, vulnequal.VulnerabilityIdsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ve.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VulnEqualClient) Hooks() []Hook {
	return c.hooks.VulnEqual
}

// Interceptors returns the client interceptors.
func (c *VulnEqualClient) Interceptors() []Interceptor {
	return c.inters.VulnEqual
}

func (c *VulnEqualClient) mutate(ctx context.Context, m *VulnEqualMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VulnEqualCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VulnEqualUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VulnEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VulnEqualDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VulnEqual mutation op: %q", m.Op())
	}
}

// VulnerabilityIDClient is a client for the VulnerabilityID schema.
type VulnerabilityIDClient struct {
	config
}

// NewVulnerabilityIDClient returns a client for the VulnerabilityID from the given config.
func NewVulnerabilityIDClient(c config) *VulnerabilityIDClient {
	return &VulnerabilityIDClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vulnerabilityid.Hooks(f(g(h())))`.
func (c *VulnerabilityIDClient) Use(hooks ...Hook) {
	c.hooks.VulnerabilityID = append(c.hooks.VulnerabilityID, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vulnerabilityid.Intercept(f(g(h())))`.
func (c *VulnerabilityIDClient) Intercept(interceptors ...Interceptor) {
	c.inters.VulnerabilityID = append(c.inters.VulnerabilityID, interceptors...)
}

// Create returns a builder for creating a VulnerabilityID entity.
func (c *VulnerabilityIDClient) Create() *VulnerabilityIDCreate {
	mutation := newVulnerabilityIDMutation(c.config, OpCreate)
	return &VulnerabilityIDCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VulnerabilityID entities.
func (c *VulnerabilityIDClient) CreateBulk(builders ...*VulnerabilityIDCreate) *VulnerabilityIDCreateBulk {
	return &VulnerabilityIDCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VulnerabilityIDClient) MapCreateBulk(slice any, setFunc func(*VulnerabilityIDCreate, int)) *VulnerabilityIDCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VulnerabilityIDCreateBulk{err: fmt.Errorf("calling to VulnerabilityIDClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VulnerabilityIDCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VulnerabilityIDCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VulnerabilityID.
func (c *VulnerabilityIDClient) Update() *VulnerabilityIDUpdate {
	mutation := newVulnerabilityIDMutation(c.config, OpUpdate)
	return &VulnerabilityIDUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VulnerabilityIDClient) UpdateOne(vi *VulnerabilityID) *VulnerabilityIDUpdateOne {
	mutation := newVulnerabilityIDMutation(c.config, OpUpdateOne, withVulnerabilityID(vi))
	return &VulnerabilityIDUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VulnerabilityIDClient) UpdateOneID(id int) *VulnerabilityIDUpdateOne {
	mutation := newVulnerabilityIDMutation(c.config, OpUpdateOne, withVulnerabilityIDID(id))
	return &VulnerabilityIDUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VulnerabilityID.
func (c *VulnerabilityIDClient) Delete() *VulnerabilityIDDelete {
	mutation := newVulnerabilityIDMutation(c.config, OpDelete)
	return &VulnerabilityIDDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VulnerabilityIDClient) DeleteOne(vi *VulnerabilityID) *VulnerabilityIDDeleteOne {
	return c.DeleteOneID(vi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VulnerabilityIDClient) DeleteOneID(id int) *VulnerabilityIDDeleteOne {
	builder := c.Delete().Where(vulnerabilityid.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VulnerabilityIDDeleteOne{builder}
}

// Query returns a query builder for VulnerabilityID.
func (c *VulnerabilityIDClient) Query() *VulnerabilityIDQuery {
	return &VulnerabilityIDQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVulnerabilityID},
		inters: c.Interceptors(),
	}
}

// Get returns a VulnerabilityID entity by its id.
func (c *VulnerabilityIDClient) Get(ctx context.Context, id int) (*VulnerabilityID, error) {
	return c.Query().Where(vulnerabilityid.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VulnerabilityIDClient) GetX(ctx context.Context, id int) *VulnerabilityID {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryType queries the type edge of a VulnerabilityID.
func (c *VulnerabilityIDClient) QueryType(vi *VulnerabilityID) *VulnerabilityTypeQuery {
	query := (&VulnerabilityTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityid.Table, vulnerabilityid.FieldID, id),
			sqlgraph.To(vulnerabilitytype.Table, vulnerabilitytype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vulnerabilityid.TypeTable, vulnerabilityid.TypeColumn),
		)
		fromV = sqlgraph.Neighbors(vi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnEquals queries the vuln_equals edge of a VulnerabilityID.
func (c *VulnerabilityIDClient) QueryVulnEquals(vi *VulnerabilityID) *VulnEqualQuery {
	query := (&VulnEqualClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityid.Table, vulnerabilityid.FieldID, id),
			sqlgraph.To(vulnequal.Table, vulnequal.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, vulnerabilityid.VulnEqualsTable, vulnerabilityid.VulnEqualsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(vi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VulnerabilityIDClient) Hooks() []Hook {
	return c.hooks.VulnerabilityID
}

// Interceptors returns the client interceptors.
func (c *VulnerabilityIDClient) Interceptors() []Interceptor {
	return c.inters.VulnerabilityID
}

func (c *VulnerabilityIDClient) mutate(ctx context.Context, m *VulnerabilityIDMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VulnerabilityIDCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VulnerabilityIDUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VulnerabilityIDUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VulnerabilityIDDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VulnerabilityID mutation op: %q", m.Op())
	}
}

// VulnerabilityTypeClient is a client for the VulnerabilityType schema.
type VulnerabilityTypeClient struct {
	config
}

// NewVulnerabilityTypeClient returns a client for the VulnerabilityType from the given config.
func NewVulnerabilityTypeClient(c config) *VulnerabilityTypeClient {
	return &VulnerabilityTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vulnerabilitytype.Hooks(f(g(h())))`.
func (c *VulnerabilityTypeClient) Use(hooks ...Hook) {
	c.hooks.VulnerabilityType = append(c.hooks.VulnerabilityType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vulnerabilitytype.Intercept(f(g(h())))`.
func (c *VulnerabilityTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.VulnerabilityType = append(c.inters.VulnerabilityType, interceptors...)
}

// Create returns a builder for creating a VulnerabilityType entity.
func (c *VulnerabilityTypeClient) Create() *VulnerabilityTypeCreate {
	mutation := newVulnerabilityTypeMutation(c.config, OpCreate)
	return &VulnerabilityTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VulnerabilityType entities.
func (c *VulnerabilityTypeClient) CreateBulk(builders ...*VulnerabilityTypeCreate) *VulnerabilityTypeCreateBulk {
	return &VulnerabilityTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VulnerabilityTypeClient) MapCreateBulk(slice any, setFunc func(*VulnerabilityTypeCreate, int)) *VulnerabilityTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VulnerabilityTypeCreateBulk{err: fmt.Errorf("calling to VulnerabilityTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VulnerabilityTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VulnerabilityTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VulnerabilityType.
func (c *VulnerabilityTypeClient) Update() *VulnerabilityTypeUpdate {
	mutation := newVulnerabilityTypeMutation(c.config, OpUpdate)
	return &VulnerabilityTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VulnerabilityTypeClient) UpdateOne(vt *VulnerabilityType) *VulnerabilityTypeUpdateOne {
	mutation := newVulnerabilityTypeMutation(c.config, OpUpdateOne, withVulnerabilityType(vt))
	return &VulnerabilityTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VulnerabilityTypeClient) UpdateOneID(id int) *VulnerabilityTypeUpdateOne {
	mutation := newVulnerabilityTypeMutation(c.config, OpUpdateOne, withVulnerabilityTypeID(id))
	return &VulnerabilityTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VulnerabilityType.
func (c *VulnerabilityTypeClient) Delete() *VulnerabilityTypeDelete {
	mutation := newVulnerabilityTypeMutation(c.config, OpDelete)
	return &VulnerabilityTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VulnerabilityTypeClient) DeleteOne(vt *VulnerabilityType) *VulnerabilityTypeDeleteOne {
	return c.DeleteOneID(vt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VulnerabilityTypeClient) DeleteOneID(id int) *VulnerabilityTypeDeleteOne {
	builder := c.Delete().Where(vulnerabilitytype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VulnerabilityTypeDeleteOne{builder}
}

// Query returns a query builder for VulnerabilityType.
func (c *VulnerabilityTypeClient) Query() *VulnerabilityTypeQuery {
	return &VulnerabilityTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVulnerabilityType},
		inters: c.Interceptors(),
	}
}

// Get returns a VulnerabilityType entity by its id.
func (c *VulnerabilityTypeClient) Get(ctx context.Context, id int) (*VulnerabilityType, error) {
	return c.Query().Where(vulnerabilitytype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VulnerabilityTypeClient) GetX(ctx context.Context, id int) *VulnerabilityType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVulnerabilityIds queries the vulnerability_ids edge of a VulnerabilityType.
func (c *VulnerabilityTypeClient) QueryVulnerabilityIds(vt *VulnerabilityType) *VulnerabilityIDQuery {
	query := (&VulnerabilityIDClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilitytype.Table, vulnerabilitytype.FieldID, id),
			sqlgraph.To(vulnerabilityid.Table, vulnerabilityid.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vulnerabilitytype.VulnerabilityIdsTable, vulnerabilitytype.VulnerabilityIdsColumn),
		)
		fromV = sqlgraph.Neighbors(vt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VulnerabilityTypeClient) Hooks() []Hook {
	return c.hooks.VulnerabilityType
}

// Interceptors returns the client interceptors.
func (c *VulnerabilityTypeClient) Interceptors() []Interceptor {
	return c.inters.VulnerabilityType
}

func (c *VulnerabilityTypeClient) mutate(ctx context.Context, m *VulnerabilityTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VulnerabilityTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VulnerabilityTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VulnerabilityTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VulnerabilityTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VulnerabilityType mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Artifact, BillOfMaterials, Builder, Certification, CertifyLegal,
		CertifyScorecard, CertifyVex, CertifyVuln, Dependency, HasSourceAt, HashEqual,
		IsVulnerability, License, Occurrence, PackageName, PackageNamespace,
		PackageType, PackageVersion, PkgEqual, SLSAAttestation, Scorecard, SourceName,
		SourceNamespace, SourceType, VulnEqual, VulnerabilityID,
		VulnerabilityType []ent.Hook
	}
	inters struct {
		Artifact, BillOfMaterials, Builder, Certification, CertifyLegal,
		CertifyScorecard, CertifyVex, CertifyVuln, Dependency, HasSourceAt, HashEqual,
		IsVulnerability, License, Occurrence, PackageName, PackageNamespace,
		PackageType, PackageVersion, PkgEqual, SLSAAttestation, Scorecard, SourceName,
		SourceNamespace, SourceType, VulnEqual, VulnerabilityID,
		VulnerabilityType []ent.Interceptor
	}
)
