// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/google/uuid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/artifact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/billofmaterials"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/builder"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certification"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifylegal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyscorecard"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvex"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/certifyvuln"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/dependency"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hashequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hasmetadata"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/hassourceat"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/license"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/occurrence"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pkgequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/pointofcontact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/slsaattestation"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnequal"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilityid"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/vulnerabilitymetadata"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Artifact is the client for interacting with the Artifact builders.
	Artifact *ArtifactClient
	// BillOfMaterials is the client for interacting with the BillOfMaterials builders.
	BillOfMaterials *BillOfMaterialsClient
	// Builder is the client for interacting with the Builder builders.
	Builder *BuilderClient
	// Certification is the client for interacting with the Certification builders.
	Certification *CertificationClient
	// CertifyLegal is the client for interacting with the CertifyLegal builders.
	CertifyLegal *CertifyLegalClient
	// CertifyScorecard is the client for interacting with the CertifyScorecard builders.
	CertifyScorecard *CertifyScorecardClient
	// CertifyVex is the client for interacting with the CertifyVex builders.
	CertifyVex *CertifyVexClient
	// CertifyVuln is the client for interacting with the CertifyVuln builders.
	CertifyVuln *CertifyVulnClient
	// Dependency is the client for interacting with the Dependency builders.
	Dependency *DependencyClient
	// HasMetadata is the client for interacting with the HasMetadata builders.
	HasMetadata *HasMetadataClient
	// HasSourceAt is the client for interacting with the HasSourceAt builders.
	HasSourceAt *HasSourceAtClient
	// HashEqual is the client for interacting with the HashEqual builders.
	HashEqual *HashEqualClient
	// License is the client for interacting with the License builders.
	License *LicenseClient
	// Occurrence is the client for interacting with the Occurrence builders.
	Occurrence *OccurrenceClient
	// PackageName is the client for interacting with the PackageName builders.
	PackageName *PackageNameClient
	// PackageVersion is the client for interacting with the PackageVersion builders.
	PackageVersion *PackageVersionClient
	// PkgEqual is the client for interacting with the PkgEqual builders.
	PkgEqual *PkgEqualClient
	// PointOfContact is the client for interacting with the PointOfContact builders.
	PointOfContact *PointOfContactClient
	// SLSAAttestation is the client for interacting with the SLSAAttestation builders.
	SLSAAttestation *SLSAAttestationClient
	// SourceName is the client for interacting with the SourceName builders.
	SourceName *SourceNameClient
	// VulnEqual is the client for interacting with the VulnEqual builders.
	VulnEqual *VulnEqualClient
	// VulnerabilityID is the client for interacting with the VulnerabilityID builders.
	VulnerabilityID *VulnerabilityIDClient
	// VulnerabilityMetadata is the client for interacting with the VulnerabilityMetadata builders.
	VulnerabilityMetadata *VulnerabilityMetadataClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Artifact = NewArtifactClient(c.config)
	c.BillOfMaterials = NewBillOfMaterialsClient(c.config)
	c.Builder = NewBuilderClient(c.config)
	c.Certification = NewCertificationClient(c.config)
	c.CertifyLegal = NewCertifyLegalClient(c.config)
	c.CertifyScorecard = NewCertifyScorecardClient(c.config)
	c.CertifyVex = NewCertifyVexClient(c.config)
	c.CertifyVuln = NewCertifyVulnClient(c.config)
	c.Dependency = NewDependencyClient(c.config)
	c.HasMetadata = NewHasMetadataClient(c.config)
	c.HasSourceAt = NewHasSourceAtClient(c.config)
	c.HashEqual = NewHashEqualClient(c.config)
	c.License = NewLicenseClient(c.config)
	c.Occurrence = NewOccurrenceClient(c.config)
	c.PackageName = NewPackageNameClient(c.config)
	c.PackageVersion = NewPackageVersionClient(c.config)
	c.PkgEqual = NewPkgEqualClient(c.config)
	c.PointOfContact = NewPointOfContactClient(c.config)
	c.SLSAAttestation = NewSLSAAttestationClient(c.config)
	c.SourceName = NewSourceNameClient(c.config)
	c.VulnEqual = NewVulnEqualClient(c.config)
	c.VulnerabilityID = NewVulnerabilityIDClient(c.config)
	c.VulnerabilityMetadata = NewVulnerabilityMetadataClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Artifact:              NewArtifactClient(cfg),
		BillOfMaterials:       NewBillOfMaterialsClient(cfg),
		Builder:               NewBuilderClient(cfg),
		Certification:         NewCertificationClient(cfg),
		CertifyLegal:          NewCertifyLegalClient(cfg),
		CertifyScorecard:      NewCertifyScorecardClient(cfg),
		CertifyVex:            NewCertifyVexClient(cfg),
		CertifyVuln:           NewCertifyVulnClient(cfg),
		Dependency:            NewDependencyClient(cfg),
		HasMetadata:           NewHasMetadataClient(cfg),
		HasSourceAt:           NewHasSourceAtClient(cfg),
		HashEqual:             NewHashEqualClient(cfg),
		License:               NewLicenseClient(cfg),
		Occurrence:            NewOccurrenceClient(cfg),
		PackageName:           NewPackageNameClient(cfg),
		PackageVersion:        NewPackageVersionClient(cfg),
		PkgEqual:              NewPkgEqualClient(cfg),
		PointOfContact:        NewPointOfContactClient(cfg),
		SLSAAttestation:       NewSLSAAttestationClient(cfg),
		SourceName:            NewSourceNameClient(cfg),
		VulnEqual:             NewVulnEqualClient(cfg),
		VulnerabilityID:       NewVulnerabilityIDClient(cfg),
		VulnerabilityMetadata: NewVulnerabilityMetadataClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Artifact:              NewArtifactClient(cfg),
		BillOfMaterials:       NewBillOfMaterialsClient(cfg),
		Builder:               NewBuilderClient(cfg),
		Certification:         NewCertificationClient(cfg),
		CertifyLegal:          NewCertifyLegalClient(cfg),
		CertifyScorecard:      NewCertifyScorecardClient(cfg),
		CertifyVex:            NewCertifyVexClient(cfg),
		CertifyVuln:           NewCertifyVulnClient(cfg),
		Dependency:            NewDependencyClient(cfg),
		HasMetadata:           NewHasMetadataClient(cfg),
		HasSourceAt:           NewHasSourceAtClient(cfg),
		HashEqual:             NewHashEqualClient(cfg),
		License:               NewLicenseClient(cfg),
		Occurrence:            NewOccurrenceClient(cfg),
		PackageName:           NewPackageNameClient(cfg),
		PackageVersion:        NewPackageVersionClient(cfg),
		PkgEqual:              NewPkgEqualClient(cfg),
		PointOfContact:        NewPointOfContactClient(cfg),
		SLSAAttestation:       NewSLSAAttestationClient(cfg),
		SourceName:            NewSourceNameClient(cfg),
		VulnEqual:             NewVulnEqualClient(cfg),
		VulnerabilityID:       NewVulnerabilityIDClient(cfg),
		VulnerabilityMetadata: NewVulnerabilityMetadataClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Artifact.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Artifact, c.BillOfMaterials, c.Builder, c.Certification, c.CertifyLegal,
		c.CertifyScorecard, c.CertifyVex, c.CertifyVuln, c.Dependency, c.HasMetadata,
		c.HasSourceAt, c.HashEqual, c.License, c.Occurrence, c.PackageName,
		c.PackageVersion, c.PkgEqual, c.PointOfContact, c.SLSAAttestation,
		c.SourceName, c.VulnEqual, c.VulnerabilityID, c.VulnerabilityMetadata,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Artifact, c.BillOfMaterials, c.Builder, c.Certification, c.CertifyLegal,
		c.CertifyScorecard, c.CertifyVex, c.CertifyVuln, c.Dependency, c.HasMetadata,
		c.HasSourceAt, c.HashEqual, c.License, c.Occurrence, c.PackageName,
		c.PackageVersion, c.PkgEqual, c.PointOfContact, c.SLSAAttestation,
		c.SourceName, c.VulnEqual, c.VulnerabilityID, c.VulnerabilityMetadata,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ArtifactMutation:
		return c.Artifact.mutate(ctx, m)
	case *BillOfMaterialsMutation:
		return c.BillOfMaterials.mutate(ctx, m)
	case *BuilderMutation:
		return c.Builder.mutate(ctx, m)
	case *CertificationMutation:
		return c.Certification.mutate(ctx, m)
	case *CertifyLegalMutation:
		return c.CertifyLegal.mutate(ctx, m)
	case *CertifyScorecardMutation:
		return c.CertifyScorecard.mutate(ctx, m)
	case *CertifyVexMutation:
		return c.CertifyVex.mutate(ctx, m)
	case *CertifyVulnMutation:
		return c.CertifyVuln.mutate(ctx, m)
	case *DependencyMutation:
		return c.Dependency.mutate(ctx, m)
	case *HasMetadataMutation:
		return c.HasMetadata.mutate(ctx, m)
	case *HasSourceAtMutation:
		return c.HasSourceAt.mutate(ctx, m)
	case *HashEqualMutation:
		return c.HashEqual.mutate(ctx, m)
	case *LicenseMutation:
		return c.License.mutate(ctx, m)
	case *OccurrenceMutation:
		return c.Occurrence.mutate(ctx, m)
	case *PackageNameMutation:
		return c.PackageName.mutate(ctx, m)
	case *PackageVersionMutation:
		return c.PackageVersion.mutate(ctx, m)
	case *PkgEqualMutation:
		return c.PkgEqual.mutate(ctx, m)
	case *PointOfContactMutation:
		return c.PointOfContact.mutate(ctx, m)
	case *SLSAAttestationMutation:
		return c.SLSAAttestation.mutate(ctx, m)
	case *SourceNameMutation:
		return c.SourceName.mutate(ctx, m)
	case *VulnEqualMutation:
		return c.VulnEqual.mutate(ctx, m)
	case *VulnerabilityIDMutation:
		return c.VulnerabilityID.mutate(ctx, m)
	case *VulnerabilityMetadataMutation:
		return c.VulnerabilityMetadata.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ArtifactClient is a client for the Artifact schema.
type ArtifactClient struct {
	config
}

// NewArtifactClient returns a client for the Artifact from the given config.
func NewArtifactClient(c config) *ArtifactClient {
	return &ArtifactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artifact.Hooks(f(g(h())))`.
func (c *ArtifactClient) Use(hooks ...Hook) {
	c.hooks.Artifact = append(c.hooks.Artifact, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `artifact.Intercept(f(g(h())))`.
func (c *ArtifactClient) Intercept(interceptors ...Interceptor) {
	c.inters.Artifact = append(c.inters.Artifact, interceptors...)
}

// Create returns a builder for creating a Artifact entity.
func (c *ArtifactClient) Create() *ArtifactCreate {
	mutation := newArtifactMutation(c.config, OpCreate)
	return &ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Artifact entities.
func (c *ArtifactClient) CreateBulk(builders ...*ArtifactCreate) *ArtifactCreateBulk {
	return &ArtifactCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ArtifactClient) MapCreateBulk(slice any, setFunc func(*ArtifactCreate, int)) *ArtifactCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ArtifactCreateBulk{err: fmt.Errorf("calling to ArtifactClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ArtifactCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ArtifactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Artifact.
func (c *ArtifactClient) Update() *ArtifactUpdate {
	mutation := newArtifactMutation(c.config, OpUpdate)
	return &ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtifactClient) UpdateOne(a *Artifact) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifact(a))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtifactClient) UpdateOneID(id uuid.UUID) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifactID(id))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Artifact.
func (c *ArtifactClient) Delete() *ArtifactDelete {
	mutation := newArtifactMutation(c.config, OpDelete)
	return &ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtifactClient) DeleteOne(a *Artifact) *ArtifactDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtifactClient) DeleteOneID(id uuid.UUID) *ArtifactDeleteOne {
	builder := c.Delete().Where(artifact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtifactDeleteOne{builder}
}

// Query returns a query builder for Artifact.
func (c *ArtifactClient) Query() *ArtifactQuery {
	return &ArtifactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArtifact},
		inters: c.Interceptors(),
	}
}

// Get returns a Artifact entity by its id.
func (c *ArtifactClient) Get(ctx context.Context, id uuid.UUID) (*Artifact, error) {
	return c.Query().Where(artifact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtifactClient) GetX(ctx context.Context, id uuid.UUID) *Artifact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOccurrences queries the occurrences edge of a Artifact.
func (c *ArtifactClient) QueryOccurrences(a *Artifact) *OccurrenceQuery {
	query := (&OccurrenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(occurrence.Table, occurrence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.OccurrencesTable, artifact.OccurrencesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySbom queries the sbom edge of a Artifact.
func (c *ArtifactClient) QuerySbom(a *Artifact) *BillOfMaterialsQuery {
	query := (&BillOfMaterialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(billofmaterials.Table, billofmaterials.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.SbomTable, artifact.SbomColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttestations queries the attestations edge of a Artifact.
func (c *ArtifactClient) QueryAttestations(a *Artifact) *SLSAAttestationQuery {
	query := (&SLSAAttestationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(slsaattestation.Table, slsaattestation.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, artifact.AttestationsTable, artifact.AttestationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttestationsSubject queries the attestations_subject edge of a Artifact.
func (c *ArtifactClient) QueryAttestationsSubject(a *Artifact) *SLSAAttestationQuery {
	query := (&SLSAAttestationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(slsaattestation.Table, slsaattestation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.AttestationsSubjectTable, artifact.AttestationsSubjectColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHashEqualArtA queries the hash_equal_art_a edge of a Artifact.
func (c *ArtifactClient) QueryHashEqualArtA(a *Artifact) *HashEqualQuery {
	query := (&HashEqualClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(hashequal.Table, hashequal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.HashEqualArtATable, artifact.HashEqualArtAColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHashEqualArtB queries the hash_equal_art_b edge of a Artifact.
func (c *ArtifactClient) QueryHashEqualArtB(a *Artifact) *HashEqualQuery {
	query := (&HashEqualClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(hashequal.Table, hashequal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.HashEqualArtBTable, artifact.HashEqualArtBColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVex queries the vex edge of a Artifact.
func (c *ArtifactClient) QueryVex(a *Artifact) *CertifyVexQuery {
	query := (&CertifyVexClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(certifyvex.Table, certifyvex.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.VexTable, artifact.VexColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCertification queries the certification edge of a Artifact.
func (c *ArtifactClient) QueryCertification(a *Artifact) *CertificationQuery {
	query := (&CertificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(certification.Table, certification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.CertificationTable, artifact.CertificationColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a Artifact.
func (c *ArtifactClient) QueryMetadata(a *Artifact) *HasMetadataQuery {
	query := (&HasMetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(hasmetadata.Table, hasmetadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.MetadataTable, artifact.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPoc queries the poc edge of a Artifact.
func (c *ArtifactClient) QueryPoc(a *Artifact) *PointOfContactQuery {
	query := (&PointOfContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(pointofcontact.Table, pointofcontact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.PocTable, artifact.PocColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedInSboms queries the included_in_sboms edge of a Artifact.
func (c *ArtifactClient) QueryIncludedInSboms(a *Artifact) *BillOfMaterialsQuery {
	query := (&BillOfMaterialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(billofmaterials.Table, billofmaterials.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, artifact.IncludedInSbomsTable, artifact.IncludedInSbomsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtifactClient) Hooks() []Hook {
	return c.hooks.Artifact
}

// Interceptors returns the client interceptors.
func (c *ArtifactClient) Interceptors() []Interceptor {
	return c.inters.Artifact
}

func (c *ArtifactClient) mutate(ctx context.Context, m *ArtifactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Artifact mutation op: %q", m.Op())
	}
}

// BillOfMaterialsClient is a client for the BillOfMaterials schema.
type BillOfMaterialsClient struct {
	config
}

// NewBillOfMaterialsClient returns a client for the BillOfMaterials from the given config.
func NewBillOfMaterialsClient(c config) *BillOfMaterialsClient {
	return &BillOfMaterialsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `billofmaterials.Hooks(f(g(h())))`.
func (c *BillOfMaterialsClient) Use(hooks ...Hook) {
	c.hooks.BillOfMaterials = append(c.hooks.BillOfMaterials, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `billofmaterials.Intercept(f(g(h())))`.
func (c *BillOfMaterialsClient) Intercept(interceptors ...Interceptor) {
	c.inters.BillOfMaterials = append(c.inters.BillOfMaterials, interceptors...)
}

// Create returns a builder for creating a BillOfMaterials entity.
func (c *BillOfMaterialsClient) Create() *BillOfMaterialsCreate {
	mutation := newBillOfMaterialsMutation(c.config, OpCreate)
	return &BillOfMaterialsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BillOfMaterials entities.
func (c *BillOfMaterialsClient) CreateBulk(builders ...*BillOfMaterialsCreate) *BillOfMaterialsCreateBulk {
	return &BillOfMaterialsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BillOfMaterialsClient) MapCreateBulk(slice any, setFunc func(*BillOfMaterialsCreate, int)) *BillOfMaterialsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BillOfMaterialsCreateBulk{err: fmt.Errorf("calling to BillOfMaterialsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BillOfMaterialsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BillOfMaterialsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BillOfMaterials.
func (c *BillOfMaterialsClient) Update() *BillOfMaterialsUpdate {
	mutation := newBillOfMaterialsMutation(c.config, OpUpdate)
	return &BillOfMaterialsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BillOfMaterialsClient) UpdateOne(bom *BillOfMaterials) *BillOfMaterialsUpdateOne {
	mutation := newBillOfMaterialsMutation(c.config, OpUpdateOne, withBillOfMaterials(bom))
	return &BillOfMaterialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BillOfMaterialsClient) UpdateOneID(id uuid.UUID) *BillOfMaterialsUpdateOne {
	mutation := newBillOfMaterialsMutation(c.config, OpUpdateOne, withBillOfMaterialsID(id))
	return &BillOfMaterialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BillOfMaterials.
func (c *BillOfMaterialsClient) Delete() *BillOfMaterialsDelete {
	mutation := newBillOfMaterialsMutation(c.config, OpDelete)
	return &BillOfMaterialsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BillOfMaterialsClient) DeleteOne(bom *BillOfMaterials) *BillOfMaterialsDeleteOne {
	return c.DeleteOneID(bom.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BillOfMaterialsClient) DeleteOneID(id uuid.UUID) *BillOfMaterialsDeleteOne {
	builder := c.Delete().Where(billofmaterials.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BillOfMaterialsDeleteOne{builder}
}

// Query returns a query builder for BillOfMaterials.
func (c *BillOfMaterialsClient) Query() *BillOfMaterialsQuery {
	return &BillOfMaterialsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBillOfMaterials},
		inters: c.Interceptors(),
	}
}

// Get returns a BillOfMaterials entity by its id.
func (c *BillOfMaterialsClient) Get(ctx context.Context, id uuid.UUID) (*BillOfMaterials, error) {
	return c.Query().Where(billofmaterials.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BillOfMaterialsClient) GetX(ctx context.Context, id uuid.UUID) *BillOfMaterials {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a BillOfMaterials.
func (c *BillOfMaterialsClient) QueryPackage(bom *BillOfMaterials) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bom.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(billofmaterials.Table, billofmaterials.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, billofmaterials.PackageTable, billofmaterials.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(bom.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifact queries the artifact edge of a BillOfMaterials.
func (c *BillOfMaterialsClient) QueryArtifact(bom *BillOfMaterials) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bom.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(billofmaterials.Table, billofmaterials.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, billofmaterials.ArtifactTable, billofmaterials.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(bom.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedSoftwarePackages queries the included_software_packages edge of a BillOfMaterials.
func (c *BillOfMaterialsClient) QueryIncludedSoftwarePackages(bom *BillOfMaterials) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bom.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(billofmaterials.Table, billofmaterials.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, billofmaterials.IncludedSoftwarePackagesTable, billofmaterials.IncludedSoftwarePackagesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(bom.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedSoftwareArtifacts queries the included_software_artifacts edge of a BillOfMaterials.
func (c *BillOfMaterialsClient) QueryIncludedSoftwareArtifacts(bom *BillOfMaterials) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bom.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(billofmaterials.Table, billofmaterials.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, billofmaterials.IncludedSoftwareArtifactsTable, billofmaterials.IncludedSoftwareArtifactsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(bom.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedDependencies queries the included_dependencies edge of a BillOfMaterials.
func (c *BillOfMaterialsClient) QueryIncludedDependencies(bom *BillOfMaterials) *DependencyQuery {
	query := (&DependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bom.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(billofmaterials.Table, billofmaterials.FieldID, id),
			sqlgraph.To(dependency.Table, dependency.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, billofmaterials.IncludedDependenciesTable, billofmaterials.IncludedDependenciesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(bom.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedOccurrences queries the included_occurrences edge of a BillOfMaterials.
func (c *BillOfMaterialsClient) QueryIncludedOccurrences(bom *BillOfMaterials) *OccurrenceQuery {
	query := (&OccurrenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bom.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(billofmaterials.Table, billofmaterials.FieldID, id),
			sqlgraph.To(occurrence.Table, occurrence.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, billofmaterials.IncludedOccurrencesTable, billofmaterials.IncludedOccurrencesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(bom.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BillOfMaterialsClient) Hooks() []Hook {
	return c.hooks.BillOfMaterials
}

// Interceptors returns the client interceptors.
func (c *BillOfMaterialsClient) Interceptors() []Interceptor {
	return c.inters.BillOfMaterials
}

func (c *BillOfMaterialsClient) mutate(ctx context.Context, m *BillOfMaterialsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BillOfMaterialsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BillOfMaterialsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BillOfMaterialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BillOfMaterialsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BillOfMaterials mutation op: %q", m.Op())
	}
}

// BuilderClient is a client for the Builder schema.
type BuilderClient struct {
	config
}

// NewBuilderClient returns a client for the Builder from the given config.
func NewBuilderClient(c config) *BuilderClient {
	return &BuilderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `builder.Hooks(f(g(h())))`.
func (c *BuilderClient) Use(hooks ...Hook) {
	c.hooks.Builder = append(c.hooks.Builder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `builder.Intercept(f(g(h())))`.
func (c *BuilderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Builder = append(c.inters.Builder, interceptors...)
}

// Create returns a builder for creating a Builder entity.
func (c *BuilderClient) Create() *BuilderCreate {
	mutation := newBuilderMutation(c.config, OpCreate)
	return &BuilderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Builder entities.
func (c *BuilderClient) CreateBulk(builders ...*BuilderCreate) *BuilderCreateBulk {
	return &BuilderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BuilderClient) MapCreateBulk(slice any, setFunc func(*BuilderCreate, int)) *BuilderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BuilderCreateBulk{err: fmt.Errorf("calling to BuilderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BuilderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BuilderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Builder.
func (c *BuilderClient) Update() *BuilderUpdate {
	mutation := newBuilderMutation(c.config, OpUpdate)
	return &BuilderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BuilderClient) UpdateOne(b *Builder) *BuilderUpdateOne {
	mutation := newBuilderMutation(c.config, OpUpdateOne, withBuilder(b))
	return &BuilderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BuilderClient) UpdateOneID(id uuid.UUID) *BuilderUpdateOne {
	mutation := newBuilderMutation(c.config, OpUpdateOne, withBuilderID(id))
	return &BuilderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Builder.
func (c *BuilderClient) Delete() *BuilderDelete {
	mutation := newBuilderMutation(c.config, OpDelete)
	return &BuilderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BuilderClient) DeleteOne(b *Builder) *BuilderDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BuilderClient) DeleteOneID(id uuid.UUID) *BuilderDeleteOne {
	builderC := c.Delete().Where(builder.ID(id))
	builderC.mutation.id = &id
	builderC.mutation.op = OpDeleteOne
	return &BuilderDeleteOne{builderC}
}

// Query returns a query builder for Builder.
func (c *BuilderClient) Query() *BuilderQuery {
	return &BuilderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBuilder},
		inters: c.Interceptors(),
	}
}

// Get returns a Builder entity by its id.
func (c *BuilderClient) Get(ctx context.Context, id uuid.UUID) (*Builder, error) {
	return c.Query().Where(builder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BuilderClient) GetX(ctx context.Context, id uuid.UUID) *Builder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySlsaAttestations queries the slsa_attestations edge of a Builder.
func (c *BuilderClient) QuerySlsaAttestations(b *Builder) *SLSAAttestationQuery {
	query := (&SLSAAttestationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(builder.Table, builder.FieldID, id),
			sqlgraph.To(slsaattestation.Table, slsaattestation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, builder.SlsaAttestationsTable, builder.SlsaAttestationsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BuilderClient) Hooks() []Hook {
	return c.hooks.Builder
}

// Interceptors returns the client interceptors.
func (c *BuilderClient) Interceptors() []Interceptor {
	return c.inters.Builder
}

func (c *BuilderClient) mutate(ctx context.Context, m *BuilderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BuilderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BuilderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BuilderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BuilderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Builder mutation op: %q", m.Op())
	}
}

// CertificationClient is a client for the Certification schema.
type CertificationClient struct {
	config
}

// NewCertificationClient returns a client for the Certification from the given config.
func NewCertificationClient(c config) *CertificationClient {
	return &CertificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certification.Hooks(f(g(h())))`.
func (c *CertificationClient) Use(hooks ...Hook) {
	c.hooks.Certification = append(c.hooks.Certification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certification.Intercept(f(g(h())))`.
func (c *CertificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Certification = append(c.inters.Certification, interceptors...)
}

// Create returns a builder for creating a Certification entity.
func (c *CertificationClient) Create() *CertificationCreate {
	mutation := newCertificationMutation(c.config, OpCreate)
	return &CertificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Certification entities.
func (c *CertificationClient) CreateBulk(builders ...*CertificationCreate) *CertificationCreateBulk {
	return &CertificationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertificationClient) MapCreateBulk(slice any, setFunc func(*CertificationCreate, int)) *CertificationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertificationCreateBulk{err: fmt.Errorf("calling to CertificationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertificationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Certification.
func (c *CertificationClient) Update() *CertificationUpdate {
	mutation := newCertificationMutation(c.config, OpUpdate)
	return &CertificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertificationClient) UpdateOne(ce *Certification) *CertificationUpdateOne {
	mutation := newCertificationMutation(c.config, OpUpdateOne, withCertification(ce))
	return &CertificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertificationClient) UpdateOneID(id uuid.UUID) *CertificationUpdateOne {
	mutation := newCertificationMutation(c.config, OpUpdateOne, withCertificationID(id))
	return &CertificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Certification.
func (c *CertificationClient) Delete() *CertificationDelete {
	mutation := newCertificationMutation(c.config, OpDelete)
	return &CertificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertificationClient) DeleteOne(ce *Certification) *CertificationDeleteOne {
	return c.DeleteOneID(ce.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertificationClient) DeleteOneID(id uuid.UUID) *CertificationDeleteOne {
	builder := c.Delete().Where(certification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertificationDeleteOne{builder}
}

// Query returns a query builder for Certification.
func (c *CertificationClient) Query() *CertificationQuery {
	return &CertificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertification},
		inters: c.Interceptors(),
	}
}

// Get returns a Certification entity by its id.
func (c *CertificationClient) Get(ctx context.Context, id uuid.UUID) (*Certification, error) {
	return c.Query().Where(certification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertificationClient) GetX(ctx context.Context, id uuid.UUID) *Certification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySource queries the source edge of a Certification.
func (c *CertificationClient) QuerySource(ce *Certification) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certification.Table, certification.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certification.SourceTable, certification.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPackageVersion queries the package_version edge of a Certification.
func (c *CertificationClient) QueryPackageVersion(ce *Certification) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certification.Table, certification.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certification.PackageVersionTable, certification.PackageVersionColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAllVersions queries the all_versions edge of a Certification.
func (c *CertificationClient) QueryAllVersions(ce *Certification) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certification.Table, certification.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certification.AllVersionsTable, certification.AllVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifact queries the artifact edge of a Certification.
func (c *CertificationClient) QueryArtifact(ce *Certification) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certification.Table, certification.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certification.ArtifactTable, certification.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertificationClient) Hooks() []Hook {
	return c.hooks.Certification
}

// Interceptors returns the client interceptors.
func (c *CertificationClient) Interceptors() []Interceptor {
	return c.inters.Certification
}

func (c *CertificationClient) mutate(ctx context.Context, m *CertificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Certification mutation op: %q", m.Op())
	}
}

// CertifyLegalClient is a client for the CertifyLegal schema.
type CertifyLegalClient struct {
	config
}

// NewCertifyLegalClient returns a client for the CertifyLegal from the given config.
func NewCertifyLegalClient(c config) *CertifyLegalClient {
	return &CertifyLegalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certifylegal.Hooks(f(g(h())))`.
func (c *CertifyLegalClient) Use(hooks ...Hook) {
	c.hooks.CertifyLegal = append(c.hooks.CertifyLegal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certifylegal.Intercept(f(g(h())))`.
func (c *CertifyLegalClient) Intercept(interceptors ...Interceptor) {
	c.inters.CertifyLegal = append(c.inters.CertifyLegal, interceptors...)
}

// Create returns a builder for creating a CertifyLegal entity.
func (c *CertifyLegalClient) Create() *CertifyLegalCreate {
	mutation := newCertifyLegalMutation(c.config, OpCreate)
	return &CertifyLegalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CertifyLegal entities.
func (c *CertifyLegalClient) CreateBulk(builders ...*CertifyLegalCreate) *CertifyLegalCreateBulk {
	return &CertifyLegalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertifyLegalClient) MapCreateBulk(slice any, setFunc func(*CertifyLegalCreate, int)) *CertifyLegalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertifyLegalCreateBulk{err: fmt.Errorf("calling to CertifyLegalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertifyLegalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertifyLegalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CertifyLegal.
func (c *CertifyLegalClient) Update() *CertifyLegalUpdate {
	mutation := newCertifyLegalMutation(c.config, OpUpdate)
	return &CertifyLegalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertifyLegalClient) UpdateOne(cl *CertifyLegal) *CertifyLegalUpdateOne {
	mutation := newCertifyLegalMutation(c.config, OpUpdateOne, withCertifyLegal(cl))
	return &CertifyLegalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertifyLegalClient) UpdateOneID(id uuid.UUID) *CertifyLegalUpdateOne {
	mutation := newCertifyLegalMutation(c.config, OpUpdateOne, withCertifyLegalID(id))
	return &CertifyLegalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CertifyLegal.
func (c *CertifyLegalClient) Delete() *CertifyLegalDelete {
	mutation := newCertifyLegalMutation(c.config, OpDelete)
	return &CertifyLegalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertifyLegalClient) DeleteOne(cl *CertifyLegal) *CertifyLegalDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertifyLegalClient) DeleteOneID(id uuid.UUID) *CertifyLegalDeleteOne {
	builder := c.Delete().Where(certifylegal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertifyLegalDeleteOne{builder}
}

// Query returns a query builder for CertifyLegal.
func (c *CertifyLegalClient) Query() *CertifyLegalQuery {
	return &CertifyLegalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertifyLegal},
		inters: c.Interceptors(),
	}
}

// Get returns a CertifyLegal entity by its id.
func (c *CertifyLegalClient) Get(ctx context.Context, id uuid.UUID) (*CertifyLegal, error) {
	return c.Query().Where(certifylegal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertifyLegalClient) GetX(ctx context.Context, id uuid.UUID) *CertifyLegal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a CertifyLegal.
func (c *CertifyLegalClient) QueryPackage(cl *CertifyLegal) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifylegal.Table, certifylegal.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifylegal.PackageTable, certifylegal.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySource queries the source edge of a CertifyLegal.
func (c *CertifyLegalClient) QuerySource(cl *CertifyLegal) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifylegal.Table, certifylegal.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifylegal.SourceTable, certifylegal.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeclaredLicenses queries the declared_licenses edge of a CertifyLegal.
func (c *CertifyLegalClient) QueryDeclaredLicenses(cl *CertifyLegal) *LicenseQuery {
	query := (&LicenseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifylegal.Table, certifylegal.FieldID, id),
			sqlgraph.To(license.Table, license.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, certifylegal.DeclaredLicensesTable, certifylegal.DeclaredLicensesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscoveredLicenses queries the discovered_licenses edge of a CertifyLegal.
func (c *CertifyLegalClient) QueryDiscoveredLicenses(cl *CertifyLegal) *LicenseQuery {
	query := (&LicenseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifylegal.Table, certifylegal.FieldID, id),
			sqlgraph.To(license.Table, license.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, certifylegal.DiscoveredLicensesTable, certifylegal.DiscoveredLicensesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertifyLegalClient) Hooks() []Hook {
	return c.hooks.CertifyLegal
}

// Interceptors returns the client interceptors.
func (c *CertifyLegalClient) Interceptors() []Interceptor {
	return c.inters.CertifyLegal
}

func (c *CertifyLegalClient) mutate(ctx context.Context, m *CertifyLegalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertifyLegalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertifyLegalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertifyLegalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertifyLegalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CertifyLegal mutation op: %q", m.Op())
	}
}

// CertifyScorecardClient is a client for the CertifyScorecard schema.
type CertifyScorecardClient struct {
	config
}

// NewCertifyScorecardClient returns a client for the CertifyScorecard from the given config.
func NewCertifyScorecardClient(c config) *CertifyScorecardClient {
	return &CertifyScorecardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certifyscorecard.Hooks(f(g(h())))`.
func (c *CertifyScorecardClient) Use(hooks ...Hook) {
	c.hooks.CertifyScorecard = append(c.hooks.CertifyScorecard, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certifyscorecard.Intercept(f(g(h())))`.
func (c *CertifyScorecardClient) Intercept(interceptors ...Interceptor) {
	c.inters.CertifyScorecard = append(c.inters.CertifyScorecard, interceptors...)
}

// Create returns a builder for creating a CertifyScorecard entity.
func (c *CertifyScorecardClient) Create() *CertifyScorecardCreate {
	mutation := newCertifyScorecardMutation(c.config, OpCreate)
	return &CertifyScorecardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CertifyScorecard entities.
func (c *CertifyScorecardClient) CreateBulk(builders ...*CertifyScorecardCreate) *CertifyScorecardCreateBulk {
	return &CertifyScorecardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertifyScorecardClient) MapCreateBulk(slice any, setFunc func(*CertifyScorecardCreate, int)) *CertifyScorecardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertifyScorecardCreateBulk{err: fmt.Errorf("calling to CertifyScorecardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertifyScorecardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertifyScorecardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CertifyScorecard.
func (c *CertifyScorecardClient) Update() *CertifyScorecardUpdate {
	mutation := newCertifyScorecardMutation(c.config, OpUpdate)
	return &CertifyScorecardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertifyScorecardClient) UpdateOne(cs *CertifyScorecard) *CertifyScorecardUpdateOne {
	mutation := newCertifyScorecardMutation(c.config, OpUpdateOne, withCertifyScorecard(cs))
	return &CertifyScorecardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertifyScorecardClient) UpdateOneID(id uuid.UUID) *CertifyScorecardUpdateOne {
	mutation := newCertifyScorecardMutation(c.config, OpUpdateOne, withCertifyScorecardID(id))
	return &CertifyScorecardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CertifyScorecard.
func (c *CertifyScorecardClient) Delete() *CertifyScorecardDelete {
	mutation := newCertifyScorecardMutation(c.config, OpDelete)
	return &CertifyScorecardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertifyScorecardClient) DeleteOne(cs *CertifyScorecard) *CertifyScorecardDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertifyScorecardClient) DeleteOneID(id uuid.UUID) *CertifyScorecardDeleteOne {
	builder := c.Delete().Where(certifyscorecard.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertifyScorecardDeleteOne{builder}
}

// Query returns a query builder for CertifyScorecard.
func (c *CertifyScorecardClient) Query() *CertifyScorecardQuery {
	return &CertifyScorecardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertifyScorecard},
		inters: c.Interceptors(),
	}
}

// Get returns a CertifyScorecard entity by its id.
func (c *CertifyScorecardClient) Get(ctx context.Context, id uuid.UUID) (*CertifyScorecard, error) {
	return c.Query().Where(certifyscorecard.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertifyScorecardClient) GetX(ctx context.Context, id uuid.UUID) *CertifyScorecard {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySource queries the source edge of a CertifyScorecard.
func (c *CertifyScorecardClient) QuerySource(cs *CertifyScorecard) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifyscorecard.Table, certifyscorecard.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifyscorecard.SourceTable, certifyscorecard.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertifyScorecardClient) Hooks() []Hook {
	return c.hooks.CertifyScorecard
}

// Interceptors returns the client interceptors.
func (c *CertifyScorecardClient) Interceptors() []Interceptor {
	return c.inters.CertifyScorecard
}

func (c *CertifyScorecardClient) mutate(ctx context.Context, m *CertifyScorecardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertifyScorecardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertifyScorecardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertifyScorecardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertifyScorecardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CertifyScorecard mutation op: %q", m.Op())
	}
}

// CertifyVexClient is a client for the CertifyVex schema.
type CertifyVexClient struct {
	config
}

// NewCertifyVexClient returns a client for the CertifyVex from the given config.
func NewCertifyVexClient(c config) *CertifyVexClient {
	return &CertifyVexClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certifyvex.Hooks(f(g(h())))`.
func (c *CertifyVexClient) Use(hooks ...Hook) {
	c.hooks.CertifyVex = append(c.hooks.CertifyVex, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certifyvex.Intercept(f(g(h())))`.
func (c *CertifyVexClient) Intercept(interceptors ...Interceptor) {
	c.inters.CertifyVex = append(c.inters.CertifyVex, interceptors...)
}

// Create returns a builder for creating a CertifyVex entity.
func (c *CertifyVexClient) Create() *CertifyVexCreate {
	mutation := newCertifyVexMutation(c.config, OpCreate)
	return &CertifyVexCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CertifyVex entities.
func (c *CertifyVexClient) CreateBulk(builders ...*CertifyVexCreate) *CertifyVexCreateBulk {
	return &CertifyVexCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertifyVexClient) MapCreateBulk(slice any, setFunc func(*CertifyVexCreate, int)) *CertifyVexCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertifyVexCreateBulk{err: fmt.Errorf("calling to CertifyVexClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertifyVexCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertifyVexCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CertifyVex.
func (c *CertifyVexClient) Update() *CertifyVexUpdate {
	mutation := newCertifyVexMutation(c.config, OpUpdate)
	return &CertifyVexUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertifyVexClient) UpdateOne(cv *CertifyVex) *CertifyVexUpdateOne {
	mutation := newCertifyVexMutation(c.config, OpUpdateOne, withCertifyVex(cv))
	return &CertifyVexUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertifyVexClient) UpdateOneID(id uuid.UUID) *CertifyVexUpdateOne {
	mutation := newCertifyVexMutation(c.config, OpUpdateOne, withCertifyVexID(id))
	return &CertifyVexUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CertifyVex.
func (c *CertifyVexClient) Delete() *CertifyVexDelete {
	mutation := newCertifyVexMutation(c.config, OpDelete)
	return &CertifyVexDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertifyVexClient) DeleteOne(cv *CertifyVex) *CertifyVexDeleteOne {
	return c.DeleteOneID(cv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertifyVexClient) DeleteOneID(id uuid.UUID) *CertifyVexDeleteOne {
	builder := c.Delete().Where(certifyvex.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertifyVexDeleteOne{builder}
}

// Query returns a query builder for CertifyVex.
func (c *CertifyVexClient) Query() *CertifyVexQuery {
	return &CertifyVexQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertifyVex},
		inters: c.Interceptors(),
	}
}

// Get returns a CertifyVex entity by its id.
func (c *CertifyVexClient) Get(ctx context.Context, id uuid.UUID) (*CertifyVex, error) {
	return c.Query().Where(certifyvex.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertifyVexClient) GetX(ctx context.Context, id uuid.UUID) *CertifyVex {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a CertifyVex.
func (c *CertifyVexClient) QueryPackage(cv *CertifyVex) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifyvex.Table, certifyvex.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifyvex.PackageTable, certifyvex.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifact queries the artifact edge of a CertifyVex.
func (c *CertifyVexClient) QueryArtifact(cv *CertifyVex) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifyvex.Table, certifyvex.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifyvex.ArtifactTable, certifyvex.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerability queries the vulnerability edge of a CertifyVex.
func (c *CertifyVexClient) QueryVulnerability(cv *CertifyVex) *VulnerabilityIDQuery {
	query := (&VulnerabilityIDClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifyvex.Table, certifyvex.FieldID, id),
			sqlgraph.To(vulnerabilityid.Table, vulnerabilityid.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifyvex.VulnerabilityTable, certifyvex.VulnerabilityColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertifyVexClient) Hooks() []Hook {
	return c.hooks.CertifyVex
}

// Interceptors returns the client interceptors.
func (c *CertifyVexClient) Interceptors() []Interceptor {
	return c.inters.CertifyVex
}

func (c *CertifyVexClient) mutate(ctx context.Context, m *CertifyVexMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertifyVexCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertifyVexUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertifyVexUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertifyVexDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CertifyVex mutation op: %q", m.Op())
	}
}

// CertifyVulnClient is a client for the CertifyVuln schema.
type CertifyVulnClient struct {
	config
}

// NewCertifyVulnClient returns a client for the CertifyVuln from the given config.
func NewCertifyVulnClient(c config) *CertifyVulnClient {
	return &CertifyVulnClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certifyvuln.Hooks(f(g(h())))`.
func (c *CertifyVulnClient) Use(hooks ...Hook) {
	c.hooks.CertifyVuln = append(c.hooks.CertifyVuln, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certifyvuln.Intercept(f(g(h())))`.
func (c *CertifyVulnClient) Intercept(interceptors ...Interceptor) {
	c.inters.CertifyVuln = append(c.inters.CertifyVuln, interceptors...)
}

// Create returns a builder for creating a CertifyVuln entity.
func (c *CertifyVulnClient) Create() *CertifyVulnCreate {
	mutation := newCertifyVulnMutation(c.config, OpCreate)
	return &CertifyVulnCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CertifyVuln entities.
func (c *CertifyVulnClient) CreateBulk(builders ...*CertifyVulnCreate) *CertifyVulnCreateBulk {
	return &CertifyVulnCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertifyVulnClient) MapCreateBulk(slice any, setFunc func(*CertifyVulnCreate, int)) *CertifyVulnCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertifyVulnCreateBulk{err: fmt.Errorf("calling to CertifyVulnClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertifyVulnCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertifyVulnCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CertifyVuln.
func (c *CertifyVulnClient) Update() *CertifyVulnUpdate {
	mutation := newCertifyVulnMutation(c.config, OpUpdate)
	return &CertifyVulnUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertifyVulnClient) UpdateOne(cv *CertifyVuln) *CertifyVulnUpdateOne {
	mutation := newCertifyVulnMutation(c.config, OpUpdateOne, withCertifyVuln(cv))
	return &CertifyVulnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertifyVulnClient) UpdateOneID(id uuid.UUID) *CertifyVulnUpdateOne {
	mutation := newCertifyVulnMutation(c.config, OpUpdateOne, withCertifyVulnID(id))
	return &CertifyVulnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CertifyVuln.
func (c *CertifyVulnClient) Delete() *CertifyVulnDelete {
	mutation := newCertifyVulnMutation(c.config, OpDelete)
	return &CertifyVulnDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertifyVulnClient) DeleteOne(cv *CertifyVuln) *CertifyVulnDeleteOne {
	return c.DeleteOneID(cv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertifyVulnClient) DeleteOneID(id uuid.UUID) *CertifyVulnDeleteOne {
	builder := c.Delete().Where(certifyvuln.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertifyVulnDeleteOne{builder}
}

// Query returns a query builder for CertifyVuln.
func (c *CertifyVulnClient) Query() *CertifyVulnQuery {
	return &CertifyVulnQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertifyVuln},
		inters: c.Interceptors(),
	}
}

// Get returns a CertifyVuln entity by its id.
func (c *CertifyVulnClient) Get(ctx context.Context, id uuid.UUID) (*CertifyVuln, error) {
	return c.Query().Where(certifyvuln.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertifyVulnClient) GetX(ctx context.Context, id uuid.UUID) *CertifyVuln {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVulnerability queries the vulnerability edge of a CertifyVuln.
func (c *CertifyVulnClient) QueryVulnerability(cv *CertifyVuln) *VulnerabilityIDQuery {
	query := (&VulnerabilityIDClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifyvuln.Table, certifyvuln.FieldID, id),
			sqlgraph.To(vulnerabilityid.Table, vulnerabilityid.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifyvuln.VulnerabilityTable, certifyvuln.VulnerabilityColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPackage queries the package edge of a CertifyVuln.
func (c *CertifyVulnClient) QueryPackage(cv *CertifyVuln) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certifyvuln.Table, certifyvuln.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certifyvuln.PackageTable, certifyvuln.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertifyVulnClient) Hooks() []Hook {
	return c.hooks.CertifyVuln
}

// Interceptors returns the client interceptors.
func (c *CertifyVulnClient) Interceptors() []Interceptor {
	return c.inters.CertifyVuln
}

func (c *CertifyVulnClient) mutate(ctx context.Context, m *CertifyVulnMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertifyVulnCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertifyVulnUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertifyVulnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertifyVulnDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CertifyVuln mutation op: %q", m.Op())
	}
}

// DependencyClient is a client for the Dependency schema.
type DependencyClient struct {
	config
}

// NewDependencyClient returns a client for the Dependency from the given config.
func NewDependencyClient(c config) *DependencyClient {
	return &DependencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dependency.Hooks(f(g(h())))`.
func (c *DependencyClient) Use(hooks ...Hook) {
	c.hooks.Dependency = append(c.hooks.Dependency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dependency.Intercept(f(g(h())))`.
func (c *DependencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Dependency = append(c.inters.Dependency, interceptors...)
}

// Create returns a builder for creating a Dependency entity.
func (c *DependencyClient) Create() *DependencyCreate {
	mutation := newDependencyMutation(c.config, OpCreate)
	return &DependencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dependency entities.
func (c *DependencyClient) CreateBulk(builders ...*DependencyCreate) *DependencyCreateBulk {
	return &DependencyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DependencyClient) MapCreateBulk(slice any, setFunc func(*DependencyCreate, int)) *DependencyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DependencyCreateBulk{err: fmt.Errorf("calling to DependencyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DependencyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DependencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dependency.
func (c *DependencyClient) Update() *DependencyUpdate {
	mutation := newDependencyMutation(c.config, OpUpdate)
	return &DependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DependencyClient) UpdateOne(d *Dependency) *DependencyUpdateOne {
	mutation := newDependencyMutation(c.config, OpUpdateOne, withDependency(d))
	return &DependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DependencyClient) UpdateOneID(id uuid.UUID) *DependencyUpdateOne {
	mutation := newDependencyMutation(c.config, OpUpdateOne, withDependencyID(id))
	return &DependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dependency.
func (c *DependencyClient) Delete() *DependencyDelete {
	mutation := newDependencyMutation(c.config, OpDelete)
	return &DependencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DependencyClient) DeleteOne(d *Dependency) *DependencyDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DependencyClient) DeleteOneID(id uuid.UUID) *DependencyDeleteOne {
	builder := c.Delete().Where(dependency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DependencyDeleteOne{builder}
}

// Query returns a query builder for Dependency.
func (c *DependencyClient) Query() *DependencyQuery {
	return &DependencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDependency},
		inters: c.Interceptors(),
	}
}

// Get returns a Dependency entity by its id.
func (c *DependencyClient) Get(ctx context.Context, id uuid.UUID) (*Dependency, error) {
	return c.Query().Where(dependency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DependencyClient) GetX(ctx context.Context, id uuid.UUID) *Dependency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a Dependency.
func (c *DependencyClient) QueryPackage(d *Dependency) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dependency.Table, dependency.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, dependency.PackageTable, dependency.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependentPackageVersion queries the dependent_package_version edge of a Dependency.
func (c *DependencyClient) QueryDependentPackageVersion(d *Dependency) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dependency.Table, dependency.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, dependency.DependentPackageVersionTable, dependency.DependentPackageVersionColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedInSboms queries the included_in_sboms edge of a Dependency.
func (c *DependencyClient) QueryIncludedInSboms(d *Dependency) *BillOfMaterialsQuery {
	query := (&BillOfMaterialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dependency.Table, dependency.FieldID, id),
			sqlgraph.To(billofmaterials.Table, billofmaterials.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, dependency.IncludedInSbomsTable, dependency.IncludedInSbomsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DependencyClient) Hooks() []Hook {
	return c.hooks.Dependency
}

// Interceptors returns the client interceptors.
func (c *DependencyClient) Interceptors() []Interceptor {
	return c.inters.Dependency
}

func (c *DependencyClient) mutate(ctx context.Context, m *DependencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DependencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DependencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Dependency mutation op: %q", m.Op())
	}
}

// HasMetadataClient is a client for the HasMetadata schema.
type HasMetadataClient struct {
	config
}

// NewHasMetadataClient returns a client for the HasMetadata from the given config.
func NewHasMetadataClient(c config) *HasMetadataClient {
	return &HasMetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hasmetadata.Hooks(f(g(h())))`.
func (c *HasMetadataClient) Use(hooks ...Hook) {
	c.hooks.HasMetadata = append(c.hooks.HasMetadata, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hasmetadata.Intercept(f(g(h())))`.
func (c *HasMetadataClient) Intercept(interceptors ...Interceptor) {
	c.inters.HasMetadata = append(c.inters.HasMetadata, interceptors...)
}

// Create returns a builder for creating a HasMetadata entity.
func (c *HasMetadataClient) Create() *HasMetadataCreate {
	mutation := newHasMetadataMutation(c.config, OpCreate)
	return &HasMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HasMetadata entities.
func (c *HasMetadataClient) CreateBulk(builders ...*HasMetadataCreate) *HasMetadataCreateBulk {
	return &HasMetadataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HasMetadataClient) MapCreateBulk(slice any, setFunc func(*HasMetadataCreate, int)) *HasMetadataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HasMetadataCreateBulk{err: fmt.Errorf("calling to HasMetadataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HasMetadataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HasMetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HasMetadata.
func (c *HasMetadataClient) Update() *HasMetadataUpdate {
	mutation := newHasMetadataMutation(c.config, OpUpdate)
	return &HasMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HasMetadataClient) UpdateOne(hm *HasMetadata) *HasMetadataUpdateOne {
	mutation := newHasMetadataMutation(c.config, OpUpdateOne, withHasMetadata(hm))
	return &HasMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HasMetadataClient) UpdateOneID(id uuid.UUID) *HasMetadataUpdateOne {
	mutation := newHasMetadataMutation(c.config, OpUpdateOne, withHasMetadataID(id))
	return &HasMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HasMetadata.
func (c *HasMetadataClient) Delete() *HasMetadataDelete {
	mutation := newHasMetadataMutation(c.config, OpDelete)
	return &HasMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HasMetadataClient) DeleteOne(hm *HasMetadata) *HasMetadataDeleteOne {
	return c.DeleteOneID(hm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HasMetadataClient) DeleteOneID(id uuid.UUID) *HasMetadataDeleteOne {
	builder := c.Delete().Where(hasmetadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HasMetadataDeleteOne{builder}
}

// Query returns a query builder for HasMetadata.
func (c *HasMetadataClient) Query() *HasMetadataQuery {
	return &HasMetadataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHasMetadata},
		inters: c.Interceptors(),
	}
}

// Get returns a HasMetadata entity by its id.
func (c *HasMetadataClient) Get(ctx context.Context, id uuid.UUID) (*HasMetadata, error) {
	return c.Query().Where(hasmetadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HasMetadataClient) GetX(ctx context.Context, id uuid.UUID) *HasMetadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySource queries the source edge of a HasMetadata.
func (c *HasMetadataClient) QuerySource(hm *HasMetadata) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hasmetadata.Table, hasmetadata.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hasmetadata.SourceTable, hasmetadata.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(hm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPackageVersion queries the package_version edge of a HasMetadata.
func (c *HasMetadataClient) QueryPackageVersion(hm *HasMetadata) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hasmetadata.Table, hasmetadata.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hasmetadata.PackageVersionTable, hasmetadata.PackageVersionColumn),
		)
		fromV = sqlgraph.Neighbors(hm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAllVersions queries the all_versions edge of a HasMetadata.
func (c *HasMetadataClient) QueryAllVersions(hm *HasMetadata) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hasmetadata.Table, hasmetadata.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hasmetadata.AllVersionsTable, hasmetadata.AllVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(hm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifact queries the artifact edge of a HasMetadata.
func (c *HasMetadataClient) QueryArtifact(hm *HasMetadata) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hasmetadata.Table, hasmetadata.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hasmetadata.ArtifactTable, hasmetadata.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(hm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HasMetadataClient) Hooks() []Hook {
	return c.hooks.HasMetadata
}

// Interceptors returns the client interceptors.
func (c *HasMetadataClient) Interceptors() []Interceptor {
	return c.inters.HasMetadata
}

func (c *HasMetadataClient) mutate(ctx context.Context, m *HasMetadataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HasMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HasMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HasMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HasMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HasMetadata mutation op: %q", m.Op())
	}
}

// HasSourceAtClient is a client for the HasSourceAt schema.
type HasSourceAtClient struct {
	config
}

// NewHasSourceAtClient returns a client for the HasSourceAt from the given config.
func NewHasSourceAtClient(c config) *HasSourceAtClient {
	return &HasSourceAtClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hassourceat.Hooks(f(g(h())))`.
func (c *HasSourceAtClient) Use(hooks ...Hook) {
	c.hooks.HasSourceAt = append(c.hooks.HasSourceAt, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hassourceat.Intercept(f(g(h())))`.
func (c *HasSourceAtClient) Intercept(interceptors ...Interceptor) {
	c.inters.HasSourceAt = append(c.inters.HasSourceAt, interceptors...)
}

// Create returns a builder for creating a HasSourceAt entity.
func (c *HasSourceAtClient) Create() *HasSourceAtCreate {
	mutation := newHasSourceAtMutation(c.config, OpCreate)
	return &HasSourceAtCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HasSourceAt entities.
func (c *HasSourceAtClient) CreateBulk(builders ...*HasSourceAtCreate) *HasSourceAtCreateBulk {
	return &HasSourceAtCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HasSourceAtClient) MapCreateBulk(slice any, setFunc func(*HasSourceAtCreate, int)) *HasSourceAtCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HasSourceAtCreateBulk{err: fmt.Errorf("calling to HasSourceAtClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HasSourceAtCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HasSourceAtCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HasSourceAt.
func (c *HasSourceAtClient) Update() *HasSourceAtUpdate {
	mutation := newHasSourceAtMutation(c.config, OpUpdate)
	return &HasSourceAtUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HasSourceAtClient) UpdateOne(hsa *HasSourceAt) *HasSourceAtUpdateOne {
	mutation := newHasSourceAtMutation(c.config, OpUpdateOne, withHasSourceAt(hsa))
	return &HasSourceAtUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HasSourceAtClient) UpdateOneID(id uuid.UUID) *HasSourceAtUpdateOne {
	mutation := newHasSourceAtMutation(c.config, OpUpdateOne, withHasSourceAtID(id))
	return &HasSourceAtUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HasSourceAt.
func (c *HasSourceAtClient) Delete() *HasSourceAtDelete {
	mutation := newHasSourceAtMutation(c.config, OpDelete)
	return &HasSourceAtDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HasSourceAtClient) DeleteOne(hsa *HasSourceAt) *HasSourceAtDeleteOne {
	return c.DeleteOneID(hsa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HasSourceAtClient) DeleteOneID(id uuid.UUID) *HasSourceAtDeleteOne {
	builder := c.Delete().Where(hassourceat.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HasSourceAtDeleteOne{builder}
}

// Query returns a query builder for HasSourceAt.
func (c *HasSourceAtClient) Query() *HasSourceAtQuery {
	return &HasSourceAtQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHasSourceAt},
		inters: c.Interceptors(),
	}
}

// Get returns a HasSourceAt entity by its id.
func (c *HasSourceAtClient) Get(ctx context.Context, id uuid.UUID) (*HasSourceAt, error) {
	return c.Query().Where(hassourceat.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HasSourceAtClient) GetX(ctx context.Context, id uuid.UUID) *HasSourceAt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackageVersion queries the package_version edge of a HasSourceAt.
func (c *HasSourceAtClient) QueryPackageVersion(hsa *HasSourceAt) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hsa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hassourceat.Table, hassourceat.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hassourceat.PackageVersionTable, hassourceat.PackageVersionColumn),
		)
		fromV = sqlgraph.Neighbors(hsa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAllVersions queries the all_versions edge of a HasSourceAt.
func (c *HasSourceAtClient) QueryAllVersions(hsa *HasSourceAt) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hsa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hassourceat.Table, hassourceat.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hassourceat.AllVersionsTable, hassourceat.AllVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(hsa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySource queries the source edge of a HasSourceAt.
func (c *HasSourceAtClient) QuerySource(hsa *HasSourceAt) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hsa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hassourceat.Table, hassourceat.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hassourceat.SourceTable, hassourceat.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(hsa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HasSourceAtClient) Hooks() []Hook {
	return c.hooks.HasSourceAt
}

// Interceptors returns the client interceptors.
func (c *HasSourceAtClient) Interceptors() []Interceptor {
	return c.inters.HasSourceAt
}

func (c *HasSourceAtClient) mutate(ctx context.Context, m *HasSourceAtMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HasSourceAtCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HasSourceAtUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HasSourceAtUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HasSourceAtDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HasSourceAt mutation op: %q", m.Op())
	}
}

// HashEqualClient is a client for the HashEqual schema.
type HashEqualClient struct {
	config
}

// NewHashEqualClient returns a client for the HashEqual from the given config.
func NewHashEqualClient(c config) *HashEqualClient {
	return &HashEqualClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hashequal.Hooks(f(g(h())))`.
func (c *HashEqualClient) Use(hooks ...Hook) {
	c.hooks.HashEqual = append(c.hooks.HashEqual, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hashequal.Intercept(f(g(h())))`.
func (c *HashEqualClient) Intercept(interceptors ...Interceptor) {
	c.inters.HashEqual = append(c.inters.HashEqual, interceptors...)
}

// Create returns a builder for creating a HashEqual entity.
func (c *HashEqualClient) Create() *HashEqualCreate {
	mutation := newHashEqualMutation(c.config, OpCreate)
	return &HashEqualCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HashEqual entities.
func (c *HashEqualClient) CreateBulk(builders ...*HashEqualCreate) *HashEqualCreateBulk {
	return &HashEqualCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HashEqualClient) MapCreateBulk(slice any, setFunc func(*HashEqualCreate, int)) *HashEqualCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HashEqualCreateBulk{err: fmt.Errorf("calling to HashEqualClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HashEqualCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HashEqualCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HashEqual.
func (c *HashEqualClient) Update() *HashEqualUpdate {
	mutation := newHashEqualMutation(c.config, OpUpdate)
	return &HashEqualUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HashEqualClient) UpdateOne(he *HashEqual) *HashEqualUpdateOne {
	mutation := newHashEqualMutation(c.config, OpUpdateOne, withHashEqual(he))
	return &HashEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HashEqualClient) UpdateOneID(id uuid.UUID) *HashEqualUpdateOne {
	mutation := newHashEqualMutation(c.config, OpUpdateOne, withHashEqualID(id))
	return &HashEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HashEqual.
func (c *HashEqualClient) Delete() *HashEqualDelete {
	mutation := newHashEqualMutation(c.config, OpDelete)
	return &HashEqualDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HashEqualClient) DeleteOne(he *HashEqual) *HashEqualDeleteOne {
	return c.DeleteOneID(he.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HashEqualClient) DeleteOneID(id uuid.UUID) *HashEqualDeleteOne {
	builder := c.Delete().Where(hashequal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HashEqualDeleteOne{builder}
}

// Query returns a query builder for HashEqual.
func (c *HashEqualClient) Query() *HashEqualQuery {
	return &HashEqualQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHashEqual},
		inters: c.Interceptors(),
	}
}

// Get returns a HashEqual entity by its id.
func (c *HashEqualClient) Get(ctx context.Context, id uuid.UUID) (*HashEqual, error) {
	return c.Query().Where(hashequal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HashEqualClient) GetX(ctx context.Context, id uuid.UUID) *HashEqual {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifactA queries the artifact_a edge of a HashEqual.
func (c *HashEqualClient) QueryArtifactA(he *HashEqual) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := he.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hashequal.Table, hashequal.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hashequal.ArtifactATable, hashequal.ArtifactAColumn),
		)
		fromV = sqlgraph.Neighbors(he.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifactB queries the artifact_b edge of a HashEqual.
func (c *HashEqualClient) QueryArtifactB(he *HashEqual) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := he.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hashequal.Table, hashequal.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hashequal.ArtifactBTable, hashequal.ArtifactBColumn),
		)
		fromV = sqlgraph.Neighbors(he.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HashEqualClient) Hooks() []Hook {
	return c.hooks.HashEqual
}

// Interceptors returns the client interceptors.
func (c *HashEqualClient) Interceptors() []Interceptor {
	return c.inters.HashEqual
}

func (c *HashEqualClient) mutate(ctx context.Context, m *HashEqualMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HashEqualCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HashEqualUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HashEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HashEqualDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HashEqual mutation op: %q", m.Op())
	}
}

// LicenseClient is a client for the License schema.
type LicenseClient struct {
	config
}

// NewLicenseClient returns a client for the License from the given config.
func NewLicenseClient(c config) *LicenseClient {
	return &LicenseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `license.Hooks(f(g(h())))`.
func (c *LicenseClient) Use(hooks ...Hook) {
	c.hooks.License = append(c.hooks.License, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `license.Intercept(f(g(h())))`.
func (c *LicenseClient) Intercept(interceptors ...Interceptor) {
	c.inters.License = append(c.inters.License, interceptors...)
}

// Create returns a builder for creating a License entity.
func (c *LicenseClient) Create() *LicenseCreate {
	mutation := newLicenseMutation(c.config, OpCreate)
	return &LicenseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of License entities.
func (c *LicenseClient) CreateBulk(builders ...*LicenseCreate) *LicenseCreateBulk {
	return &LicenseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LicenseClient) MapCreateBulk(slice any, setFunc func(*LicenseCreate, int)) *LicenseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LicenseCreateBulk{err: fmt.Errorf("calling to LicenseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LicenseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LicenseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for License.
func (c *LicenseClient) Update() *LicenseUpdate {
	mutation := newLicenseMutation(c.config, OpUpdate)
	return &LicenseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LicenseClient) UpdateOne(l *License) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicense(l))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LicenseClient) UpdateOneID(id uuid.UUID) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicenseID(id))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for License.
func (c *LicenseClient) Delete() *LicenseDelete {
	mutation := newLicenseMutation(c.config, OpDelete)
	return &LicenseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LicenseClient) DeleteOne(l *License) *LicenseDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LicenseClient) DeleteOneID(id uuid.UUID) *LicenseDeleteOne {
	builder := c.Delete().Where(license.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LicenseDeleteOne{builder}
}

// Query returns a query builder for License.
func (c *LicenseClient) Query() *LicenseQuery {
	return &LicenseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLicense},
		inters: c.Interceptors(),
	}
}

// Get returns a License entity by its id.
func (c *LicenseClient) Get(ctx context.Context, id uuid.UUID) (*License, error) {
	return c.Query().Where(license.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LicenseClient) GetX(ctx context.Context, id uuid.UUID) *License {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDeclaredInCertifyLegals queries the declared_in_certify_legals edge of a License.
func (c *LicenseClient) QueryDeclaredInCertifyLegals(l *License) *CertifyLegalQuery {
	query := (&CertifyLegalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(certifylegal.Table, certifylegal.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, license.DeclaredInCertifyLegalsTable, license.DeclaredInCertifyLegalsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscoveredInCertifyLegals queries the discovered_in_certify_legals edge of a License.
func (c *LicenseClient) QueryDiscoveredInCertifyLegals(l *License) *CertifyLegalQuery {
	query := (&CertifyLegalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(certifylegal.Table, certifylegal.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, license.DiscoveredInCertifyLegalsTable, license.DiscoveredInCertifyLegalsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LicenseClient) Hooks() []Hook {
	return c.hooks.License
}

// Interceptors returns the client interceptors.
func (c *LicenseClient) Interceptors() []Interceptor {
	return c.inters.License
}

func (c *LicenseClient) mutate(ctx context.Context, m *LicenseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LicenseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LicenseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LicenseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown License mutation op: %q", m.Op())
	}
}

// OccurrenceClient is a client for the Occurrence schema.
type OccurrenceClient struct {
	config
}

// NewOccurrenceClient returns a client for the Occurrence from the given config.
func NewOccurrenceClient(c config) *OccurrenceClient {
	return &OccurrenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `occurrence.Hooks(f(g(h())))`.
func (c *OccurrenceClient) Use(hooks ...Hook) {
	c.hooks.Occurrence = append(c.hooks.Occurrence, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `occurrence.Intercept(f(g(h())))`.
func (c *OccurrenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Occurrence = append(c.inters.Occurrence, interceptors...)
}

// Create returns a builder for creating a Occurrence entity.
func (c *OccurrenceClient) Create() *OccurrenceCreate {
	mutation := newOccurrenceMutation(c.config, OpCreate)
	return &OccurrenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Occurrence entities.
func (c *OccurrenceClient) CreateBulk(builders ...*OccurrenceCreate) *OccurrenceCreateBulk {
	return &OccurrenceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OccurrenceClient) MapCreateBulk(slice any, setFunc func(*OccurrenceCreate, int)) *OccurrenceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OccurrenceCreateBulk{err: fmt.Errorf("calling to OccurrenceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OccurrenceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OccurrenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Occurrence.
func (c *OccurrenceClient) Update() *OccurrenceUpdate {
	mutation := newOccurrenceMutation(c.config, OpUpdate)
	return &OccurrenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OccurrenceClient) UpdateOne(o *Occurrence) *OccurrenceUpdateOne {
	mutation := newOccurrenceMutation(c.config, OpUpdateOne, withOccurrence(o))
	return &OccurrenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OccurrenceClient) UpdateOneID(id uuid.UUID) *OccurrenceUpdateOne {
	mutation := newOccurrenceMutation(c.config, OpUpdateOne, withOccurrenceID(id))
	return &OccurrenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Occurrence.
func (c *OccurrenceClient) Delete() *OccurrenceDelete {
	mutation := newOccurrenceMutation(c.config, OpDelete)
	return &OccurrenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OccurrenceClient) DeleteOne(o *Occurrence) *OccurrenceDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OccurrenceClient) DeleteOneID(id uuid.UUID) *OccurrenceDeleteOne {
	builder := c.Delete().Where(occurrence.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OccurrenceDeleteOne{builder}
}

// Query returns a query builder for Occurrence.
func (c *OccurrenceClient) Query() *OccurrenceQuery {
	return &OccurrenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOccurrence},
		inters: c.Interceptors(),
	}
}

// Get returns a Occurrence entity by its id.
func (c *OccurrenceClient) Get(ctx context.Context, id uuid.UUID) (*Occurrence, error) {
	return c.Query().Where(occurrence.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OccurrenceClient) GetX(ctx context.Context, id uuid.UUID) *Occurrence {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifact queries the artifact edge of a Occurrence.
func (c *OccurrenceClient) QueryArtifact(o *Occurrence) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(occurrence.Table, occurrence.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, occurrence.ArtifactTable, occurrence.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPackage queries the package edge of a Occurrence.
func (c *OccurrenceClient) QueryPackage(o *Occurrence) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(occurrence.Table, occurrence.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, occurrence.PackageTable, occurrence.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySource queries the source edge of a Occurrence.
func (c *OccurrenceClient) QuerySource(o *Occurrence) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(occurrence.Table, occurrence.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, occurrence.SourceTable, occurrence.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedInSboms queries the included_in_sboms edge of a Occurrence.
func (c *OccurrenceClient) QueryIncludedInSboms(o *Occurrence) *BillOfMaterialsQuery {
	query := (&BillOfMaterialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(occurrence.Table, occurrence.FieldID, id),
			sqlgraph.To(billofmaterials.Table, billofmaterials.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, occurrence.IncludedInSbomsTable, occurrence.IncludedInSbomsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OccurrenceClient) Hooks() []Hook {
	return c.hooks.Occurrence
}

// Interceptors returns the client interceptors.
func (c *OccurrenceClient) Interceptors() []Interceptor {
	return c.inters.Occurrence
}

func (c *OccurrenceClient) mutate(ctx context.Context, m *OccurrenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OccurrenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OccurrenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OccurrenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OccurrenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Occurrence mutation op: %q", m.Op())
	}
}

// PackageNameClient is a client for the PackageName schema.
type PackageNameClient struct {
	config
}

// NewPackageNameClient returns a client for the PackageName from the given config.
func NewPackageNameClient(c config) *PackageNameClient {
	return &PackageNameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packagename.Hooks(f(g(h())))`.
func (c *PackageNameClient) Use(hooks ...Hook) {
	c.hooks.PackageName = append(c.hooks.PackageName, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packagename.Intercept(f(g(h())))`.
func (c *PackageNameClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageName = append(c.inters.PackageName, interceptors...)
}

// Create returns a builder for creating a PackageName entity.
func (c *PackageNameClient) Create() *PackageNameCreate {
	mutation := newPackageNameMutation(c.config, OpCreate)
	return &PackageNameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageName entities.
func (c *PackageNameClient) CreateBulk(builders ...*PackageNameCreate) *PackageNameCreateBulk {
	return &PackageNameCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PackageNameClient) MapCreateBulk(slice any, setFunc func(*PackageNameCreate, int)) *PackageNameCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PackageNameCreateBulk{err: fmt.Errorf("calling to PackageNameClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PackageNameCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PackageNameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageName.
func (c *PackageNameClient) Update() *PackageNameUpdate {
	mutation := newPackageNameMutation(c.config, OpUpdate)
	return &PackageNameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageNameClient) UpdateOne(pn *PackageName) *PackageNameUpdateOne {
	mutation := newPackageNameMutation(c.config, OpUpdateOne, withPackageName(pn))
	return &PackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageNameClient) UpdateOneID(id uuid.UUID) *PackageNameUpdateOne {
	mutation := newPackageNameMutation(c.config, OpUpdateOne, withPackageNameID(id))
	return &PackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageName.
func (c *PackageNameClient) Delete() *PackageNameDelete {
	mutation := newPackageNameMutation(c.config, OpDelete)
	return &PackageNameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageNameClient) DeleteOne(pn *PackageName) *PackageNameDeleteOne {
	return c.DeleteOneID(pn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageNameClient) DeleteOneID(id uuid.UUID) *PackageNameDeleteOne {
	builder := c.Delete().Where(packagename.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageNameDeleteOne{builder}
}

// Query returns a query builder for PackageName.
func (c *PackageNameClient) Query() *PackageNameQuery {
	return &PackageNameQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageName},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageName entity by its id.
func (c *PackageNameClient) Get(ctx context.Context, id uuid.UUID) (*PackageName, error) {
	return c.Query().Where(packagename.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageNameClient) GetX(ctx context.Context, id uuid.UUID) *PackageName {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVersions queries the versions edge of a PackageName.
func (c *PackageNameClient) QueryVersions(pn *PackageName) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagename.Table, packagename.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, packagename.VersionsTable, packagename.VersionsColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHasSourceAt queries the has_source_at edge of a PackageName.
func (c *PackageNameClient) QueryHasSourceAt(pn *PackageName) *HasSourceAtQuery {
	query := (&HasSourceAtClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagename.Table, packagename.FieldID, id),
			sqlgraph.To(hassourceat.Table, hassourceat.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packagename.HasSourceAtTable, packagename.HasSourceAtColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCertification queries the certification edge of a PackageName.
func (c *PackageNameClient) QueryCertification(pn *PackageName) *CertificationQuery {
	query := (&CertificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagename.Table, packagename.FieldID, id),
			sqlgraph.To(certification.Table, certification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packagename.CertificationTable, packagename.CertificationColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a PackageName.
func (c *PackageNameClient) QueryMetadata(pn *PackageName) *HasMetadataQuery {
	query := (&HasMetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagename.Table, packagename.FieldID, id),
			sqlgraph.To(hasmetadata.Table, hasmetadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packagename.MetadataTable, packagename.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPoc queries the poc edge of a PackageName.
func (c *PackageNameClient) QueryPoc(pn *PackageName) *PointOfContactQuery {
	query := (&PointOfContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagename.Table, packagename.FieldID, id),
			sqlgraph.To(pointofcontact.Table, pointofcontact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packagename.PocTable, packagename.PocColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageNameClient) Hooks() []Hook {
	return c.hooks.PackageName
}

// Interceptors returns the client interceptors.
func (c *PackageNameClient) Interceptors() []Interceptor {
	return c.inters.PackageName
}

func (c *PackageNameClient) mutate(ctx context.Context, m *PackageNameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageNameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageNameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageNameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageName mutation op: %q", m.Op())
	}
}

// PackageVersionClient is a client for the PackageVersion schema.
type PackageVersionClient struct {
	config
}

// NewPackageVersionClient returns a client for the PackageVersion from the given config.
func NewPackageVersionClient(c config) *PackageVersionClient {
	return &PackageVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packageversion.Hooks(f(g(h())))`.
func (c *PackageVersionClient) Use(hooks ...Hook) {
	c.hooks.PackageVersion = append(c.hooks.PackageVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packageversion.Intercept(f(g(h())))`.
func (c *PackageVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageVersion = append(c.inters.PackageVersion, interceptors...)
}

// Create returns a builder for creating a PackageVersion entity.
func (c *PackageVersionClient) Create() *PackageVersionCreate {
	mutation := newPackageVersionMutation(c.config, OpCreate)
	return &PackageVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageVersion entities.
func (c *PackageVersionClient) CreateBulk(builders ...*PackageVersionCreate) *PackageVersionCreateBulk {
	return &PackageVersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PackageVersionClient) MapCreateBulk(slice any, setFunc func(*PackageVersionCreate, int)) *PackageVersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PackageVersionCreateBulk{err: fmt.Errorf("calling to PackageVersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PackageVersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PackageVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageVersion.
func (c *PackageVersionClient) Update() *PackageVersionUpdate {
	mutation := newPackageVersionMutation(c.config, OpUpdate)
	return &PackageVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageVersionClient) UpdateOne(pv *PackageVersion) *PackageVersionUpdateOne {
	mutation := newPackageVersionMutation(c.config, OpUpdateOne, withPackageVersion(pv))
	return &PackageVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageVersionClient) UpdateOneID(id uuid.UUID) *PackageVersionUpdateOne {
	mutation := newPackageVersionMutation(c.config, OpUpdateOne, withPackageVersionID(id))
	return &PackageVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageVersion.
func (c *PackageVersionClient) Delete() *PackageVersionDelete {
	mutation := newPackageVersionMutation(c.config, OpDelete)
	return &PackageVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageVersionClient) DeleteOne(pv *PackageVersion) *PackageVersionDeleteOne {
	return c.DeleteOneID(pv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageVersionClient) DeleteOneID(id uuid.UUID) *PackageVersionDeleteOne {
	builder := c.Delete().Where(packageversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageVersionDeleteOne{builder}
}

// Query returns a query builder for PackageVersion.
func (c *PackageVersionClient) Query() *PackageVersionQuery {
	return &PackageVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageVersion entity by its id.
func (c *PackageVersionClient) Get(ctx context.Context, id uuid.UUID) (*PackageVersion, error) {
	return c.Query().Where(packageversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageVersionClient) GetX(ctx context.Context, id uuid.UUID) *PackageVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryName queries the name edge of a PackageVersion.
func (c *PackageVersionClient) QueryName(pv *PackageVersion) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, packageversion.NameTable, packageversion.NameColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOccurrences queries the occurrences edge of a PackageVersion.
func (c *PackageVersionClient) QueryOccurrences(pv *PackageVersion) *OccurrenceQuery {
	query := (&OccurrenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(occurrence.Table, occurrence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.OccurrencesTable, packageversion.OccurrencesColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySbom queries the sbom edge of a PackageVersion.
func (c *PackageVersionClient) QuerySbom(pv *PackageVersion) *BillOfMaterialsQuery {
	query := (&BillOfMaterialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(billofmaterials.Table, billofmaterials.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.SbomTable, packageversion.SbomColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVuln queries the vuln edge of a PackageVersion.
func (c *PackageVersionClient) QueryVuln(pv *PackageVersion) *CertifyVulnQuery {
	query := (&CertifyVulnClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(certifyvuln.Table, certifyvuln.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.VulnTable, packageversion.VulnColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVex queries the vex edge of a PackageVersion.
func (c *PackageVersionClient) QueryVex(pv *PackageVersion) *CertifyVexQuery {
	query := (&CertifyVexClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(certifyvex.Table, certifyvex.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.VexTable, packageversion.VexColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHasSourceAt queries the has_source_at edge of a PackageVersion.
func (c *PackageVersionClient) QueryHasSourceAt(pv *PackageVersion) *HasSourceAtQuery {
	query := (&HasSourceAtClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(hassourceat.Table, hassourceat.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.HasSourceAtTable, packageversion.HasSourceAtColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCertification queries the certification edge of a PackageVersion.
func (c *PackageVersionClient) QueryCertification(pv *PackageVersion) *CertificationQuery {
	query := (&CertificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(certification.Table, certification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.CertificationTable, packageversion.CertificationColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a PackageVersion.
func (c *PackageVersionClient) QueryMetadata(pv *PackageVersion) *HasMetadataQuery {
	query := (&HasMetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(hasmetadata.Table, hasmetadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.MetadataTable, packageversion.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependency queries the dependency edge of a PackageVersion.
func (c *PackageVersionClient) QueryDependency(pv *PackageVersion) *DependencyQuery {
	query := (&DependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(dependency.Table, dependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.DependencyTable, packageversion.DependencyColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependencySubject queries the dependency_subject edge of a PackageVersion.
func (c *PackageVersionClient) QueryDependencySubject(pv *PackageVersion) *DependencyQuery {
	query := (&DependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(dependency.Table, dependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.DependencySubjectTable, packageversion.DependencySubjectColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedInSboms queries the included_in_sboms edge of a PackageVersion.
func (c *PackageVersionClient) QueryIncludedInSboms(pv *PackageVersion) *BillOfMaterialsQuery {
	query := (&BillOfMaterialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(billofmaterials.Table, billofmaterials.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, packageversion.IncludedInSbomsTable, packageversion.IncludedInSbomsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPkgEqualPkgA queries the pkg_equal_pkg_a edge of a PackageVersion.
func (c *PackageVersionClient) QueryPkgEqualPkgA(pv *PackageVersion) *PkgEqualQuery {
	query := (&PkgEqualClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(pkgequal.Table, pkgequal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.PkgEqualPkgATable, packageversion.PkgEqualPkgAColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPkgEqualPkgB queries the pkg_equal_pkg_b edge of a PackageVersion.
func (c *PackageVersionClient) QueryPkgEqualPkgB(pv *PackageVersion) *PkgEqualQuery {
	query := (&PkgEqualClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(pkgequal.Table, pkgequal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.PkgEqualPkgBTable, packageversion.PkgEqualPkgBColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPoc queries the poc edge of a PackageVersion.
func (c *PackageVersionClient) QueryPoc(pv *PackageVersion) *PointOfContactQuery {
	query := (&PointOfContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(pointofcontact.Table, pointofcontact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.PocTable, packageversion.PocColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCertifyLegal queries the certify_legal edge of a PackageVersion.
func (c *PackageVersionClient) QueryCertifyLegal(pv *PackageVersion) *CertifyLegalQuery {
	query := (&CertifyLegalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(certifylegal.Table, certifylegal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.CertifyLegalTable, packageversion.CertifyLegalColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageVersionClient) Hooks() []Hook {
	return c.hooks.PackageVersion
}

// Interceptors returns the client interceptors.
func (c *PackageVersionClient) Interceptors() []Interceptor {
	return c.inters.PackageVersion
}

func (c *PackageVersionClient) mutate(ctx context.Context, m *PackageVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageVersion mutation op: %q", m.Op())
	}
}

// PkgEqualClient is a client for the PkgEqual schema.
type PkgEqualClient struct {
	config
}

// NewPkgEqualClient returns a client for the PkgEqual from the given config.
func NewPkgEqualClient(c config) *PkgEqualClient {
	return &PkgEqualClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pkgequal.Hooks(f(g(h())))`.
func (c *PkgEqualClient) Use(hooks ...Hook) {
	c.hooks.PkgEqual = append(c.hooks.PkgEqual, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pkgequal.Intercept(f(g(h())))`.
func (c *PkgEqualClient) Intercept(interceptors ...Interceptor) {
	c.inters.PkgEqual = append(c.inters.PkgEqual, interceptors...)
}

// Create returns a builder for creating a PkgEqual entity.
func (c *PkgEqualClient) Create() *PkgEqualCreate {
	mutation := newPkgEqualMutation(c.config, OpCreate)
	return &PkgEqualCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PkgEqual entities.
func (c *PkgEqualClient) CreateBulk(builders ...*PkgEqualCreate) *PkgEqualCreateBulk {
	return &PkgEqualCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PkgEqualClient) MapCreateBulk(slice any, setFunc func(*PkgEqualCreate, int)) *PkgEqualCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PkgEqualCreateBulk{err: fmt.Errorf("calling to PkgEqualClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PkgEqualCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PkgEqualCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PkgEqual.
func (c *PkgEqualClient) Update() *PkgEqualUpdate {
	mutation := newPkgEqualMutation(c.config, OpUpdate)
	return &PkgEqualUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PkgEqualClient) UpdateOne(pe *PkgEqual) *PkgEqualUpdateOne {
	mutation := newPkgEqualMutation(c.config, OpUpdateOne, withPkgEqual(pe))
	return &PkgEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PkgEqualClient) UpdateOneID(id uuid.UUID) *PkgEqualUpdateOne {
	mutation := newPkgEqualMutation(c.config, OpUpdateOne, withPkgEqualID(id))
	return &PkgEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PkgEqual.
func (c *PkgEqualClient) Delete() *PkgEqualDelete {
	mutation := newPkgEqualMutation(c.config, OpDelete)
	return &PkgEqualDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PkgEqualClient) DeleteOne(pe *PkgEqual) *PkgEqualDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PkgEqualClient) DeleteOneID(id uuid.UUID) *PkgEqualDeleteOne {
	builder := c.Delete().Where(pkgequal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PkgEqualDeleteOne{builder}
}

// Query returns a query builder for PkgEqual.
func (c *PkgEqualClient) Query() *PkgEqualQuery {
	return &PkgEqualQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePkgEqual},
		inters: c.Interceptors(),
	}
}

// Get returns a PkgEqual entity by its id.
func (c *PkgEqualClient) Get(ctx context.Context, id uuid.UUID) (*PkgEqual, error) {
	return c.Query().Where(pkgequal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PkgEqualClient) GetX(ctx context.Context, id uuid.UUID) *PkgEqual {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackageA queries the package_a edge of a PkgEqual.
func (c *PkgEqualClient) QueryPackageA(pe *PkgEqual) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pkgequal.Table, pkgequal.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, pkgequal.PackageATable, pkgequal.PackageAColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPackageB queries the package_b edge of a PkgEqual.
func (c *PkgEqualClient) QueryPackageB(pe *PkgEqual) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pkgequal.Table, pkgequal.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, pkgequal.PackageBTable, pkgequal.PackageBColumn),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PkgEqualClient) Hooks() []Hook {
	return c.hooks.PkgEqual
}

// Interceptors returns the client interceptors.
func (c *PkgEqualClient) Interceptors() []Interceptor {
	return c.inters.PkgEqual
}

func (c *PkgEqualClient) mutate(ctx context.Context, m *PkgEqualMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PkgEqualCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PkgEqualUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PkgEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PkgEqualDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PkgEqual mutation op: %q", m.Op())
	}
}

// PointOfContactClient is a client for the PointOfContact schema.
type PointOfContactClient struct {
	config
}

// NewPointOfContactClient returns a client for the PointOfContact from the given config.
func NewPointOfContactClient(c config) *PointOfContactClient {
	return &PointOfContactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pointofcontact.Hooks(f(g(h())))`.
func (c *PointOfContactClient) Use(hooks ...Hook) {
	c.hooks.PointOfContact = append(c.hooks.PointOfContact, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pointofcontact.Intercept(f(g(h())))`.
func (c *PointOfContactClient) Intercept(interceptors ...Interceptor) {
	c.inters.PointOfContact = append(c.inters.PointOfContact, interceptors...)
}

// Create returns a builder for creating a PointOfContact entity.
func (c *PointOfContactClient) Create() *PointOfContactCreate {
	mutation := newPointOfContactMutation(c.config, OpCreate)
	return &PointOfContactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PointOfContact entities.
func (c *PointOfContactClient) CreateBulk(builders ...*PointOfContactCreate) *PointOfContactCreateBulk {
	return &PointOfContactCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PointOfContactClient) MapCreateBulk(slice any, setFunc func(*PointOfContactCreate, int)) *PointOfContactCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PointOfContactCreateBulk{err: fmt.Errorf("calling to PointOfContactClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PointOfContactCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PointOfContactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PointOfContact.
func (c *PointOfContactClient) Update() *PointOfContactUpdate {
	mutation := newPointOfContactMutation(c.config, OpUpdate)
	return &PointOfContactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PointOfContactClient) UpdateOne(poc *PointOfContact) *PointOfContactUpdateOne {
	mutation := newPointOfContactMutation(c.config, OpUpdateOne, withPointOfContact(poc))
	return &PointOfContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PointOfContactClient) UpdateOneID(id uuid.UUID) *PointOfContactUpdateOne {
	mutation := newPointOfContactMutation(c.config, OpUpdateOne, withPointOfContactID(id))
	return &PointOfContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PointOfContact.
func (c *PointOfContactClient) Delete() *PointOfContactDelete {
	mutation := newPointOfContactMutation(c.config, OpDelete)
	return &PointOfContactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PointOfContactClient) DeleteOne(poc *PointOfContact) *PointOfContactDeleteOne {
	return c.DeleteOneID(poc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PointOfContactClient) DeleteOneID(id uuid.UUID) *PointOfContactDeleteOne {
	builder := c.Delete().Where(pointofcontact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PointOfContactDeleteOne{builder}
}

// Query returns a query builder for PointOfContact.
func (c *PointOfContactClient) Query() *PointOfContactQuery {
	return &PointOfContactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePointOfContact},
		inters: c.Interceptors(),
	}
}

// Get returns a PointOfContact entity by its id.
func (c *PointOfContactClient) Get(ctx context.Context, id uuid.UUID) (*PointOfContact, error) {
	return c.Query().Where(pointofcontact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PointOfContactClient) GetX(ctx context.Context, id uuid.UUID) *PointOfContact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySource queries the source edge of a PointOfContact.
func (c *PointOfContactClient) QuerySource(poc *PointOfContact) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := poc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pointofcontact.Table, pointofcontact.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, pointofcontact.SourceTable, pointofcontact.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(poc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPackageVersion queries the package_version edge of a PointOfContact.
func (c *PointOfContactClient) QueryPackageVersion(poc *PointOfContact) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := poc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pointofcontact.Table, pointofcontact.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, pointofcontact.PackageVersionTable, pointofcontact.PackageVersionColumn),
		)
		fromV = sqlgraph.Neighbors(poc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAllVersions queries the all_versions edge of a PointOfContact.
func (c *PointOfContactClient) QueryAllVersions(poc *PointOfContact) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := poc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pointofcontact.Table, pointofcontact.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, pointofcontact.AllVersionsTable, pointofcontact.AllVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(poc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifact queries the artifact edge of a PointOfContact.
func (c *PointOfContactClient) QueryArtifact(poc *PointOfContact) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := poc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pointofcontact.Table, pointofcontact.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, pointofcontact.ArtifactTable, pointofcontact.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(poc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PointOfContactClient) Hooks() []Hook {
	return c.hooks.PointOfContact
}

// Interceptors returns the client interceptors.
func (c *PointOfContactClient) Interceptors() []Interceptor {
	return c.inters.PointOfContact
}

func (c *PointOfContactClient) mutate(ctx context.Context, m *PointOfContactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PointOfContactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PointOfContactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PointOfContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PointOfContactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PointOfContact mutation op: %q", m.Op())
	}
}

// SLSAAttestationClient is a client for the SLSAAttestation schema.
type SLSAAttestationClient struct {
	config
}

// NewSLSAAttestationClient returns a client for the SLSAAttestation from the given config.
func NewSLSAAttestationClient(c config) *SLSAAttestationClient {
	return &SLSAAttestationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `slsaattestation.Hooks(f(g(h())))`.
func (c *SLSAAttestationClient) Use(hooks ...Hook) {
	c.hooks.SLSAAttestation = append(c.hooks.SLSAAttestation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `slsaattestation.Intercept(f(g(h())))`.
func (c *SLSAAttestationClient) Intercept(interceptors ...Interceptor) {
	c.inters.SLSAAttestation = append(c.inters.SLSAAttestation, interceptors...)
}

// Create returns a builder for creating a SLSAAttestation entity.
func (c *SLSAAttestationClient) Create() *SLSAAttestationCreate {
	mutation := newSLSAAttestationMutation(c.config, OpCreate)
	return &SLSAAttestationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SLSAAttestation entities.
func (c *SLSAAttestationClient) CreateBulk(builders ...*SLSAAttestationCreate) *SLSAAttestationCreateBulk {
	return &SLSAAttestationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SLSAAttestationClient) MapCreateBulk(slice any, setFunc func(*SLSAAttestationCreate, int)) *SLSAAttestationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SLSAAttestationCreateBulk{err: fmt.Errorf("calling to SLSAAttestationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SLSAAttestationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SLSAAttestationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SLSAAttestation.
func (c *SLSAAttestationClient) Update() *SLSAAttestationUpdate {
	mutation := newSLSAAttestationMutation(c.config, OpUpdate)
	return &SLSAAttestationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SLSAAttestationClient) UpdateOne(sa *SLSAAttestation) *SLSAAttestationUpdateOne {
	mutation := newSLSAAttestationMutation(c.config, OpUpdateOne, withSLSAAttestation(sa))
	return &SLSAAttestationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SLSAAttestationClient) UpdateOneID(id uuid.UUID) *SLSAAttestationUpdateOne {
	mutation := newSLSAAttestationMutation(c.config, OpUpdateOne, withSLSAAttestationID(id))
	return &SLSAAttestationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SLSAAttestation.
func (c *SLSAAttestationClient) Delete() *SLSAAttestationDelete {
	mutation := newSLSAAttestationMutation(c.config, OpDelete)
	return &SLSAAttestationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SLSAAttestationClient) DeleteOne(sa *SLSAAttestation) *SLSAAttestationDeleteOne {
	return c.DeleteOneID(sa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SLSAAttestationClient) DeleteOneID(id uuid.UUID) *SLSAAttestationDeleteOne {
	builder := c.Delete().Where(slsaattestation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SLSAAttestationDeleteOne{builder}
}

// Query returns a query builder for SLSAAttestation.
func (c *SLSAAttestationClient) Query() *SLSAAttestationQuery {
	return &SLSAAttestationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSLSAAttestation},
		inters: c.Interceptors(),
	}
}

// Get returns a SLSAAttestation entity by its id.
func (c *SLSAAttestationClient) Get(ctx context.Context, id uuid.UUID) (*SLSAAttestation, error) {
	return c.Query().Where(slsaattestation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SLSAAttestationClient) GetX(ctx context.Context, id uuid.UUID) *SLSAAttestation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBuiltFrom queries the built_from edge of a SLSAAttestation.
func (c *SLSAAttestationClient) QueryBuiltFrom(sa *SLSAAttestation) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(slsaattestation.Table, slsaattestation.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, slsaattestation.BuiltFromTable, slsaattestation.BuiltFromPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuiltBy queries the built_by edge of a SLSAAttestation.
func (c *SLSAAttestationClient) QueryBuiltBy(sa *SLSAAttestation) *BuilderQuery {
	query := (&BuilderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(slsaattestation.Table, slsaattestation.FieldID, id),
			sqlgraph.To(builder.Table, builder.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, slsaattestation.BuiltByTable, slsaattestation.BuiltByColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubject queries the subject edge of a SLSAAttestation.
func (c *SLSAAttestationClient) QuerySubject(sa *SLSAAttestation) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(slsaattestation.Table, slsaattestation.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, slsaattestation.SubjectTable, slsaattestation.SubjectColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SLSAAttestationClient) Hooks() []Hook {
	return c.hooks.SLSAAttestation
}

// Interceptors returns the client interceptors.
func (c *SLSAAttestationClient) Interceptors() []Interceptor {
	return c.inters.SLSAAttestation
}

func (c *SLSAAttestationClient) mutate(ctx context.Context, m *SLSAAttestationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SLSAAttestationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SLSAAttestationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SLSAAttestationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SLSAAttestationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SLSAAttestation mutation op: %q", m.Op())
	}
}

// SourceNameClient is a client for the SourceName schema.
type SourceNameClient struct {
	config
}

// NewSourceNameClient returns a client for the SourceName from the given config.
func NewSourceNameClient(c config) *SourceNameClient {
	return &SourceNameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sourcename.Hooks(f(g(h())))`.
func (c *SourceNameClient) Use(hooks ...Hook) {
	c.hooks.SourceName = append(c.hooks.SourceName, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sourcename.Intercept(f(g(h())))`.
func (c *SourceNameClient) Intercept(interceptors ...Interceptor) {
	c.inters.SourceName = append(c.inters.SourceName, interceptors...)
}

// Create returns a builder for creating a SourceName entity.
func (c *SourceNameClient) Create() *SourceNameCreate {
	mutation := newSourceNameMutation(c.config, OpCreate)
	return &SourceNameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SourceName entities.
func (c *SourceNameClient) CreateBulk(builders ...*SourceNameCreate) *SourceNameCreateBulk {
	return &SourceNameCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SourceNameClient) MapCreateBulk(slice any, setFunc func(*SourceNameCreate, int)) *SourceNameCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SourceNameCreateBulk{err: fmt.Errorf("calling to SourceNameClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SourceNameCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SourceNameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SourceName.
func (c *SourceNameClient) Update() *SourceNameUpdate {
	mutation := newSourceNameMutation(c.config, OpUpdate)
	return &SourceNameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceNameClient) UpdateOne(sn *SourceName) *SourceNameUpdateOne {
	mutation := newSourceNameMutation(c.config, OpUpdateOne, withSourceName(sn))
	return &SourceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceNameClient) UpdateOneID(id uuid.UUID) *SourceNameUpdateOne {
	mutation := newSourceNameMutation(c.config, OpUpdateOne, withSourceNameID(id))
	return &SourceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SourceName.
func (c *SourceNameClient) Delete() *SourceNameDelete {
	mutation := newSourceNameMutation(c.config, OpDelete)
	return &SourceNameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceNameClient) DeleteOne(sn *SourceName) *SourceNameDeleteOne {
	return c.DeleteOneID(sn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceNameClient) DeleteOneID(id uuid.UUID) *SourceNameDeleteOne {
	builder := c.Delete().Where(sourcename.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceNameDeleteOne{builder}
}

// Query returns a query builder for SourceName.
func (c *SourceNameClient) Query() *SourceNameQuery {
	return &SourceNameQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSourceName},
		inters: c.Interceptors(),
	}
}

// Get returns a SourceName entity by its id.
func (c *SourceNameClient) Get(ctx context.Context, id uuid.UUID) (*SourceName, error) {
	return c.Query().Where(sourcename.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceNameClient) GetX(ctx context.Context, id uuid.UUID) *SourceName {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOccurrences queries the occurrences edge of a SourceName.
func (c *SourceNameClient) QueryOccurrences(sn *SourceName) *OccurrenceQuery {
	query := (&OccurrenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcename.Table, sourcename.FieldID, id),
			sqlgraph.To(occurrence.Table, occurrence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcename.OccurrencesTable, sourcename.OccurrencesColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHasSourceAt queries the has_source_at edge of a SourceName.
func (c *SourceNameClient) QueryHasSourceAt(sn *SourceName) *HasSourceAtQuery {
	query := (&HasSourceAtClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcename.Table, sourcename.FieldID, id),
			sqlgraph.To(hassourceat.Table, hassourceat.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcename.HasSourceAtTable, sourcename.HasSourceAtColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScorecard queries the scorecard edge of a SourceName.
func (c *SourceNameClient) QueryScorecard(sn *SourceName) *CertifyScorecardQuery {
	query := (&CertifyScorecardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcename.Table, sourcename.FieldID, id),
			sqlgraph.To(certifyscorecard.Table, certifyscorecard.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcename.ScorecardTable, sourcename.ScorecardColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCertification queries the certification edge of a SourceName.
func (c *SourceNameClient) QueryCertification(sn *SourceName) *CertificationQuery {
	query := (&CertificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcename.Table, sourcename.FieldID, id),
			sqlgraph.To(certification.Table, certification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcename.CertificationTable, sourcename.CertificationColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a SourceName.
func (c *SourceNameClient) QueryMetadata(sn *SourceName) *HasMetadataQuery {
	query := (&HasMetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcename.Table, sourcename.FieldID, id),
			sqlgraph.To(hasmetadata.Table, hasmetadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcename.MetadataTable, sourcename.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPoc queries the poc edge of a SourceName.
func (c *SourceNameClient) QueryPoc(sn *SourceName) *PointOfContactQuery {
	query := (&PointOfContactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcename.Table, sourcename.FieldID, id),
			sqlgraph.To(pointofcontact.Table, pointofcontact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcename.PocTable, sourcename.PocColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCertifyLegal queries the certify_legal edge of a SourceName.
func (c *SourceNameClient) QueryCertifyLegal(sn *SourceName) *CertifyLegalQuery {
	query := (&CertifyLegalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcename.Table, sourcename.FieldID, id),
			sqlgraph.To(certifylegal.Table, certifylegal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcename.CertifyLegalTable, sourcename.CertifyLegalColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SourceNameClient) Hooks() []Hook {
	return c.hooks.SourceName
}

// Interceptors returns the client interceptors.
func (c *SourceNameClient) Interceptors() []Interceptor {
	return c.inters.SourceName
}

func (c *SourceNameClient) mutate(ctx context.Context, m *SourceNameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceNameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceNameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceNameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SourceName mutation op: %q", m.Op())
	}
}

// VulnEqualClient is a client for the VulnEqual schema.
type VulnEqualClient struct {
	config
}

// NewVulnEqualClient returns a client for the VulnEqual from the given config.
func NewVulnEqualClient(c config) *VulnEqualClient {
	return &VulnEqualClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vulnequal.Hooks(f(g(h())))`.
func (c *VulnEqualClient) Use(hooks ...Hook) {
	c.hooks.VulnEqual = append(c.hooks.VulnEqual, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vulnequal.Intercept(f(g(h())))`.
func (c *VulnEqualClient) Intercept(interceptors ...Interceptor) {
	c.inters.VulnEqual = append(c.inters.VulnEqual, interceptors...)
}

// Create returns a builder for creating a VulnEqual entity.
func (c *VulnEqualClient) Create() *VulnEqualCreate {
	mutation := newVulnEqualMutation(c.config, OpCreate)
	return &VulnEqualCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VulnEqual entities.
func (c *VulnEqualClient) CreateBulk(builders ...*VulnEqualCreate) *VulnEqualCreateBulk {
	return &VulnEqualCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VulnEqualClient) MapCreateBulk(slice any, setFunc func(*VulnEqualCreate, int)) *VulnEqualCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VulnEqualCreateBulk{err: fmt.Errorf("calling to VulnEqualClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VulnEqualCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VulnEqualCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VulnEqual.
func (c *VulnEqualClient) Update() *VulnEqualUpdate {
	mutation := newVulnEqualMutation(c.config, OpUpdate)
	return &VulnEqualUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VulnEqualClient) UpdateOne(ve *VulnEqual) *VulnEqualUpdateOne {
	mutation := newVulnEqualMutation(c.config, OpUpdateOne, withVulnEqual(ve))
	return &VulnEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VulnEqualClient) UpdateOneID(id uuid.UUID) *VulnEqualUpdateOne {
	mutation := newVulnEqualMutation(c.config, OpUpdateOne, withVulnEqualID(id))
	return &VulnEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VulnEqual.
func (c *VulnEqualClient) Delete() *VulnEqualDelete {
	mutation := newVulnEqualMutation(c.config, OpDelete)
	return &VulnEqualDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VulnEqualClient) DeleteOne(ve *VulnEqual) *VulnEqualDeleteOne {
	return c.DeleteOneID(ve.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VulnEqualClient) DeleteOneID(id uuid.UUID) *VulnEqualDeleteOne {
	builder := c.Delete().Where(vulnequal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VulnEqualDeleteOne{builder}
}

// Query returns a query builder for VulnEqual.
func (c *VulnEqualClient) Query() *VulnEqualQuery {
	return &VulnEqualQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVulnEqual},
		inters: c.Interceptors(),
	}
}

// Get returns a VulnEqual entity by its id.
func (c *VulnEqualClient) Get(ctx context.Context, id uuid.UUID) (*VulnEqual, error) {
	return c.Query().Where(vulnequal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VulnEqualClient) GetX(ctx context.Context, id uuid.UUID) *VulnEqual {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVulnerabilityA queries the vulnerability_a edge of a VulnEqual.
func (c *VulnEqualClient) QueryVulnerabilityA(ve *VulnEqual) *VulnerabilityIDQuery {
	query := (&VulnerabilityIDClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ve.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnequal.Table, vulnequal.FieldID, id),
			sqlgraph.To(vulnerabilityid.Table, vulnerabilityid.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, vulnequal.VulnerabilityATable, vulnequal.VulnerabilityAColumn),
		)
		fromV = sqlgraph.Neighbors(ve.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilityB queries the vulnerability_b edge of a VulnEqual.
func (c *VulnEqualClient) QueryVulnerabilityB(ve *VulnEqual) *VulnerabilityIDQuery {
	query := (&VulnerabilityIDClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ve.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnequal.Table, vulnequal.FieldID, id),
			sqlgraph.To(vulnerabilityid.Table, vulnerabilityid.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, vulnequal.VulnerabilityBTable, vulnequal.VulnerabilityBColumn),
		)
		fromV = sqlgraph.Neighbors(ve.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VulnEqualClient) Hooks() []Hook {
	return c.hooks.VulnEqual
}

// Interceptors returns the client interceptors.
func (c *VulnEqualClient) Interceptors() []Interceptor {
	return c.inters.VulnEqual
}

func (c *VulnEqualClient) mutate(ctx context.Context, m *VulnEqualMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VulnEqualCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VulnEqualUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VulnEqualUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VulnEqualDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VulnEqual mutation op: %q", m.Op())
	}
}

// VulnerabilityIDClient is a client for the VulnerabilityID schema.
type VulnerabilityIDClient struct {
	config
}

// NewVulnerabilityIDClient returns a client for the VulnerabilityID from the given config.
func NewVulnerabilityIDClient(c config) *VulnerabilityIDClient {
	return &VulnerabilityIDClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vulnerabilityid.Hooks(f(g(h())))`.
func (c *VulnerabilityIDClient) Use(hooks ...Hook) {
	c.hooks.VulnerabilityID = append(c.hooks.VulnerabilityID, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vulnerabilityid.Intercept(f(g(h())))`.
func (c *VulnerabilityIDClient) Intercept(interceptors ...Interceptor) {
	c.inters.VulnerabilityID = append(c.inters.VulnerabilityID, interceptors...)
}

// Create returns a builder for creating a VulnerabilityID entity.
func (c *VulnerabilityIDClient) Create() *VulnerabilityIDCreate {
	mutation := newVulnerabilityIDMutation(c.config, OpCreate)
	return &VulnerabilityIDCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VulnerabilityID entities.
func (c *VulnerabilityIDClient) CreateBulk(builders ...*VulnerabilityIDCreate) *VulnerabilityIDCreateBulk {
	return &VulnerabilityIDCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VulnerabilityIDClient) MapCreateBulk(slice any, setFunc func(*VulnerabilityIDCreate, int)) *VulnerabilityIDCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VulnerabilityIDCreateBulk{err: fmt.Errorf("calling to VulnerabilityIDClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VulnerabilityIDCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VulnerabilityIDCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VulnerabilityID.
func (c *VulnerabilityIDClient) Update() *VulnerabilityIDUpdate {
	mutation := newVulnerabilityIDMutation(c.config, OpUpdate)
	return &VulnerabilityIDUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VulnerabilityIDClient) UpdateOne(vi *VulnerabilityID) *VulnerabilityIDUpdateOne {
	mutation := newVulnerabilityIDMutation(c.config, OpUpdateOne, withVulnerabilityID(vi))
	return &VulnerabilityIDUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VulnerabilityIDClient) UpdateOneID(id uuid.UUID) *VulnerabilityIDUpdateOne {
	mutation := newVulnerabilityIDMutation(c.config, OpUpdateOne, withVulnerabilityIDID(id))
	return &VulnerabilityIDUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VulnerabilityID.
func (c *VulnerabilityIDClient) Delete() *VulnerabilityIDDelete {
	mutation := newVulnerabilityIDMutation(c.config, OpDelete)
	return &VulnerabilityIDDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VulnerabilityIDClient) DeleteOne(vi *VulnerabilityID) *VulnerabilityIDDeleteOne {
	return c.DeleteOneID(vi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VulnerabilityIDClient) DeleteOneID(id uuid.UUID) *VulnerabilityIDDeleteOne {
	builder := c.Delete().Where(vulnerabilityid.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VulnerabilityIDDeleteOne{builder}
}

// Query returns a query builder for VulnerabilityID.
func (c *VulnerabilityIDClient) Query() *VulnerabilityIDQuery {
	return &VulnerabilityIDQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVulnerabilityID},
		inters: c.Interceptors(),
	}
}

// Get returns a VulnerabilityID entity by its id.
func (c *VulnerabilityIDClient) Get(ctx context.Context, id uuid.UUID) (*VulnerabilityID, error) {
	return c.Query().Where(vulnerabilityid.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VulnerabilityIDClient) GetX(ctx context.Context, id uuid.UUID) *VulnerabilityID {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVulnEqualVulnA queries the vuln_equal_vuln_a edge of a VulnerabilityID.
func (c *VulnerabilityIDClient) QueryVulnEqualVulnA(vi *VulnerabilityID) *VulnEqualQuery {
	query := (&VulnEqualClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityid.Table, vulnerabilityid.FieldID, id),
			sqlgraph.To(vulnequal.Table, vulnequal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, vulnerabilityid.VulnEqualVulnATable, vulnerabilityid.VulnEqualVulnAColumn),
		)
		fromV = sqlgraph.Neighbors(vi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnEqualVulnB queries the vuln_equal_vuln_b edge of a VulnerabilityID.
func (c *VulnerabilityIDClient) QueryVulnEqualVulnB(vi *VulnerabilityID) *VulnEqualQuery {
	query := (&VulnEqualClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityid.Table, vulnerabilityid.FieldID, id),
			sqlgraph.To(vulnequal.Table, vulnequal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, vulnerabilityid.VulnEqualVulnBTable, vulnerabilityid.VulnEqualVulnBColumn),
		)
		fromV = sqlgraph.Neighbors(vi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a VulnerabilityID.
func (c *VulnerabilityIDClient) QueryMetadata(vi *VulnerabilityID) *VulnerabilityMetadataQuery {
	query := (&VulnerabilityMetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityid.Table, vulnerabilityid.FieldID, id),
			sqlgraph.To(vulnerabilitymetadata.Table, vulnerabilitymetadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, vulnerabilityid.MetadataTable, vulnerabilityid.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(vi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCertifyVuln queries the certify_vuln edge of a VulnerabilityID.
func (c *VulnerabilityIDClient) QueryCertifyVuln(vi *VulnerabilityID) *CertifyVulnQuery {
	query := (&CertifyVulnClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityid.Table, vulnerabilityid.FieldID, id),
			sqlgraph.To(certifyvuln.Table, certifyvuln.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, vulnerabilityid.CertifyVulnTable, vulnerabilityid.CertifyVulnColumn),
		)
		fromV = sqlgraph.Neighbors(vi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVex queries the vex edge of a VulnerabilityID.
func (c *VulnerabilityIDClient) QueryVex(vi *VulnerabilityID) *CertifyVexQuery {
	query := (&CertifyVexClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityid.Table, vulnerabilityid.FieldID, id),
			sqlgraph.To(certifyvex.Table, certifyvex.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, vulnerabilityid.VexTable, vulnerabilityid.VexColumn),
		)
		fromV = sqlgraph.Neighbors(vi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VulnerabilityIDClient) Hooks() []Hook {
	return c.hooks.VulnerabilityID
}

// Interceptors returns the client interceptors.
func (c *VulnerabilityIDClient) Interceptors() []Interceptor {
	return c.inters.VulnerabilityID
}

func (c *VulnerabilityIDClient) mutate(ctx context.Context, m *VulnerabilityIDMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VulnerabilityIDCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VulnerabilityIDUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VulnerabilityIDUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VulnerabilityIDDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VulnerabilityID mutation op: %q", m.Op())
	}
}

// VulnerabilityMetadataClient is a client for the VulnerabilityMetadata schema.
type VulnerabilityMetadataClient struct {
	config
}

// NewVulnerabilityMetadataClient returns a client for the VulnerabilityMetadata from the given config.
func NewVulnerabilityMetadataClient(c config) *VulnerabilityMetadataClient {
	return &VulnerabilityMetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vulnerabilitymetadata.Hooks(f(g(h())))`.
func (c *VulnerabilityMetadataClient) Use(hooks ...Hook) {
	c.hooks.VulnerabilityMetadata = append(c.hooks.VulnerabilityMetadata, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vulnerabilitymetadata.Intercept(f(g(h())))`.
func (c *VulnerabilityMetadataClient) Intercept(interceptors ...Interceptor) {
	c.inters.VulnerabilityMetadata = append(c.inters.VulnerabilityMetadata, interceptors...)
}

// Create returns a builder for creating a VulnerabilityMetadata entity.
func (c *VulnerabilityMetadataClient) Create() *VulnerabilityMetadataCreate {
	mutation := newVulnerabilityMetadataMutation(c.config, OpCreate)
	return &VulnerabilityMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VulnerabilityMetadata entities.
func (c *VulnerabilityMetadataClient) CreateBulk(builders ...*VulnerabilityMetadataCreate) *VulnerabilityMetadataCreateBulk {
	return &VulnerabilityMetadataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VulnerabilityMetadataClient) MapCreateBulk(slice any, setFunc func(*VulnerabilityMetadataCreate, int)) *VulnerabilityMetadataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VulnerabilityMetadataCreateBulk{err: fmt.Errorf("calling to VulnerabilityMetadataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VulnerabilityMetadataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VulnerabilityMetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VulnerabilityMetadata.
func (c *VulnerabilityMetadataClient) Update() *VulnerabilityMetadataUpdate {
	mutation := newVulnerabilityMetadataMutation(c.config, OpUpdate)
	return &VulnerabilityMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VulnerabilityMetadataClient) UpdateOne(vm *VulnerabilityMetadata) *VulnerabilityMetadataUpdateOne {
	mutation := newVulnerabilityMetadataMutation(c.config, OpUpdateOne, withVulnerabilityMetadata(vm))
	return &VulnerabilityMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VulnerabilityMetadataClient) UpdateOneID(id uuid.UUID) *VulnerabilityMetadataUpdateOne {
	mutation := newVulnerabilityMetadataMutation(c.config, OpUpdateOne, withVulnerabilityMetadataID(id))
	return &VulnerabilityMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VulnerabilityMetadata.
func (c *VulnerabilityMetadataClient) Delete() *VulnerabilityMetadataDelete {
	mutation := newVulnerabilityMetadataMutation(c.config, OpDelete)
	return &VulnerabilityMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VulnerabilityMetadataClient) DeleteOne(vm *VulnerabilityMetadata) *VulnerabilityMetadataDeleteOne {
	return c.DeleteOneID(vm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VulnerabilityMetadataClient) DeleteOneID(id uuid.UUID) *VulnerabilityMetadataDeleteOne {
	builder := c.Delete().Where(vulnerabilitymetadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VulnerabilityMetadataDeleteOne{builder}
}

// Query returns a query builder for VulnerabilityMetadata.
func (c *VulnerabilityMetadataClient) Query() *VulnerabilityMetadataQuery {
	return &VulnerabilityMetadataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVulnerabilityMetadata},
		inters: c.Interceptors(),
	}
}

// Get returns a VulnerabilityMetadata entity by its id.
func (c *VulnerabilityMetadataClient) Get(ctx context.Context, id uuid.UUID) (*VulnerabilityMetadata, error) {
	return c.Query().Where(vulnerabilitymetadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VulnerabilityMetadataClient) GetX(ctx context.Context, id uuid.UUID) *VulnerabilityMetadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVulnerabilityID queries the vulnerability_id edge of a VulnerabilityMetadata.
func (c *VulnerabilityMetadataClient) QueryVulnerabilityID(vm *VulnerabilityMetadata) *VulnerabilityIDQuery {
	query := (&VulnerabilityIDClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilitymetadata.Table, vulnerabilitymetadata.FieldID, id),
			sqlgraph.To(vulnerabilityid.Table, vulnerabilityid.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, vulnerabilitymetadata.VulnerabilityIDTable, vulnerabilitymetadata.VulnerabilityIDColumn),
		)
		fromV = sqlgraph.Neighbors(vm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VulnerabilityMetadataClient) Hooks() []Hook {
	return c.hooks.VulnerabilityMetadata
}

// Interceptors returns the client interceptors.
func (c *VulnerabilityMetadataClient) Interceptors() []Interceptor {
	return c.inters.VulnerabilityMetadata
}

func (c *VulnerabilityMetadataClient) mutate(ctx context.Context, m *VulnerabilityMetadataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VulnerabilityMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VulnerabilityMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VulnerabilityMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VulnerabilityMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VulnerabilityMetadata mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Artifact, BillOfMaterials, Builder, Certification, CertifyLegal,
		CertifyScorecard, CertifyVex, CertifyVuln, Dependency, HasMetadata,
		HasSourceAt, HashEqual, License, Occurrence, PackageName, PackageVersion,
		PkgEqual, PointOfContact, SLSAAttestation, SourceName, VulnEqual,
		VulnerabilityID, VulnerabilityMetadata []ent.Hook
	}
	inters struct {
		Artifact, BillOfMaterials, Builder, Certification, CertifyLegal,
		CertifyScorecard, CertifyVex, CertifyVuln, Dependency, HasMetadata,
		HasSourceAt, HashEqual, License, Occurrence, PackageName, PackageVersion,
		PkgEqual, PointOfContact, SLSAAttestation, SourceName, VulnEqual,
		VulnerabilityID, VulnerabilityMetadata []ent.Interceptor
	}
)
