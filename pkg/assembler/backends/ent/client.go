// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/guacsec/guac/pkg/assembler/backends/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/artifact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/billofmaterials"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/buildernode"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/dependency"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/occurrence"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagetype"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packageversion"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/slsaattestation"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcename"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcenamespace"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcetype"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Artifact is the client for interacting with the Artifact builders.
	Artifact *ArtifactClient
	// BillOfMaterials is the client for interacting with the BillOfMaterials builders.
	BillOfMaterials *BillOfMaterialsClient
	// BuilderNode is the client for interacting with the BuilderNode builders.
	BuilderNode *BuilderNodeClient
	// Dependency is the client for interacting with the Dependency builders.
	Dependency *DependencyClient
	// Occurrence is the client for interacting with the Occurrence builders.
	Occurrence *OccurrenceClient
	// PackageName is the client for interacting with the PackageName builders.
	PackageName *PackageNameClient
	// PackageNamespace is the client for interacting with the PackageNamespace builders.
	PackageNamespace *PackageNamespaceClient
	// PackageType is the client for interacting with the PackageType builders.
	PackageType *PackageTypeClient
	// PackageVersion is the client for interacting with the PackageVersion builders.
	PackageVersion *PackageVersionClient
	// SLSAAttestation is the client for interacting with the SLSAAttestation builders.
	SLSAAttestation *SLSAAttestationClient
	// SourceName is the client for interacting with the SourceName builders.
	SourceName *SourceNameClient
	// SourceNamespace is the client for interacting with the SourceNamespace builders.
	SourceNamespace *SourceNamespaceClient
	// SourceType is the client for interacting with the SourceType builders.
	SourceType *SourceTypeClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Artifact = NewArtifactClient(c.config)
	c.BillOfMaterials = NewBillOfMaterialsClient(c.config)
	c.BuilderNode = NewBuilderNodeClient(c.config)
	c.Dependency = NewDependencyClient(c.config)
	c.Occurrence = NewOccurrenceClient(c.config)
	c.PackageName = NewPackageNameClient(c.config)
	c.PackageNamespace = NewPackageNamespaceClient(c.config)
	c.PackageType = NewPackageTypeClient(c.config)
	c.PackageVersion = NewPackageVersionClient(c.config)
	c.SLSAAttestation = NewSLSAAttestationClient(c.config)
	c.SourceName = NewSourceNameClient(c.config)
	c.SourceNamespace = NewSourceNamespaceClient(c.config)
	c.SourceType = NewSourceTypeClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Artifact:         NewArtifactClient(cfg),
		BillOfMaterials:  NewBillOfMaterialsClient(cfg),
		BuilderNode:      NewBuilderNodeClient(cfg),
		Dependency:       NewDependencyClient(cfg),
		Occurrence:       NewOccurrenceClient(cfg),
		PackageName:      NewPackageNameClient(cfg),
		PackageNamespace: NewPackageNamespaceClient(cfg),
		PackageType:      NewPackageTypeClient(cfg),
		PackageVersion:   NewPackageVersionClient(cfg),
		SLSAAttestation:  NewSLSAAttestationClient(cfg),
		SourceName:       NewSourceNameClient(cfg),
		SourceNamespace:  NewSourceNamespaceClient(cfg),
		SourceType:       NewSourceTypeClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Artifact:         NewArtifactClient(cfg),
		BillOfMaterials:  NewBillOfMaterialsClient(cfg),
		BuilderNode:      NewBuilderNodeClient(cfg),
		Dependency:       NewDependencyClient(cfg),
		Occurrence:       NewOccurrenceClient(cfg),
		PackageName:      NewPackageNameClient(cfg),
		PackageNamespace: NewPackageNamespaceClient(cfg),
		PackageType:      NewPackageTypeClient(cfg),
		PackageVersion:   NewPackageVersionClient(cfg),
		SLSAAttestation:  NewSLSAAttestationClient(cfg),
		SourceName:       NewSourceNameClient(cfg),
		SourceNamespace:  NewSourceNamespaceClient(cfg),
		SourceType:       NewSourceTypeClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Artifact.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Artifact, c.BillOfMaterials, c.BuilderNode, c.Dependency, c.Occurrence,
		c.PackageName, c.PackageNamespace, c.PackageType, c.PackageVersion,
		c.SLSAAttestation, c.SourceName, c.SourceNamespace, c.SourceType,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Artifact, c.BillOfMaterials, c.BuilderNode, c.Dependency, c.Occurrence,
		c.PackageName, c.PackageNamespace, c.PackageType, c.PackageVersion,
		c.SLSAAttestation, c.SourceName, c.SourceNamespace, c.SourceType,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ArtifactMutation:
		return c.Artifact.mutate(ctx, m)
	case *BillOfMaterialsMutation:
		return c.BillOfMaterials.mutate(ctx, m)
	case *BuilderNodeMutation:
		return c.BuilderNode.mutate(ctx, m)
	case *DependencyMutation:
		return c.Dependency.mutate(ctx, m)
	case *OccurrenceMutation:
		return c.Occurrence.mutate(ctx, m)
	case *PackageNameMutation:
		return c.PackageName.mutate(ctx, m)
	case *PackageNamespaceMutation:
		return c.PackageNamespace.mutate(ctx, m)
	case *PackageTypeMutation:
		return c.PackageType.mutate(ctx, m)
	case *PackageVersionMutation:
		return c.PackageVersion.mutate(ctx, m)
	case *SLSAAttestationMutation:
		return c.SLSAAttestation.mutate(ctx, m)
	case *SourceNameMutation:
		return c.SourceName.mutate(ctx, m)
	case *SourceNamespaceMutation:
		return c.SourceNamespace.mutate(ctx, m)
	case *SourceTypeMutation:
		return c.SourceType.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ArtifactClient is a client for the Artifact schema.
type ArtifactClient struct {
	config
}

// NewArtifactClient returns a client for the Artifact from the given config.
func NewArtifactClient(c config) *ArtifactClient {
	return &ArtifactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artifact.Hooks(f(g(h())))`.
func (c *ArtifactClient) Use(hooks ...Hook) {
	c.hooks.Artifact = append(c.hooks.Artifact, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `artifact.Intercept(f(g(h())))`.
func (c *ArtifactClient) Intercept(interceptors ...Interceptor) {
	c.inters.Artifact = append(c.inters.Artifact, interceptors...)
}

// Create returns a builder for creating a Artifact entity.
func (c *ArtifactClient) Create() *ArtifactCreate {
	mutation := newArtifactMutation(c.config, OpCreate)
	return &ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Artifact entities.
func (c *ArtifactClient) CreateBulk(builders ...*ArtifactCreate) *ArtifactCreateBulk {
	return &ArtifactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Artifact.
func (c *ArtifactClient) Update() *ArtifactUpdate {
	mutation := newArtifactMutation(c.config, OpUpdate)
	return &ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtifactClient) UpdateOne(a *Artifact) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifact(a))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtifactClient) UpdateOneID(id int) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifactID(id))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Artifact.
func (c *ArtifactClient) Delete() *ArtifactDelete {
	mutation := newArtifactMutation(c.config, OpDelete)
	return &ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ArtifactClient) DeleteOne(a *Artifact) *ArtifactDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ArtifactClient) DeleteOneID(id int) *ArtifactDeleteOne {
	builder := c.Delete().Where(artifact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtifactDeleteOne{builder}
}

// Query returns a query builder for Artifact.
func (c *ArtifactClient) Query() *ArtifactQuery {
	return &ArtifactQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArtifact},
		inters: c.Interceptors(),
	}
}

// Get returns a Artifact entity by its id.
func (c *ArtifactClient) Get(ctx context.Context, id int) (*Artifact, error) {
	return c.Query().Where(artifact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtifactClient) GetX(ctx context.Context, id int) *Artifact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOccurrences queries the occurrences edge of a Artifact.
func (c *ArtifactClient) QueryOccurrences(a *Artifact) *OccurrenceQuery {
	query := (&OccurrenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(occurrence.Table, occurrence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.OccurrencesTable, artifact.OccurrencesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySbom queries the sbom edge of a Artifact.
func (c *ArtifactClient) QuerySbom(a *Artifact) *BillOfMaterialsQuery {
	query := (&BillOfMaterialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(billofmaterials.Table, billofmaterials.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.SbomTable, artifact.SbomColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtifactClient) Hooks() []Hook {
	return c.hooks.Artifact
}

// Interceptors returns the client interceptors.
func (c *ArtifactClient) Interceptors() []Interceptor {
	return c.inters.Artifact
}

func (c *ArtifactClient) mutate(ctx context.Context, m *ArtifactMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Artifact mutation op: %q", m.Op())
	}
}

// BillOfMaterialsClient is a client for the BillOfMaterials schema.
type BillOfMaterialsClient struct {
	config
}

// NewBillOfMaterialsClient returns a client for the BillOfMaterials from the given config.
func NewBillOfMaterialsClient(c config) *BillOfMaterialsClient {
	return &BillOfMaterialsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `billofmaterials.Hooks(f(g(h())))`.
func (c *BillOfMaterialsClient) Use(hooks ...Hook) {
	c.hooks.BillOfMaterials = append(c.hooks.BillOfMaterials, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `billofmaterials.Intercept(f(g(h())))`.
func (c *BillOfMaterialsClient) Intercept(interceptors ...Interceptor) {
	c.inters.BillOfMaterials = append(c.inters.BillOfMaterials, interceptors...)
}

// Create returns a builder for creating a BillOfMaterials entity.
func (c *BillOfMaterialsClient) Create() *BillOfMaterialsCreate {
	mutation := newBillOfMaterialsMutation(c.config, OpCreate)
	return &BillOfMaterialsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BillOfMaterials entities.
func (c *BillOfMaterialsClient) CreateBulk(builders ...*BillOfMaterialsCreate) *BillOfMaterialsCreateBulk {
	return &BillOfMaterialsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BillOfMaterials.
func (c *BillOfMaterialsClient) Update() *BillOfMaterialsUpdate {
	mutation := newBillOfMaterialsMutation(c.config, OpUpdate)
	return &BillOfMaterialsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BillOfMaterialsClient) UpdateOne(bom *BillOfMaterials) *BillOfMaterialsUpdateOne {
	mutation := newBillOfMaterialsMutation(c.config, OpUpdateOne, withBillOfMaterials(bom))
	return &BillOfMaterialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BillOfMaterialsClient) UpdateOneID(id int) *BillOfMaterialsUpdateOne {
	mutation := newBillOfMaterialsMutation(c.config, OpUpdateOne, withBillOfMaterialsID(id))
	return &BillOfMaterialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BillOfMaterials.
func (c *BillOfMaterialsClient) Delete() *BillOfMaterialsDelete {
	mutation := newBillOfMaterialsMutation(c.config, OpDelete)
	return &BillOfMaterialsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BillOfMaterialsClient) DeleteOne(bom *BillOfMaterials) *BillOfMaterialsDeleteOne {
	return c.DeleteOneID(bom.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BillOfMaterialsClient) DeleteOneID(id int) *BillOfMaterialsDeleteOne {
	builder := c.Delete().Where(billofmaterials.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BillOfMaterialsDeleteOne{builder}
}

// Query returns a query builder for BillOfMaterials.
func (c *BillOfMaterialsClient) Query() *BillOfMaterialsQuery {
	return &BillOfMaterialsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBillOfMaterials},
		inters: c.Interceptors(),
	}
}

// Get returns a BillOfMaterials entity by its id.
func (c *BillOfMaterialsClient) Get(ctx context.Context, id int) (*BillOfMaterials, error) {
	return c.Query().Where(billofmaterials.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BillOfMaterialsClient) GetX(ctx context.Context, id int) *BillOfMaterials {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a BillOfMaterials.
func (c *BillOfMaterialsClient) QueryPackage(bom *BillOfMaterials) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bom.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(billofmaterials.Table, billofmaterials.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, billofmaterials.PackageTable, billofmaterials.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(bom.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifact queries the artifact edge of a BillOfMaterials.
func (c *BillOfMaterialsClient) QueryArtifact(bom *BillOfMaterials) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bom.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(billofmaterials.Table, billofmaterials.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, billofmaterials.ArtifactTable, billofmaterials.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(bom.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BillOfMaterialsClient) Hooks() []Hook {
	return c.hooks.BillOfMaterials
}

// Interceptors returns the client interceptors.
func (c *BillOfMaterialsClient) Interceptors() []Interceptor {
	return c.inters.BillOfMaterials
}

func (c *BillOfMaterialsClient) mutate(ctx context.Context, m *BillOfMaterialsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BillOfMaterialsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BillOfMaterialsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BillOfMaterialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BillOfMaterialsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BillOfMaterials mutation op: %q", m.Op())
	}
}

// BuilderNodeClient is a client for the BuilderNode schema.
type BuilderNodeClient struct {
	config
}

// NewBuilderNodeClient returns a client for the BuilderNode from the given config.
func NewBuilderNodeClient(c config) *BuilderNodeClient {
	return &BuilderNodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `buildernode.Hooks(f(g(h())))`.
func (c *BuilderNodeClient) Use(hooks ...Hook) {
	c.hooks.BuilderNode = append(c.hooks.BuilderNode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `buildernode.Intercept(f(g(h())))`.
func (c *BuilderNodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.BuilderNode = append(c.inters.BuilderNode, interceptors...)
}

// Create returns a builder for creating a BuilderNode entity.
func (c *BuilderNodeClient) Create() *BuilderNodeCreate {
	mutation := newBuilderNodeMutation(c.config, OpCreate)
	return &BuilderNodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BuilderNode entities.
func (c *BuilderNodeClient) CreateBulk(builders ...*BuilderNodeCreate) *BuilderNodeCreateBulk {
	return &BuilderNodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BuilderNode.
func (c *BuilderNodeClient) Update() *BuilderNodeUpdate {
	mutation := newBuilderNodeMutation(c.config, OpUpdate)
	return &BuilderNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BuilderNodeClient) UpdateOne(bn *BuilderNode) *BuilderNodeUpdateOne {
	mutation := newBuilderNodeMutation(c.config, OpUpdateOne, withBuilderNode(bn))
	return &BuilderNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BuilderNodeClient) UpdateOneID(id int) *BuilderNodeUpdateOne {
	mutation := newBuilderNodeMutation(c.config, OpUpdateOne, withBuilderNodeID(id))
	return &BuilderNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BuilderNode.
func (c *BuilderNodeClient) Delete() *BuilderNodeDelete {
	mutation := newBuilderNodeMutation(c.config, OpDelete)
	return &BuilderNodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BuilderNodeClient) DeleteOne(bn *BuilderNode) *BuilderNodeDeleteOne {
	return c.DeleteOneID(bn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BuilderNodeClient) DeleteOneID(id int) *BuilderNodeDeleteOne {
	builder := c.Delete().Where(buildernode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BuilderNodeDeleteOne{builder}
}

// Query returns a query builder for BuilderNode.
func (c *BuilderNodeClient) Query() *BuilderNodeQuery {
	return &BuilderNodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBuilderNode},
		inters: c.Interceptors(),
	}
}

// Get returns a BuilderNode entity by its id.
func (c *BuilderNodeClient) Get(ctx context.Context, id int) (*BuilderNode, error) {
	return c.Query().Where(buildernode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BuilderNodeClient) GetX(ctx context.Context, id int) *BuilderNode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BuilderNodeClient) Hooks() []Hook {
	return c.hooks.BuilderNode
}

// Interceptors returns the client interceptors.
func (c *BuilderNodeClient) Interceptors() []Interceptor {
	return c.inters.BuilderNode
}

func (c *BuilderNodeClient) mutate(ctx context.Context, m *BuilderNodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BuilderNodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BuilderNodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BuilderNodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BuilderNodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BuilderNode mutation op: %q", m.Op())
	}
}

// DependencyClient is a client for the Dependency schema.
type DependencyClient struct {
	config
}

// NewDependencyClient returns a client for the Dependency from the given config.
func NewDependencyClient(c config) *DependencyClient {
	return &DependencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dependency.Hooks(f(g(h())))`.
func (c *DependencyClient) Use(hooks ...Hook) {
	c.hooks.Dependency = append(c.hooks.Dependency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dependency.Intercept(f(g(h())))`.
func (c *DependencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Dependency = append(c.inters.Dependency, interceptors...)
}

// Create returns a builder for creating a Dependency entity.
func (c *DependencyClient) Create() *DependencyCreate {
	mutation := newDependencyMutation(c.config, OpCreate)
	return &DependencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dependency entities.
func (c *DependencyClient) CreateBulk(builders ...*DependencyCreate) *DependencyCreateBulk {
	return &DependencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dependency.
func (c *DependencyClient) Update() *DependencyUpdate {
	mutation := newDependencyMutation(c.config, OpUpdate)
	return &DependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DependencyClient) UpdateOne(d *Dependency) *DependencyUpdateOne {
	mutation := newDependencyMutation(c.config, OpUpdateOne, withDependency(d))
	return &DependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DependencyClient) UpdateOneID(id int) *DependencyUpdateOne {
	mutation := newDependencyMutation(c.config, OpUpdateOne, withDependencyID(id))
	return &DependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dependency.
func (c *DependencyClient) Delete() *DependencyDelete {
	mutation := newDependencyMutation(c.config, OpDelete)
	return &DependencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DependencyClient) DeleteOne(d *Dependency) *DependencyDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DependencyClient) DeleteOneID(id int) *DependencyDeleteOne {
	builder := c.Delete().Where(dependency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DependencyDeleteOne{builder}
}

// Query returns a query builder for Dependency.
func (c *DependencyClient) Query() *DependencyQuery {
	return &DependencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDependency},
		inters: c.Interceptors(),
	}
}

// Get returns a Dependency entity by its id.
func (c *DependencyClient) Get(ctx context.Context, id int) (*Dependency, error) {
	return c.Query().Where(dependency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DependencyClient) GetX(ctx context.Context, id int) *Dependency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a Dependency.
func (c *DependencyClient) QueryPackage(d *Dependency) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dependency.Table, dependency.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, dependency.PackageTable, dependency.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependentPackage queries the dependent_package edge of a Dependency.
func (c *DependencyClient) QueryDependentPackage(d *Dependency) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dependency.Table, dependency.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, dependency.DependentPackageTable, dependency.DependentPackageColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DependencyClient) Hooks() []Hook {
	return c.hooks.Dependency
}

// Interceptors returns the client interceptors.
func (c *DependencyClient) Interceptors() []Interceptor {
	return c.inters.Dependency
}

func (c *DependencyClient) mutate(ctx context.Context, m *DependencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DependencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DependencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Dependency mutation op: %q", m.Op())
	}
}

// OccurrenceClient is a client for the Occurrence schema.
type OccurrenceClient struct {
	config
}

// NewOccurrenceClient returns a client for the Occurrence from the given config.
func NewOccurrenceClient(c config) *OccurrenceClient {
	return &OccurrenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `occurrence.Hooks(f(g(h())))`.
func (c *OccurrenceClient) Use(hooks ...Hook) {
	c.hooks.Occurrence = append(c.hooks.Occurrence, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `occurrence.Intercept(f(g(h())))`.
func (c *OccurrenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Occurrence = append(c.inters.Occurrence, interceptors...)
}

// Create returns a builder for creating a Occurrence entity.
func (c *OccurrenceClient) Create() *OccurrenceCreate {
	mutation := newOccurrenceMutation(c.config, OpCreate)
	return &OccurrenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Occurrence entities.
func (c *OccurrenceClient) CreateBulk(builders ...*OccurrenceCreate) *OccurrenceCreateBulk {
	return &OccurrenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Occurrence.
func (c *OccurrenceClient) Update() *OccurrenceUpdate {
	mutation := newOccurrenceMutation(c.config, OpUpdate)
	return &OccurrenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OccurrenceClient) UpdateOne(o *Occurrence) *OccurrenceUpdateOne {
	mutation := newOccurrenceMutation(c.config, OpUpdateOne, withOccurrence(o))
	return &OccurrenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OccurrenceClient) UpdateOneID(id int) *OccurrenceUpdateOne {
	mutation := newOccurrenceMutation(c.config, OpUpdateOne, withOccurrenceID(id))
	return &OccurrenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Occurrence.
func (c *OccurrenceClient) Delete() *OccurrenceDelete {
	mutation := newOccurrenceMutation(c.config, OpDelete)
	return &OccurrenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OccurrenceClient) DeleteOne(o *Occurrence) *OccurrenceDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OccurrenceClient) DeleteOneID(id int) *OccurrenceDeleteOne {
	builder := c.Delete().Where(occurrence.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OccurrenceDeleteOne{builder}
}

// Query returns a query builder for Occurrence.
func (c *OccurrenceClient) Query() *OccurrenceQuery {
	return &OccurrenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOccurrence},
		inters: c.Interceptors(),
	}
}

// Get returns a Occurrence entity by its id.
func (c *OccurrenceClient) Get(ctx context.Context, id int) (*Occurrence, error) {
	return c.Query().Where(occurrence.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OccurrenceClient) GetX(ctx context.Context, id int) *Occurrence {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifact queries the artifact edge of a Occurrence.
func (c *OccurrenceClient) QueryArtifact(o *Occurrence) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(occurrence.Table, occurrence.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, occurrence.ArtifactTable, occurrence.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPackage queries the package edge of a Occurrence.
func (c *OccurrenceClient) QueryPackage(o *Occurrence) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(occurrence.Table, occurrence.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, occurrence.PackageTable, occurrence.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySource queries the source edge of a Occurrence.
func (c *OccurrenceClient) QuerySource(o *Occurrence) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(occurrence.Table, occurrence.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, occurrence.SourceTable, occurrence.SourceColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OccurrenceClient) Hooks() []Hook {
	return c.hooks.Occurrence
}

// Interceptors returns the client interceptors.
func (c *OccurrenceClient) Interceptors() []Interceptor {
	return c.inters.Occurrence
}

func (c *OccurrenceClient) mutate(ctx context.Context, m *OccurrenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OccurrenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OccurrenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OccurrenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OccurrenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Occurrence mutation op: %q", m.Op())
	}
}

// PackageNameClient is a client for the PackageName schema.
type PackageNameClient struct {
	config
}

// NewPackageNameClient returns a client for the PackageName from the given config.
func NewPackageNameClient(c config) *PackageNameClient {
	return &PackageNameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packagename.Hooks(f(g(h())))`.
func (c *PackageNameClient) Use(hooks ...Hook) {
	c.hooks.PackageName = append(c.hooks.PackageName, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packagename.Intercept(f(g(h())))`.
func (c *PackageNameClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageName = append(c.inters.PackageName, interceptors...)
}

// Create returns a builder for creating a PackageName entity.
func (c *PackageNameClient) Create() *PackageNameCreate {
	mutation := newPackageNameMutation(c.config, OpCreate)
	return &PackageNameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageName entities.
func (c *PackageNameClient) CreateBulk(builders ...*PackageNameCreate) *PackageNameCreateBulk {
	return &PackageNameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageName.
func (c *PackageNameClient) Update() *PackageNameUpdate {
	mutation := newPackageNameMutation(c.config, OpUpdate)
	return &PackageNameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageNameClient) UpdateOne(pn *PackageName) *PackageNameUpdateOne {
	mutation := newPackageNameMutation(c.config, OpUpdateOne, withPackageName(pn))
	return &PackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageNameClient) UpdateOneID(id int) *PackageNameUpdateOne {
	mutation := newPackageNameMutation(c.config, OpUpdateOne, withPackageNameID(id))
	return &PackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageName.
func (c *PackageNameClient) Delete() *PackageNameDelete {
	mutation := newPackageNameMutation(c.config, OpDelete)
	return &PackageNameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageNameClient) DeleteOne(pn *PackageName) *PackageNameDeleteOne {
	return c.DeleteOneID(pn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageNameClient) DeleteOneID(id int) *PackageNameDeleteOne {
	builder := c.Delete().Where(packagename.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageNameDeleteOne{builder}
}

// Query returns a query builder for PackageName.
func (c *PackageNameClient) Query() *PackageNameQuery {
	return &PackageNameQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageName},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageName entity by its id.
func (c *PackageNameClient) Get(ctx context.Context, id int) (*PackageName, error) {
	return c.Query().Where(packagename.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageNameClient) GetX(ctx context.Context, id int) *PackageName {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a PackageName.
func (c *PackageNameClient) QueryNamespace(pn *PackageName) *PackageNamespaceQuery {
	query := (&PackageNamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagename.Table, packagename.FieldID, id),
			sqlgraph.To(packagenamespace.Table, packagenamespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, packagename.NamespaceTable, packagename.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVersions queries the versions edge of a PackageName.
func (c *PackageNameClient) QueryVersions(pn *PackageName) *PackageVersionQuery {
	query := (&PackageVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagename.Table, packagename.FieldID, id),
			sqlgraph.To(packageversion.Table, packageversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, packagename.VersionsTable, packagename.VersionsColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageNameClient) Hooks() []Hook {
	return c.hooks.PackageName
}

// Interceptors returns the client interceptors.
func (c *PackageNameClient) Interceptors() []Interceptor {
	return c.inters.PackageName
}

func (c *PackageNameClient) mutate(ctx context.Context, m *PackageNameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageNameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageNameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageNameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageName mutation op: %q", m.Op())
	}
}

// PackageNamespaceClient is a client for the PackageNamespace schema.
type PackageNamespaceClient struct {
	config
}

// NewPackageNamespaceClient returns a client for the PackageNamespace from the given config.
func NewPackageNamespaceClient(c config) *PackageNamespaceClient {
	return &PackageNamespaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packagenamespace.Hooks(f(g(h())))`.
func (c *PackageNamespaceClient) Use(hooks ...Hook) {
	c.hooks.PackageNamespace = append(c.hooks.PackageNamespace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packagenamespace.Intercept(f(g(h())))`.
func (c *PackageNamespaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageNamespace = append(c.inters.PackageNamespace, interceptors...)
}

// Create returns a builder for creating a PackageNamespace entity.
func (c *PackageNamespaceClient) Create() *PackageNamespaceCreate {
	mutation := newPackageNamespaceMutation(c.config, OpCreate)
	return &PackageNamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageNamespace entities.
func (c *PackageNamespaceClient) CreateBulk(builders ...*PackageNamespaceCreate) *PackageNamespaceCreateBulk {
	return &PackageNamespaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageNamespace.
func (c *PackageNamespaceClient) Update() *PackageNamespaceUpdate {
	mutation := newPackageNamespaceMutation(c.config, OpUpdate)
	return &PackageNamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageNamespaceClient) UpdateOne(pn *PackageNamespace) *PackageNamespaceUpdateOne {
	mutation := newPackageNamespaceMutation(c.config, OpUpdateOne, withPackageNamespace(pn))
	return &PackageNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageNamespaceClient) UpdateOneID(id int) *PackageNamespaceUpdateOne {
	mutation := newPackageNamespaceMutation(c.config, OpUpdateOne, withPackageNamespaceID(id))
	return &PackageNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageNamespace.
func (c *PackageNamespaceClient) Delete() *PackageNamespaceDelete {
	mutation := newPackageNamespaceMutation(c.config, OpDelete)
	return &PackageNamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageNamespaceClient) DeleteOne(pn *PackageNamespace) *PackageNamespaceDeleteOne {
	return c.DeleteOneID(pn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageNamespaceClient) DeleteOneID(id int) *PackageNamespaceDeleteOne {
	builder := c.Delete().Where(packagenamespace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageNamespaceDeleteOne{builder}
}

// Query returns a query builder for PackageNamespace.
func (c *PackageNamespaceClient) Query() *PackageNamespaceQuery {
	return &PackageNamespaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageNamespace},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageNamespace entity by its id.
func (c *PackageNamespaceClient) Get(ctx context.Context, id int) (*PackageNamespace, error) {
	return c.Query().Where(packagenamespace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageNamespaceClient) GetX(ctx context.Context, id int) *PackageNamespace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPackage queries the package edge of a PackageNamespace.
func (c *PackageNamespaceClient) QueryPackage(pn *PackageNamespace) *PackageTypeQuery {
	query := (&PackageTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagenamespace.Table, packagenamespace.FieldID, id),
			sqlgraph.To(packagetype.Table, packagetype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, packagenamespace.PackageTable, packagenamespace.PackageColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNames queries the names edge of a PackageNamespace.
func (c *PackageNamespaceClient) QueryNames(pn *PackageNamespace) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagenamespace.Table, packagenamespace.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, packagenamespace.NamesTable, packagenamespace.NamesColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageNamespaceClient) Hooks() []Hook {
	return c.hooks.PackageNamespace
}

// Interceptors returns the client interceptors.
func (c *PackageNamespaceClient) Interceptors() []Interceptor {
	return c.inters.PackageNamespace
}

func (c *PackageNamespaceClient) mutate(ctx context.Context, m *PackageNamespaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageNamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageNamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageNamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageNamespace mutation op: %q", m.Op())
	}
}

// PackageTypeClient is a client for the PackageType schema.
type PackageTypeClient struct {
	config
}

// NewPackageTypeClient returns a client for the PackageType from the given config.
func NewPackageTypeClient(c config) *PackageTypeClient {
	return &PackageTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packagetype.Hooks(f(g(h())))`.
func (c *PackageTypeClient) Use(hooks ...Hook) {
	c.hooks.PackageType = append(c.hooks.PackageType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packagetype.Intercept(f(g(h())))`.
func (c *PackageTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageType = append(c.inters.PackageType, interceptors...)
}

// Create returns a builder for creating a PackageType entity.
func (c *PackageTypeClient) Create() *PackageTypeCreate {
	mutation := newPackageTypeMutation(c.config, OpCreate)
	return &PackageTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageType entities.
func (c *PackageTypeClient) CreateBulk(builders ...*PackageTypeCreate) *PackageTypeCreateBulk {
	return &PackageTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageType.
func (c *PackageTypeClient) Update() *PackageTypeUpdate {
	mutation := newPackageTypeMutation(c.config, OpUpdate)
	return &PackageTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageTypeClient) UpdateOne(pt *PackageType) *PackageTypeUpdateOne {
	mutation := newPackageTypeMutation(c.config, OpUpdateOne, withPackageType(pt))
	return &PackageTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageTypeClient) UpdateOneID(id int) *PackageTypeUpdateOne {
	mutation := newPackageTypeMutation(c.config, OpUpdateOne, withPackageTypeID(id))
	return &PackageTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageType.
func (c *PackageTypeClient) Delete() *PackageTypeDelete {
	mutation := newPackageTypeMutation(c.config, OpDelete)
	return &PackageTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageTypeClient) DeleteOne(pt *PackageType) *PackageTypeDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageTypeClient) DeleteOneID(id int) *PackageTypeDeleteOne {
	builder := c.Delete().Where(packagetype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageTypeDeleteOne{builder}
}

// Query returns a query builder for PackageType.
func (c *PackageTypeClient) Query() *PackageTypeQuery {
	return &PackageTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageType},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageType entity by its id.
func (c *PackageTypeClient) Get(ctx context.Context, id int) (*PackageType, error) {
	return c.Query().Where(packagetype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageTypeClient) GetX(ctx context.Context, id int) *PackageType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespaces queries the namespaces edge of a PackageType.
func (c *PackageTypeClient) QueryNamespaces(pt *PackageType) *PackageNamespaceQuery {
	query := (&PackageNamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packagetype.Table, packagetype.FieldID, id),
			sqlgraph.To(packagenamespace.Table, packagenamespace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, packagetype.NamespacesTable, packagetype.NamespacesColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageTypeClient) Hooks() []Hook {
	return c.hooks.PackageType
}

// Interceptors returns the client interceptors.
func (c *PackageTypeClient) Interceptors() []Interceptor {
	return c.inters.PackageType
}

func (c *PackageTypeClient) mutate(ctx context.Context, m *PackageTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageType mutation op: %q", m.Op())
	}
}

// PackageVersionClient is a client for the PackageVersion schema.
type PackageVersionClient struct {
	config
}

// NewPackageVersionClient returns a client for the PackageVersion from the given config.
func NewPackageVersionClient(c config) *PackageVersionClient {
	return &PackageVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `packageversion.Hooks(f(g(h())))`.
func (c *PackageVersionClient) Use(hooks ...Hook) {
	c.hooks.PackageVersion = append(c.hooks.PackageVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `packageversion.Intercept(f(g(h())))`.
func (c *PackageVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.PackageVersion = append(c.inters.PackageVersion, interceptors...)
}

// Create returns a builder for creating a PackageVersion entity.
func (c *PackageVersionClient) Create() *PackageVersionCreate {
	mutation := newPackageVersionMutation(c.config, OpCreate)
	return &PackageVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PackageVersion entities.
func (c *PackageVersionClient) CreateBulk(builders ...*PackageVersionCreate) *PackageVersionCreateBulk {
	return &PackageVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PackageVersion.
func (c *PackageVersionClient) Update() *PackageVersionUpdate {
	mutation := newPackageVersionMutation(c.config, OpUpdate)
	return &PackageVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PackageVersionClient) UpdateOne(pv *PackageVersion) *PackageVersionUpdateOne {
	mutation := newPackageVersionMutation(c.config, OpUpdateOne, withPackageVersion(pv))
	return &PackageVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PackageVersionClient) UpdateOneID(id int) *PackageVersionUpdateOne {
	mutation := newPackageVersionMutation(c.config, OpUpdateOne, withPackageVersionID(id))
	return &PackageVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PackageVersion.
func (c *PackageVersionClient) Delete() *PackageVersionDelete {
	mutation := newPackageVersionMutation(c.config, OpDelete)
	return &PackageVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PackageVersionClient) DeleteOne(pv *PackageVersion) *PackageVersionDeleteOne {
	return c.DeleteOneID(pv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PackageVersionClient) DeleteOneID(id int) *PackageVersionDeleteOne {
	builder := c.Delete().Where(packageversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PackageVersionDeleteOne{builder}
}

// Query returns a query builder for PackageVersion.
func (c *PackageVersionClient) Query() *PackageVersionQuery {
	return &PackageVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePackageVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a PackageVersion entity by its id.
func (c *PackageVersionClient) Get(ctx context.Context, id int) (*PackageVersion, error) {
	return c.Query().Where(packageversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PackageVersionClient) GetX(ctx context.Context, id int) *PackageVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryName queries the name edge of a PackageVersion.
func (c *PackageVersionClient) QueryName(pv *PackageVersion) *PackageNameQuery {
	query := (&PackageNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(packagename.Table, packagename.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, packageversion.NameTable, packageversion.NameColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOccurrences queries the occurrences edge of a PackageVersion.
func (c *PackageVersionClient) QueryOccurrences(pv *PackageVersion) *OccurrenceQuery {
	query := (&OccurrenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(occurrence.Table, occurrence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.OccurrencesTable, packageversion.OccurrencesColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySbom queries the sbom edge of a PackageVersion.
func (c *PackageVersionClient) QuerySbom(pv *PackageVersion) *BillOfMaterialsQuery {
	query := (&BillOfMaterialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(packageversion.Table, packageversion.FieldID, id),
			sqlgraph.To(billofmaterials.Table, billofmaterials.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, packageversion.SbomTable, packageversion.SbomColumn),
		)
		fromV = sqlgraph.Neighbors(pv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PackageVersionClient) Hooks() []Hook {
	return c.hooks.PackageVersion
}

// Interceptors returns the client interceptors.
func (c *PackageVersionClient) Interceptors() []Interceptor {
	return c.inters.PackageVersion
}

func (c *PackageVersionClient) mutate(ctx context.Context, m *PackageVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PackageVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PackageVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PackageVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PackageVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PackageVersion mutation op: %q", m.Op())
	}
}

// SLSAAttestationClient is a client for the SLSAAttestation schema.
type SLSAAttestationClient struct {
	config
}

// NewSLSAAttestationClient returns a client for the SLSAAttestation from the given config.
func NewSLSAAttestationClient(c config) *SLSAAttestationClient {
	return &SLSAAttestationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `slsaattestation.Hooks(f(g(h())))`.
func (c *SLSAAttestationClient) Use(hooks ...Hook) {
	c.hooks.SLSAAttestation = append(c.hooks.SLSAAttestation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `slsaattestation.Intercept(f(g(h())))`.
func (c *SLSAAttestationClient) Intercept(interceptors ...Interceptor) {
	c.inters.SLSAAttestation = append(c.inters.SLSAAttestation, interceptors...)
}

// Create returns a builder for creating a SLSAAttestation entity.
func (c *SLSAAttestationClient) Create() *SLSAAttestationCreate {
	mutation := newSLSAAttestationMutation(c.config, OpCreate)
	return &SLSAAttestationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SLSAAttestation entities.
func (c *SLSAAttestationClient) CreateBulk(builders ...*SLSAAttestationCreate) *SLSAAttestationCreateBulk {
	return &SLSAAttestationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SLSAAttestation.
func (c *SLSAAttestationClient) Update() *SLSAAttestationUpdate {
	mutation := newSLSAAttestationMutation(c.config, OpUpdate)
	return &SLSAAttestationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SLSAAttestationClient) UpdateOne(sa *SLSAAttestation) *SLSAAttestationUpdateOne {
	mutation := newSLSAAttestationMutation(c.config, OpUpdateOne, withSLSAAttestation(sa))
	return &SLSAAttestationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SLSAAttestationClient) UpdateOneID(id int) *SLSAAttestationUpdateOne {
	mutation := newSLSAAttestationMutation(c.config, OpUpdateOne, withSLSAAttestationID(id))
	return &SLSAAttestationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SLSAAttestation.
func (c *SLSAAttestationClient) Delete() *SLSAAttestationDelete {
	mutation := newSLSAAttestationMutation(c.config, OpDelete)
	return &SLSAAttestationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SLSAAttestationClient) DeleteOne(sa *SLSAAttestation) *SLSAAttestationDeleteOne {
	return c.DeleteOneID(sa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SLSAAttestationClient) DeleteOneID(id int) *SLSAAttestationDeleteOne {
	builder := c.Delete().Where(slsaattestation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SLSAAttestationDeleteOne{builder}
}

// Query returns a query builder for SLSAAttestation.
func (c *SLSAAttestationClient) Query() *SLSAAttestationQuery {
	return &SLSAAttestationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSLSAAttestation},
		inters: c.Interceptors(),
	}
}

// Get returns a SLSAAttestation entity by its id.
func (c *SLSAAttestationClient) Get(ctx context.Context, id int) (*SLSAAttestation, error) {
	return c.Query().Where(slsaattestation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SLSAAttestationClient) GetX(ctx context.Context, id int) *SLSAAttestation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBuiltFrom queries the built_from edge of a SLSAAttestation.
func (c *SLSAAttestationClient) QueryBuiltFrom(sa *SLSAAttestation) *ArtifactQuery {
	query := (&ArtifactClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(slsaattestation.Table, slsaattestation.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, slsaattestation.BuiltFromTable, slsaattestation.BuiltFromColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuiltBy queries the built_by edge of a SLSAAttestation.
func (c *SLSAAttestationClient) QueryBuiltBy(sa *SLSAAttestation) *BuilderNodeQuery {
	query := (&BuilderNodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(slsaattestation.Table, slsaattestation.FieldID, id),
			sqlgraph.To(buildernode.Table, buildernode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, slsaattestation.BuiltByTable, slsaattestation.BuiltByColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SLSAAttestationClient) Hooks() []Hook {
	return c.hooks.SLSAAttestation
}

// Interceptors returns the client interceptors.
func (c *SLSAAttestationClient) Interceptors() []Interceptor {
	return c.inters.SLSAAttestation
}

func (c *SLSAAttestationClient) mutate(ctx context.Context, m *SLSAAttestationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SLSAAttestationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SLSAAttestationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SLSAAttestationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SLSAAttestationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SLSAAttestation mutation op: %q", m.Op())
	}
}

// SourceNameClient is a client for the SourceName schema.
type SourceNameClient struct {
	config
}

// NewSourceNameClient returns a client for the SourceName from the given config.
func NewSourceNameClient(c config) *SourceNameClient {
	return &SourceNameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sourcename.Hooks(f(g(h())))`.
func (c *SourceNameClient) Use(hooks ...Hook) {
	c.hooks.SourceName = append(c.hooks.SourceName, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sourcename.Intercept(f(g(h())))`.
func (c *SourceNameClient) Intercept(interceptors ...Interceptor) {
	c.inters.SourceName = append(c.inters.SourceName, interceptors...)
}

// Create returns a builder for creating a SourceName entity.
func (c *SourceNameClient) Create() *SourceNameCreate {
	mutation := newSourceNameMutation(c.config, OpCreate)
	return &SourceNameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SourceName entities.
func (c *SourceNameClient) CreateBulk(builders ...*SourceNameCreate) *SourceNameCreateBulk {
	return &SourceNameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SourceName.
func (c *SourceNameClient) Update() *SourceNameUpdate {
	mutation := newSourceNameMutation(c.config, OpUpdate)
	return &SourceNameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceNameClient) UpdateOne(sn *SourceName) *SourceNameUpdateOne {
	mutation := newSourceNameMutation(c.config, OpUpdateOne, withSourceName(sn))
	return &SourceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceNameClient) UpdateOneID(id int) *SourceNameUpdateOne {
	mutation := newSourceNameMutation(c.config, OpUpdateOne, withSourceNameID(id))
	return &SourceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SourceName.
func (c *SourceNameClient) Delete() *SourceNameDelete {
	mutation := newSourceNameMutation(c.config, OpDelete)
	return &SourceNameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceNameClient) DeleteOne(sn *SourceName) *SourceNameDeleteOne {
	return c.DeleteOneID(sn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceNameClient) DeleteOneID(id int) *SourceNameDeleteOne {
	builder := c.Delete().Where(sourcename.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceNameDeleteOne{builder}
}

// Query returns a query builder for SourceName.
func (c *SourceNameClient) Query() *SourceNameQuery {
	return &SourceNameQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSourceName},
		inters: c.Interceptors(),
	}
}

// Get returns a SourceName entity by its id.
func (c *SourceNameClient) Get(ctx context.Context, id int) (*SourceName, error) {
	return c.Query().Where(sourcename.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceNameClient) GetX(ctx context.Context, id int) *SourceName {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a SourceName.
func (c *SourceNameClient) QueryNamespace(sn *SourceName) *SourceNamespaceQuery {
	query := (&SourceNamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcename.Table, sourcename.FieldID, id),
			sqlgraph.To(sourcenamespace.Table, sourcenamespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, sourcename.NamespaceTable, sourcename.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOccurrences queries the occurrences edge of a SourceName.
func (c *SourceNameClient) QueryOccurrences(sn *SourceName) *OccurrenceQuery {
	query := (&OccurrenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcename.Table, sourcename.FieldID, id),
			sqlgraph.To(occurrence.Table, occurrence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcename.OccurrencesTable, sourcename.OccurrencesColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SourceNameClient) Hooks() []Hook {
	return c.hooks.SourceName
}

// Interceptors returns the client interceptors.
func (c *SourceNameClient) Interceptors() []Interceptor {
	return c.inters.SourceName
}

func (c *SourceNameClient) mutate(ctx context.Context, m *SourceNameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceNameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceNameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceNameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SourceName mutation op: %q", m.Op())
	}
}

// SourceNamespaceClient is a client for the SourceNamespace schema.
type SourceNamespaceClient struct {
	config
}

// NewSourceNamespaceClient returns a client for the SourceNamespace from the given config.
func NewSourceNamespaceClient(c config) *SourceNamespaceClient {
	return &SourceNamespaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sourcenamespace.Hooks(f(g(h())))`.
func (c *SourceNamespaceClient) Use(hooks ...Hook) {
	c.hooks.SourceNamespace = append(c.hooks.SourceNamespace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sourcenamespace.Intercept(f(g(h())))`.
func (c *SourceNamespaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.SourceNamespace = append(c.inters.SourceNamespace, interceptors...)
}

// Create returns a builder for creating a SourceNamespace entity.
func (c *SourceNamespaceClient) Create() *SourceNamespaceCreate {
	mutation := newSourceNamespaceMutation(c.config, OpCreate)
	return &SourceNamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SourceNamespace entities.
func (c *SourceNamespaceClient) CreateBulk(builders ...*SourceNamespaceCreate) *SourceNamespaceCreateBulk {
	return &SourceNamespaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SourceNamespace.
func (c *SourceNamespaceClient) Update() *SourceNamespaceUpdate {
	mutation := newSourceNamespaceMutation(c.config, OpUpdate)
	return &SourceNamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceNamespaceClient) UpdateOne(sn *SourceNamespace) *SourceNamespaceUpdateOne {
	mutation := newSourceNamespaceMutation(c.config, OpUpdateOne, withSourceNamespace(sn))
	return &SourceNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceNamespaceClient) UpdateOneID(id int) *SourceNamespaceUpdateOne {
	mutation := newSourceNamespaceMutation(c.config, OpUpdateOne, withSourceNamespaceID(id))
	return &SourceNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SourceNamespace.
func (c *SourceNamespaceClient) Delete() *SourceNamespaceDelete {
	mutation := newSourceNamespaceMutation(c.config, OpDelete)
	return &SourceNamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceNamespaceClient) DeleteOne(sn *SourceNamespace) *SourceNamespaceDeleteOne {
	return c.DeleteOneID(sn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceNamespaceClient) DeleteOneID(id int) *SourceNamespaceDeleteOne {
	builder := c.Delete().Where(sourcenamespace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceNamespaceDeleteOne{builder}
}

// Query returns a query builder for SourceNamespace.
func (c *SourceNamespaceClient) Query() *SourceNamespaceQuery {
	return &SourceNamespaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSourceNamespace},
		inters: c.Interceptors(),
	}
}

// Get returns a SourceNamespace entity by its id.
func (c *SourceNamespaceClient) Get(ctx context.Context, id int) (*SourceNamespace, error) {
	return c.Query().Where(sourcenamespace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceNamespaceClient) GetX(ctx context.Context, id int) *SourceNamespace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySourceType queries the source_type edge of a SourceNamespace.
func (c *SourceNamespaceClient) QuerySourceType(sn *SourceNamespace) *SourceTypeQuery {
	query := (&SourceTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcenamespace.Table, sourcenamespace.FieldID, id),
			sqlgraph.To(sourcetype.Table, sourcetype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, sourcenamespace.SourceTypeTable, sourcenamespace.SourceTypeColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNames queries the names edge of a SourceNamespace.
func (c *SourceNamespaceClient) QueryNames(sn *SourceNamespace) *SourceNameQuery {
	query := (&SourceNameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcenamespace.Table, sourcenamespace.FieldID, id),
			sqlgraph.To(sourcename.Table, sourcename.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcenamespace.NamesTable, sourcenamespace.NamesColumn),
		)
		fromV = sqlgraph.Neighbors(sn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SourceNamespaceClient) Hooks() []Hook {
	return c.hooks.SourceNamespace
}

// Interceptors returns the client interceptors.
func (c *SourceNamespaceClient) Interceptors() []Interceptor {
	return c.inters.SourceNamespace
}

func (c *SourceNamespaceClient) mutate(ctx context.Context, m *SourceNamespaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceNamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceNamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceNamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceNamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SourceNamespace mutation op: %q", m.Op())
	}
}

// SourceTypeClient is a client for the SourceType schema.
type SourceTypeClient struct {
	config
}

// NewSourceTypeClient returns a client for the SourceType from the given config.
func NewSourceTypeClient(c config) *SourceTypeClient {
	return &SourceTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sourcetype.Hooks(f(g(h())))`.
func (c *SourceTypeClient) Use(hooks ...Hook) {
	c.hooks.SourceType = append(c.hooks.SourceType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sourcetype.Intercept(f(g(h())))`.
func (c *SourceTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.SourceType = append(c.inters.SourceType, interceptors...)
}

// Create returns a builder for creating a SourceType entity.
func (c *SourceTypeClient) Create() *SourceTypeCreate {
	mutation := newSourceTypeMutation(c.config, OpCreate)
	return &SourceTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SourceType entities.
func (c *SourceTypeClient) CreateBulk(builders ...*SourceTypeCreate) *SourceTypeCreateBulk {
	return &SourceTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SourceType.
func (c *SourceTypeClient) Update() *SourceTypeUpdate {
	mutation := newSourceTypeMutation(c.config, OpUpdate)
	return &SourceTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceTypeClient) UpdateOne(st *SourceType) *SourceTypeUpdateOne {
	mutation := newSourceTypeMutation(c.config, OpUpdateOne, withSourceType(st))
	return &SourceTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceTypeClient) UpdateOneID(id int) *SourceTypeUpdateOne {
	mutation := newSourceTypeMutation(c.config, OpUpdateOne, withSourceTypeID(id))
	return &SourceTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SourceType.
func (c *SourceTypeClient) Delete() *SourceTypeDelete {
	mutation := newSourceTypeMutation(c.config, OpDelete)
	return &SourceTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceTypeClient) DeleteOne(st *SourceType) *SourceTypeDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceTypeClient) DeleteOneID(id int) *SourceTypeDeleteOne {
	builder := c.Delete().Where(sourcetype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceTypeDeleteOne{builder}
}

// Query returns a query builder for SourceType.
func (c *SourceTypeClient) Query() *SourceTypeQuery {
	return &SourceTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSourceType},
		inters: c.Interceptors(),
	}
}

// Get returns a SourceType entity by its id.
func (c *SourceTypeClient) Get(ctx context.Context, id int) (*SourceType, error) {
	return c.Query().Where(sourcetype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceTypeClient) GetX(ctx context.Context, id int) *SourceType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespaces queries the namespaces edge of a SourceType.
func (c *SourceTypeClient) QueryNamespaces(st *SourceType) *SourceNamespaceQuery {
	query := (&SourceNamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sourcetype.Table, sourcetype.FieldID, id),
			sqlgraph.To(sourcenamespace.Table, sourcenamespace.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, sourcetype.NamespacesTable, sourcetype.NamespacesColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SourceTypeClient) Hooks() []Hook {
	return c.hooks.SourceType
}

// Interceptors returns the client interceptors.
func (c *SourceTypeClient) Interceptors() []Interceptor {
	return c.inters.SourceType
}

func (c *SourceTypeClient) mutate(ctx context.Context, m *SourceTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SourceType mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Artifact, BillOfMaterials, BuilderNode, Dependency, Occurrence, PackageName,
		PackageNamespace, PackageType, PackageVersion, SLSAAttestation, SourceName,
		SourceNamespace, SourceType []ent.Hook
	}
	inters struct {
		Artifact, BillOfMaterials, BuilderNode, Dependency, Occurrence, PackageName,
		PackageNamespace, PackageType, PackageVersion, SLSAAttestation, SourceName,
		SourceNamespace, SourceType []ent.Interceptor
	}
)
