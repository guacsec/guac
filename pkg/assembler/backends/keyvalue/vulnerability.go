//
// Copyright 2023 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package keyvalue

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"github.com/vektah/gqlparser/v2/gqlerror"

	"github.com/guacsec/guac/internal/testing/ptrfrom"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

const noVulnType string = "novuln"

// Internal data: Vulnerability
type vulnTypeMap map[string]*vulnTypeStruct
type vulnTypeStruct struct {
	id      string
	typeKey string
	vulnIDs vulnIDList
}
type vulnIDList []*vulnIDNode
type vulnIDNode struct {
	id                string
	parent            string
	vulnID            string
	certifyVulnLinks  []string
	vulnEqualLinks    []string
	vexLinks          []string
	vulnMetadataLinks []string
}

func (n *vulnTypeStruct) ID() string { return n.id }
func (n *vulnIDNode) ID() string     { return n.id }

func (n *vulnTypeStruct) Neighbors(allowedEdges edgeMap) []string {
	out := make([]string, 0, len(n.vulnIDs))
	for _, v := range n.vulnIDs {
		out = append(out, v.id)
	}
	return out
}
func (n *vulnIDNode) Neighbors(allowedEdges edgeMap) []string {
	out := []string{n.parent}

	if allowedEdges[model.EdgeVulnerabilityCertifyVuln] {
		out = append(out, n.certifyVulnLinks...)
	}
	if allowedEdges[model.EdgeVulnerabilityVulnEqual] {
		out = append(out, n.vulnEqualLinks...)
	}
	if allowedEdges[model.EdgeVulnerabilityCertifyVexStatement] {
		out = append(out, n.vexLinks...)
	}
	if allowedEdges[model.EdgeVulnMetadataVulnerability] {
		out = append(out, n.vulnMetadataLinks...)
	}

	return out
}

func (n *vulnTypeStruct) BuildModelNode(ctx context.Context, c *demoClient) (model.Node, error) {
	return c.buildVulnResponse(n.id, nil)
}
func (n *vulnIDNode) BuildModelNode(ctx context.Context, c *demoClient) (model.Node, error) {
	return c.buildVulnResponse(n.id, nil)
}

// certifyVulnerability back edges
func (n *vulnIDNode) setVulnerabilityLinks(id string) {
	n.certifyVulnLinks = append(n.certifyVulnLinks, id)
}

// equalVulnerability back edges
func (n *vulnIDNode) setVulnEqualLinks(id string) { n.vulnEqualLinks = append(n.vulnEqualLinks, id) }

// certifyVexStatement back edges
func (n *vulnIDNode) setVexLinks(id string) { n.vexLinks = append(n.vexLinks, id) }

// vulnerability Metadata back edges
func (n *vulnIDNode) setVulnMetadataLinks(id string) {
	n.vulnMetadataLinks = append(n.vulnMetadataLinks, id)
}

// Ingest Vulnerabilities

func (c *demoClient) IngestVulnerabilities(ctx context.Context, vulns []*model.VulnerabilityInputSpec) ([]*model.Vulnerability, error) {
	var modelVulnerabilities []*model.Vulnerability
	for _, vuln := range vulns {
		modelVuln, err := c.IngestVulnerability(ctx, *vuln)
		if err != nil {
			return nil, gqlerror.Errorf("IngestVulnerability failed with err: %v", err)
		}
		modelVulnerabilities = append(modelVulnerabilities, modelVuln)
	}
	return modelVulnerabilities, nil
}

func (c *demoClient) IngestVulnerability(ctx context.Context, vuln model.VulnerabilityInputSpec) (*model.Vulnerability, error) {
	return c.ingestVuln(ctx, vuln, true)
}

func (c *demoClient) ingestVuln(ctx context.Context, input model.VulnerabilityInputSpec, readOnly bool) (*model.Vulnerability, error) {
	typeLowerCase := strings.ToLower(input.Type)
	vulIDLoweCase := strings.ToLower(input.VulnerabilityID)
	c.m.RLock()
	typeStruct, hasType := c.vulnerabilities[typeLowerCase]
	c.m.RUnlock()
	if !hasType {
		c.m.Lock()
		typeStruct, hasType = c.vulnerabilities[typeLowerCase]
		if !hasType {
			typeStruct = &vulnTypeStruct{
				id:      c.getNextID(),
				typeKey: typeLowerCase,
				vulnIDs: vulnIDList{},
			}
			c.index[typeStruct.id] = typeStruct
			c.vulnerabilities[typeLowerCase] = typeStruct
		}
		c.m.Unlock()
	}

	c.m.RLock()
	duplicate, collectedVulnID := duplicateVulnID(typeStruct.vulnIDs, input)
	c.m.RUnlock()
	if !duplicate {
		c.m.Lock()
		duplicate, collectedVulnID = duplicateVulnID(typeStruct.vulnIDs, input)
		if !duplicate {
			collectedVulnID = &vulnIDNode{
				id:     c.getNextID(),
				parent: typeStruct.id,
				vulnID: vulIDLoweCase,
			}
			c.index[collectedVulnID.id] = collectedVulnID
			typeStruct.vulnIDs = append(typeStruct.vulnIDs, collectedVulnID)
		}
		c.m.Unlock()
	}

	// build return GraphQL type
	c.m.RLock()
	defer c.m.RUnlock()
	return c.buildVulnResponse(collectedVulnID.id, nil)
}

func duplicateVulnID(vulnIDs vulnIDList, input model.VulnerabilityInputSpec) (bool, *vulnIDNode) {
	for _, vulnID := range vulnIDs {
		if vulnID.vulnID != strings.ToLower(input.VulnerabilityID) {
			continue
		}
		return true, vulnID
	}
	return false, nil
}

// Query Vulnerabilities
func (c *demoClient) Vulnerabilities(ctx context.Context, filter *model.VulnerabilitySpec) ([]*model.Vulnerability, error) {
	c.m.RLock()
	defer c.m.RUnlock()
	if filter != nil && filter.ID != nil {
		v, err := c.buildVulnResponse(*filter.ID, filter)
		if err != nil {
			if errors.Is(err, errNotFound) {
				// not found
				return nil, nil
			}
			return nil, err
		}
		return []*model.Vulnerability{v}, nil
	}

	if filter.NoVuln != nil && !*filter.NoVuln {
		if filter.Type != nil && *filter.Type == noVulnType {
			return []*model.Vulnerability{}, gqlerror.Errorf("novuln boolean set to false, cannot specify vulnerability type to be novuln")
		}
	}

	out := []*model.Vulnerability{}
	// if novuln is specified, retrieve all "novuln" type nodes
	if filter != nil && filter.NoVuln != nil && *filter.NoVuln {
		filter.Type = ptrfrom.String(noVulnType)
		filter.VulnerabilityID = ptrfrom.String("")
	}

	if filter != nil && filter.Type != nil {
		typeStruct, ok := c.vulnerabilities[strings.ToLower(*filter.Type)]
		if ok {
			vulnIDs := buildVulnID(typeStruct, filter)
			if len(vulnIDs) > 0 {
				out = append(out, &model.Vulnerability{
					ID:               typeStruct.id,
					Type:             typeStruct.typeKey,
					VulnerabilityIDs: vulnIDs,
				})
			}
		}
	} else {
		for vulnType, typeStruct := range c.vulnerabilities {
			vulnIDs := buildVulnID(typeStruct, filter)
			if len(vulnIDs) > 0 {
				out = append(out, &model.Vulnerability{
					ID:               typeStruct.id,
					Type:             vulnType,
					VulnerabilityIDs: vulnIDs,
				})
			}
		}
	}
	return out, nil
}

func buildVulnID(typeStruct *vulnTypeStruct, filter *model.VulnerabilitySpec) []*model.VulnerabilityID {
	vunIDs := []*model.VulnerabilityID{}
	for _, v := range typeStruct.vulnIDs {
		if filter != nil && noMatch(toLower(filter.VulnerabilityID), v.vulnID) {
			continue
		}
		vunIDs = append(vunIDs, &model.VulnerabilityID{
			ID:              v.id,
			VulnerabilityID: v.vulnID,
		})
	}
	return vunIDs
}

func (c *demoClient) exactVulnerability(filter *model.VulnerabilitySpec) (*vulnIDNode, error) {
	if filter == nil {
		return nil, nil
	}
	if filter.ID != nil {
		if node, ok := c.index[*filter.ID]; ok {
			if v, ok := node.(*vulnIDNode); ok {
				return v, nil
			}
		}
	}
	if filter.Type != nil && filter.VulnerabilityID != nil {
		tp, ok := c.vulnerabilities[strings.ToLower(*filter.Type)]
		if !ok {
			return nil, nil
		}
		for _, vulnID := range tp.vulnIDs {
			if strings.ToLower(*filter.VulnerabilityID) != vulnID.vulnID {
				continue
			}
			return vulnID, nil
		}
	}
	return nil, nil
}

// Builds a model.Vulnerability to send as GraphQL response, starting from id.
// The optional filter allows restricting output (on selection operations).
func (c *demoClient) buildVulnResponse(id string, filter *model.VulnerabilitySpec) (*model.Vulnerability, error) {
	if filter != nil && filter.ID != nil && *filter.ID != id {
		return nil, nil
	}

	node, ok := c.index[id]
	if !ok {
		return nil, fmt.Errorf("%w : ID does not match existing node", errNotFound)
	}

	var vl []*model.VulnerabilityID
	if vulnNode, ok := node.(*vulnIDNode); ok {
		if filter != nil && noMatch(toLower(filter.VulnerabilityID), vulnNode.vulnID) {
			return nil, nil
		}
		vl = append(vl, &model.VulnerabilityID{
			// IDs are generated as string even though we ask for integers
			// See https://github.com/99designs/gqlgen/issues/2561
			ID:              vulnNode.id,
			VulnerabilityID: vulnNode.vulnID,
		})
		node, ok = c.index[vulnNode.parent]
		if !ok {
			return nil, fmt.Errorf("internal ID does not match existing node")
		}
	}

	typeStruct, ok := node.(*vulnTypeStruct)
	if !ok {
		return nil, fmt.Errorf("%w: ID does not match expected node type for vulnerability", errNotFound)
	}
	v := model.Vulnerability{
		ID:               typeStruct.id,
		Type:             typeStruct.typeKey,
		VulnerabilityIDs: vl,
	}
	if filter != nil && noMatch(toLower(filter.Type), v.Type) {
		return nil, nil
	}
	return &v, nil
}

func getVulnerabilityIDFromInput(c *demoClient, input model.VulnerabilityInputSpec) (string, error) {
	typeStruct, vulnTypeFound := c.vulnerabilities[strings.ToLower(input.Type)]
	if !vulnTypeFound {
		return "", gqlerror.Errorf("vulnerability type \"%s\" not found", input.Type)
	}
	found := false
	var vulnNodeID string
	for _, vulnID := range typeStruct.vulnIDs {
		if vulnID.vulnID != strings.ToLower(input.VulnerabilityID) {
			continue
		}
		if found {
			return "", gqlerror.Errorf("more than one vulnerability matches input")
		}
		vulnNodeID = vulnID.id
		found = true
	}
	if !found {
		return "", gqlerror.Errorf("No vulnerability matches input")
	}
	return vulnNodeID, nil
}
