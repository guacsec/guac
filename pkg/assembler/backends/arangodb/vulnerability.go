//
// Copyright 2023 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package arangodb

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/arangodb/go-driver"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

const noVulnType string = "novuln"

// dbVulnID is the full presentation of the vulnerability node within the arango database
type dbVulnID struct {
	TypeID   string `json:"type_id"`
	VulnType string `json:"type"`
	// VulnID is the ID of the vulnerability node within the database
	VulnID string `json:"vuln_id"`
	// Vuln is the actual vulnerabilityID within the vulnerability ID node within the database
	Vuln string `json:"vuln"`
}

type dbVulnType struct {
	TypeID   string `json:"type_id"`
	VulnType string `json:"type"`
}

type vulnIds struct {
	TypeId          string
	VulnerabilityID string
}

func (c *arangoClient) Vulnerabilities(ctx context.Context, vulnSpec *model.VulnerabilitySpec) ([]*model.Vulnerability, error) {

	// fields: [type vulnerabilityIDs ]
	fields := getPreloads(ctx)

	vulnerabilityRequired := false
	for _, f := range fields {
		if f == vulnerabilityID {
			vulnerabilityRequired = true
		}
	}

	if !vulnerabilityRequired {
		return c.vulnerabilityType(ctx, vulnSpec)
	}

	values := map[string]any{}

	arangoQueryBuilder := setVulnMatchValues(vulnSpec, values)

	arangoQueryBuilder.query.WriteString("\n")
	arangoQueryBuilder.query.WriteString(`RETURN {
		"type_id": vType._id,
		"type": vType.type,
		"vuln_id": vVulnID._id,
		"vuln": vVulnID.vulnerabilityID
	  }`)

	fmt.Println(arangoQueryBuilder.string())

	cursor, err := executeQueryWithRetry(ctx, c.db, arangoQueryBuilder.string(), values, "Vulnerabilities")
	if err != nil {
		return nil, fmt.Errorf("failed to query for sources: %w", err)
	}
	defer cursor.Close()

	return getVulnerabilities(ctx, cursor)
}

func (c *arangoClient) vulnerabilityType(ctx context.Context, vulnSpec *model.VulnerabilitySpec) ([]*model.Vulnerability, error) {

	values := map[string]any{}

	arangoQueryBuilder := newForQuery(vulnTypesStr, "vType")
	if vulnSpec.Type != nil {
		arangoQueryBuilder.filter("vType", "type", "==", "@vulnType")
		values["vulnType"] = strings.ToLower(*vulnSpec.Type)
	}
	arangoQueryBuilder.query.WriteString("\n")
	arangoQueryBuilder.query.WriteString(`RETURN {
		"type_id": vType._id,
		"type": vType.type
	}`)

	fmt.Println(arangoQueryBuilder.string())

	cursor, err := executeQueryWithRetry(ctx, c.db, arangoQueryBuilder.string(), values, "vulnerabilityType")
	if err != nil {
		return nil, fmt.Errorf("failed to query for vulnerability type: %w", err)
	}
	defer cursor.Close()

	var vulnerabilities []*model.Vulnerability
	for {
		var doc dbVulnType
		_, err := cursor.ReadDocument(ctx, &doc)
		if err != nil {
			if driver.IsNoMoreDocuments(err) {
				break
			} else {
				return nil, fmt.Errorf("failed to query source type: %w", err)
			}
		} else {
			collectedVuln := &model.Vulnerability{
				ID:               doc.TypeID,
				Type:             doc.VulnType,
				VulnerabilityIDs: []*model.VulnerabilityID{},
			}
			vulnerabilities = append(vulnerabilities, collectedVuln)
		}
	}

	return vulnerabilities, nil
}

func setVulnMatchValues(vulnSpec *model.VulnerabilitySpec, queryValues map[string]any) *arangoQueryBuilder {
	var arangoQueryBuilder *arangoQueryBuilder
	if vulnSpec != nil {
		arangoQueryBuilder = newForQuery(vulnTypesStr, "vType")
		if vulnSpec.Type != nil {
			arangoQueryBuilder.filter("vType", "type", "==", "@vulnType")
			queryValues["vulnType"] = strings.ToLower(*vulnSpec.Type)
		}
		arangoQueryBuilder.forOutBound(vulnHasVulnerabilityIDStr, "vVulnID", "vType")
		if vulnSpec.VulnerabilityID != nil {
			arangoQueryBuilder.filter("vVulnID", "vulnerabilityID", "==", "@vulnerabilityID")
			queryValues["vulnerabilityID"] = strings.ToLower(*vulnSpec.VulnerabilityID)
		}
	} else {
		arangoQueryBuilder = newForQuery(vulnTypesStr, "vType")
		arangoQueryBuilder.forOutBound(vulnHasVulnerabilityIDStr, "vVulnID", "vType")
	}
	return arangoQueryBuilder
}

func guacVulnId(vuln model.VulnerabilityInputSpec) vulnIds {
	ids := vulnIds{}
	ids.TypeId = strings.ToLower(vuln.Type)
	ids.VulnerabilityID = fmt.Sprintf("%s::%s", ids.TypeId, strings.ToLower(vuln.VulnerabilityID))
	return ids
}

func getVulnQueryValues(vuln *model.VulnerabilityInputSpec) map[string]any {
	values := map[string]any{}
	// add guac keys
	guacIds := guacVulnId(*vuln)
	values["guacVulnKey"] = guacIds.VulnerabilityID
	values["vulnerabilityID"] = strings.ToLower(vuln.VulnerabilityID)
	values["vulnType"] = strings.ToLower(vuln.Type)

	return values
}

func (c *arangoClient) IngestVulnerabilities(ctx context.Context, vulns []*model.VulnerabilityInputSpec) ([]*model.Vulnerability, error) {
	var listOfValues []map[string]any

	for i := range vulns {
		listOfValues = append(listOfValues, getVulnQueryValues(vulns[i]))
	}

	var documents []string
	for _, val := range listOfValues {
		bs, _ := json.Marshal(val)
		documents = append(documents, string(bs))
	}

	queryValues := map[string]any{}
	queryValues["documents"] = fmt.Sprint(strings.Join(documents, ","))

	var sb strings.Builder

	sb.WriteString("for doc in [")
	for i, val := range listOfValues {
		bs, _ := json.Marshal(val)
		if i == len(listOfValues)-1 {
			sb.WriteString(string(bs))
		} else {
			sb.WriteString(string(bs) + ",")
		}
	}
	sb.WriteString("]")

	query := `
	LET type = FIRST(
		UPSERT { type: doc.vulnType }
		INSERT { type: doc.vulnType }
		UPDATE {}
		IN vulnTypes OPTIONS { indexHint: "byVulnType" }
		RETURN NEW
    )

	LET vuln = FIRST(
	  UPSERT { vulnerabilityID: doc.vulnerabilityID, _parent: type._id , guacKey: doc.guacVulnKey}
	  INSERT { vulnerabilityID: doc.vulnerabilityID, _parent: type._id , guacKey: doc.guacVulnKey}
	  UPDATE {}
	  IN vulnerabilities OPTIONS { indexHint: "byVulnGuacKey" }
	  RETURN NEW
	)

	LET vulnHasVulnerabilityIDCollection = (
	  INSERT { _key: CONCAT("vulnHasVulnerabilityID", type._key, vuln._key), _from: type._id, _to: vuln._id } INTO vulnHasVulnerabilityID OPTIONS { overwriteMode: "ignore" }
	)
	  
    RETURN {
	  "type_id": type._id,
	  "type": type.type,
	  "vuln_id": vuln._id,
	  "vuln": vuln.vulnerabilityID
	}`

	sb.WriteString(query)

	cursor, err := executeQueryWithRetry(ctx, c.db, sb.String(), nil, "IngestVulnerabilities")
	if err != nil {
		return nil, fmt.Errorf("failed to ingest source: %w", err)
	}

	return getVulnerabilities(ctx, cursor)
}

func (c *arangoClient) IngestVulnerability(ctx context.Context, vuln model.VulnerabilityInputSpec) (*model.Vulnerability, error) {
	query := `
	LET type = FIRST(
		UPSERT { type: @vulnType }
		INSERT { type: @vulnType }
		UPDATE {}
		IN vulnTypes OPTIONS { indexHint: "byVulnType" }
		RETURN NEW
    )

	LET vuln = FIRST(
	  UPSERT { vulnerabilityID: @vulnerabilityID, _parent: type._id , guacKey: @guacVulnKey}
	  INSERT { vulnerabilityID: @vulnerabilityID, _parent: type._id , guacKey: @guacVulnKey}
	  UPDATE {}
	  IN vulnerabilities OPTIONS { indexHint: "byVulnGuacKey" }
	  RETURN NEW
	)

	LET vulnHasVulnerabilityIDCollection = (
	  INSERT { _key: CONCAT("vulnHasVulnerabilityID", type._key, vuln._key), _from: type._id, _to: vuln._id } INTO vulnHasVulnerabilityID OPTIONS { overwriteMode: "ignore" }
	)
	  
    RETURN {
	  "type_id": type._id,
	  "type": type.type,
	  "vuln_id": vuln._id,
	  "vuln": vuln.vulnerabilityID
	}`

	cursor, err := executeQueryWithRetry(ctx, c.db, query, getVulnQueryValues(&vuln), "IngestVulnerability")
	if err != nil {
		return nil, fmt.Errorf("failed to ingest cve: %w", err)
	}
	defer cursor.Close()

	createdVulns, err := getVulnerabilities(ctx, cursor)
	if err != nil {
		return nil, fmt.Errorf("failed to get vulnerabilities from arango cursor: %w", err)
	}
	if len(createdVulns) == 1 {
		return createdVulns[0], nil
	} else {
		return nil, fmt.Errorf("number of vulnerabilities ingested is greater than one")
	}
}

func getVulnerabilities(ctx context.Context, cursor driver.Cursor) ([]*model.Vulnerability, error) {
	vulnTypes := map[string][]*model.VulnerabilityID{}
	var doc dbVulnID
	for {
		_, err := cursor.ReadDocument(ctx, &doc)
		if err != nil {
			if driver.IsNoMoreDocuments(err) {
				break
			} else {
				return nil, fmt.Errorf("failed to get vulnerabilities from cursor: %w", err)
			}
		} else {
			typeString := doc.VulnType + "," + doc.TypeID
			vulnID := &model.VulnerabilityID{
				ID:              doc.VulnID,
				VulnerabilityID: doc.Vuln,
			}
			if _, ok := vulnTypes[typeString]; ok {
				vulnTypes[typeString] = append(vulnTypes[typeString], vulnID)
			} else {
				var vulnIDs []*model.VulnerabilityID
				vulnIDs = append(vulnIDs, vulnID)
				vulnTypes[typeString] = vulnIDs
			}
		}
	}
	var vulnerabilities []*model.Vulnerability
	for vulnType, vulnIDs := range vulnTypes {
		typeValues := strings.Split(vulnType, ",")
		vuln := &model.Vulnerability{
			ID:               typeValues[1],
			Type:             typeValues[0],
			VulnerabilityIDs: vulnIDs,
		}
		vulnerabilities = append(vulnerabilities, vuln)
	}
	return vulnerabilities, nil
}
