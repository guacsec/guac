//
// Copyright 2024 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package datadog_malware

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"net/http/httptest"
	"path"
	"strings"
	"testing"

	"github.com/guacsec/guac/pkg/assembler"
	"github.com/guacsec/guac/pkg/assembler/clients/generated"
	ingestor "github.com/guacsec/guac/pkg/assembler/clients/helpers"
	"github.com/guacsec/guac/pkg/assembler/helpers"
	"github.com/guacsec/guac/pkg/certifier/components/root_package"
	"github.com/guacsec/guac/pkg/logging"
	"github.com/stretchr/testify/assert"
)

func TestDatadogMalwareCertifier_CertifyComponent(t *testing.T) {
	// set up test server that handles both npm and pypi manifests
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var response map[string][]string
		switch path.Base(r.URL.Path) {
		case "manifest.json":
			if strings.Contains(r.URL.Path, "npm") {
				response = map[string][]string{
					"@malicious/package":          {"1.0.0"},
					"evil-package":                {"2.0.0"},
					"@malicious/emptyversions":    {},
					"@malicious/multipleversions": {"1.0.0", "2.0.0"},
					"@malicious/singleversion":    {"1.0.0"},
				}
			} else if strings.Contains(r.URL.Path, "pypi") {
				response = map[string][]string{
					"malicious-pypi":     {"0.1.0"},
					"emptyversions-pypi": {},
					"manyversions-pypi":  {"0.1.0", "0.2.0"},
					"singleversion-pypi": {"3.3.3"},
				}
			}
		default:
			http.Error(w, "not found", http.StatusNotFound)
			return
		}

		err := json.NewEncoder(w).Encode(response)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}))
	defer server.Close()

	// create a custom client that redirects all requests to our test server
	testClient := &http.Client{
		Transport: &mockTransport{
			server:          server,
			npmManifestURL:  NPM_MANIFEST_URL,
			pypiManifestURL: PYPI_MANIFEST_URL,
		},
	}

	ctx := logging.WithLogger(context.Background())

	type testCase struct {
		name           string
		rootComponent  interface{}
		expectedPreds  int
		wantPackages   []string
		wantPkgMatch   generated.PkgMatchType
		wantErr        bool
		errMessage     error
		assemblerError error
	}

	tests := []testCase{
		{
			name: "certify malicious npm and pypi packages",
			rootComponent: []*root_package.PackageNode{
				{Purl: "pkg:npm/%40malicious/package@1.0.0"},
				{Purl: "pkg:npm/evil-package@2.0.0"},
				{Purl: "pkg:pypi/malicious-pypi@0.1.0"},
				{Purl: "pkg:maven/safe/package@1.0.0"},
			},
			expectedPreds: 3,
			wantPackages: []string{
				"pkg:npm/%40malicious/package@1.0.0",
				"pkg:npm/evil-package@2.0.0",
				"pkg:pypi/malicious-pypi@0.1.0",
			},
			wantPkgMatch: generated.PkgMatchTypeSpecificVersion,
			wantErr:      false,
		},
		{
			name:          "bad component type",
			rootComponent: map[string]string{},
			expectedPreds: 0,
			wantErr:       true,
			errMessage:    ErrDatadogMalwareComponentTypeMismatch,
		},
		{
			name: "no malicious packages",
			rootComponent: []*root_package.PackageNode{
				{Purl: "pkg:npm/safe-package@1.0.0"},
				{Purl: "pkg:pypi/good-package@1.0.0"},
			},
			expectedPreds: 0,
			wantErr:       false,
		},
		{
			name: "assembler error",
			rootComponent: []*root_package.PackageNode{
				{Purl: "pkg:npm/%40malicious/multipleversions@1.0.0"},
			},
			expectedPreds:  1,
			wantPackages:   []string{"pkg:npm/%40malicious/multipleversions@1.0.0"},
			wantPkgMatch:   generated.PkgMatchTypeSpecificVersion,
			wantErr:        true,
			assemblerError: errors.New("assembler error"),
		},

		// empty versions list, no package version specified
		{
			name: "empty versions, no package version (npm)",
			rootComponent: []*root_package.PackageNode{
				{Purl: "pkg:npm/%40malicious/emptyversions"},
			},
			expectedPreds: 1,
			wantPackages:  []string{"pkg:npm/%40malicious/emptyversions"},
			wantPkgMatch:  generated.PkgMatchTypeAllVersions,
			wantErr:       false,
		},
		{
			name: "empty versions, no package version (pypi)",
			rootComponent: []*root_package.PackageNode{
				{Purl: "pkg:pypi/emptyversions-pypi"},
			},
			expectedPreds: 1,
			wantPackages:  []string{"pkg:pypi/emptyversions-pypi"},
			wantPkgMatch:  generated.PkgMatchTypeAllVersions,
			wantErr:       false,
		},

		// empty versions list, with package version specified
		{
			name: "empty versions, package version specified (npm)",
			rootComponent: []*root_package.PackageNode{
				{Purl: "pkg:npm/%40malicious/emptyversions@9.9.9"},
			},
			expectedPreds: 1,
			wantPackages:  []string{"pkg:npm/%40malicious/emptyversions@9.9.9"},
			wantPkgMatch:  generated.PkgMatchTypeAllVersions,
			wantErr:       false,
		},

		// non-empty versions, no package version specified -> all malicious
		{
			name: "non-empty versions, no version specified (npm)",
			rootComponent: []*root_package.PackageNode{
				{Purl: "pkg:npm/%40malicious/multipleversions"},
			},
			expectedPreds: 1,
			wantPackages:  []string{"pkg:npm/%40malicious/multipleversions"},
			wantPkgMatch:  generated.PkgMatchTypeAllVersions,
			wantErr:       false,
		},
		{
			name: "non-empty versions, no version specified (pypi)",
			rootComponent: []*root_package.PackageNode{
				{Purl: "pkg:pypi/manyversions-pypi"},
			},
			expectedPreds: 1,
			wantPackages:  []string{"pkg:pypi/manyversions-pypi"},
			wantPkgMatch:  generated.PkgMatchTypeAllVersions,
			wantErr:       false,
		},

		// non-empty versions, with a specified malicious version
		{
			name: "non-empty versions, specified malicious version (npm)",
			rootComponent: []*root_package.PackageNode{
				{Purl: "pkg:npm/%40malicious/multipleversions@1.0.0"},
			},
			expectedPreds: 1,
			wantPackages:  []string{"pkg:npm/%40malicious/multipleversions@1.0.0"},
			wantPkgMatch:  generated.PkgMatchTypeSpecificVersion,
			wantErr:       false,
		},
		{
			name: "non-empty versions, specified malicious version (pypi)",
			rootComponent: []*root_package.PackageNode{
				{Purl: "pkg:pypi/manyversions-pypi@0.1.0"},
			},
			expectedPreds: 1,
			wantPackages:  []string{"pkg:pypi/manyversions-pypi@0.1.0"},
			wantPkgMatch:  generated.PkgMatchTypeSpecificVersion,
			wantErr:       false,
		},

		// non-empty versions, with a specified non-malicious version
		{
			name: "non-empty versions, specified non-malicious version (npm)",
			rootComponent: []*root_package.PackageNode{
				{Purl: "pkg:npm/%40malicious/multipleversions@3.0.0"},
			},
			expectedPreds: 0,
			wantErr:       false,
		},
		{
			name: "non-empty versions, specified non-malicious version (pypi)",
			rootComponent: []*root_package.PackageNode{
				{Purl: "pkg:pypi/manyversions-pypi@1.1.1"},
			},
			expectedPreds: 0,
			wantErr:       false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var capturedPreds []assembler.IngestPredicates
			mockAssembler := func(preds []assembler.IngestPredicates) (*ingestor.AssemblerIngestedIDs, error) {
				capturedPreds = preds
				if tt.assemblerError != nil {
					return nil, tt.assemblerError
				}
				return &ingestor.AssemblerIngestedIDs{}, nil
			}

			certifier, err := NewDatadogMalwareCertifier(ctx, mockAssembler, WithHTTPClient(testClient))
			if err != nil {
				t.Fatalf("Failed to create certifier: %v", err)
			}

			err = certifier.CertifyComponent(ctx, tt.rootComponent, nil)

			if (err != nil) != tt.wantErr {
				t.Errorf("CertifyComponent() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if err != nil {
				if tt.errMessage != nil && !errors.Is(err, tt.errMessage) {
					t.Errorf("CertifyComponent() error = %v, want error = %v", err, tt.errMessage)
				}
				return
			}

			if tt.expectedPreds > 0 {
				assert.Len(t, capturedPreds, 1, "Should have one IngestPredicates")
				assert.Len(t, capturedPreds[0].CertifyBad, tt.expectedPreds, "Should have expected number of CertifyBad predicates")

				foundPackages := make(map[string]bool)
				for _, certifyBad := range capturedPreds[0].CertifyBad {
					purl := helpers.PkgInputSpecToPurl(certifyBad.Pkg)
					foundPackages[purl] = true

					// verify predicate content
					assert.Equal(t, DatadogMalwareCertifier, certifyBad.CertifyBad.Collector)
					assert.Equal(t, "Datadog Malicious Software Packages Dataset", certifyBad.CertifyBad.Origin)
					assert.NotEmpty(t, certifyBad.CertifyBad.Justification)
					assert.Equal(t, tt.wantPkgMatch, certifyBad.PkgMatchFlag.Pkg)
					assert.NotNil(t, certifyBad.CertifyBad.KnownSince)
				}

				for _, pkg := range tt.wantPackages {
					assert.True(t, foundPackages[pkg], fmt.Sprintf("Package %s was not found in certifications", pkg))
				}
			} else {
				assert.Len(t, capturedPreds, 0, "Should have no IngestPredicates")
			}
		})
	}
}

// mockTransport redirects requests to the test server while preserving paths
type mockTransport struct {
	server          *httptest.Server
	npmManifestURL  string
	pypiManifestURL string
}

func (t *mockTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	newURL := t.server.URL
	switch req.URL.String() {
	case t.npmManifestURL:
		newURL += "/npm/manifest.json"
	case t.pypiManifestURL:
		newURL += "/pypi/manifest.json"
	default:
		return nil, fmt.Errorf("unexpected URL: %s", req.URL.String())
	}

	newReq := req.Clone(req.Context())
	var err error
	newReq.URL, err = req.URL.Parse(newURL)
	if err != nil {
		return nil, err
	}

	return t.server.Client().Do(newReq)
}
