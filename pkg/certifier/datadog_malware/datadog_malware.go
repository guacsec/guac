//
// Copyright 2024 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package datadog_malware

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/guacsec/guac/pkg/assembler"
	"github.com/guacsec/guac/pkg/assembler/clients/generated"
	ingestor "github.com/guacsec/guac/pkg/assembler/clients/helpers"
	"github.com/guacsec/guac/pkg/assembler/helpers"
	"github.com/guacsec/guac/pkg/certifier"
	"github.com/guacsec/guac/pkg/certifier/components/root_package"
	"github.com/guacsec/guac/pkg/clients"
	"github.com/guacsec/guac/pkg/handler/processor"
	"github.com/guacsec/guac/pkg/logging"
	"github.com/guacsec/guac/pkg/version"
	jsoniter "github.com/json-iterator/go"
	"golang.org/x/time/rate"
)

var (
	json              = jsoniter.ConfigCompatibleWithStandardLibrary
	rateLimit         = 10000
	rateLimitInterval = 30 * time.Second
)

const (
	NPM_MANIFEST_URL        string = "https://raw.githubusercontent.com/DataDog/malicious-software-packages-dataset/main/samples/npm/manifest.json"
	PYPI_MANIFEST_URL       string = "https://raw.githubusercontent.com/DataDog/malicious-software-packages-dataset/main/samples/pypi/manifest.json"
	DatadogMalwareCertifier string = "datadog_malware_certifier"

	// manifestRefreshInterval is the interval at which we periodically re-fetch
	// the Datadog malicious packages manifests.
	manifestRefreshInterval = 4 * time.Hour
)

var ErrDatadogMalwareComponentTypeMismatch error = errors.New("rootComponent type is not []*root_package.PackageNode")

type MaliciousPackages map[string][]string

type assemblerFuncType func([]assembler.IngestPredicates) (*ingestor.AssemblerIngestedIDs, error)

type datadogMalwareCertifier struct {
	httpClient    *http.Client
	assemblerFunc assemblerFuncType

	dataMu   sync.RWMutex
	npmData  MaliciousPackages
	pypiData MaliciousPackages
}

// CertifierOption defines functional options for the certifier
type CertifierOption func(*datadogMalwareCertifier)

// WithHTTPClient allows overriding the default HTTP client
func WithHTTPClient(client *http.Client) CertifierOption {
	return func(d *datadogMalwareCertifier) {
		d.httpClient = client
	}
}

// NewDatadogMalwareCertifier initializes the Datadog Malicious Software Packages certifier.
//
// The Datadog malicious software packages dataset is a public repository that catalogs
// known malicious artifacts for platforms such as npm and PyPI. By using this data,
// we can certify suspect packages in our GUAC graph as known bad (i.e. CertifyBad).
// https://github.com/DataDog/malicious-software-packages-dataset
//
//   - added predicates: each discovered malicious package is ingested with a `CertifyBad`
//     predicate, describing the justification, origin, and collector used.
//
//   - recommended intervals: this certifier is typically run on a recurring basis or
//     with a background refresh at least every few hours. the default here is every 4 hours.
//
// If the provided context is canceled, the refresh loop will exit.
func NewDatadogMalwareCertifier(ctx context.Context, assemblerFunc assemblerFuncType, opts ...CertifierOption) (certifier.Certifier, error) {
	limiter := rate.NewLimiter(rate.Every(rateLimitInterval), rateLimit)
	transport := clients.NewRateLimitedTransport(version.UATransport, limiter)
	defaultClient := &http.Client{Transport: transport}

	d := &datadogMalwareCertifier{
		httpClient:    defaultClient,
		assemblerFunc: assemblerFunc,
	}

	// apply user-provided options
	for _, opt := range opts {
		opt(d)
	}

	// Fetch immediately on creation to have initial data
	if err := d.fetchManifests(); err != nil {
		return nil, fmt.Errorf("failed to fetch Datadog Malicious Software Packages manifests: %w", err)
	}

	// Start a background loop to refresh data every so often
	go d.startManifestRefreshLoop(ctx)

	return d, nil
}

// startManifestRefreshLoop uses a ticker to periodically fetch the manifests
func (d *datadogMalwareCertifier) startManifestRefreshLoop(ctx context.Context) {
	ticker := time.NewTicker(manifestRefreshInterval)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			if err := d.fetchManifests(); err != nil {
				logging.FromContext(ctx).Errorf("failed to refresh Datadog Malicious Software Packages manifests: %v", err)
			}
		case <-ctx.Done():
			return
		}
	}
}

// fetchManifests updates the local npmData and pypiData from remote sources
func (d *datadogMalwareCertifier) fetchManifests() error {
	d.dataMu.Lock()
	defer d.dataMu.Unlock()

	npmResp, err := d.httpClient.Get(NPM_MANIFEST_URL)
	if err != nil {
		return fmt.Errorf("failed to fetch NPM manifest: %w", err)
	}
	defer npmResp.Body.Close()

	npmData := make(MaliciousPackages)
	if err := json.NewDecoder(npmResp.Body).Decode(&npmData); err != nil {
		return fmt.Errorf("failed to decode NPM manifest: %w", err)
	}

	pypiResp, err := d.httpClient.Get(PYPI_MANIFEST_URL)
	if err != nil {
		return fmt.Errorf("failed to fetch PyPI manifest: %w", err)
	}
	defer pypiResp.Body.Close()

	pypiData := make(MaliciousPackages)
	if err := json.NewDecoder(pypiResp.Body).Decode(&pypiData); err != nil {
		return fmt.Errorf("failed to decode PyPI manifest: %w", err)
	}

	d.npmData = npmData
	d.pypiData = pypiData
	return nil
}

// CertifyComponent checks the provided packages against the Datadog malicious datasets
func (d *datadogMalwareCertifier) CertifyComponent(ctx context.Context, rootComponent interface{}, docChannel chan<- *processor.Document) error {
	logger := logging.FromContext(ctx)
	packageNodes, ok := rootComponent.([]*root_package.PackageNode)
	if !ok {
		return ErrDatadogMalwareComponentTypeMismatch
	}

	predicates := &assembler.IngestPredicates{}
	currentTime := time.Now().UTC()

	d.dataMu.RLock()
	npmData := d.npmData
	pypiData := d.pypiData
	d.dataMu.RUnlock()

	for _, node := range packageNodes {
		purl := node.Purl

		pkgInput, err := helpers.PurlToPkg(purl)
		if err != nil {
			logger.Debugf("failed to parse purl '%s' into package: %v", purl, err)
			continue
		}

		var maliciousVersions []string
		switch pkgInput.Type {
		case "npm":
			// Conditionally add "@" only if the original namespace began with "@" or "%40"
			fullName := pkgInput.Name
			if pkgInput.Namespace != nil && *pkgInput.Namespace != "" {
				ns := *pkgInput.Namespace
				trimmedNS := strings.TrimPrefix(ns, "@")
				trimmedNS = strings.TrimPrefix(trimmedNS, "%40")

				// If we did actually remove a prefix, then re-add the "@"
				if strings.HasPrefix(ns, "@") || strings.HasPrefix(ns, "%40") {
					fullName = "@" + trimmedNS + "/" + pkgInput.Name
				} else {
					// Otherwise, just combine them without '@'
					fullName = trimmedNS + "/" + pkgInput.Name
				}
			}
			v, found := npmData[fullName]
			if !found {
				continue
			}
			maliciousVersions = v

		case "pypi":
			v, found := pypiData[pkgInput.Name]
			if !found {
				continue
			}
			maliciousVersions = v

		default:
			logger.Debugf("Skipping package %s, not npm or pypi", purl)
			continue
		}

		if len(maliciousVersions) == 0 {
			// interpret empty versions array as "all versions malicious"
			justification := "All versions of this package are malicious."
			certifyBad := &assembler.CertifyBadIngest{
				Pkg:          pkgInput,
				PkgMatchFlag: generated.MatchFlags{Pkg: generated.PkgMatchTypeAllVersions},
				CertifyBad: &generated.CertifyBadInputSpec{
					Justification: justification,
					Origin:        "Datadog Malicious Software Packages Dataset",
					Collector:     DatadogMalwareCertifier,
					KnownSince:    currentTime,
				},
			}
			predicates.CertifyBad = append(predicates.CertifyBad, *certifyBad)
		} else {
			// we have specific malicious versions listed
			if pkgInput.Version == nil || *pkgInput.Version == "" {
				// no specific version requested, treat all known malicious versions as applying to all versions
				justification := "All versions of this package are malicious according to Datadog's dataset."
				certifyBad := &assembler.CertifyBadIngest{
					Pkg:          pkgInput,
					PkgMatchFlag: generated.MatchFlags{Pkg: generated.PkgMatchTypeAllVersions},
					CertifyBad: &generated.CertifyBadInputSpec{
						Justification: justification,
						Origin:        "Datadog Malicious Software Packages Dataset",
						Collector:     DatadogMalwareCertifier,
						KnownSince:    currentTime,
					},
				}
				predicates.CertifyBad = append(predicates.CertifyBad, *certifyBad)
			} else {
				// If a specific version is given, check if it's malicious
				versionToCheck := *pkgInput.Version
				if !containsVersion(maliciousVersions, versionToCheck) {
					logger.Debugf("Package %s version %s not found in malicious dataset", purl, versionToCheck)
					continue
				}

				justification := fmt.Sprintf("Package version %s found in Datadog's malicious software packages dataset.", versionToCheck)
				certifyBad := &assembler.CertifyBadIngest{
					Pkg:          pkgInput,
					PkgMatchFlag: generated.MatchFlags{Pkg: generated.PkgMatchTypeSpecificVersion},
					CertifyBad: &generated.CertifyBadInputSpec{
						Justification: justification,
						Origin:        "Datadog Malicious Software Packages Dataset",
						Collector:     DatadogMalwareCertifier,
						KnownSince:    currentTime,
					},
				}
				predicates.CertifyBad = append(predicates.CertifyBad, *certifyBad)
			}
		}
	}

	if len(predicates.CertifyBad) > 0 {
		if _, err := d.assemblerFunc([]assembler.IngestPredicates{*predicates}); err != nil {
			return fmt.Errorf("unable to assemble graphs: %w", err)
		}
	}

	return nil
}

// containsVersion checks if a given version string is in the malicious versions list
func containsVersion(maliciousVersions []string, versionToCheck string) bool {
	for _, v := range maliciousVersions {
		if v == versionToCheck {
			return true
		}
	}
	return false
}
