//
// Copyright 2024 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package clearlydefined

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
	"time"

	"golang.org/x/time/rate"

	"github.com/guacsec/guac/pkg/assembler/helpers"
	"github.com/guacsec/guac/pkg/certifier"
	"github.com/guacsec/guac/pkg/certifier/attestation"
	"github.com/guacsec/guac/pkg/certifier/components/root_package"
	"github.com/guacsec/guac/pkg/clients" // Import the clients package for rate limiter
	"github.com/guacsec/guac/pkg/events"
	"github.com/guacsec/guac/pkg/handler/processor"
	"github.com/guacsec/guac/pkg/logging"
	"github.com/guacsec/guac/pkg/misc/coordinates"
	"github.com/guacsec/guac/pkg/version"

	attestationv1 "github.com/in-toto/attestation/go/v1"
	jsoniter "github.com/json-iterator/go"
)

var json = jsoniter.ConfigCompatibleWithStandardLibrary
var rateLimit = 2000
var rateLimitInterval = time.Minute

const (
	PRODUCER_ID string = "guacsec/guac"
	CDCollector string = "clearlydefined"
)

var ErrComponentTypeMismatch error = errors.New("rootComponent type is not []*root_package.PackageNode")

type cdCertifier struct {
	cdHTTPClient *http.Client
}

// NewClearlyDefinedCertifier initializes the cdCertifier
func NewClearlyDefinedCertifier() certifier.Certifier {
	limiter := rate.NewLimiter(rate.Every(rateLimitInterval), rateLimit)
	client := NewClearlyDefinedHTTPClient(limiter)
	return &cdCertifier{
		cdHTTPClient: client,
	}
}

func NewClearlyDefinedHTTPClient(limiter *rate.Limiter) *http.Client {
	transport := clients.NewRateLimitedTransport(version.UATransport, limiter)
	return &http.Client{Transport: transport}
}

// GetDefinitions uses the coordinates to query clearly defined for license definition
func GetDefinitions(ctx context.Context, purls []string, coordinates []string) (map[string]*attestation.Definition, error) {

	definitionMap := make(map[string]*attestation.Definition)

	// Convert coordinates to JSON
	jsonData, err := json.Marshal(coordinates)
	if err != nil {
		log.Fatalf("Error marshalling coordinates: %v", err)
	}

	req, err := http.NewRequest("POST", "https://api.clearlydefined.io/definitions", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to generate new request with error: %w", err)
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to get response from clearly defined API with error: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		// otherwise return an error
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %v", err)
	}

	var definitions []*attestation.Definition
	if err := json.Unmarshal(body, &definitions); err != nil {
		return nil, fmt.Errorf("error unmarshalling JSON: %v", err)
	}

	if len(purls) == len(definitions) {
		return nil, fmt.Errorf("failed to get expected responses back! Purl count: %d, returned definition count %d", len(purls), len(definitions))
	}

	for i, definition := range definitions {
		definitionMap[purls[i]] = definition
	}

	return definitionMap, nil
}

// CertifyComponent takes in the root component from the gauc database and does a recursive scan
// to generate clearly defined attestations
func (c *cdCertifier) CertifyComponent(ctx context.Context, rootComponent interface{}, docChannel chan<- *processor.Document) error {
	logger := logging.FromContext(ctx)

	packageNodes, ok := rootComponent.([]*root_package.PackageNode)
	if !ok {
		return ErrComponentTypeMismatch
	}

	var batchCoordinates []string
	var purls []string
	packMap := map[string]bool{}
	for _, node := range packageNodes {
		// skip any purls that are generated by GUAC as they will not be found in clearly defined
		if strings.Contains(node.Purl, "pkg:guac") {
			continue
		}
		if _, ok := packMap[node.Purl]; !ok {
			coordinate, err := coordinates.ConvertPurlToCoordinate(node.Purl)
			if err != nil {
				logger.Errorf("failed to parse purl into coordinate with error: %v", err)
				continue
			}
			packMap[node.Purl] = true
			purls = append(purls, node.Purl)
			batchCoordinates = append(batchCoordinates, coordinate.ToString())
		}
	}

	definitionMap, err := GetDefinitions(ctx, purls, batchCoordinates)
	if err != nil {
		return fmt.Errorf("failed get package definition from clearly defined with error: %w", err)
	}

	if err := generateDocument(definitionMap, docChannel); err != nil {
		return fmt.Errorf("could not generate document from Clearly Defined results: %w", err)
	}

	if err := evaluateDefinitionForSource(ctx, definitionMap, docChannel); err != nil {
		return fmt.Errorf("evaluateDefinitionForSource failed with error: %w", err)
	}

	return nil
}

// generateDocument generates the actual clearly defined attestation
func generateDocument(definitionMap map[string]*attestation.Definition, docChannel chan<- *processor.Document) error {
	for purl, definition := range definitionMap {
		if definition.Described.ReleaseDate == "" {
			continue
		}
		currentTime := time.Now()
		payload, err := json.Marshal(CreateAttestation(purl, definition, currentTime))
		if err != nil {
			return fmt.Errorf("unable to marshal attestation: %w", err)
		}
		doc := &processor.Document{
			Blob:   payload,
			Type:   processor.DocumentITE6ClearlyDefined,
			Format: processor.FormatJSON,
			SourceInformation: processor.SourceInformation{
				Collector:   CDCollector,
				Source:      CDCollector,
				DocumentRef: events.GetDocRef(payload),
			},
		}
		docChannel <- doc
	}
	return nil
}

func evaluateDefinitionForSource(ctx context.Context, definitionMap map[string]*attestation.Definition, docChannel chan<- *processor.Document) error {
	sourceMap := map[string]bool{}
	var batchCoordinates []string
	var sourceInputs []string
	for _, definition := range definitionMap {
		if definition.Described.SourceLocation != nil {

			srcInput := helpers.SourceToSourceInput(definition.Described.SourceLocation.Type, definition.Described.SourceLocation.Namespace,
				definition.Described.SourceLocation.Name, &definition.Described.SourceLocation.Revision)

			nameID := helpers.SrcClientKey(srcInput).NameId

			if _, ok := sourceMap[nameID]; !ok {
				coordinate := &coordinates.Coordinate{
					CoordinateType: definition.Described.SourceLocation.Type,
					Provider:       definition.Described.SourceLocation.Provider,
					Namespace:      definition.Described.SourceLocation.Namespace,
					Name:           definition.Described.SourceLocation.Name,
					Revision:       definition.Described.SourceLocation.Revision,
				}
				sourceMap[nameID] = true
				sourceInputs = append(sourceInputs, nameID)
				batchCoordinates = append(batchCoordinates, coordinate.ToString())
			}

			definitionMap, err := GetDefinitions(ctx, sourceInputs, batchCoordinates)
			if err != nil {
				return fmt.Errorf("failed get source definition from clearly defined with error: %w", err)
			}

			if err := generateDocument(definitionMap, docChannel); err != nil {
				return fmt.Errorf("could not generate document from Clearly Defined results: %w", err)
			}
		}
	}
	return nil
}

func CreateAttestation(purl string, definition *attestation.Definition, currentTime time.Time) *attestation.ClearlyDefinedStatement {
	attestation := &attestation.ClearlyDefinedStatement{
		Statement: attestationv1.Statement{
			Type:          attestationv1.StatementTypeUri,
			PredicateType: attestation.PredicateClearlyDefined,
		},
		Predicate: attestation.ClearlyDefinedPredicate{
			Definition: *definition,
			Metadata: attestation.Metadata{
				ScannedOn: &currentTime,
			},
		},
	}

	subject := &attestationv1.ResourceDescriptor{Uri: purl}
	attestation.Statement.Subject = append(attestation.Statement.Subject, subject)

	return attestation
}
