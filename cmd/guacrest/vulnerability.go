//
// Copyright 2023 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"strconv"
	"strings"

	"github.com/guacsec/guac/pkg/assembler/helpers"

	"github.com/Khan/genqlient/graphql"
	"github.com/gin-gonic/gin"
	model "github.com/guacsec/guac/pkg/assembler/clients/generated"
	"github.com/guacsec/guac/pkg/misc/depversion"
)

// vulnerabilityHandler is a function that handles the vulnerability route for the REST API.
// It is responsible for parsing the query parameters from the request, creating a GraphQL client,
// and handling the vulnerability ID query or the no vulnerability ID query based on the parsed parameters.
// It returns a function that takes a gin.Context and performs the necessary operations to handle the request.
// This comment is for Swagger documentation
// @Summary Vulnerability handler
// @Description Handles the vulnerability based on the context
// @Tags Vulnerabilities
// @Accept  json
// @Produce  json
// @Param   purl   path    string     true  "PURL"
// @Success      200  {object}  Response
// @Failure      400  {object}  HTTPError
// @Failure      404  {object}  HTTPError
// @Failure      500  {object}  HTTPError
// @Router /vuln/{purl} [get]
func vulnerabilityHandler(ctx context.Context) func(c *gin.Context) {
	return func(c *gin.Context) {
		vulnID, graphqlEndpoint, searchDepth, pathsToReturn, err := parseQueryParameters(c)
		if err != nil {
			c.JSON(http.StatusBadRequest, HTTPError{http.StatusBadRequest, fmt.Sprintf("error parsing query parameters: %v", err)})
			return
		}

		httpClient := &http.Client{Timeout: httpTimeout}
		gqlclient := graphql.NewClient(graphqlEndpoint, httpClient)

		purl := strings.TrimLeft(c.Param("purl"), "/") // Retrieve and trim the purl from the URL parameter

		// Convert package URL to package input
		pkgInput, err := helpers.PurlToPkg(purl)
		if err != nil {
			c.JSON(http.StatusBadRequest, HTTPError{http.StatusBadRequest, "invalid purl"})
			return
		}

		pkgFilter := createPackageFilter(pkgInput)

		// Query for the package
		pkgResponse, err := model.Packages(ctx, gqlclient, *pkgFilter)
		if err != nil {
			c.JSON(http.StatusInternalServerError, HTTPError{http.StatusInternalServerError, fmt.Sprintf("error querying package: %v", err)})
			return
		}

		if len(pkgResponse.Packages) != 1 {
			c.JSON(http.StatusNotFound, HTTPError{http.StatusNotFound, "no package found for the given hash"})
			return
		}

		if vulnID != "" {
			handleVulnerabilityIDQuery(ctx, c, gqlclient, vulnID, pkgResponse, searchDepth, pathsToReturn)
		} else {
			handleNoVulnerabilityIDQuery(ctx, c, gqlclient, pkgResponse, searchDepth)
		}
	}
}

// parseQueryParameters is a function that parses the query parameters from the request.
// It extracts the vulnerability ID, search depth, and number of paths to return from the request.
// It returns the parsed parameters and an error if any of the parameters are invalid.
func parseQueryParameters(c *gin.Context) (string, string, int, int, error) {
	vulnID := c.Query("vuln_id")

	graphqlEndpoint := c.Query("gql_addr")

	if graphqlEndpoint == "" {
		graphqlEndpoint = gqlDefaultServerURL
	}

	searchDepthString := c.Query("search_depth")
	if searchDepthString == "" {
		return "", "", 0, 0, errors.New("empty search depth")
	}
	searchDepth, err := strconv.Atoi(searchDepthString)
	if err != nil && searchDepthString != "" {
		return "", "", 0, 0, errors.New("invalid search depth")
	}

	pathsToReturnString := c.Query("num_path")
	if vulnID != "" && pathsToReturnString == "" {
		return "", "", 0, 0, errors.New("empty number of paths even though vuln_id is given")
	}
	pathsToReturn, err := strconv.Atoi(pathsToReturnString)
	if err != nil && pathsToReturnString != "" {
		return "", "", 0, 0, errors.New("invalid number of paths")
	}

	return vulnID, graphqlEndpoint, searchDepth, pathsToReturn, nil
}

// handleVulnerabilityIDQuery is a function that handles the vulnerability ID query.
// It queries for vulnerabilities based on the vulnerability ID and handles the response.
// It takes a context, a gin.Context, a GraphQL client, a vulnerability ID, a package response, a search depth, and a number of paths to return.
// It does not return anything, but it does output a gin context in the form of a string.
func handleVulnerabilityIDQuery(ctx context.Context, c *gin.Context, gqlclient graphql.Client, vulnID string, pkgResponse *model.PackagesResponse, searchDepth, pathsToReturn int) {
	vulnResponse, err := model.Vulnerabilities(ctx, gqlclient, model.VulnerabilitySpec{VulnerabilityID: &vulnID})
	if err != nil {
		c.JSON(http.StatusInternalServerError, HTTPError{http.StatusInternalServerError, fmt.Sprintf("error querying for vulnerabilities: %v", err)})
		return
	}

	var path []string

	if len(vulnResponse.Vulnerabilities) > 0 {
		path, err = QueryVulnsViaVulnNodeNeighbors(ctx, gqlclient, pkgResponse, vulnResponse.Vulnerabilities, model.EdgeVulnerabilityCertifyVuln, searchDepth, pathsToReturn)

		if err != nil {
			c.JSON(http.StatusInternalServerError, HTTPError{http.StatusInternalServerError, fmt.Sprintf("error querying vulnerabilities via node neighbors: %v", err)})
			return
		}
	}

	if len(path) > 0 {
		response := Response{
			NeighborsData: vulnResponse.Vulnerabilities,
			VisualizerURL: fmt.Sprintf("http://localhost:3000/?path=%v", strings.Join(removeDuplicateValuesFromPath(path), `,`)),
		}
		c.IndentedJSON(200, response)
	} else {
		c.JSON(http.StatusNotFound, HTTPError{http.StatusNotFound, "no path to vulnerability ID found"})
		return
	}
}

// handleNoVulnerabilityIDQuery is a function that handles the case where no vulnerability ID is provided in the query.
// It queries for vulnerabilities based on the package response and the search depth.
// It takes a context, a gin.Context, a GraphQL client, a package response, and a search depth.
// It does not return anything, but it does output a gin context in the form of a string.
func handleNoVulnerabilityIDQuery(ctx context.Context, c *gin.Context, gqlclient graphql.Client, pkgResponse *model.PackagesResponse, searchDepth int) {
	path, res := []string{}, []*Neighbors{}

	if pkgResponse.Packages[0].Type != guacType {
		vulnPath, neighbors, err := queryVulnsViaPackageNeighbors(ctx, gqlclient, pkgResponse.Packages[0].Namespaces[0].Names[0].Versions[0].Id, []model.Edge{model.EdgePackageCertifyVuln, model.EdgePackageCertifyVexStatement})
		if err != nil {
			c.JSON(http.StatusInternalServerError, HTTPError{http.StatusInternalServerError, fmt.Sprintf("error querying package neighbors: %v", err)})
			return
		}

		path = append(path, vulnPath...)
		res = append(res, neighbors...)
	}

	depVulnPath, depVulnNeighbors, err := searchDependencyPackages(ctx, gqlclient, pkgResponse.Packages[0].Namespaces[0].Names[0].Versions[0].Id, searchDepth)
	if err != nil {
		c.JSON(http.StatusInternalServerError, HTTPError{http.StatusInternalServerError, fmt.Sprintf("error searching dependency packages: %v", err)})
	}
	path = append(path, depVulnPath...)
	res = append(res, depVulnNeighbors...)

	if len(path) > 0 {
		path = append([]string{pkgResponse.Packages[0].Namespaces[0].Names[0].Versions[0].Id,
			pkgResponse.Packages[0].Namespaces[0].Names[0].Id, pkgResponse.Packages[0].Namespaces[0].Id,
			pkgResponse.Packages[0].Id}, path...)

		response := Response{
			NeighborsData: res,
			VisualizerURL: fmt.Sprintf("http://localhost:3000/?path=%v", strings.Join(removeDuplicateValuesFromPath(path), `,`)),
		}
		c.IndentedJSON(200, response)
	} else {
		c.JSON(http.StatusNotFound, HTTPError{http.StatusNotFound, "no path to vulnerabilities found"})
	}
}

// QueryVulnsViaVulnNodeNeighbors is a function that queries for vulnerabilities via node neighbors.
// This function traverses through the graph with searchDependencyPackagesReverse.
// It takes a context, a GraphQL client, a package response, a list of vulnerabilities, an edge type, a search depth, and a number of paths to return.
// It returns a list of paths to the vulnerabilities and an error if the query fails.
func QueryVulnsViaVulnNodeNeighbors(ctx context.Context, gqlclient graphql.Client, topPkgResponse *model.PackagesResponse, vulnerabilitiesResponses []model.VulnerabilitiesVulnerabilitiesVulnerability, edgeType model.Edge, depth, pathsToReturn int) ([]string, error) {
	type vulnNeighbor struct {
		node model.NeighborsNeighborsNode
		id   string
	}

	var path []string
	vulnNodeNeighborResponses := []vulnNeighbor{}

	for _, vulnerabilitiesResponse := range vulnerabilitiesResponses {
		for _, vulnerabilityNodeID := range vulnerabilitiesResponse.VulnerabilityIDs {
			vulnNodeNeighborResponse, err := model.Neighbors(ctx, gqlclient, vulnerabilityNodeID.Id, []model.Edge{edgeType})

			if err != nil {
				return nil, fmt.Errorf("error querying neighbor for vulnerability: %w", err)
			}

			for _, neighbor := range vulnNodeNeighborResponse.Neighbors {
				vulnNodeNeighborResponses = append(vulnNodeNeighborResponses, vulnNeighbor{neighbor, vulnerabilityNodeID.Id})
			}
		}
	}

	certifyVulnFound := false
	numberOfPaths := 0
	for _, neighbor := range vulnNodeNeighborResponses {
		if certifyVuln, ok := neighbor.node.(*model.NeighborsNeighborsCertifyVuln); ok {
			certifyVulnFound = true
			pkgPath, err := searchDependencyPackagesReverse(ctx, gqlclient, topPkgResponse.Packages[0].Namespaces[0].Names[0].Versions[0].Id, certifyVuln.Package.Namespaces[0].Names[0].Versions[0].Id, depth)
			if err != nil {
				return nil, fmt.Errorf("error searching dependency packages match: %w", err)
			}
			if len(pkgPath) > 0 {
				fullVulnPath := append([]string{neighbor.id, certifyVuln.Id,
					certifyVuln.Package.Namespaces[0].Names[0].Versions[0].Id,
					certifyVuln.Package.Namespaces[0].Names[0].Id, certifyVuln.Package.Namespaces[0].Id,
					certifyVuln.Package.Id}, pkgPath...)
				path = append(path, fullVulnPath...)
				numberOfPaths += 1
			}
			if pathsToReturn != 0 && numberOfPaths == pathsToReturn {
				return path, nil
			}
		}
	}
	if !certifyVulnFound {
		return nil, fmt.Errorf("error certify vulnerability node not found, incomplete data. Please ensure certifier has run")
	}
	return path, nil
}

// queryVulnsViaPackageNeighbors queries vulnerabilities via package neighbors.
// It takes in a context, a graphql client, a package version ID and a slice of edge types.
// It returns a slice of strings, a slice of pointers to Neighbors and an error.
// The function queries the neighbors for vulnerabilities and checks if a certify vulnerability node is found.
// If not, it returns an error. If yes, it appends the certify vulnerability to the result slice and the vulnerability IDs to the path slice.
// It also checks for certify VEX statements and appends them to the result slice and their IDs to the path slice.
// The function returns the path slice, the result slice and nil if no errors occurred.
func queryVulnsViaPackageNeighbors(ctx context.Context, gqlclient graphql.Client, pkgVersionID string, edgeTypes []model.Edge) ([]string, []*Neighbors, error) {
	var path []string
	var res []*Neighbors
	pkgVersionNeighborResponse, err := model.Neighbors(ctx, gqlclient, pkgVersionID, edgeTypes)
	if err != nil {
		return nil, nil, fmt.Errorf("error querying neighbor for vulnerability: %w", err)
	}
	certifyVulnFound := false
	for _, neighbor := range pkgVersionNeighborResponse.Neighbors {
		if certifyVuln, ok := neighbor.(*model.NeighborsNeighborsCertifyVuln); ok {
			certifyVulnFound = true
			if certifyVuln.Vulnerability.Type != noVulnType {
				res = append(res, &Neighbors{CertifyVulns: []*model.NeighborsNeighborsCertifyVuln{certifyVuln}})
				for _, vuln := range certifyVuln.Vulnerability.VulnerabilityIDs {
					path = append(path, []string{vuln.Id, certifyVuln.Id,
						certifyVuln.Package.Namespaces[0].Names[0].Versions[0].Id,
						certifyVuln.Package.Namespaces[0].Names[0].Id, certifyVuln.Package.Namespaces[0].Id,
						certifyVuln.Package.Id}...)
				}
			}
		}

		if certifyVex, ok := neighbor.(*model.NeighborsNeighborsCertifyVEXStatement); ok {
			res = append(res, &Neighbors{VexLinks: []*model.NeighborsNeighborsCertifyVEXStatement{certifyVex}})
			for _, vuln := range certifyVex.Vulnerability.VulnerabilityIDs {
				path = append(path, certifyVex.Id, vuln.Id)
			}
			path = append(path, vexSubjectIds(certifyVex.Subject)...)
		}

	}
	if !certifyVulnFound {
		return nil, nil, fmt.Errorf("error certify vulnerability node not found, incomplete data. Please ensure certifier has run")
	}
	return path, res, nil
}

// vexSubjectIds returns a slice of strings containing the IDs of the subject of a VEX statement.
// It takes in a model.AllCertifyVEXStatementSubjectPackageOrArtifact and checks its type.
// If it's a model.AllCertifyVEXStatementSubjectArtifact, it returns a slice containing its ID.
// If it's a model.AllCertifyVEXStatementSubjectPackage, it returns a slice containing its ID and the IDs of its namespaces, names and versions.
// If it's neither, it returns an empty slice.
func vexSubjectIds(s model.AllCertifyVEXStatementSubjectPackageOrArtifact) []string {
	switch v := s.(type) {
	case *model.AllCertifyVEXStatementSubjectArtifact:
		return []string{v.Id}
	case *model.AllCertifyVEXStatementSubjectPackage:
		return []string{
			v.Id,
			v.Namespaces[0].Id,
			v.Namespaces[0].Names[0].Id,
			v.Namespaces[0].Names[0].Versions[0].Id}
	default:
		return []string{}
	}
}

// searchDependencyPackages is a function that performs a breadth-first search (BFS) on the dependency graph.
// It starts from a given package (topPkgID) and traverses the graph in the direction from dependencies to dependents.
// The function stops when it reaches a specified depth (maxLength).
// The function returns a path from the topPkgID to the deepest package.
// The path is represented as a slice of strings, where each string is an ID of a package in the path.
// The function also collects the table rows of all visited packages in the res slice.
// The function uses a queue to implement the BFS algorithm and a map (nodeMap) to keep track of visited packages and their properties.
func searchDependencyPackages(ctx context.Context, gqlclient graphql.Client, topPkgID string, maxLength int) ([]string, []*Neighbors, error) {
	var path []string
	var res []*Neighbors
	queue := make([]string, 0) // the queue of nodes in bfs
	type dfsNode struct {
		expanded bool // true once all node neighbors are added to queue
		parent   string
		depth    int
	}
	nodeMap := map[string]dfsNode{}

	nodeMap[topPkgID] = dfsNode{}
	queue = append(queue, topPkgID)

	for len(queue) > 0 {
		now := queue[0]
		queue = queue[1:]
		nowNode := nodeMap[now]

		// Stop if the maximum depth is reached
		if maxLength != 0 && nowNode.depth >= maxLength {
			break
		}

		// Query the neighbors of the current node
		isDependencyNeighborResponses, err := model.Neighbors(ctx, gqlclient, now, []model.Edge{model.EdgePackageIsDependency})
		if err != nil {
			return nil, nil, fmt.Errorf("failed getting package parent:%w", err)
		}
		for _, neighbor := range isDependencyNeighborResponses.Neighbors {
			if isDependency, ok := neighbor.(*model.NeighborsNeighborsIsDependency); ok {
				if isDependency.DependencyPackage.Type == guacType {
					continue
				}

				depPkgFilter := &model.PkgSpec{
					Type:      &isDependency.DependencyPackage.Type,
					Namespace: &isDependency.DependencyPackage.Namespaces[0].Namespace,
					Name:      &isDependency.DependencyPackage.Namespaces[0].Names[0].Name,
				}

				depPkgResponse, err := model.Packages(ctx, gqlclient, *depPkgFilter)
				if err != nil {
					return nil, nil, fmt.Errorf("error querying for dependent package: %w", err)
				}

				// Create a map and a slice for the versions of the dependency package
				depPkgVersionsMap := map[string]string{}
				depPkgVersions := []string{}
				for _, depPkgVersion := range depPkgResponse.Packages[0].Namespaces[0].Names[0].Versions {
					depPkgVersions = append(depPkgVersions, depPkgVersion.Version)
					depPkgVersionsMap[depPkgVersion.Version] = depPkgVersion.Id
				}

				// Determine which versions of the dependency package match the version range
				matchingDepPkgVersions, err := depversion.WhichVersionMatches(depPkgVersions, isDependency.VersionRange)
				if err != nil {
					// TODO(jeffmendoza): depversion is not handling all/new possible
					// version ranges from deps.dev. Continue here to report possible
					// vulns even if some paths cannot be followed.
					matchingDepPkgVersions = nil
					//return nil, nil, fmt.Errorf("error determining dependent version matches: %w", err)
				}

				for matchingDepPkgVersion := range matchingDepPkgVersions {
					matchingDepPkgVersionID := depPkgVersionsMap[matchingDepPkgVersion]
					vulnPath, foundVulnTableRow, err := queryVulnsViaPackageNeighbors(ctx, gqlclient, matchingDepPkgVersionID, []model.Edge{model.EdgePackageCertifyVuln, model.EdgePackageCertifyVexStatement})
					if err != nil {
						return nil, nil, fmt.Errorf("error querying neighbor: %w", err)
					}
					// If vulnerabilities are found, add them to the path and result slices
					if len(vulnPath) > 0 {
						path = append(path, isDependency.Id, matchingDepPkgVersionID,
							depPkgResponse.Packages[0].Namespaces[0].Names[0].Id, depPkgResponse.Packages[0].Namespaces[0].Id,
							depPkgResponse.Packages[0].Id)
						path = append(path, vulnPath...)
						res = append(res, foundVulnTableRow...)
					}

					// Check if the matching version has been visited before
					dfsN, seen := nodeMap[matchingDepPkgVersionID]
					if !seen {
						dfsN = dfsNode{
							parent: now,
							depth:  nowNode.depth + 1,
						}
						nodeMap[matchingDepPkgVersionID] = dfsN
					}
					// If the matching version hasn't been expanded yet, add it to the queue
					if !dfsN.expanded {
						queue = append(queue, matchingDepPkgVersionID)
					}
				}
			}
		}

		// Mark the current node as expanded
		nowNode.expanded = true
		nodeMap[now] = nowNode
	}

	return path, res, nil
}

// searchDependencyPackagesReverse performs a breadth-first search (BFS) on the dependency graph.
// It starts from a given package (searchPkgID) and traverses the graph in reverse direction (from dependents to dependencies).
// The function stops either when it reaches a specified package (topPkgID) or when it reaches a specified depth (maxLength).
// The function returns a path from the searchPkgID to the topPkgID (or to the deepest package if topPkgID is not specified).
// The path is represented as a slice of strings, where each string is an ID of a package in the path.
// If the function cannot find a path to the topPkgID, it returns an error.
// The function also collects the IDs of all visited packages in the collectedIDs slice.
// The function uses a queue to implement the BFS algorithm and a map (nodeMap) to keep track of visited packages and their properties.
func searchDependencyPackagesReverse(ctx context.Context, gqlclient graphql.Client, topPkgID string, searchPkgID string, maxLength int) ([]string, error) {
	var path []string
	var collectedIDs []string
	queue := make([]string, 0) // the queue of nodes in bfs
	type dfsNode struct {
		expanded     bool // true once all node neighbors are added to queue
		parent       string
		isDependency *model.NeighborsNeighborsIsDependency
		depth        int
	}
	nodeMap := map[string]dfsNode{}

	// Add the starting package to the nodeMap and queue
	nodeMap[searchPkgID] = dfsNode{}
	queue = append(queue, searchPkgID)
	collectedIDs = append(collectedIDs, searchPkgID)

	found := false
	for len(queue) > 0 {
		now := queue[0]
		queue = queue[1:]
		nowNode := nodeMap[now]

		// If the current package is the topPkgID, set found to true and break the loop
		if topPkgID != "" {
			if now == topPkgID {
				found = true
				break
			}
		}

		// If a maxLength is specified and the depth of the current package is greater or equal to maxLength, break the loop
		if maxLength != 0 && nowNode.depth >= maxLength {
			break
		}

		pkgNameNeighborResponses, err := model.Neighbors(ctx, gqlclient, now, []model.Edge{})
		if err != nil {
			return nil, fmt.Errorf("failed getting package parent:%v", err)
		}

		for _, neighbor := range pkgNameNeighborResponses.Neighbors {
			if pkgName, ok := neighbor.(*model.NeighborsNeighborsPackage); ok {
				// If the package has no namespaces, skip it
				if len(pkgName.Namespaces) == 0 {
					continue
				}
				isDependencyNeighborResponses, err := model.Neighbors(ctx, gqlclient, pkgName.Namespaces[0].Names[0].Id, []model.Edge{model.EdgePackageIsDependency})
				if err != nil {
					return nil, fmt.Errorf("failed getting package parent:%v", err)
				}

				// Iterate over the dependencies of the package
				for _, neighbor := range isDependencyNeighborResponses.Neighbors {
					if isDependency, ok := neighbor.(*model.NeighborsNeighborsIsDependency); ok && now != isDependency.Package.Namespaces[0].Names[0].Versions[0].Id {
						dfsN, seen := nodeMap[isDependency.Package.Namespaces[0].Names[0].Versions[0].Id]
						if !seen {
							dfsN = dfsNode{
								parent:       now,
								isDependency: isDependency,
								depth:        nowNode.depth + 1,
							}
							nodeMap[isDependency.Package.Namespaces[0].Names[0].Versions[0].Id] = dfsN
						}

						// If the dependency has not been expanded, add it to the queue
						if !dfsN.expanded {
							queue = append(queue, isDependency.Package.Namespaces[0].Names[0].Versions[0].Id)
							collectedIDs = append(collectedIDs, isDependency.Package.Namespaces[0].Names[0].Versions[0].Id)
						}
					}
				}
			}

			// If the neighbor is a dependency and it's not the current package, add it to the nodeMap and queue
			if isDependency, ok := neighbor.(*model.NeighborsNeighborsIsDependency); ok && now != isDependency.Package.Namespaces[0].Names[0].Versions[0].Id {
				dfsN, seen := nodeMap[isDependency.Package.Namespaces[0].Names[0].Versions[0].Id]
				if !seen {
					dfsN = dfsNode{
						parent:       now,
						isDependency: isDependency,
						depth:        nowNode.depth + 1,
					}
					nodeMap[isDependency.Package.Namespaces[0].Names[0].Versions[0].Id] = dfsN
				}
				if !dfsN.expanded {
					queue = append(queue, isDependency.Package.Namespaces[0].Names[0].Versions[0].Id)
					collectedIDs = append(collectedIDs, isDependency.Package.Namespaces[0].Names[0].Versions[0].Id)
				}
			}

		}

		// Mark the current node as expanded
		nowNode.expanded = true
		nodeMap[now] = nowNode
	}

	if topPkgID != "" && !found {
		return nil, fmt.Errorf("no path found up to specified length")
	}

	var now string
	if topPkgID != "" {
		// If a topPkgID is specified, build the path from topPkgID to searchPkgID
		now = topPkgID
		for now != searchPkgID {
			path = append(path, nodeMap[now].isDependency.Id, nodeMap[now].isDependency.DependencyPackage.Namespaces[0].Names[0].Id,
				nodeMap[now].isDependency.DependencyPackage.Namespaces[0].Id, nodeMap[now].isDependency.DependencyPackage.Id,
				nodeMap[now].isDependency.Package.Namespaces[0].Names[0].Versions[0].Id,
				nodeMap[now].isDependency.Package.Namespaces[0].Names[0].Id, nodeMap[now].isDependency.Package.Namespaces[0].Id,
				nodeMap[now].isDependency.Package.Id)
			now = nodeMap[now].parent
		}
		return path, nil
	} else {
		// If a topPkgID is not specified, build the path from the deepest package to searchPkgID
		for i := len(collectedIDs) - 1; i >= 0; i-- {
			if nodeMap[collectedIDs[i]].isDependency != nil {
				path = append(path, nodeMap[collectedIDs[i]].isDependency.Id, nodeMap[collectedIDs[i]].isDependency.DependencyPackage.Namespaces[0].Names[0].Id,
					nodeMap[collectedIDs[i]].isDependency.DependencyPackage.Namespaces[0].Id, nodeMap[collectedIDs[i]].isDependency.DependencyPackage.Id,
					nodeMap[collectedIDs[i]].isDependency.Package.Namespaces[0].Names[0].Versions[0].Id,
					nodeMap[collectedIDs[i]].isDependency.Package.Namespaces[0].Names[0].Id, nodeMap[collectedIDs[i]].isDependency.Package.Namespaces[0].Id,
					nodeMap[collectedIDs[i]].isDependency.Package.Id)
			}
		}
		return path, nil
	}
}
