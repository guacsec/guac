//
// Copyright 2023 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"strings"

	"github.com/Khan/genqlient/graphql"
	model "github.com/guacsec/guac/pkg/assembler/clients/generated"
	"github.com/guacsec/guac/pkg/assembler/helpers"
	"github.com/guacsec/guac/pkg/cli"
	"github.com/guacsec/guac/pkg/logging"
	"github.com/guacsec/guac/pkg/misc/depversion"
	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

const (
	guacType   string = "guac"
	noVulnType string = "novuln"
)

type queryOptions struct {
	// gql endpoint
	graphqlEndpoint string

	purl            string
	vulnerabilityID string
	depth           int
	pathsToReturn   int
}

var queryVulnCmd = &cobra.Command{
	Use:   "vuln [flags] purl",
	Short: "query if a package is affected by the specified vulnerability",
	Run: func(cmd *cobra.Command, args []string) {
		ctx := logging.WithLogger(context.Background())
		logger := logging.FromContext(ctx)

		opts, err := validateQueryVulnFlags(
			viper.GetString("gql-addr"),
			viper.GetString("vuln-id"),
			viper.GetInt("search-depth"),
			viper.GetInt("num-path"),
			args,
		)

		if err != nil {
			fmt.Printf("unable to validate flags: %v\n", err)
			_ = cmd.Help()
			os.Exit(1)
		}

		httpClient := http.Client{}
		gqlclient := graphql.NewClient(opts.graphqlEndpoint, &httpClient)

		t := table.NewWriter()
		tTemp := table.Table{}
		tTemp.Render()
		t.AppendHeader(rowHeader)

		pkgInput, err := helpers.PurlToPkg(opts.purl)
		if err != nil {
			logger.Fatalf("failed to parse PURL: %v", err)
		}

		pkgQualifierFilter := []model.PackageQualifierSpec{}
		for _, qualifier := range pkgInput.Qualifiers {
			pkgQualifierFilter = append(pkgQualifierFilter, model.PackageQualifierSpec{
				Key:   qualifier.Key,
				Value: &qualifier.Value,
			})
		}

		pkgFilter := &model.PkgSpec{
			Type:       &pkgInput.Type,
			Namespace:  pkgInput.Namespace,
			Name:       &pkgInput.Name,
			Version:    pkgInput.Version,
			Subpath:    pkgInput.Subpath,
			Qualifiers: pkgQualifierFilter,
		}
		pkgResponse, err := model.Packages(ctx, gqlclient, *pkgFilter)
		if err != nil {
			logger.Fatalf("error querying for package: %v", err)
		}
		if len(pkgResponse.Packages) != 1 {
			logger.Fatalf("failed to located package based on purl")
		}

		if opts.vulnerabilityID != "" {
			var tableRows []table.Row

			vulnResponse, err := model.Vulnerabilities(ctx, gqlclient, model.VulnerabilitySpec{VulnerabilityID: &opts.vulnerabilityID})
			if err != nil {
				logger.Fatalf("error querying for vulnerabilities: %v", err)
			}
			var path []string
			if len(vulnResponse.Vulnerabilities) > 0 {

				tableRows = append(tableRows, table.Row{vulnResponse.Vulnerabilities[0].Type, vulnResponse.Vulnerabilities[0].Id, "vulnerability ID: " + vulnResponse.Vulnerabilities[0].VulnerabilityIDs[0].VulnerabilityID})

				path, err = queryVulnsViaVulnNodeNeighbors(ctx, gqlclient, pkgResponse, vulnResponse.Vulnerabilities[0].VulnerabilityIDs[0].Id, model.EdgeVulnerabilityCertifyVuln, opts.depth, opts.pathsToReturn)
				if err != nil {
					logger.Fatalf("error querying neighbor: %v", err)
				}
			} else {
				fmt.Printf("Failed to identify vulnerability \n")
			}
			if len(path) > 0 {
				t.AppendRows(tableRows)
				fmt.Println(t.Render())
				fmt.Printf("Visualizer url: http://localhost:3000/?path=%v\n", strings.Join(removeDuplicateValuesFromPath(path), `,`))
			} else {
				fmt.Printf("No path to vulnerability ID found!\n")
			}
		} else {
			var path []string
			var tableRows []table.Row
			if pkgResponse.Packages[0].Type != guacType {
				vulnPath, pkgVulnTableRows, err := queryVulnsViaPackageNeighbors(ctx, gqlclient, pkgResponse.Packages[0].Namespaces[0].Names[0].Versions[0].Id, []model.Edge{model.EdgePackageCertifyVuln, model.EdgePackageCertifyVexStatement})
				if err != nil {
					logger.Fatalf("error querying neighbor: %v", err)
				}
				path = append(path, vulnPath...)
				tableRows = append(tableRows, pkgVulnTableRows...)
			}

			depVulnPath, depVulnTableRows, err := searchDependencyPackages(ctx, gqlclient, pkgResponse.Packages[0].Namespaces[0].Names[0].Versions[0].Id, opts.depth)
			if err != nil {
				logger.Fatalf("error searching dependency packages match: %v", err)
			}
			path = append(path, depVulnPath...)
			tableRows = append(tableRows, depVulnTableRows...)

			if len(path) > 0 {
				path = append([]string{pkgResponse.Packages[0].Namespaces[0].Names[0].Versions[0].Id,
					pkgResponse.Packages[0].Namespaces[0].Names[0].Id, pkgResponse.Packages[0].Namespaces[0].Id,
					pkgResponse.Packages[0].Id}, path...)
				t.AppendRows(tableRows)

				fmt.Println(t.Render())
				fmt.Printf("Visualizer url: http://localhost:3000/?path=%v\n", strings.Join(removeDuplicateValuesFromPath(path), `,`))
			} else {
				fmt.Printf("No path to vulnerabilities found!\n")
			}
		}
	},
}

func queryVulnsViaPackageNeighbors(ctx context.Context, gqlclient graphql.Client, pkgVersionID string, edgeTypes []model.Edge) ([]string, []table.Row, error) {
	var path []string
	var tableRows []table.Row
	pkgVersionNeighborResponse, err := model.Neighbors(ctx, gqlclient, pkgVersionID, edgeTypes)
	if err != nil {
		return nil, nil, fmt.Errorf("error querying neighbor for vulnerability: %w", err)
	}
	certifyVulnFound := false
	for _, neighbor := range pkgVersionNeighborResponse.Neighbors {
		if certifyVuln, ok := neighbor.(*model.NeighborsNeighborsCertifyVuln); ok {
			certifyVulnFound = true
			if certifyVuln.Vulnerability.Type != noVulnType {
				for _, vuln := range certifyVuln.Vulnerability.VulnerabilityIDs {
					tableRows = append(tableRows, table.Row{certifyVulnStr, certifyVuln.Id, "vulnerability ID: " + vuln.VulnerabilityID})
					path = append(path, []string{vuln.Id, certifyVuln.Id,
						certifyVuln.Package.Namespaces[0].Names[0].Versions[0].Id,
						certifyVuln.Package.Namespaces[0].Names[0].Id, certifyVuln.Package.Namespaces[0].Id,
						certifyVuln.Package.Id}...)
				}
			}
		}

		if certifyVex, ok := neighbor.(*model.NeighborsNeighborsCertifyVEXStatement); ok {
			for _, vuln := range certifyVex.Vulnerability.VulnerabilityIDs {
				tableRows = append(tableRows, table.Row{vexLinkStr, certifyVex.Id, "vulnerability ID: " + vuln.VulnerabilityID + ", Vex Status: " + string(certifyVex.Status) + ", Subject: " + vexSubjectString(certifyVex.Subject)})
				path = append(path, certifyVex.Id, vuln.Id)
			}
			path = append(path, vexSubjectIds(certifyVex.Subject)...)
		}

	}
	if !certifyVulnFound {
		return nil, nil, fmt.Errorf("error certify vulnerability node not found, incomplete data. Please ensure certifier has run")
	}
	return path, tableRows, nil
}

func vexSubjectString(s model.AllCertifyVEXStatementSubjectPackageOrArtifact) string {
	switch v := s.(type) {
	case *model.AllCertifyVEXStatementSubjectArtifact:
		return fmt.Sprintf("artifact (id:%v) %v:%v", v.Id, v.Algorithm, v.Digest)
	case *model.AllCertifyVEXStatementSubjectPackage:
		return fmt.Sprintf("package (id:%v) %v:%v/%v@%v",
			v.Id,
			v.Type,
			v.Namespaces[0].Namespace,
			v.Namespaces[0].Names[0].Name,
			v.Namespaces[0].Names[0].Versions[0].Version)
	default:
		return "unknown subject"
	}
}
func vexSubjectIds(s model.AllCertifyVEXStatementSubjectPackageOrArtifact) []string {
	switch v := s.(type) {
	case *model.AllCertifyVEXStatementSubjectArtifact:
		return []string{v.Id}
	case *model.AllCertifyVEXStatementSubjectPackage:
		return []string{
			v.Id,
			v.Namespaces[0].Id,
			v.Namespaces[0].Names[0].Id,
			v.Namespaces[0].Names[0].Versions[0].Id}
	default:
		return []string{}
	}
}

func searchDependencyPackages(ctx context.Context, gqlclient graphql.Client, topPkgID string, maxLength int) ([]string, []table.Row, error) {
	var path []string
	var tableRows []table.Row
	queue := make([]string, 0) // the queue of nodes in bfs
	type dfsNode struct {
		expanded bool // true once all node neighbors are added to queue
		parent   string
		depth    int
	}
	nodeMap := map[string]dfsNode{}

	nodeMap[topPkgID] = dfsNode{}
	queue = append(queue, topPkgID)

	for len(queue) > 0 {
		now := queue[0]
		queue = queue[1:]
		nowNode := nodeMap[now]

		if maxLength != 0 && nowNode.depth >= maxLength {
			break
		}

		isDependencyNeighborResponses, err := model.Neighbors(ctx, gqlclient, now, []model.Edge{model.EdgePackageIsDependency})
		if err != nil {
			return nil, nil, fmt.Errorf("failed getting package parent:%w", err)
		}
		for _, neighbor := range isDependencyNeighborResponses.Neighbors {
			if isDependency, ok := neighbor.(*model.NeighborsNeighborsIsDependency); ok {
				if isDependency.DependencyPackage.Type == guacType {
					continue
				}

				depPkgFilter := &model.PkgSpec{
					Type:      &isDependency.DependencyPackage.Type,
					Namespace: &isDependency.DependencyPackage.Namespaces[0].Namespace,
					Name:      &isDependency.DependencyPackage.Namespaces[0].Names[0].Name,
				}

				depPkgResponse, err := model.Packages(ctx, gqlclient, *depPkgFilter)
				if err != nil {
					return nil, nil, fmt.Errorf("error querying for dependent package: %w", err)
				}

				depPkgVersionsMap := map[string]string{}
				depPkgVersions := []string{}
				for _, depPkgVersion := range depPkgResponse.Packages[0].Namespaces[0].Names[0].Versions {
					depPkgVersions = append(depPkgVersions, depPkgVersion.Version)
					depPkgVersionsMap[depPkgVersion.Version] = depPkgVersion.Id
				}

				matchingDepPkgVersions, err := depversion.WhichVersionMatches(depPkgVersions, isDependency.VersionRange)
				if err != nil {
					// TODO(jeffmendoza): depversion is not handling all/new possible
					// version ranges from deps.dev. Continue here to report possible
					// vulns even if some paths cannot be followed.
					matchingDepPkgVersions = nil
					//return nil, nil, fmt.Errorf("error determining dependent version matches: %w", err)
				}

				for matchingDepPkgVersion := range matchingDepPkgVersions {
					matchingDepPkgVersionID := depPkgVersionsMap[matchingDepPkgVersion]
					vulnPath, foundVulnTableRow, err := queryVulnsViaPackageNeighbors(ctx, gqlclient, matchingDepPkgVersionID, []model.Edge{model.EdgePackageCertifyVuln, model.EdgePackageCertifyVexStatement})
					if err != nil {
						return nil, nil, fmt.Errorf("error querying neighbor: %w", err)
					}
					if len(vulnPath) > 0 {
						path = append(path, isDependency.Id, matchingDepPkgVersionID,
							depPkgResponse.Packages[0].Namespaces[0].Names[0].Id, depPkgResponse.Packages[0].Namespaces[0].Id,
							depPkgResponse.Packages[0].Id)
						path = append(path, vulnPath...)
						tableRows = append(tableRows, foundVulnTableRow...)
					}

					dfsN, seen := nodeMap[matchingDepPkgVersionID]
					if !seen {
						dfsN = dfsNode{
							parent: now,
							depth:  nowNode.depth + 1,
						}
						nodeMap[matchingDepPkgVersionID] = dfsN
					}
					if !dfsN.expanded {
						queue = append(queue, matchingDepPkgVersionID)
					}
				}
			}
		}

		nowNode.expanded = true
		nodeMap[now] = nowNode
	}

	return path, tableRows, nil
}

func queryVulnsViaVulnNodeNeighbors(ctx context.Context, gqlclient graphql.Client, topPkgResponse *model.PackagesResponse, vulnerabilityNodeID string, edgeType model.Edge, depth, pathsToReturn int) ([]string, error) {
	var path []string
	vulnNodeNeighborResponse, err := model.Neighbors(ctx, gqlclient, vulnerabilityNodeID, []model.Edge{edgeType})
	if err != nil {
		return nil, fmt.Errorf("error querying neighbor for vulnerability: %w", err)
	}
	certifyVulnFound := false
	numberOfPaths := 0
	for _, neighbor := range vulnNodeNeighborResponse.Neighbors {
		if certifyVuln, ok := neighbor.(*model.NeighborsNeighborsCertifyVuln); ok {
			certifyVulnFound = true
			pkgPath, err := searchDependencyPackagesReverse(ctx, gqlclient, topPkgResponse.Packages[0].Namespaces[0].Names[0].Versions[0].Id, certifyVuln.Package.Namespaces[0].Names[0].Versions[0].Id, depth)
			if err != nil {
				return nil, fmt.Errorf("error searching dependency packages match: %w", err)
			}
			if len(pkgPath) > 0 {
				fullVulnPath := append([]string{vulnerabilityNodeID, certifyVuln.Id,
					certifyVuln.Package.Namespaces[0].Names[0].Versions[0].Id,
					certifyVuln.Package.Namespaces[0].Names[0].Id, certifyVuln.Package.Namespaces[0].Id,
					certifyVuln.Package.Id}, pkgPath...)
				path = append(path, fullVulnPath...)
				numberOfPaths += 1
			}
			if pathsToReturn != 0 && numberOfPaths == pathsToReturn {
				return path, nil
			}
		}
	}
	if !certifyVulnFound {
		return nil, fmt.Errorf("error certify vulnerability node not found, incomplete data. Please ensure certifier has run")
	}
	return path, nil
}

func searchDependencyPackagesReverse(ctx context.Context, gqlclient graphql.Client, topPkgID string, searchPkgID string, maxLength int) ([]string, error) {
	var path []string
	var collectedIDs []string
	queue := make([]string, 0) // the queue of nodes in bfs
	type dfsNode struct {
		expanded     bool // true once all node neighbors are added to queue
		parent       string
		isDependency *model.NeighborsNeighborsIsDependency
		depth        int
	}
	nodeMap := map[string]dfsNode{}

	nodeMap[searchPkgID] = dfsNode{}
	queue = append(queue, searchPkgID)
	collectedIDs = append(collectedIDs, searchPkgID)

	found := false
	for len(queue) > 0 {
		now := queue[0]
		queue = queue[1:]
		nowNode := nodeMap[now]

		if topPkgID != "" {
			if now == topPkgID {
				found = true
				break
			}
		}

		if maxLength != 0 && nowNode.depth >= maxLength {
			break
		}

		pkgNameNeighborResponses, err := model.Neighbors(ctx, gqlclient, now, []model.Edge{})
		if err != nil {
			return nil, fmt.Errorf("failed getting package parent:%v", err)
		}

		for _, neighbor := range pkgNameNeighborResponses.Neighbors {
			if pkgName, ok := neighbor.(*model.NeighborsNeighborsPackage); ok {
				if len(pkgName.Namespaces) == 0 {
					continue
				}
				isDependencyNeighborResponses, err := model.Neighbors(ctx, gqlclient, pkgName.Namespaces[0].Names[0].Id, []model.Edge{model.EdgePackageIsDependency})
				if err != nil {
					return nil, fmt.Errorf("failed getting package parent:%v", err)
				}
				for _, neighbor := range isDependencyNeighborResponses.Neighbors {
					if isDependency, ok := neighbor.(*model.NeighborsNeighborsIsDependency); ok && now != isDependency.Package.Namespaces[0].Names[0].Versions[0].Id {
						dfsN, seen := nodeMap[isDependency.Package.Namespaces[0].Names[0].Versions[0].Id]
						if !seen {
							dfsN = dfsNode{
								parent:       now,
								isDependency: isDependency,
								depth:        nowNode.depth + 1,
							}
							nodeMap[isDependency.Package.Namespaces[0].Names[0].Versions[0].Id] = dfsN
						}
						if !dfsN.expanded {
							queue = append(queue, isDependency.Package.Namespaces[0].Names[0].Versions[0].Id)
							collectedIDs = append(collectedIDs, isDependency.Package.Namespaces[0].Names[0].Versions[0].Id)
						}
					}
				}
			}
			if isDependency, ok := neighbor.(*model.NeighborsNeighborsIsDependency); ok && now != isDependency.Package.Namespaces[0].Names[0].Versions[0].Id {
				dfsN, seen := nodeMap[isDependency.Package.Namespaces[0].Names[0].Versions[0].Id]
				if !seen {
					dfsN = dfsNode{
						parent:       now,
						isDependency: isDependency,
						depth:        nowNode.depth + 1,
					}
					nodeMap[isDependency.Package.Namespaces[0].Names[0].Versions[0].Id] = dfsN
				}
				if !dfsN.expanded {
					queue = append(queue, isDependency.Package.Namespaces[0].Names[0].Versions[0].Id)
					collectedIDs = append(collectedIDs, isDependency.Package.Namespaces[0].Names[0].Versions[0].Id)
				}
			}

		}

		nowNode.expanded = true
		nodeMap[now] = nowNode
	}

	if topPkgID != "" && !found {
		return nil, fmt.Errorf("no path found up to specified length")
	}

	var now string
	if topPkgID != "" {
		now = topPkgID
		for now != searchPkgID {
			path = append(path, nodeMap[now].isDependency.Id, nodeMap[now].isDependency.DependencyPackage.Namespaces[0].Names[0].Id,
				nodeMap[now].isDependency.DependencyPackage.Namespaces[0].Id, nodeMap[now].isDependency.DependencyPackage.Id,
				nodeMap[now].isDependency.Package.Namespaces[0].Names[0].Versions[0].Id,
				nodeMap[now].isDependency.Package.Namespaces[0].Names[0].Id, nodeMap[now].isDependency.Package.Namespaces[0].Id,
				nodeMap[now].isDependency.Package.Id)
			now = nodeMap[now].parent
		}
		return path, nil
	} else {
		for i := len(collectedIDs) - 1; i >= 0; i-- {
			if nodeMap[collectedIDs[i]].isDependency != nil {
				path = append(path, nodeMap[collectedIDs[i]].isDependency.Id, nodeMap[collectedIDs[i]].isDependency.DependencyPackage.Namespaces[0].Names[0].Id,
					nodeMap[collectedIDs[i]].isDependency.DependencyPackage.Namespaces[0].Id, nodeMap[collectedIDs[i]].isDependency.DependencyPackage.Id,
					nodeMap[collectedIDs[i]].isDependency.Package.Namespaces[0].Names[0].Versions[0].Id,
					nodeMap[collectedIDs[i]].isDependency.Package.Namespaces[0].Names[0].Id, nodeMap[collectedIDs[i]].isDependency.Package.Namespaces[0].Id,
					nodeMap[collectedIDs[i]].isDependency.Package.Id)
			}
		}
		return path, nil
	}
}

func removeDuplicateValuesFromPath(path []string) []string {
	keys := make(map[string]bool)
	var list []string

	for _, entry := range path {
		if _, value := keys[entry]; !value {
			keys[entry] = true
			list = append(list, entry)
		}
	}
	return list
}

func validateQueryVulnFlags(graphqlEndpoint, vulnID string, depth, path int, args []string) (queryOptions, error) {
	var opts queryOptions
	opts.graphqlEndpoint = graphqlEndpoint
	opts.vulnerabilityID = vulnID
	opts.depth = depth
	opts.pathsToReturn = path

	if len(args) > 0 {
		opts.purl = args[0]
	} else {
		return opts, fmt.Errorf("expected subject input to be purl")
	}
	return opts, nil
}

func init() {
	set, err := cli.BuildFlags([]string{"vuln-id", "search-depth", "num-path"})
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to setup flag: %v", err)
		os.Exit(1)
	}
	queryVulnCmd.Flags().AddFlagSet(set)
	if err := viper.BindPFlags(queryVulnCmd.Flags()); err != nil {
		fmt.Fprintf(os.Stderr, "failed to bind flags: %v", err)
		os.Exit(1)
	}

	queryCmd.AddCommand(queryVulnCmd)
}
