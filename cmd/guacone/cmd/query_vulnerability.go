//
// Copyright 2023 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"strings"

	"github.com/Khan/genqlient/graphql"
	"github.com/guacsec/guac/internal/testing/ptrfrom"
	model "github.com/guacsec/guac/pkg/assembler/clients/generated"
	"github.com/guacsec/guac/pkg/assembler/helpers"
	"github.com/guacsec/guac/pkg/logging"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

var queryFlags = struct {
	purl            string
	vulnerabilityID string
	depth           int
}{}

type queryOptions struct {
	dbAddr string
	user   string
	pass   string
	realm  string
	// gql endpoint
	graphqlEndpoint string

	purl            string
	vulnerabilityID string
	depth           int
}

var queryVulnCmd = &cobra.Command{
	Use:   "queryVuln [flags]",
	Short: "query if a package is affected by the specified vulnerability",
	Run: func(cmd *cobra.Command, args []string) {
		ctx := logging.WithLogger(context.Background())
		logger := logging.FromContext(ctx)

		opts, err := validateQueryVulnFlags(
			viper.GetString("gdbuser"),
			viper.GetString("gdbpass"),
			viper.GetString("gdbaddr"),
			viper.GetString("realm"),
			viper.GetString("gql-endpoint"),
			viper.GetString("purl"),
			viper.GetString("vulnerabilityID"),
			viper.GetInt("depth"),
		)

		if err != nil {
			fmt.Printf("unable to validate flags: %v\n", err)
			_ = cmd.Help()
			os.Exit(1)
		}

		httpClient := http.Client{}
		gqlclient := graphql.NewClient(opts.graphqlEndpoint, &httpClient)

		pkgInput, err := helpers.PurlToPkg(opts.purl)
		if err != nil {
			logger.Fatalf("failed to parse PURL: %v", err)
		}

		pkgQualifierFilter := []model.PackageQualifierSpec{}
		for _, qualifier := range pkgInput.Qualifiers {
			pkgQualifierFilter = append(pkgQualifierFilter, model.PackageQualifierSpec{
				Key:   qualifier.Key,
				Value: &qualifier.Value,
			})
		}

		pkgFilter := &model.PkgSpec{
			Type:       &pkgInput.Type,
			Namespace:  pkgInput.Namespace,
			Name:       &pkgInput.Name,
			Version:    pkgInput.Version,
			Subpath:    pkgInput.Subpath,
			Qualifiers: pkgQualifierFilter,
		}
		pkgResponse, err := model.Packages(ctx, gqlclient, pkgFilter)
		if err != nil {
			logger.Fatalf("error querying for package: %v", err)
		}
		if len(pkgResponse.Packages) != 1 {
			logger.Fatalf("error too many packages matching purl found")
		}

		if opts.vulnerabilityID != "" {
			cveResponse := &model.CVEsResponse{}
			ghsaResponse := &model.GHSAsResponse{}

			osvResponse, err := model.OSVs(ctx, gqlclient, &model.OSVSpec{OsvId: &opts.vulnerabilityID})
			if err != nil {
				logger.Debugf("error querying for osvs: %v", err)
			}

			if len(osvResponse.Osv) == 0 {
				if strings.HasPrefix(opts.vulnerabilityID, "cve") {
					cveResponse, err = model.CVEs(ctx, gqlclient, &model.CVESpec{CveId: &opts.vulnerabilityID})
					if err != nil {
						logger.Fatalf("error querying for cves: %v", err)
					}
					if len(cveResponse.Cve) == 0 {
						logger.Fatalf("error failed to find CVE or OSV matching vulnerability ID")
					}
				} else if strings.HasPrefix(opts.vulnerabilityID, "ghsa") {
					ghsaResponse, err = model.GHSAs(ctx, gqlclient, &model.GHSASpec{GhsaId: &opts.vulnerabilityID})
					if err != nil {
						logger.Fatalf("error querying for ghsas: %v", err)
					}
					if len(ghsaResponse.Ghsa) == 0 {
						logger.Fatalf("error failed to find CVE or OSV matching vulnerability ID")
					}
				} else {
					logger.Fatalf("failed to identify vulnerability as cve or ghsa and no results found for OSV")
				}
			}

			var path []string
			if len(osvResponse.Osv) > 0 {
				path, err = queryVulnsViaVulnNodeNeighbors(ctx, gqlclient, pkgResponse, osvResponse.Osv[0].Id, model.EdgeOsvCertifyVuln, opts.depth)
				if err != nil {
					logger.Fatalf("error querying neighbor: %v", err)
				}
			} else if len(cveResponse.Cve) > 0 {
				path, err = queryVulnsViaVulnNodeNeighbors(ctx, gqlclient, pkgResponse, cveResponse.Cve[0].Id, model.EdgeCveCertifyVuln, opts.depth)
				if err != nil {
					logger.Fatalf("error querying neighbor: %v", err)
				}
			} else if len(ghsaResponse.Ghsa) > 0 {
				path, err = queryVulnsViaVulnNodeNeighbors(ctx, gqlclient, pkgResponse, ghsaResponse.Ghsa[0].Id, model.EdgeGhsaCertifyVuln, opts.depth)
				if err != nil {
					logger.Fatalf("error querying neighbor: %v", err)
				}
			} else {
				logger.Fatalf("failed to identify vulnerability as cve or ghsa and no results found for OSV")
			}
			logger.Infof("found path %v", strings.Join(path, `,`))
			logger.Infof("Visualizer url: http://localhost:3000/visualize?path=[%v]", strings.Join(path, `,`))
		} else {
			var path []string
			vulnPath, err := queryVulnsViaPackageNeighbors(ctx, gqlclient, pkgResponse.Packages[0].Namespaces[0].Names[0].Versions[0].Id, model.EdgePackageCertifyVuln)
			if err != nil {
				logger.Fatalf("error querying neighbor: %v", err)
			}
			depVulnPath, err := searchDependencyPackages(ctx, gqlclient, pkgResponse.Packages[0].Namespaces[0].Names[0].Versions[0].Id, opts.depth)
			if err != nil {
				logger.Fatalf("error searching dependency packages match: %v", err)
			}
			path = append(path, pkgResponse.Packages[0].Namespaces[0].Names[0].Versions[0].Id,
				pkgResponse.Packages[0].Namespaces[0].Names[0].Id, pkgResponse.Packages[0].Namespaces[0].Id,
				pkgResponse.Packages[0].Id)
			path = append(path, vulnPath...)
			path = append(path, depVulnPath...)
			logger.Infof("found path %v", strings.Join(path, `,`))
			logger.Infof("Visualizer url: http://localhost:3000/visualize?path=[%v]", strings.Join(path, `,`))
		}

	},
}

func queryVulnsViaPackageNeighbors(ctx context.Context, gqlclient graphql.Client, pkgVersionID string, edgeType model.Edge) ([]string, error) {
	path := []string{}
	certifyVulns, err := model.Neighbors(ctx, gqlclient, pkgVersionID, []model.Edge{edgeType})
	if err != nil {
		return nil, fmt.Errorf("error querying neighbor for vulnerability: %v", err)
	}
	for _, certifyVuln := range certifyVulns.Neighbors {
		if certifyVuln, ok := certifyVuln.(*model.NeighborsNeighborsCertifyVuln); ok {
			if vuln, ok := certifyVuln.Vulnerability.(*model.AllCertifyVulnVulnerabilityOSV); ok {
				path = append(path, []string{vuln.Id, certifyVuln.Id,
					certifyVuln.Package.Namespaces[0].Names[0].Versions[0].Id,
					certifyVuln.Package.Namespaces[0].Names[0].Id, certifyVuln.Package.Namespaces[0].Id,
					certifyVuln.Package.Id}...)
			} else if vuln, ok := certifyVuln.Vulnerability.(*model.AllCertifyVulnVulnerabilityCVE); ok {
				path = append(path, []string{vuln.Id, certifyVuln.Id,
					certifyVuln.Package.Namespaces[0].Names[0].Versions[0].Id,
					certifyVuln.Package.Namespaces[0].Names[0].Id, certifyVuln.Package.Namespaces[0].Id,
					certifyVuln.Package.Id}...)
			} else if vuln, ok := certifyVuln.Vulnerability.(*model.AllCertifyVulnVulnerabilityGHSA); ok {
				path = append(path, []string{vuln.Id, certifyVuln.Id,
					certifyVuln.Package.Namespaces[0].Names[0].Versions[0].Id,
					certifyVuln.Package.Namespaces[0].Names[0].Id, certifyVuln.Package.Namespaces[0].Id,
					certifyVuln.Package.Id}...)
			}
		}
	}
	return path, nil
}

func searchDependencyPackages(ctx context.Context, gqlclient graphql.Client, topPkgID string, maxLength int) ([]string, error) {
	path := []string{}
	queue := make([]string, 0) // the queue of nodes in bfs
	type dfsNode struct {
		expanded bool // true once all node neighbors are added to queue
		parent   string
		depth    int
	}
	nodeMap := map[string]dfsNode{}

	nodeMap[topPkgID] = dfsNode{}
	queue = append(queue, topPkgID)

	for len(queue) > 0 {
		now := queue[0]
		queue = queue[1:]
		nowNode := nodeMap[now]

		if maxLength != 0 && nowNode.depth >= maxLength {
			break
		}

		isDependencyResponses, err := model.Neighbors(ctx, gqlclient, now, []model.Edge{model.EdgePackageIsDependency})
		if err != nil {
			return nil, fmt.Errorf("failed getting package parent:%v", err)
		}
		for _, isDependencyResponse := range isDependencyResponses.Neighbors {
			if isDependency, ok := isDependencyResponse.(*model.NeighborsNeighborsIsDependency); ok {
				if isDependency.DependentPackage.Type == "guac" {
					continue
				}
				depPkgFilter := &model.PkgSpec{
					Type:      &isDependency.DependentPackage.Type,
					Namespace: &isDependency.DependentPackage.Namespaces[0].Namespace,
					Name:      &isDependency.DependentPackage.Namespaces[0].Names[0].Name,
					Version:   ptrfrom.String(isDependency.VersionRange),
				}

				depPkgResponse, err := model.Packages(ctx, gqlclient, depPkgFilter)
				if err != nil {
					return nil, fmt.Errorf("error querying for dependent package: %v", err)
				}
				if len(depPkgResponse.Packages) != 1 {
					return nil, fmt.Errorf("error too many dependent packages matching purl found")
				}
				for _, depPkgVersion := range depPkgResponse.Packages[0].Namespaces[0].Names[0].Versions {
					vulnPath, err := queryVulnsViaPackageNeighbors(ctx, gqlclient, depPkgVersion.Id, model.EdgePackageCertifyVuln)
					if err != nil {
						return nil, fmt.Errorf("error querying neighbor: %v", err)
					}
					if len(vulnPath) > 0 {
						path = append(path, isDependency.Id, depPkgVersion.Id,
							depPkgResponse.Packages[0].Namespaces[0].Names[0].Id, depPkgResponse.Packages[0].Namespaces[0].Id,
							depPkgResponse.Packages[0].Id)
						path = append(path, vulnPath...)
					}

					dfsN, seen := nodeMap[depPkgVersion.Id]
					if !seen {
						dfsN = dfsNode{
							parent: now,
							depth:  nowNode.depth + 1,
						}
						nodeMap[depPkgVersion.Id] = dfsN
					}
					if !dfsN.expanded {
						queue = append(queue, depPkgVersion.Id)
					}
				}
			}
		}

		nowNode.expanded = true
		nodeMap[now] = nowNode
	}

	return path, nil
}

func queryVulnsViaVulnNodeNeighbors(ctx context.Context, gqlclient graphql.Client, topPkgResponse *model.PackagesResponse, vulnerabilityNodeID string, edgeType model.Edge, depth int) ([]string, error) {
	path := []string{}
	certifyVulns, err := model.Neighbors(ctx, gqlclient, vulnerabilityNodeID, []model.Edge{edgeType})
	if err != nil {
		return nil, fmt.Errorf("error querying neighbor for vulnerability: %v", err)
	}
	for _, certifyVuln := range certifyVulns.Neighbors {
		if certifyVuln, ok := certifyVuln.(*model.NeighborsNeighborsCertifyVuln); ok {
			pkgPath, err := searchDependencyPackagesReverse(ctx, gqlclient, topPkgResponse.Packages[0].Namespaces[0].Names[0].Versions[0].Id, certifyVuln.Package.Namespaces[0].Names[0].Versions[0].Id, depth)
			if err != nil {
				return nil, fmt.Errorf("error searching dependency packages match: %v", err)
			}
			path = append([]string{vulnerabilityNodeID, certifyVuln.Id,
				certifyVuln.Package.Namespaces[0].Names[0].Versions[0].Id,
				certifyVuln.Package.Namespaces[0].Names[0].Id, certifyVuln.Package.Namespaces[0].Id,
				certifyVuln.Package.Id}, pkgPath...)
		}
	}
	return path, nil
}

func searchDependencyPackagesReverse(ctx context.Context, gqlclient graphql.Client, topPkgID string, searchPkgID string, maxLength int) ([]string, error) {
	path := []string{}
	queue := make([]string, 0) // the queue of nodes in bfs
	type dfsNode struct {
		expanded bool // true once all node neighbors are added to queue
		parent   string
		depth    int
	}
	nodeMap := map[string]dfsNode{}

	nodeMap[searchPkgID] = dfsNode{}
	queue = append(queue, searchPkgID)

	found := false
	for len(queue) > 0 {
		now := queue[0]
		queue = queue[1:]
		nowNode := nodeMap[now]

		if now == topPkgID {
			found = true
			break
		}

		if maxLength != 0 && nowNode.depth >= maxLength {
			break
		}

		pkgNameResponses, err := model.Neighbors(ctx, gqlclient, now, []model.Edge{})
		if err != nil {
			return nil, fmt.Errorf("failed getting package parent:%v", err)
		}

		for _, pkgNameResponse := range pkgNameResponses.Neighbors {
			if pkgName, ok := pkgNameResponse.(*model.NeighborsNeighborsPackage); ok {
				if len(pkgName.Namespaces) == 0 {
					continue
				}
				isDependencyResponses, err := model.Neighbors(ctx, gqlclient, pkgName.Namespaces[0].Names[0].Id, []model.Edge{model.EdgePackageIsDependency})
				if err != nil {
					return nil, fmt.Errorf("failed getting package parent:%v", err)
				}
				for _, isDependencyResponse := range isDependencyResponses.Neighbors {
					if isDependency, ok := isDependencyResponse.(*model.NeighborsNeighborsIsDependency); ok {
						path = append(path, isDependency.Id, isDependency.Package.Namespaces[0].Names[0].Versions[0].Id,
							isDependency.Package.Namespaces[0].Names[0].Id, isDependency.Package.Namespaces[0].Id,
							isDependency.Package.Id)

						dfsN, seen := nodeMap[isDependency.Package.Namespaces[0].Names[0].Versions[0].Id]
						if !seen {
							dfsN = dfsNode{
								parent: now,
								depth:  nowNode.depth + 1,
							}
							nodeMap[isDependency.Package.Namespaces[0].Names[0].Versions[0].Id] = dfsN
						}
						if !dfsN.expanded {
							queue = append(queue, isDependency.Package.Namespaces[0].Names[0].Versions[0].Id)
						}
					}
				}
			}
		}

		nowNode.expanded = true
		nodeMap[now] = nowNode
	}

	if !found {
		return nil, gqlerror.Errorf("No path found up to specified length")
	}

	return path, nil
}

func validateQueryVulnFlags(user string, pass string, dbAddr string, realm string, graphqlEndpoint, purl, vulnID string, depth int) (queryOptions, error) {
	var opts queryOptions
	opts.user = user
	opts.pass = pass
	opts.dbAddr = dbAddr
	opts.realm = realm
	opts.graphqlEndpoint = graphqlEndpoint
	opts.purl = purl
	opts.vulnerabilityID = vulnID
	opts.depth = depth
	return opts, nil
}

func init() {
	localFlags := queryVulnCmd.Flags()
	localFlags.StringVar(&queryFlags.purl, "purl", "", "package purl to check")
	localFlags.StringVar(&queryFlags.vulnerabilityID, "vulnerabilityID", "", "CVE, GHSA or OSV ID to check")
	localFlags.IntVar(&queryFlags.depth, "depth", 0, "depth to check, 0 has no limit")
	flagNames := []string{"purl", "vulnerabilityID", "depth"}
	for _, name := range flagNames {
		if flag := localFlags.Lookup(name); flag != nil {
			if err := viper.BindPFlag(name, flag); err != nil {
				fmt.Fprintf(os.Stderr, "failed to bind flag: %v", err)
				os.Exit(1)
			}
		}
	}
	rootCmd.AddCommand(queryVulnCmd)
}
