//
// Copyright 2023 The GUAC Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"strings"

	"github.com/Khan/genqlient/graphql"
	model "github.com/guacsec/guac/pkg/assembler/clients/generated"
	"github.com/guacsec/guac/pkg/assembler/helpers"
	"github.com/guacsec/guac/pkg/logging"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

var queryFlags = struct {
	purl            string
	vulnerabilityID string
	depth           int
}{}

type queryOptions struct {
	dbAddr string
	user   string
	pass   string
	realm  string
	// gql endpoint
	graphqlEndpoint string

	purl            string
	vulnerabilityID string
	depth           int
}

var queryVulnCmd = &cobra.Command{
	Use:   "queryVuln [flags]",
	Short: "query if a package is affected by the specified vulnerability",
	Run: func(cmd *cobra.Command, args []string) {
		ctx := logging.WithLogger(context.Background())
		logger := logging.FromContext(ctx)

		opts, err := validateQueryVulnFlags(
			viper.GetString("gdbuser"),
			viper.GetString("gdbpass"),
			viper.GetString("gdbaddr"),
			viper.GetString("realm"),
			viper.GetString("gql-endpoint"),
			viper.GetString("purl"),
			viper.GetString("vulnerabilityID"),
			viper.GetInt("depth"),
		)

		if err != nil {
			fmt.Printf("unable to validate flags: %v\n", err)
			_ = cmd.Help()
			os.Exit(1)
		}

		httpClient := http.Client{}
		gqlclient := graphql.NewClient(opts.graphqlEndpoint, &httpClient)

		pkgInput, err := helpers.PurlToPkg(opts.purl)
		if err != nil {
			logger.Fatalf("failed to parse PURL: %v", err)
		}

		pkgQualifierFilter := []model.PackageQualifierSpec{}
		for _, qualifier := range pkgInput.Qualifiers {
			pkgQualifierFilter = append(pkgQualifierFilter, model.PackageQualifierSpec{
				Key:   qualifier.Key,
				Value: &qualifier.Value,
			})
		}

		pkgFilter := &model.PkgSpec{
			Type:       &pkgInput.Type,
			Namespace:  pkgInput.Namespace,
			Name:       &pkgInput.Name,
			Version:    pkgInput.Version,
			Subpath:    pkgInput.Subpath,
			Qualifiers: pkgQualifierFilter,
		}
		pkgResponse, err := model.Packages(ctx, gqlclient, pkgFilter)
		if err != nil {
			logger.Fatalf("error querying for package: %v", err)
		}
		if len(pkgResponse.Packages) != 1 {
			logger.Fatalf("error too many packages matching purl found")
		}
		cveResponse := &model.CVEsResponse{}
		ghsaResponse := &model.GHSAsResponse{}

		osvResponse, err := model.OSVs(ctx, gqlclient, &model.OSVSpec{OsvId: &opts.vulnerabilityID})
		if err != nil {
			logger.Debugf("error querying for osvs: %v", err)
		}
		if osvResponse != nil && len(osvResponse.Osv) != 1 {
			logger.Fatalf("error too many OSVs matching ID found")
		}

		if osvResponse == nil {
			if strings.HasPrefix(opts.vulnerabilityID, "cve") {
				cveResponse, err = model.CVEs(ctx, gqlclient, &model.CVESpec{CveId: &opts.vulnerabilityID})
				if err != nil {
					logger.Fatalf("error querying for cves: %v", err)
				}
				if len(cveResponse.Cve) != 1 {
					logger.Fatalf("error too many CVEs matching ID found")
				}
			} else if strings.HasPrefix(opts.vulnerabilityID, "ghsa") {
				ghsaResponse, err = model.GHSAs(ctx, gqlclient, &model.GHSASpec{GhsaId: &opts.vulnerabilityID})
				if err != nil {
					logger.Fatalf("error querying for ghsas: %v", err)
				}
				if len(ghsaResponse.Ghsa) != 1 {
					logger.Fatalf("error too many GHSAs matching ID found")
				}
			}
		}

		path := []string{}
		if osvResponse != nil {
			certifyVulns, err := model.Neighbors(ctx, gqlclient, osvResponse.Osv[0].Id, []model.Edge{model.EdgeOsvCertifyVuln})
			if err != nil {
				logger.Fatalf("error querying neighbor for cves: %v", err)
			}
			for _, certifyVuln := range certifyVulns.Neighbors {
				if certifyVuln, ok := certifyVuln.(*model.NeighborsNeighborsCertifyVuln); ok {
					pkgPath, err := searchDependencyPackages(ctx, gqlclient, pkgResponse.Packages[0].Id, certifyVuln.Package.Namespaces[0].Names[0].Versions[0].Id, opts.depth)
					if err != nil {
						logger.Fatalf("error searching dependency packages match: %v", err)
					}
					path = append([]string{osvResponse.Osv[0].Id, certifyVuln.Id}, pkgPath...)
				}
			}
		} else {
			if cveResponse != nil {
				certifyVulns, err := model.Neighbors(ctx, gqlclient, cveResponse.Cve[0].Id, []model.Edge{model.EdgeCveCertifyVuln})
				if err != nil {
					logger.Fatalf("error querying neighbor for cves: %v", err)
				}
				for _, certifyVuln := range certifyVulns.Neighbors {
					if certifyVuln, ok := certifyVuln.(*model.NeighborsNeighborsCertifyVuln); ok {
						pkgPath, err := searchDependencyPackages(ctx, gqlclient, pkgResponse.Packages[0].Id, certifyVuln.Package.Namespaces[0].Id, opts.depth)
						if err != nil {
							logger.Fatalf("error searching dependency packages match: %v", err)
						}
						path = append([]string{cveResponse.Cve[0].Id, certifyVuln.Id}, pkgPath...)
					}
				}
			}
			if ghsaResponse != nil {
				certifyVulns, err := model.Neighbors(ctx, gqlclient, ghsaResponse.Ghsa[0].Id, []model.Edge{model.EdgeGhsaCertifyVuln})
				if err != nil {
					logger.Fatalf("error querying neighbor for cves: %v", err)
				}
				for _, certifyVuln := range certifyVulns.Neighbors {
					if certifyVuln, ok := certifyVuln.(*model.NeighborsNeighborsCertifyVuln); ok {
						pkgPath, err := searchDependencyPackages(ctx, gqlclient, pkgResponse.Packages[0].Id, certifyVuln.Package.Namespaces[0].Id, opts.depth)
						if err != nil {
							logger.Fatalf("error searching dependency packages match: %v", err)
						}
						path = append([]string{ghsaResponse.Ghsa[0].Id, certifyVuln.Id}, pkgPath...)
					}
				}
			}
		}
		logger.Infof("found path %v", strings.Join(path, `,`))
		logger.Infof("Visualizer url: http://localhost:3000/visualize?path=[%v]", strings.Join(path, `,`))
	},
}

func searchDependencyPackages(ctx context.Context, gqlclient graphql.Client, topPkgID string, searchPkgID string, maxLength int) ([]string, error) {
	path := []string{}
	queue := make([]string, 0) // the queue of nodes in bfs
	type dfsNode struct {
		expanded bool // true once all node neighbors are added to queue
		parent   string
		depth    int
	}
	nodeMap := map[string]dfsNode{}

	nodeMap[searchPkgID] = dfsNode{}
	queue = append(queue, searchPkgID)

	found := false
	for len(queue) > 0 {
		now := queue[0]
		queue = queue[1:]
		nowNode := nodeMap[now]

		if now == topPkgID {
			path = append(path, now)
			found = true
			break
		}

		if maxLength != 0 && nowNode.depth >= maxLength {
			break
		}

		path = append(path, now)
		pkgNameResponses, err := model.Neighbors(ctx, gqlclient, now, []model.Edge{})
		if err != nil {
			return nil, fmt.Errorf("failed getting package parent:%v", err)
		}

		for _, pkgNameResponse := range pkgNameResponses.Neighbors {
			if pkgName, ok := pkgNameResponse.(*model.NeighborsNeighborsPackage); ok {
				if len(pkgName.Namespaces) == 0 {
					continue
				}
				isDependencyResponses, err := model.Neighbors(ctx, gqlclient, pkgName.Namespaces[0].Names[0].Id, []model.Edge{model.EdgePackageIsDependency})
				if err != nil {
					return nil, fmt.Errorf("failed getting package parent:%v", err)
				}
				for _, isDependencyResponse := range isDependencyResponses.Neighbors {
					if isDependency, ok := isDependencyResponse.(*model.NeighborsNeighborsIsDependency); ok {
						path = append(path, isDependency.Id)
						dfsN, seen := nodeMap[isDependency.Package.Id]
						if !seen {
							dfsN = dfsNode{
								parent: now,
								depth:  nowNode.depth + 1,
							}
							nodeMap[isDependency.Package.Id] = dfsN
						}
						if !dfsN.expanded {
							queue = append(queue, isDependency.Package.Id)
						}
					}
				}
			}
		}

		nowNode.expanded = true
		nodeMap[now] = nowNode
	}

	if !found {
		return nil, gqlerror.Errorf("No path found up to specified length")
	}

	return path, nil
}

func validateQueryVulnFlags(user string, pass string, dbAddr string, realm string, graphqlEndpoint, purl, vulnID string, depth int) (queryOptions, error) {
	var opts queryOptions
	opts.user = user
	opts.pass = pass
	opts.dbAddr = dbAddr
	opts.realm = realm
	opts.graphqlEndpoint = graphqlEndpoint
	opts.purl = purl
	opts.vulnerabilityID = vulnID
	opts.depth = depth
	return opts, nil
}

func init() {
	localFlags := queryVulnCmd.Flags()
	localFlags.StringVar(&queryFlags.purl, "purl", "", "package purl to check")
	localFlags.StringVar(&queryFlags.vulnerabilityID, "vulnerabilityID", "", "CVE, GHSA or OSV ID to check")
	localFlags.IntVar(&queryFlags.depth, "depth", 0, "depth to check, 0 has no limit")
	flagNames := []string{"purl", "vulnerabilityID", "depth"}
	for _, name := range flagNames {
		if flag := localFlags.Lookup(name); flag != nil {
			if err := viper.BindPFlag(name, flag); err != nil {
				fmt.Fprintf(os.Stderr, "failed to bind flag: %v", err)
				os.Exit(1)
			}
		}
	}
	rootCmd.AddCommand(queryVulnCmd)
}
