// Code generated by MockGen. DO NOT EDIT.
// Source: ../../../pkg/assembler/backends/backends.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	model "github.com/guacsec/guac/pkg/assembler/graphql/model"
)

// MockBackend is a mock of Backend interface.
type MockBackend struct {
	ctrl     *gomock.Controller
	recorder *MockBackendMockRecorder
}

// MockBackendMockRecorder is the mock recorder for MockBackend.
type MockBackendMockRecorder struct {
	mock *MockBackend
}

// NewMockBackend creates a new mock instance.
func NewMockBackend(ctrl *gomock.Controller) *MockBackend {
	mock := &MockBackend{ctrl: ctrl}
	mock.recorder = &MockBackendMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBackend) EXPECT() *MockBackendMockRecorder {
	return m.recorder
}

// Artifacts mocks base method.
func (m *MockBackend) Artifacts(ctx context.Context, artifactSpec *model.ArtifactSpec) ([]*model.Artifact, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Artifacts", ctx, artifactSpec)
	ret0, _ := ret[0].([]*model.Artifact)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Artifacts indicates an expected call of Artifacts.
func (mr *MockBackendMockRecorder) Artifacts(ctx, artifactSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Artifacts", reflect.TypeOf((*MockBackend)(nil).Artifacts), ctx, artifactSpec)
}

// Builders mocks base method.
func (m *MockBackend) Builders(ctx context.Context, builderSpec *model.BuilderSpec) ([]*model.Builder, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Builders", ctx, builderSpec)
	ret0, _ := ret[0].([]*model.Builder)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Builders indicates an expected call of Builders.
func (mr *MockBackendMockRecorder) Builders(ctx, builderSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Builders", reflect.TypeOf((*MockBackend)(nil).Builders), ctx, builderSpec)
}

// CertifyBad mocks base method.
func (m *MockBackend) CertifyBad(ctx context.Context, certifyBadSpec *model.CertifyBadSpec) ([]*model.CertifyBad, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CertifyBad", ctx, certifyBadSpec)
	ret0, _ := ret[0].([]*model.CertifyBad)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CertifyBad indicates an expected call of CertifyBad.
func (mr *MockBackendMockRecorder) CertifyBad(ctx, certifyBadSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CertifyBad", reflect.TypeOf((*MockBackend)(nil).CertifyBad), ctx, certifyBadSpec)
}

// CertifyGood mocks base method.
func (m *MockBackend) CertifyGood(ctx context.Context, certifyGoodSpec *model.CertifyGoodSpec) ([]*model.CertifyGood, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CertifyGood", ctx, certifyGoodSpec)
	ret0, _ := ret[0].([]*model.CertifyGood)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CertifyGood indicates an expected call of CertifyGood.
func (mr *MockBackendMockRecorder) CertifyGood(ctx, certifyGoodSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CertifyGood", reflect.TypeOf((*MockBackend)(nil).CertifyGood), ctx, certifyGoodSpec)
}

// CertifyLegal mocks base method.
func (m *MockBackend) CertifyLegal(ctx context.Context, certifyLegalSpec *model.CertifyLegalSpec) ([]*model.CertifyLegal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CertifyLegal", ctx, certifyLegalSpec)
	ret0, _ := ret[0].([]*model.CertifyLegal)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CertifyLegal indicates an expected call of CertifyLegal.
func (mr *MockBackendMockRecorder) CertifyLegal(ctx, certifyLegalSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CertifyLegal", reflect.TypeOf((*MockBackend)(nil).CertifyLegal), ctx, certifyLegalSpec)
}

// CertifyVEXStatement mocks base method.
func (m *MockBackend) CertifyVEXStatement(ctx context.Context, certifyVEXStatementSpec *model.CertifyVEXStatementSpec) ([]*model.CertifyVEXStatement, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CertifyVEXStatement", ctx, certifyVEXStatementSpec)
	ret0, _ := ret[0].([]*model.CertifyVEXStatement)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CertifyVEXStatement indicates an expected call of CertifyVEXStatement.
func (mr *MockBackendMockRecorder) CertifyVEXStatement(ctx, certifyVEXStatementSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CertifyVEXStatement", reflect.TypeOf((*MockBackend)(nil).CertifyVEXStatement), ctx, certifyVEXStatementSpec)
}

// CertifyVuln mocks base method.
func (m *MockBackend) CertifyVuln(ctx context.Context, certifyVulnSpec *model.CertifyVulnSpec) ([]*model.CertifyVuln, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CertifyVuln", ctx, certifyVulnSpec)
	ret0, _ := ret[0].([]*model.CertifyVuln)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CertifyVuln indicates an expected call of CertifyVuln.
func (mr *MockBackendMockRecorder) CertifyVuln(ctx, certifyVulnSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CertifyVuln", reflect.TypeOf((*MockBackend)(nil).CertifyVuln), ctx, certifyVulnSpec)
}

// FindSoftware mocks base method.
func (m *MockBackend) FindSoftware(ctx context.Context, searchText string) ([]model.PackageSourceOrArtifact, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindSoftware", ctx, searchText)
	ret0, _ := ret[0].([]model.PackageSourceOrArtifact)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindSoftware indicates an expected call of FindSoftware.
func (mr *MockBackendMockRecorder) FindSoftware(ctx, searchText interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindSoftware", reflect.TypeOf((*MockBackend)(nil).FindSoftware), ctx, searchText)
}

// HasMetadata mocks base method.
func (m *MockBackend) HasMetadata(ctx context.Context, hasMetadataSpec *model.HasMetadataSpec) ([]*model.HasMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasMetadata", ctx, hasMetadataSpec)
	ret0, _ := ret[0].([]*model.HasMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasMetadata indicates an expected call of HasMetadata.
func (mr *MockBackendMockRecorder) HasMetadata(ctx, hasMetadataSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasMetadata", reflect.TypeOf((*MockBackend)(nil).HasMetadata), ctx, hasMetadataSpec)
}

// HasSBOM mocks base method.
func (m *MockBackend) HasSBOM(ctx context.Context, hasSBOMSpec *model.HasSBOMSpec) ([]*model.HasSbom, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSBOM", ctx, hasSBOMSpec)
	ret0, _ := ret[0].([]*model.HasSbom)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasSBOM indicates an expected call of HasSBOM.
func (mr *MockBackendMockRecorder) HasSBOM(ctx, hasSBOMSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSBOM", reflect.TypeOf((*MockBackend)(nil).HasSBOM), ctx, hasSBOMSpec)
}

// HasSlsa mocks base method.
func (m *MockBackend) HasSlsa(ctx context.Context, hasSLSASpec *model.HasSLSASpec) ([]*model.HasSlsa, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSlsa", ctx, hasSLSASpec)
	ret0, _ := ret[0].([]*model.HasSlsa)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasSlsa indicates an expected call of HasSlsa.
func (mr *MockBackendMockRecorder) HasSlsa(ctx, hasSLSASpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSlsa", reflect.TypeOf((*MockBackend)(nil).HasSlsa), ctx, hasSLSASpec)
}

// HasSourceAt mocks base method.
func (m *MockBackend) HasSourceAt(ctx context.Context, hasSourceAtSpec *model.HasSourceAtSpec) ([]*model.HasSourceAt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSourceAt", ctx, hasSourceAtSpec)
	ret0, _ := ret[0].([]*model.HasSourceAt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasSourceAt indicates an expected call of HasSourceAt.
func (mr *MockBackendMockRecorder) HasSourceAt(ctx, hasSourceAtSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSourceAt", reflect.TypeOf((*MockBackend)(nil).HasSourceAt), ctx, hasSourceAtSpec)
}

// HashEqual mocks base method.
func (m *MockBackend) HashEqual(ctx context.Context, hashEqualSpec *model.HashEqualSpec) ([]*model.HashEqual, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HashEqual", ctx, hashEqualSpec)
	ret0, _ := ret[0].([]*model.HashEqual)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HashEqual indicates an expected call of HashEqual.
func (mr *MockBackendMockRecorder) HashEqual(ctx, hashEqualSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HashEqual", reflect.TypeOf((*MockBackend)(nil).HashEqual), ctx, hashEqualSpec)
}

// IngestArtifact mocks base method.
func (m *MockBackend) IngestArtifact(ctx context.Context, artifact *model.ArtifactInputSpec) (*model.Artifact, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestArtifact", ctx, artifact)
	ret0, _ := ret[0].(*model.Artifact)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestArtifact indicates an expected call of IngestArtifact.
func (mr *MockBackendMockRecorder) IngestArtifact(ctx, artifact interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestArtifact", reflect.TypeOf((*MockBackend)(nil).IngestArtifact), ctx, artifact)
}

// IngestArtifacts mocks base method.
func (m *MockBackend) IngestArtifacts(ctx context.Context, artifacts []*model.ArtifactInputSpec) ([]*model.Artifact, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestArtifacts", ctx, artifacts)
	ret0, _ := ret[0].([]*model.Artifact)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestArtifacts indicates an expected call of IngestArtifacts.
func (mr *MockBackendMockRecorder) IngestArtifacts(ctx, artifacts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestArtifacts", reflect.TypeOf((*MockBackend)(nil).IngestArtifacts), ctx, artifacts)
}

// IngestBuilder mocks base method.
func (m *MockBackend) IngestBuilder(ctx context.Context, builder *model.BuilderInputSpec) (*model.Builder, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestBuilder", ctx, builder)
	ret0, _ := ret[0].(*model.Builder)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestBuilder indicates an expected call of IngestBuilder.
func (mr *MockBackendMockRecorder) IngestBuilder(ctx, builder interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestBuilder", reflect.TypeOf((*MockBackend)(nil).IngestBuilder), ctx, builder)
}

// IngestBuilders mocks base method.
func (m *MockBackend) IngestBuilders(ctx context.Context, builders []*model.BuilderInputSpec) ([]*model.Builder, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestBuilders", ctx, builders)
	ret0, _ := ret[0].([]*model.Builder)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestBuilders indicates an expected call of IngestBuilders.
func (mr *MockBackendMockRecorder) IngestBuilders(ctx, builders interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestBuilders", reflect.TypeOf((*MockBackend)(nil).IngestBuilders), ctx, builders)
}

// IngestBulkHasMetadata mocks base method.
func (m *MockBackend) IngestBulkHasMetadata(ctx context.Context, subjects model.PackageSourceOrArtifactInputs, pkgMatchType *model.MatchFlags, hasMetadataList []*model.HasMetadataInputSpec) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestBulkHasMetadata", ctx, subjects, pkgMatchType, hasMetadataList)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestBulkHasMetadata indicates an expected call of IngestBulkHasMetadata.
func (mr *MockBackendMockRecorder) IngestBulkHasMetadata(ctx, subjects, pkgMatchType, hasMetadataList interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestBulkHasMetadata", reflect.TypeOf((*MockBackend)(nil).IngestBulkHasMetadata), ctx, subjects, pkgMatchType, hasMetadataList)
}

// IngestBulkVulnerabilityMetadata mocks base method.
func (m *MockBackend) IngestBulkVulnerabilityMetadata(ctx context.Context, vulnerabilities []*model.VulnerabilityInputSpec, vulnerabilityMetadataList []*model.VulnerabilityMetadataInputSpec) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestBulkVulnerabilityMetadata", ctx, vulnerabilities, vulnerabilityMetadataList)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestBulkVulnerabilityMetadata indicates an expected call of IngestBulkVulnerabilityMetadata.
func (mr *MockBackendMockRecorder) IngestBulkVulnerabilityMetadata(ctx, vulnerabilities, vulnerabilityMetadataList interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestBulkVulnerabilityMetadata", reflect.TypeOf((*MockBackend)(nil).IngestBulkVulnerabilityMetadata), ctx, vulnerabilities, vulnerabilityMetadataList)
}

// IngestCertifyBad mocks base method.
func (m *MockBackend) IngestCertifyBad(ctx context.Context, subject model.PackageSourceOrArtifactInput, pkgMatchType *model.MatchFlags, certifyBad model.CertifyBadInputSpec) (*model.CertifyBad, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestCertifyBad", ctx, subject, pkgMatchType, certifyBad)
	ret0, _ := ret[0].(*model.CertifyBad)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestCertifyBad indicates an expected call of IngestCertifyBad.
func (mr *MockBackendMockRecorder) IngestCertifyBad(ctx, subject, pkgMatchType, certifyBad interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestCertifyBad", reflect.TypeOf((*MockBackend)(nil).IngestCertifyBad), ctx, subject, pkgMatchType, certifyBad)
}

// IngestCertifyBads mocks base method.
func (m *MockBackend) IngestCertifyBads(ctx context.Context, subjects model.PackageSourceOrArtifactInputs, pkgMatchType *model.MatchFlags, certifyBads []*model.CertifyBadInputSpec) ([]*model.CertifyBad, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestCertifyBads", ctx, subjects, pkgMatchType, certifyBads)
	ret0, _ := ret[0].([]*model.CertifyBad)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestCertifyBads indicates an expected call of IngestCertifyBads.
func (mr *MockBackendMockRecorder) IngestCertifyBads(ctx, subjects, pkgMatchType, certifyBads interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestCertifyBads", reflect.TypeOf((*MockBackend)(nil).IngestCertifyBads), ctx, subjects, pkgMatchType, certifyBads)
}

// IngestCertifyGood mocks base method.
func (m *MockBackend) IngestCertifyGood(ctx context.Context, subject model.PackageSourceOrArtifactInput, pkgMatchType *model.MatchFlags, certifyGood model.CertifyGoodInputSpec) (*model.CertifyGood, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestCertifyGood", ctx, subject, pkgMatchType, certifyGood)
	ret0, _ := ret[0].(*model.CertifyGood)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestCertifyGood indicates an expected call of IngestCertifyGood.
func (mr *MockBackendMockRecorder) IngestCertifyGood(ctx, subject, pkgMatchType, certifyGood interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestCertifyGood", reflect.TypeOf((*MockBackend)(nil).IngestCertifyGood), ctx, subject, pkgMatchType, certifyGood)
}

// IngestCertifyGoods mocks base method.
func (m *MockBackend) IngestCertifyGoods(ctx context.Context, subjects model.PackageSourceOrArtifactInputs, pkgMatchType *model.MatchFlags, certifyGoods []*model.CertifyGoodInputSpec) ([]*model.CertifyGood, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestCertifyGoods", ctx, subjects, pkgMatchType, certifyGoods)
	ret0, _ := ret[0].([]*model.CertifyGood)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestCertifyGoods indicates an expected call of IngestCertifyGoods.
func (mr *MockBackendMockRecorder) IngestCertifyGoods(ctx, subjects, pkgMatchType, certifyGoods interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestCertifyGoods", reflect.TypeOf((*MockBackend)(nil).IngestCertifyGoods), ctx, subjects, pkgMatchType, certifyGoods)
}

// IngestCertifyLegal mocks base method.
func (m *MockBackend) IngestCertifyLegal(ctx context.Context, subject model.PackageOrSourceInput, declaredLicenses, discoveredLicenses []*model.LicenseInputSpec, certifyLegal *model.CertifyLegalInputSpec) (*model.CertifyLegal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestCertifyLegal", ctx, subject, declaredLicenses, discoveredLicenses, certifyLegal)
	ret0, _ := ret[0].(*model.CertifyLegal)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestCertifyLegal indicates an expected call of IngestCertifyLegal.
func (mr *MockBackendMockRecorder) IngestCertifyLegal(ctx, subject, declaredLicenses, discoveredLicenses, certifyLegal interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestCertifyLegal", reflect.TypeOf((*MockBackend)(nil).IngestCertifyLegal), ctx, subject, declaredLicenses, discoveredLicenses, certifyLegal)
}

// IngestCertifyLegals mocks base method.
func (m *MockBackend) IngestCertifyLegals(ctx context.Context, subjects model.PackageOrSourceInputs, declaredLicensesList, discoveredLicensesList [][]*model.LicenseInputSpec, certifyLegals []*model.CertifyLegalInputSpec) ([]*model.CertifyLegal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestCertifyLegals", ctx, subjects, declaredLicensesList, discoveredLicensesList, certifyLegals)
	ret0, _ := ret[0].([]*model.CertifyLegal)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestCertifyLegals indicates an expected call of IngestCertifyLegals.
func (mr *MockBackendMockRecorder) IngestCertifyLegals(ctx, subjects, declaredLicensesList, discoveredLicensesList, certifyLegals interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestCertifyLegals", reflect.TypeOf((*MockBackend)(nil).IngestCertifyLegals), ctx, subjects, declaredLicensesList, discoveredLicensesList, certifyLegals)
}

// IngestCertifyVuln mocks base method.
func (m *MockBackend) IngestCertifyVuln(ctx context.Context, pkg model.PkgInputSpec, vulnerability model.VulnerabilityInputSpec, certifyVuln model.ScanMetadataInput) (*model.CertifyVuln, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestCertifyVuln", ctx, pkg, vulnerability, certifyVuln)
	ret0, _ := ret[0].(*model.CertifyVuln)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestCertifyVuln indicates an expected call of IngestCertifyVuln.
func (mr *MockBackendMockRecorder) IngestCertifyVuln(ctx, pkg, vulnerability, certifyVuln interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestCertifyVuln", reflect.TypeOf((*MockBackend)(nil).IngestCertifyVuln), ctx, pkg, vulnerability, certifyVuln)
}

// IngestCertifyVulns mocks base method.
func (m *MockBackend) IngestCertifyVulns(ctx context.Context, pkgs []*model.PkgInputSpec, vulnerabilities []*model.VulnerabilityInputSpec, certifyVulns []*model.ScanMetadataInput) ([]*model.CertifyVuln, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestCertifyVulns", ctx, pkgs, vulnerabilities, certifyVulns)
	ret0, _ := ret[0].([]*model.CertifyVuln)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestCertifyVulns indicates an expected call of IngestCertifyVulns.
func (mr *MockBackendMockRecorder) IngestCertifyVulns(ctx, pkgs, vulnerabilities, certifyVulns interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestCertifyVulns", reflect.TypeOf((*MockBackend)(nil).IngestCertifyVulns), ctx, pkgs, vulnerabilities, certifyVulns)
}

// IngestDependencies mocks base method.
func (m *MockBackend) IngestDependencies(ctx context.Context, pkgs, depPkgs []*model.PkgInputSpec, depPkgMatchType model.MatchFlags, dependencies []*model.IsDependencyInputSpec) ([]*model.IsDependency, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestDependencies", ctx, pkgs, depPkgs, depPkgMatchType, dependencies)
	ret0, _ := ret[0].([]*model.IsDependency)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestDependencies indicates an expected call of IngestDependencies.
func (mr *MockBackendMockRecorder) IngestDependencies(ctx, pkgs, depPkgs, depPkgMatchType, dependencies interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestDependencies", reflect.TypeOf((*MockBackend)(nil).IngestDependencies), ctx, pkgs, depPkgs, depPkgMatchType, dependencies)
}

// IngestDependency mocks base method.
func (m *MockBackend) IngestDependency(ctx context.Context, pkg, depPkg model.PkgInputSpec, depPkgMatchType model.MatchFlags, dependency model.IsDependencyInputSpec) (*model.IsDependency, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestDependency", ctx, pkg, depPkg, depPkgMatchType, dependency)
	ret0, _ := ret[0].(*model.IsDependency)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestDependency indicates an expected call of IngestDependency.
func (mr *MockBackendMockRecorder) IngestDependency(ctx, pkg, depPkg, depPkgMatchType, dependency interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestDependency", reflect.TypeOf((*MockBackend)(nil).IngestDependency), ctx, pkg, depPkg, depPkgMatchType, dependency)
}

// IngestHasMetadata mocks base method.
func (m *MockBackend) IngestHasMetadata(ctx context.Context, subject model.PackageSourceOrArtifactInput, pkgMatchType *model.MatchFlags, hasMetadata model.HasMetadataInputSpec) (*model.HasMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestHasMetadata", ctx, subject, pkgMatchType, hasMetadata)
	ret0, _ := ret[0].(*model.HasMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestHasMetadata indicates an expected call of IngestHasMetadata.
func (mr *MockBackendMockRecorder) IngestHasMetadata(ctx, subject, pkgMatchType, hasMetadata interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestHasMetadata", reflect.TypeOf((*MockBackend)(nil).IngestHasMetadata), ctx, subject, pkgMatchType, hasMetadata)
}

// IngestHasSBOMs mocks base method.
func (m *MockBackend) IngestHasSBOMs(ctx context.Context, subjects model.PackageOrArtifactInputs, hasSBOMs []*model.HasSBOMInputSpec, includes []*model.HasSBOMIncludesInputSpec) ([]*model.HasSbom, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestHasSBOMs", ctx, subjects, hasSBOMs, includes)
	ret0, _ := ret[0].([]*model.HasSbom)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestHasSBOMs indicates an expected call of IngestHasSBOMs.
func (mr *MockBackendMockRecorder) IngestHasSBOMs(ctx, subjects, hasSBOMs, includes interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestHasSBOMs", reflect.TypeOf((*MockBackend)(nil).IngestHasSBOMs), ctx, subjects, hasSBOMs, includes)
}

// IngestHasSbom mocks base method.
func (m *MockBackend) IngestHasSbom(ctx context.Context, subject model.PackageOrArtifactInput, hasSbom model.HasSBOMInputSpec, includes model.HasSBOMIncludesInputSpec) (*model.HasSbom, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestHasSbom", ctx, subject, hasSbom, includes)
	ret0, _ := ret[0].(*model.HasSbom)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestHasSbom indicates an expected call of IngestHasSbom.
func (mr *MockBackendMockRecorder) IngestHasSbom(ctx, subject, hasSbom, includes interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestHasSbom", reflect.TypeOf((*MockBackend)(nil).IngestHasSbom), ctx, subject, hasSbom, includes)
}

// IngestHasSourceAt mocks base method.
func (m *MockBackend) IngestHasSourceAt(ctx context.Context, pkg model.PkgInputSpec, pkgMatchType model.MatchFlags, source model.SourceInputSpec, hasSourceAt model.HasSourceAtInputSpec) (*model.HasSourceAt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestHasSourceAt", ctx, pkg, pkgMatchType, source, hasSourceAt)
	ret0, _ := ret[0].(*model.HasSourceAt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestHasSourceAt indicates an expected call of IngestHasSourceAt.
func (mr *MockBackendMockRecorder) IngestHasSourceAt(ctx, pkg, pkgMatchType, source, hasSourceAt interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestHasSourceAt", reflect.TypeOf((*MockBackend)(nil).IngestHasSourceAt), ctx, pkg, pkgMatchType, source, hasSourceAt)
}

// IngestHasSourceAts mocks base method.
func (m *MockBackend) IngestHasSourceAts(ctx context.Context, pkgs []*model.PkgInputSpec, pkgMatchType *model.MatchFlags, sources []*model.SourceInputSpec, hasSourceAts []*model.HasSourceAtInputSpec) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestHasSourceAts", ctx, pkgs, pkgMatchType, sources, hasSourceAts)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestHasSourceAts indicates an expected call of IngestHasSourceAts.
func (mr *MockBackendMockRecorder) IngestHasSourceAts(ctx, pkgs, pkgMatchType, sources, hasSourceAts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestHasSourceAts", reflect.TypeOf((*MockBackend)(nil).IngestHasSourceAts), ctx, pkgs, pkgMatchType, sources, hasSourceAts)
}

// IngestHashEqual mocks base method.
func (m *MockBackend) IngestHashEqual(ctx context.Context, artifact, equalArtifact model.ArtifactInputSpec, hashEqual model.HashEqualInputSpec) (*model.HashEqual, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestHashEqual", ctx, artifact, equalArtifact, hashEqual)
	ret0, _ := ret[0].(*model.HashEqual)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestHashEqual indicates an expected call of IngestHashEqual.
func (mr *MockBackendMockRecorder) IngestHashEqual(ctx, artifact, equalArtifact, hashEqual interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestHashEqual", reflect.TypeOf((*MockBackend)(nil).IngestHashEqual), ctx, artifact, equalArtifact, hashEqual)
}

// IngestHashEquals mocks base method.
func (m *MockBackend) IngestHashEquals(ctx context.Context, artifacts, otherArtifacts []*model.ArtifactInputSpec, hashEquals []*model.HashEqualInputSpec) ([]*model.HashEqual, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestHashEquals", ctx, artifacts, otherArtifacts, hashEquals)
	ret0, _ := ret[0].([]*model.HashEqual)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestHashEquals indicates an expected call of IngestHashEquals.
func (mr *MockBackendMockRecorder) IngestHashEquals(ctx, artifacts, otherArtifacts, hashEquals interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestHashEquals", reflect.TypeOf((*MockBackend)(nil).IngestHashEquals), ctx, artifacts, otherArtifacts, hashEquals)
}

// IngestLicense mocks base method.
func (m *MockBackend) IngestLicense(ctx context.Context, license *model.LicenseInputSpec) (*model.License, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestLicense", ctx, license)
	ret0, _ := ret[0].(*model.License)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestLicense indicates an expected call of IngestLicense.
func (mr *MockBackendMockRecorder) IngestLicense(ctx, license interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestLicense", reflect.TypeOf((*MockBackend)(nil).IngestLicense), ctx, license)
}

// IngestLicenses mocks base method.
func (m *MockBackend) IngestLicenses(ctx context.Context, licenses []*model.LicenseInputSpec) ([]*model.License, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestLicenses", ctx, licenses)
	ret0, _ := ret[0].([]*model.License)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestLicenses indicates an expected call of IngestLicenses.
func (mr *MockBackendMockRecorder) IngestLicenses(ctx, licenses interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestLicenses", reflect.TypeOf((*MockBackend)(nil).IngestLicenses), ctx, licenses)
}

// IngestOccurrence mocks base method.
func (m *MockBackend) IngestOccurrence(ctx context.Context, subject model.PackageOrSourceInput, artifact model.ArtifactInputSpec, occurrence model.IsOccurrenceInputSpec) (*model.IsOccurrence, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestOccurrence", ctx, subject, artifact, occurrence)
	ret0, _ := ret[0].(*model.IsOccurrence)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestOccurrence indicates an expected call of IngestOccurrence.
func (mr *MockBackendMockRecorder) IngestOccurrence(ctx, subject, artifact, occurrence interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestOccurrence", reflect.TypeOf((*MockBackend)(nil).IngestOccurrence), ctx, subject, artifact, occurrence)
}

// IngestOccurrences mocks base method.
func (m *MockBackend) IngestOccurrences(ctx context.Context, subjects model.PackageOrSourceInputs, artifacts []*model.ArtifactInputSpec, occurrences []*model.IsOccurrenceInputSpec) ([]*model.IsOccurrence, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestOccurrences", ctx, subjects, artifacts, occurrences)
	ret0, _ := ret[0].([]*model.IsOccurrence)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestOccurrences indicates an expected call of IngestOccurrences.
func (mr *MockBackendMockRecorder) IngestOccurrences(ctx, subjects, artifacts, occurrences interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestOccurrences", reflect.TypeOf((*MockBackend)(nil).IngestOccurrences), ctx, subjects, artifacts, occurrences)
}

// IngestPackage mocks base method.
func (m *MockBackend) IngestPackage(ctx context.Context, pkg model.PkgInputSpec) (*model.Package, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestPackage", ctx, pkg)
	ret0, _ := ret[0].(*model.Package)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestPackage indicates an expected call of IngestPackage.
func (mr *MockBackendMockRecorder) IngestPackage(ctx, pkg interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestPackage", reflect.TypeOf((*MockBackend)(nil).IngestPackage), ctx, pkg)
}

// IngestPackages mocks base method.
func (m *MockBackend) IngestPackages(ctx context.Context, pkgs []*model.PkgInputSpec) ([]*model.Package, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestPackages", ctx, pkgs)
	ret0, _ := ret[0].([]*model.Package)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestPackages indicates an expected call of IngestPackages.
func (mr *MockBackendMockRecorder) IngestPackages(ctx, pkgs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestPackages", reflect.TypeOf((*MockBackend)(nil).IngestPackages), ctx, pkgs)
}

// IngestPkgEqual mocks base method.
func (m *MockBackend) IngestPkgEqual(ctx context.Context, pkg, depPkg model.PkgInputSpec, pkgEqual model.PkgEqualInputSpec) (*model.PkgEqual, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestPkgEqual", ctx, pkg, depPkg, pkgEqual)
	ret0, _ := ret[0].(*model.PkgEqual)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestPkgEqual indicates an expected call of IngestPkgEqual.
func (mr *MockBackendMockRecorder) IngestPkgEqual(ctx, pkg, depPkg, pkgEqual interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestPkgEqual", reflect.TypeOf((*MockBackend)(nil).IngestPkgEqual), ctx, pkg, depPkg, pkgEqual)
}

// IngestPkgEquals mocks base method.
func (m *MockBackend) IngestPkgEquals(ctx context.Context, pkgs, otherPackages []*model.PkgInputSpec, pkgEquals []*model.PkgEqualInputSpec) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestPkgEquals", ctx, pkgs, otherPackages, pkgEquals)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestPkgEquals indicates an expected call of IngestPkgEquals.
func (mr *MockBackendMockRecorder) IngestPkgEquals(ctx, pkgs, otherPackages, pkgEquals interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestPkgEquals", reflect.TypeOf((*MockBackend)(nil).IngestPkgEquals), ctx, pkgs, otherPackages, pkgEquals)
}

// IngestPointOfContact mocks base method.
func (m *MockBackend) IngestPointOfContact(ctx context.Context, subject model.PackageSourceOrArtifactInput, pkgMatchType *model.MatchFlags, pointOfContact model.PointOfContactInputSpec) (*model.PointOfContact, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestPointOfContact", ctx, subject, pkgMatchType, pointOfContact)
	ret0, _ := ret[0].(*model.PointOfContact)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestPointOfContact indicates an expected call of IngestPointOfContact.
func (mr *MockBackendMockRecorder) IngestPointOfContact(ctx, subject, pkgMatchType, pointOfContact interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestPointOfContact", reflect.TypeOf((*MockBackend)(nil).IngestPointOfContact), ctx, subject, pkgMatchType, pointOfContact)
}

// IngestPointOfContacts mocks base method.
func (m *MockBackend) IngestPointOfContacts(ctx context.Context, subjects model.PackageSourceOrArtifactInputs, pkgMatchType *model.MatchFlags, pointOfContacts []*model.PointOfContactInputSpec) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestPointOfContacts", ctx, subjects, pkgMatchType, pointOfContacts)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestPointOfContacts indicates an expected call of IngestPointOfContacts.
func (mr *MockBackendMockRecorder) IngestPointOfContacts(ctx, subjects, pkgMatchType, pointOfContacts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestPointOfContacts", reflect.TypeOf((*MockBackend)(nil).IngestPointOfContacts), ctx, subjects, pkgMatchType, pointOfContacts)
}

// IngestSLSA mocks base method.
func (m *MockBackend) IngestSLSA(ctx context.Context, subject model.ArtifactInputSpec, builtFrom []*model.ArtifactInputSpec, builtBy model.BuilderInputSpec, slsa model.SLSAInputSpec) (*model.HasSlsa, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestSLSA", ctx, subject, builtFrom, builtBy, slsa)
	ret0, _ := ret[0].(*model.HasSlsa)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestSLSA indicates an expected call of IngestSLSA.
func (mr *MockBackendMockRecorder) IngestSLSA(ctx, subject, builtFrom, builtBy, slsa interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestSLSA", reflect.TypeOf((*MockBackend)(nil).IngestSLSA), ctx, subject, builtFrom, builtBy, slsa)
}

// IngestSLSAs mocks base method.
func (m *MockBackend) IngestSLSAs(ctx context.Context, subjects []*model.ArtifactInputSpec, builtFromList [][]*model.ArtifactInputSpec, builtByList []*model.BuilderInputSpec, slsaList []*model.SLSAInputSpec) ([]*model.HasSlsa, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestSLSAs", ctx, subjects, builtFromList, builtByList, slsaList)
	ret0, _ := ret[0].([]*model.HasSlsa)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestSLSAs indicates an expected call of IngestSLSAs.
func (mr *MockBackendMockRecorder) IngestSLSAs(ctx, subjects, builtFromList, builtByList, slsaList interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestSLSAs", reflect.TypeOf((*MockBackend)(nil).IngestSLSAs), ctx, subjects, builtFromList, builtByList, slsaList)
}

// IngestScorecard mocks base method.
func (m *MockBackend) IngestScorecard(ctx context.Context, source model.SourceInputSpec, scorecard model.ScorecardInputSpec) (*model.CertifyScorecard, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestScorecard", ctx, source, scorecard)
	ret0, _ := ret[0].(*model.CertifyScorecard)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestScorecard indicates an expected call of IngestScorecard.
func (mr *MockBackendMockRecorder) IngestScorecard(ctx, source, scorecard interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestScorecard", reflect.TypeOf((*MockBackend)(nil).IngestScorecard), ctx, source, scorecard)
}

// IngestScorecards mocks base method.
func (m *MockBackend) IngestScorecards(ctx context.Context, sources []*model.SourceInputSpec, scorecards []*model.ScorecardInputSpec) ([]*model.CertifyScorecard, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestScorecards", ctx, sources, scorecards)
	ret0, _ := ret[0].([]*model.CertifyScorecard)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestScorecards indicates an expected call of IngestScorecards.
func (mr *MockBackendMockRecorder) IngestScorecards(ctx, sources, scorecards interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestScorecards", reflect.TypeOf((*MockBackend)(nil).IngestScorecards), ctx, sources, scorecards)
}

// IngestSource mocks base method.
func (m *MockBackend) IngestSource(ctx context.Context, source model.SourceInputSpec) (*model.Source, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestSource", ctx, source)
	ret0, _ := ret[0].(*model.Source)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestSource indicates an expected call of IngestSource.
func (mr *MockBackendMockRecorder) IngestSource(ctx, source interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestSource", reflect.TypeOf((*MockBackend)(nil).IngestSource), ctx, source)
}

// IngestSources mocks base method.
func (m *MockBackend) IngestSources(ctx context.Context, sources []*model.SourceInputSpec) ([]*model.Source, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestSources", ctx, sources)
	ret0, _ := ret[0].([]*model.Source)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestSources indicates an expected call of IngestSources.
func (mr *MockBackendMockRecorder) IngestSources(ctx, sources interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestSources", reflect.TypeOf((*MockBackend)(nil).IngestSources), ctx, sources)
}

// IngestVEXStatement mocks base method.
func (m *MockBackend) IngestVEXStatement(ctx context.Context, subject model.PackageOrArtifactInput, vulnerability model.VulnerabilityInputSpec, vexStatement model.VexStatementInputSpec) (*model.CertifyVEXStatement, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestVEXStatement", ctx, subject, vulnerability, vexStatement)
	ret0, _ := ret[0].(*model.CertifyVEXStatement)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestVEXStatement indicates an expected call of IngestVEXStatement.
func (mr *MockBackendMockRecorder) IngestVEXStatement(ctx, subject, vulnerability, vexStatement interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestVEXStatement", reflect.TypeOf((*MockBackend)(nil).IngestVEXStatement), ctx, subject, vulnerability, vexStatement)
}

// IngestVEXStatements mocks base method.
func (m *MockBackend) IngestVEXStatements(ctx context.Context, subjects model.PackageOrArtifactInputs, vulnerabilities []*model.VulnerabilityInputSpec, vexStatements []*model.VexStatementInputSpec) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestVEXStatements", ctx, subjects, vulnerabilities, vexStatements)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestVEXStatements indicates an expected call of IngestVEXStatements.
func (mr *MockBackendMockRecorder) IngestVEXStatements(ctx, subjects, vulnerabilities, vexStatements interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestVEXStatements", reflect.TypeOf((*MockBackend)(nil).IngestVEXStatements), ctx, subjects, vulnerabilities, vexStatements)
}

// IngestVulnEqual mocks base method.
func (m *MockBackend) IngestVulnEqual(ctx context.Context, vulnerability, otherVulnerability model.VulnerabilityInputSpec, vulnEqual model.VulnEqualInputSpec) (*model.VulnEqual, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestVulnEqual", ctx, vulnerability, otherVulnerability, vulnEqual)
	ret0, _ := ret[0].(*model.VulnEqual)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestVulnEqual indicates an expected call of IngestVulnEqual.
func (mr *MockBackendMockRecorder) IngestVulnEqual(ctx, vulnerability, otherVulnerability, vulnEqual interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestVulnEqual", reflect.TypeOf((*MockBackend)(nil).IngestVulnEqual), ctx, vulnerability, otherVulnerability, vulnEqual)
}

// IngestVulnEquals mocks base method.
func (m *MockBackend) IngestVulnEquals(ctx context.Context, vulnerabilities, otherVulnerabilities []*model.VulnerabilityInputSpec, vulnEquals []*model.VulnEqualInputSpec) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestVulnEquals", ctx, vulnerabilities, otherVulnerabilities, vulnEquals)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestVulnEquals indicates an expected call of IngestVulnEquals.
func (mr *MockBackendMockRecorder) IngestVulnEquals(ctx, vulnerabilities, otherVulnerabilities, vulnEquals interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestVulnEquals", reflect.TypeOf((*MockBackend)(nil).IngestVulnEquals), ctx, vulnerabilities, otherVulnerabilities, vulnEquals)
}

// IngestVulnerabilities mocks base method.
func (m *MockBackend) IngestVulnerabilities(ctx context.Context, vulns []*model.VulnerabilityInputSpec) ([]*model.Vulnerability, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestVulnerabilities", ctx, vulns)
	ret0, _ := ret[0].([]*model.Vulnerability)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestVulnerabilities indicates an expected call of IngestVulnerabilities.
func (mr *MockBackendMockRecorder) IngestVulnerabilities(ctx, vulns interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestVulnerabilities", reflect.TypeOf((*MockBackend)(nil).IngestVulnerabilities), ctx, vulns)
}

// IngestVulnerability mocks base method.
func (m *MockBackend) IngestVulnerability(ctx context.Context, vuln model.VulnerabilityInputSpec) (*model.Vulnerability, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestVulnerability", ctx, vuln)
	ret0, _ := ret[0].(*model.Vulnerability)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestVulnerability indicates an expected call of IngestVulnerability.
func (mr *MockBackendMockRecorder) IngestVulnerability(ctx, vuln interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestVulnerability", reflect.TypeOf((*MockBackend)(nil).IngestVulnerability), ctx, vuln)
}

// IngestVulnerabilityMetadata mocks base method.
func (m *MockBackend) IngestVulnerabilityMetadata(ctx context.Context, vulnerability model.VulnerabilityInputSpec, vulnerabilityMetadata model.VulnerabilityMetadataInputSpec) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IngestVulnerabilityMetadata", ctx, vulnerability, vulnerabilityMetadata)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IngestVulnerabilityMetadata indicates an expected call of IngestVulnerabilityMetadata.
func (mr *MockBackendMockRecorder) IngestVulnerabilityMetadata(ctx, vulnerability, vulnerabilityMetadata interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IngestVulnerabilityMetadata", reflect.TypeOf((*MockBackend)(nil).IngestVulnerabilityMetadata), ctx, vulnerability, vulnerabilityMetadata)
}

// IsDependency mocks base method.
func (m *MockBackend) IsDependency(ctx context.Context, isDependencySpec *model.IsDependencySpec) ([]*model.IsDependency, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDependency", ctx, isDependencySpec)
	ret0, _ := ret[0].([]*model.IsDependency)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDependency indicates an expected call of IsDependency.
func (mr *MockBackendMockRecorder) IsDependency(ctx, isDependencySpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDependency", reflect.TypeOf((*MockBackend)(nil).IsDependency), ctx, isDependencySpec)
}

// IsOccurrence mocks base method.
func (m *MockBackend) IsOccurrence(ctx context.Context, isOccurrenceSpec *model.IsOccurrenceSpec) ([]*model.IsOccurrence, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsOccurrence", ctx, isOccurrenceSpec)
	ret0, _ := ret[0].([]*model.IsOccurrence)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsOccurrence indicates an expected call of IsOccurrence.
func (mr *MockBackendMockRecorder) IsOccurrence(ctx, isOccurrenceSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsOccurrence", reflect.TypeOf((*MockBackend)(nil).IsOccurrence), ctx, isOccurrenceSpec)
}

// Licenses mocks base method.
func (m *MockBackend) Licenses(ctx context.Context, licenseSpec *model.LicenseSpec) ([]*model.License, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Licenses", ctx, licenseSpec)
	ret0, _ := ret[0].([]*model.License)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Licenses indicates an expected call of Licenses.
func (mr *MockBackendMockRecorder) Licenses(ctx, licenseSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Licenses", reflect.TypeOf((*MockBackend)(nil).Licenses), ctx, licenseSpec)
}

// Neighbors mocks base method.
func (m *MockBackend) Neighbors(ctx context.Context, node string, usingOnly []model.Edge) ([]model.Node, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Neighbors", ctx, node, usingOnly)
	ret0, _ := ret[0].([]model.Node)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Neighbors indicates an expected call of Neighbors.
func (mr *MockBackendMockRecorder) Neighbors(ctx, node, usingOnly interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Neighbors", reflect.TypeOf((*MockBackend)(nil).Neighbors), ctx, node, usingOnly)
}

// Node mocks base method.
func (m *MockBackend) Node(ctx context.Context, node string) (model.Node, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Node", ctx, node)
	ret0, _ := ret[0].(model.Node)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Node indicates an expected call of Node.
func (mr *MockBackendMockRecorder) Node(ctx, node interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Node", reflect.TypeOf((*MockBackend)(nil).Node), ctx, node)
}

// Nodes mocks base method.
func (m *MockBackend) Nodes(ctx context.Context, nodes []string) ([]model.Node, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Nodes", ctx, nodes)
	ret0, _ := ret[0].([]model.Node)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Nodes indicates an expected call of Nodes.
func (mr *MockBackendMockRecorder) Nodes(ctx, nodes interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Nodes", reflect.TypeOf((*MockBackend)(nil).Nodes), ctx, nodes)
}

// Packages mocks base method.
func (m *MockBackend) Packages(ctx context.Context, pkgSpec *model.PkgSpec) ([]*model.Package, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Packages", ctx, pkgSpec)
	ret0, _ := ret[0].([]*model.Package)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Packages indicates an expected call of Packages.
func (mr *MockBackendMockRecorder) Packages(ctx, pkgSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Packages", reflect.TypeOf((*MockBackend)(nil).Packages), ctx, pkgSpec)
}

// Path mocks base method.
func (m *MockBackend) Path(ctx context.Context, subject, target string, maxPathLength int, usingOnly []model.Edge) ([]model.Node, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Path", ctx, subject, target, maxPathLength, usingOnly)
	ret0, _ := ret[0].([]model.Node)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Path indicates an expected call of Path.
func (mr *MockBackendMockRecorder) Path(ctx, subject, target, maxPathLength, usingOnly interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Path", reflect.TypeOf((*MockBackend)(nil).Path), ctx, subject, target, maxPathLength, usingOnly)
}

// PkgEqual mocks base method.
func (m *MockBackend) PkgEqual(ctx context.Context, pkgEqualSpec *model.PkgEqualSpec) ([]*model.PkgEqual, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PkgEqual", ctx, pkgEqualSpec)
	ret0, _ := ret[0].([]*model.PkgEqual)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PkgEqual indicates an expected call of PkgEqual.
func (mr *MockBackendMockRecorder) PkgEqual(ctx, pkgEqualSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PkgEqual", reflect.TypeOf((*MockBackend)(nil).PkgEqual), ctx, pkgEqualSpec)
}

// PointOfContact mocks base method.
func (m *MockBackend) PointOfContact(ctx context.Context, pointOfContactSpec *model.PointOfContactSpec) ([]*model.PointOfContact, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PointOfContact", ctx, pointOfContactSpec)
	ret0, _ := ret[0].([]*model.PointOfContact)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PointOfContact indicates an expected call of PointOfContact.
func (mr *MockBackendMockRecorder) PointOfContact(ctx, pointOfContactSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PointOfContact", reflect.TypeOf((*MockBackend)(nil).PointOfContact), ctx, pointOfContactSpec)
}

// Scorecards mocks base method.
func (m *MockBackend) Scorecards(ctx context.Context, certifyScorecardSpec *model.CertifyScorecardSpec) ([]*model.CertifyScorecard, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Scorecards", ctx, certifyScorecardSpec)
	ret0, _ := ret[0].([]*model.CertifyScorecard)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Scorecards indicates an expected call of Scorecards.
func (mr *MockBackendMockRecorder) Scorecards(ctx, certifyScorecardSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scorecards", reflect.TypeOf((*MockBackend)(nil).Scorecards), ctx, certifyScorecardSpec)
}

// Sources mocks base method.
func (m *MockBackend) Sources(ctx context.Context, sourceSpec *model.SourceSpec) ([]*model.Source, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Sources", ctx, sourceSpec)
	ret0, _ := ret[0].([]*model.Source)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Sources indicates an expected call of Sources.
func (mr *MockBackendMockRecorder) Sources(ctx, sourceSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sources", reflect.TypeOf((*MockBackend)(nil).Sources), ctx, sourceSpec)
}

// VulnEqual mocks base method.
func (m *MockBackend) VulnEqual(ctx context.Context, vulnEqualSpec *model.VulnEqualSpec) ([]*model.VulnEqual, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VulnEqual", ctx, vulnEqualSpec)
	ret0, _ := ret[0].([]*model.VulnEqual)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// VulnEqual indicates an expected call of VulnEqual.
func (mr *MockBackendMockRecorder) VulnEqual(ctx, vulnEqualSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VulnEqual", reflect.TypeOf((*MockBackend)(nil).VulnEqual), ctx, vulnEqualSpec)
}

// Vulnerabilities mocks base method.
func (m *MockBackend) Vulnerabilities(ctx context.Context, vulnSpec *model.VulnerabilitySpec) ([]*model.Vulnerability, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Vulnerabilities", ctx, vulnSpec)
	ret0, _ := ret[0].([]*model.Vulnerability)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Vulnerabilities indicates an expected call of Vulnerabilities.
func (mr *MockBackendMockRecorder) Vulnerabilities(ctx, vulnSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Vulnerabilities", reflect.TypeOf((*MockBackend)(nil).Vulnerabilities), ctx, vulnSpec)
}

// VulnerabilityMetadata mocks base method.
func (m *MockBackend) VulnerabilityMetadata(ctx context.Context, vulnerabilityMetadataSpec *model.VulnerabilityMetadataSpec) ([]*model.VulnerabilityMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VulnerabilityMetadata", ctx, vulnerabilityMetadataSpec)
	ret0, _ := ret[0].([]*model.VulnerabilityMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// VulnerabilityMetadata indicates an expected call of VulnerabilityMetadata.
func (mr *MockBackendMockRecorder) VulnerabilityMetadata(ctx, vulnerabilityMetadataSpec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VulnerabilityMetadata", reflect.TypeOf((*MockBackend)(nil).VulnerabilityMetadata), ctx, vulnerabilityMetadataSpec)
}

// MockBackendArgs is a mock of BackendArgs interface.
type MockBackendArgs struct {
	ctrl     *gomock.Controller
	recorder *MockBackendArgsMockRecorder
}

// MockBackendArgsMockRecorder is the mock recorder for MockBackendArgs.
type MockBackendArgsMockRecorder struct {
	mock *MockBackendArgs
}

// NewMockBackendArgs creates a new mock instance.
func NewMockBackendArgs(ctrl *gomock.Controller) *MockBackendArgs {
	mock := &MockBackendArgs{ctrl: ctrl}
	mock.recorder = &MockBackendArgsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBackendArgs) EXPECT() *MockBackendArgsMockRecorder {
	return m.recorder
}
